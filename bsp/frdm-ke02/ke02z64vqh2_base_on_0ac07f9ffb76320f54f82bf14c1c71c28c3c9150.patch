diff --git a/bsp/frdm-ke02/SConscript b/bsp/frdm-ke02/SConscript
new file mode 100755
index 0000000..fe0ae94
--- /dev/null
+++ b/bsp/frdm-ke02/SConscript
@@ -0,0 +1,14 @@
+# for module compiling
+import os
+Import('RTT_ROOT')
+
+cwd = str(Dir('#'))
+objs = []
+list = os.listdir(cwd)
+
+for d in list:
+    path = os.path.join(cwd, d)
+    if os.path.isfile(os.path.join(path, 'SConscript')):
+        objs = objs + SConscript(os.path.join(d, 'SConscript'))
+
+Return('objs')
diff --git a/bsp/frdm-ke02/SConstruct b/bsp/frdm-ke02/SConstruct
new file mode 100755
index 0000000..f807146
--- /dev/null
+++ b/bsp/frdm-ke02/SConstruct
@@ -0,0 +1,37 @@
+import os
+import sys
+import rtconfig
+
+if os.getenv('RTT_ROOT'):
+    RTT_ROOT = os.getenv('RTT_ROOT')
+else:
+    RTT_ROOT = os.path.normpath(os.getcwd() + '/../..')
+
+sys.path = sys.path + [os.path.join(RTT_ROOT, 'tools')]
+from building import *
+
+TARGET = 'rtthread-ke02.' + rtconfig.TARGET_EXT
+
+env = Environment(tools = ['mingw'],
+	AS = rtconfig.AS, ASFLAGS = rtconfig.AFLAGS,
+	CC = rtconfig.CC, CCFLAGS = rtconfig.CFLAGS,
+	AR = rtconfig.AR, ARFLAGS = '-rc',
+	LINK = rtconfig.LINK, LINKFLAGS = rtconfig.LFLAGS)
+env.PrependENVPath('PATH', rtconfig.EXEC_PATH)
+
+if rtconfig.PLATFORM == 'iar':
+	env.Replace(CCCOM = ['$CC $CCFLAGS $CPPFLAGS $_CPPDEFFLAGS $_CPPINCFLAGS -o $TARGET $SOURCES'])
+	env.Replace(ARFLAGS = [''])
+	env.Replace(LINKCOM = ['$LINK $SOURCES $LINKFLAGS -o $TARGET --map project.map'])
+
+Export('RTT_ROOT')
+Export('rtconfig')
+
+# prepare building environment
+objs = PrepareBuilding(env, RTT_ROOT, has_libcpu=False)
+
+# build program 
+env.Program(TARGET, objs)
+
+# end building 
+EndBuilding(TARGET)
diff --git a/bsp/frdm-ke02/applications/SConscript b/bsp/frdm-ke02/applications/SConscript
new file mode 100755
index 0000000..01eb940
--- /dev/null
+++ b/bsp/frdm-ke02/applications/SConscript
@@ -0,0 +1,11 @@
+Import('RTT_ROOT')
+Import('rtconfig')
+from building import *
+
+cwd     = os.path.join(str(Dir('#')), 'applications')
+src	= Glob('*.c')
+CPPPATH = [cwd, str(Dir('#'))]
+
+group = DefineGroup('Applications', src, depend = [''], CPPPATH = CPPPATH)
+
+Return('group')
diff --git a/bsp/frdm-ke02/applications/application.c b/bsp/frdm-ke02/applications/application.c
new file mode 100755
index 0000000..2e2d32f
--- /dev/null
+++ b/bsp/frdm-ke02/applications/application.c
@@ -0,0 +1,84 @@
+/*
+ * File      : application.c
+ * This file is part of RT-Thread RTOS
+ * COPYRIGHT (C) 2006, RT-Thread Development Team
+ *
+ * The license and distribution terms for this file may be
+ * found in the file LICENSE in this distribution or at
+ * http://www.rt-thread.org/license/LICENSE
+ *
+ * Change Logs:
+ * Date           Author       Notes
+ *
+ */
+
+/**
+ * @addtogroup k64
+ */
+/*@{*/
+
+#include <stdio.h>
+
+#include <board.h>
+#include <rtthread.h>
+
+#include "led.h"
+
+#ifdef RT_USING_LWIP
+#include <lwip/sys.h>
+#include <lwip/api.h>
+#include <netif/ethernetif.h>
+#include "stm32_eth.h"
+#endif
+#ifdef RT_USING_RTGUI
+#include <rtgui/rtgui.h>
+#include <rtgui/rtgui_server.h>
+#include <rtgui/rtgui_system.h>
+#include <rtgui/driver.h>
+//#include <rtgui/calibration.h>
+#endif
+#ifdef RT_USING_DFS
+#include <dfs_init.h>
+#include <dfs_fs.h>
+
+#ifdef RT_USING_DFS_UFFS
+#include <dfs_uffs.h>
+#include "psram_mtd.h"
+#endif
+#endif
+
+void rt_init_thread_entry(void* parameter)
+{
+    rt_hw_led_init();
+
+    while (1)
+    {
+		rt_hw_led_on();
+		rt_thread_delay(RT_TICK_PER_SECOND/20);
+		rt_hw_led_off();
+		rt_thread_delay(RT_TICK_PER_SECOND/20);
+    }
+
+}
+int rt_application_init()
+{
+    rt_thread_t init_thread;
+    
+
+#if (RT_THREAD_PRIORITY_MAX == 32)
+    init_thread = rt_thread_create("init",
+                                   rt_init_thread_entry, RT_NULL,
+                                   512, 8, 20);
+#else
+    init_thread = rt_thread_create("init",
+                                   rt_init_thread_entry, RT_NULL,
+                                   512, 80, 20);
+#endif
+
+    if (init_thread != RT_NULL)
+        rt_thread_startup(init_thread);
+
+    return 0;
+}
+
+/*@}*/
diff --git a/bsp/frdm-ke02/applications/startup.c b/bsp/frdm-ke02/applications/startup.c
new file mode 100755
index 0000000..8485928
--- /dev/null
+++ b/bsp/frdm-ke02/applications/startup.c
@@ -0,0 +1,123 @@
+/*
+ * File      : startup.c
+ * This file is part of RT-Thread RTOS
+ * COPYRIGHT (C) 2006, RT-Thread Develop Team
+ *
+ * The license and distribution terms for this file may be
+ * found in the file LICENSE in this distribution or at
+ * http://openlab.rt-thread.com/license/LICENSE
+ *
+ * Change Logs:
+ * Date           Author       Notes
+ * 
+ */
+
+#include <rthw.h>
+#include <rtthread.h>
+
+#include <board.h>
+
+/**
+ * @addtogroup k64
+ */
+
+/*@{*/
+
+extern int  rt_application_init(void);
+#ifdef RT_USING_FINSH
+extern void finsh_system_init(void);
+extern void finsh_set_device(const char* device);
+#endif
+
+#ifdef __CC_ARM
+extern int Image$$RW_IRAM1$$ZI$$Limit;
+#define KE02_SRAM_BEGIN    (&Image$$RW_IRAM1$$ZI$$Limit)
+#elif __ICCARM__
+#pragma section="HEAP"
+#define KE02_SRAM_BEGIN    (__segment_end("HEAP"))
+#else
+extern int __bss_end__;
+#define KE02_SRAM_BEGIN    (&__bss_end__)
+#endif
+
+/*******************************************************************************
+* Function Name  : assert_failed
+* Description    : Reports the name of the source file and the source line number
+*                  where the assert error has occurred.
+* Input          : - file: pointer to the source file name
+*                  - line: assert error line source number
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void assert_failed(rt_uint8_t* file, rt_uint32_t line)
+{
+    rt_kprintf("\n\r Wrong parameter value detected on\r\n");
+    rt_kprintf("       file  %s\r\n", file);
+    rt_kprintf("       line  %d\r\n", line);
+
+    while (1) ;
+}
+
+/**
+ * This function will startup RT-Thread RTOS.
+ */
+void rtthread_startup(void)
+{
+    /* init board */
+    rt_hw_board_init();
+
+    /* show version */
+    rt_show_version();
+
+    /* init tick */
+    rt_system_tick_init();
+
+    /* init kernel object */
+    rt_system_object_init();
+
+    /* init timer system */
+    rt_system_timer_init();
+	rt_kprintf("heap begin %x ,end %x\r\n",KE02_SRAM_BEGIN,KE02_SRAM_END);
+    rt_system_heap_init((void*)KE02_SRAM_BEGIN, (void*)KE02_SRAM_END);
+
+    /* init scheduler system */
+    rt_system_scheduler_init();
+
+    /* init all device */
+    rt_device_init_all();
+
+    /* init application */
+    rt_application_init();
+
+#ifdef RT_USING_FINSH
+    /* init finsh */
+    finsh_system_init();
+    finsh_set_device( FINSH_DEVICE_NAME );
+#endif
+
+    /* init timer thread */
+    rt_system_timer_thread_init();
+
+    /* init idle thread */
+    rt_thread_idle_init();
+
+    /* start scheduler */
+    rt_system_scheduler_start();
+
+    /* never reach here */
+    return ;
+}
+
+int main(void)
+{
+		  
+    /* disable interrupt first */
+    rt_hw_interrupt_disable();
+
+    /* startup RT-Thread RTOS */
+    rtthread_startup();
+
+    return 0;
+}
+
+/*@}*/
diff --git a/bsp/frdm-ke02/board/SConscript b/bsp/frdm-ke02/board/SConscript
new file mode 100755
index 0000000..c2efbbf
--- /dev/null
+++ b/bsp/frdm-ke02/board/SConscript
@@ -0,0 +1,11 @@
+Import('RTT_ROOT')
+Import('rtconfig')
+from building import *
+
+cwd     = os.path.join(str(Dir('#')), 'board')
+src	= Glob('*.c')
+src	+= Glob('*.s')
+CPPPATH = [cwd]
+group = DefineGroup('Board', src, depend = [''], CPPPATH = CPPPATH)
+
+Return('group')
diff --git a/bsp/frdm-ke02/board/board.c b/bsp/frdm-ke02/board/board.c
new file mode 100755
index 0000000..91f5db2
--- /dev/null
+++ b/bsp/frdm-ke02/board/board.c
@@ -0,0 +1,91 @@
+/*
+ * File      : board.c
+ * This file is part of RT-Thread RTOS
+ * COPYRIGHT (C) 2009 RT-Thread Develop Team
+ *
+ * The license and distribution terms for this file may be
+ * found in the file LICENSE in this distribution or at
+ * http://www.rt-thread.org/license/LICENSE
+ *
+ * Change Logs:
+ * Date           Author       Notes
+ * 
+ */
+
+#include <rthw.h>
+#include <rtthread.h>
+
+#include "board.h"
+
+#include "drv_uart.h"
+
+
+/**
+ * @addtogroup K64
+ */
+
+/*@{*/
+
+/*******************************************************************************
+* Function Name  : NVIC_Configuration
+* Description    : Configures Vector Table base location.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void NVIC_Configuration(void)
+{
+
+}
+
+/*******************************************************************************
+ * Function Name  : SysTick_Configuration
+ * Description    : Configures the SysTick for OS tick.
+ * Input          : None
+ * Output         : None
+ * Return         : None
+ *******************************************************************************/
+void  SysTick_Configuration(void)
+{
+	/*while(!(ICS->S & ICS_S_LOCK_MASK));
+	SIM->SOPT = SIM_SOPT_SWDE_MASK | SIM_SOPT_RSTPE_MASK;
+	SIM->PINSEL |= SIM_PINSEL_SPI0PS_MASK;
+	SIM_SOPT |= SIM_SOPT_CLKOE_MASK;
+	FEI_to_FEE();
+	SIM_SCGC |= SIM_SCGC_UART0_MASK | SIM_SCGC_UART1_MASK | SIM_SCGC_UART2_MASK;*/
+	
+    //SystemCoreClockUpdate();              /* Update Core Clock Frequency        */
+    SysTick_Config(20000000L/RT_TICK_PER_SECOND); /* Generate interrupt each 1 ms       */
+}
+
+/**
+ * This is the timer interrupt service routine.
+ *
+ */
+void SysTick_Handler(void)
+{
+    /* enter interrupt */
+    rt_interrupt_enter();
+
+    rt_tick_increase();
+
+    /* leave interrupt */
+    rt_interrupt_leave();
+}
+/**
+ * This function will initial Tower board.
+ */
+void rt_hw_board_init()
+{
+    /* NVIC Configuration */
+    NVIC_Configuration();
+    /* Configure the SysTick */
+    SysTick_Configuration();
+    rt_hw_uart_init();
+	
+#ifdef RT_USING_CONSOLE
+    rt_console_set_device(CONSOLE_DEVICE);
+#endif
+}
+
+/*@}*/
diff --git a/bsp/frdm-ke02/board/board.h b/bsp/frdm-ke02/board/board.h
new file mode 100755
index 0000000..024fe5a
--- /dev/null
+++ b/bsp/frdm-ke02/board/board.h
@@ -0,0 +1,56 @@
+/*
+ * File      : board.h
+ * This file is part of RT-Thread RTOS
+ * COPYRIGHT (C) 2009, RT-Thread Development Team
+ *
+ * The license and distribution terms for this file may be
+ * found in the file LICENSE in this distribution or at
+ * http://www.rt-thread.org/license/LICENSE
+ *
+ * Change Logs:
+ * Date           Author       Notes
+ *
+ */
+
+// <<< Use Configuration Wizard in Context Menu >>>
+#ifndef __BOARD_H__
+#define __BOARD_H__
+
+
+/* board configuration */
+
+// <o> Internal SRAM memory size[Kbytes] <8-64>
+// <i>Default: 64
+#define KE02_SRAM_SIZE         4
+#define KE02_SRAM_END          (0x1FFFFC00 + (KE02_SRAM_SIZE * 1024))
+
+#define RT_USING_UART1
+#define RT_USING_UART0
+//#define RT_USING_UART3
+
+// <o> Console on USART: <0=> no console <1=>USART 1 <2=>USART 2 <3=> USART 3
+// <i>Default: 1
+#define KE02_CONSOLE_USART        1
+
+void rt_hw_board_init(void);
+
+#if KE02_CONSOLE_USART == 0
+#define CONSOLE_DEVICE "uart0"
+#elif KE02_CONSOLE_USART == 1
+#define CONSOLE_DEVICE "uart1"
+#elif KE02_CONSOLE_USART == 2
+#define CONSOLE_DEVICE "uart2"
+#elif KE02_CONSOLE_USART == 3
+#define CONSOLE_DEVICE "uart3"
+#elif KE02_CONSOLE_USART == 4
+#define CONSOLE_DEVICE "uart4"
+#elif KE02_CONSOLE_USART == 5
+#define CONSOLE_DEVICE "uart5"
+#endif
+
+#define FINSH_DEVICE_NAME   CONSOLE_DEVICE
+
+int Mem_Check(unsigned long offset);
+#endif
+
+// <<< Use Configuration Wizard in Context Menu >>>
diff --git a/bsp/frdm-ke02/board/drv_uart.c b/bsp/frdm-ke02/board/drv_uart.c
new file mode 100755
index 0000000..dca6706
--- /dev/null
+++ b/bsp/frdm-ke02/board/drv_uart.c
@@ -0,0 +1,208 @@
+/*
+ * File      : drv_uart.c
+ * This file is part of RT-Thread RTOS
+ * COPYRIGHT (C) 2013, RT-Thread Develop Team
+ *
+ * The license and distribution terms for this file may be
+ * found in the file LICENSE in this distribution or at
+ * http://openlab.rt-thread.com/license/LICENSE
+ *
+ * Change Logs:
+ * Date           Author       Notes
+ *
+ */
+
+
+#include "drv_uart.h"
+#include "uart.h"
+static struct rt_serial_device _ke02_serial0;  //abstracted serial for RTT
+static struct rt_serial_device _ke02_serial1;  //abstracted serial for RTT
+
+struct ke02_serial_device
+{
+    /* UART base address */
+    UART_Type *baseAddress;
+
+    /* UART IRQ Number */
+    int irq_num;
+
+    /* device config */
+    struct serial_configure config;
+};
+
+//hardware abstract device
+static struct ke02_serial_device _ke02_node_0 =
+{
+    (UART_Type *)UART0_BASE,
+    UART0_IRQn,
+};
+static struct ke02_serial_device _ke02_node_1 =
+{
+    (UART_Type *)UART1_BASE,
+    UART1_IRQn,
+};
+
+static rt_err_t _configure(struct rt_serial_device *serial, struct serial_configure *cfg)
+{
+	UART_Type *uart_reg;
+	uart_reg = ((struct ke02_serial_device *)serial->parent.user_data)->baseAddress;
+
+    switch ((unsigned int)uart_reg)
+    {
+    /*
+     * if you're using other board
+     * set clock and pin map for UARTx
+     */
+    case UART0_BASE:
+	{
+		UART_ConfigType sConfig;
+
+	sConfig.u32SysClkHz = BUS_CLK_HZ;
+	sConfig.u32Baudrate  = UART_PRINT_BITRATE;
+
+	UART_Init (UART0, &sConfig);
+        break;
+    	}
+    case UART1_BASE:
+	{
+		UART_ConfigType sConfig;
+
+    	sConfig.u32SysClkHz = BUS_CLK_HZ;
+    	sConfig.u32Baudrate  = UART_PRINT_BITRATE;
+    
+    	UART_Init (UART1, &sConfig);
+	break;
+    	}
+    default:
+        return -RT_ERROR;
+    }
+
+    return RT_EOK;
+}
+
+static rt_err_t _control(struct rt_serial_device *serial, int cmd, void *arg)
+{
+    UART_Type *uart_reg;
+    int uart_irq_num = 0;
+
+    uart_reg = ((struct ke02_serial_device *)serial->parent.user_data)->baseAddress;
+    uart_irq_num = ((struct ke02_serial_device *)serial->parent.user_data)->irq_num;
+	
+
+    switch (cmd)
+    {
+    case RT_DEVICE_CTRL_CLR_INT:
+        /* disable rx irq */
+        //uart_reg->C2 &= ~UART_C2_RIE_MASK;
+        //disable NVIC
+        //NVIC->ICER[uart_irq_num / 32] = 1 << (uart_irq_num % 32);
+        break;
+    case RT_DEVICE_CTRL_SET_INT:
+        /* enable rx irq */
+       // uart_reg->C2 |= UART_C2_RIE_MASK;
+        //enable NVIC,we are sure uart's NVIC vector is in NVICICPR1
+       // NVIC->ICPR[uart_irq_num / 32] = 1 << (uart_irq_num % 32);
+      //  NVIC->ISER[uart_irq_num / 32] = 1 << (uart_irq_num % 32);
+        break;
+    case RT_DEVICE_CTRL_SUSPEND:
+        /* suspend device */
+       // uart_reg->C2  &=  ~(UART_C2_RE_MASK |    //Receiver enable
+       //                     UART_C2_TE_MASK);     //Transmitter enable
+        break;
+    case RT_DEVICE_CTRL_RESUME:
+        /* resume device */
+      //  uart_reg->C2  =  UART_C2_RE_MASK |    //Receiver enable
+       //                  UART_C2_TE_MASK;     //Transmitter enable
+        break;
+    }
+
+    return RT_EOK;
+}
+
+static int _putc(struct rt_serial_device *serial, char c)
+{
+    UART_Type *uart_reg;
+    uart_reg = ((struct ke02_serial_device *)serial->parent.user_data)->baseAddress;
+
+    while (!(uart_reg->S1 & UART_S1_TDRE_MASK));
+    uart_reg->D = (c & 0xFF);
+    return 1;
+}
+
+static int _getc(struct rt_serial_device *serial)
+{
+    UART_Type *uart_reg;
+    uart_reg = ((struct ke02_serial_device *)serial->parent.user_data)->baseAddress;
+
+    if (uart_reg->S1 & UART_S1_RDRF_MASK)
+        return (uart_reg->D);
+    else
+        return -1;
+}
+
+static const struct rt_uart_ops _ke02_ops =
+{
+    _configure,
+    _control,
+    _putc,
+    _getc,
+};
+
+
+void UART0_IRQHandler(void)
+{
+    rt_interrupt_enter();
+    rt_hw_serial_isr((struct rt_serial_device*)&_ke02_serial0, RT_SERIAL_EVENT_RX_IND);
+    rt_interrupt_leave();
+}
+
+void UART1_IRQHandler(void)
+{
+    rt_interrupt_enter();
+    rt_hw_serial_isr((struct rt_serial_device*)&_ke02_serial1, RT_SERIAL_EVENT_RX_IND);
+    rt_interrupt_leave();
+}
+
+void rt_hw_uart_init(void)
+{
+    struct serial_configure config;
+
+    /* fake configuration */
+    config.baud_rate = BAUD_RATE_115200;
+    config.bit_order = BIT_ORDER_LSB;
+    config.data_bits = DATA_BITS_8;
+    config.parity    = PARITY_NONE;
+    config.stop_bits = STOP_BITS_1;
+    config.invert    = NRZ_NORMAL;
+	config.bufsz	 = RT_SERIAL_RB_BUFSZ;
+
+    _ke02_serial0.ops    = &_ke02_ops;
+    _ke02_serial0.config = config;
+    _ke02_serial1.ops    = &_ke02_ops;
+    _ke02_serial1.config = config;
+	//uart3 conflict with sdhc pin*/
+    rt_hw_serial_register(&_ke02_serial0, "uart0",
+                          RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX | RT_DEVICE_FLAG_STREAM,
+                          (void*)&_ke02_node_0);
+    
+    rt_hw_serial_register(&_ke02_serial1, "uart1",
+                          RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX | RT_DEVICE_FLAG_STREAM,
+                          (void*)&_ke02_node_1);
+}
+
+void rt_hw_console_output(const char *str)
+{
+    while(*str != '\0')
+    {
+        if (*str == '\n')
+            _putc(&_ke02_serial1,'\r');
+        _putc(&_ke02_serial1,*str);
+        str++;
+    }
+}
+void
+out_char (char ch)
+{
+	_putc(&_ke02_serial1, ch);
+}
+
diff --git a/bsp/frdm-ke02/board/drv_uart.h b/bsp/frdm-ke02/board/drv_uart.h
new file mode 100755
index 0000000..2cc8051
--- /dev/null
+++ b/bsp/frdm-ke02/board/drv_uart.h
@@ -0,0 +1,34 @@
+/*
+ * File      : drv_uart.c
+ * This file is part of RT-Thread RTOS
+ * COPYRIGHT (C) 2013, RT-Thread Develop Team
+ *
+ * The license and distribution terms for this file may be
+ * found in the file LICENSE in this distribution or at
+ * http://openlab.rt-thread.com/license/LICENSE
+ *
+ * Change Logs:
+ * Date           Author       Notes
+ * 
+ */
+
+#ifndef DRV_UART_H
+#define DRV_UART_H
+
+#include <rthw.h>
+#include <rtthread.h>
+#include <rtdevice.h>
+
+#include "common.h"
+#include "sysinit.h"
+#include "ke02_config.h"
+
+
+#include <drivers/serial.h>
+
+void rt_hw_uart_init(void);
+
+//for kernel debug when console not registered
+void rt_hw_console_output(const char *str);
+
+#endif /* end of include guard: DRV_UART_H */
diff --git a/bsp/frdm-ke02/board/led.c b/bsp/frdm-ke02/board/led.c
new file mode 100755
index 0000000..50d9d08
--- /dev/null
+++ b/bsp/frdm-ke02/board/led.c
@@ -0,0 +1,53 @@
+/*
+ * File      : led.c
+ * This file is part of RT-Thread RTOS
+ * COPYRIGHT (C) 2009, RT-Thread Development Team
+ *
+ * The license and distribution terms for this file may be
+ * found in the file LICENSE in this distribution or at
+ * http://www.rt-thread.org/license/LICENSE
+ *
+ * Change Logs:
+ * Date           Author       Notes
+ *
+ */
+
+#include "common.h"
+#include "sysinit.h"
+#include "ke02_config.h"
+#include "led.h"
+
+
+
+void rt_hw_led_init(void)
+{
+	RED_Init();
+	GREEN_Init();
+	BLUE_Init();
+
+    rt_hw_led_off();
+}
+
+void rt_hw_led_uninit(void)
+{
+}
+
+void rt_hw_led_on()
+{
+    	BLUE_Toggle();	
+}
+
+void rt_hw_led_off()
+{
+    	BLUE_Toggle();
+}
+void rt_hw_led_on2()
+{
+    	RED_Toggle();	
+}
+
+void rt_hw_led_off2()
+{
+    	RED_Toggle();
+}
+
diff --git a/bsp/frdm-ke02/board/led.h b/bsp/frdm-ke02/board/led.h
new file mode 100755
index 0000000..bd0edaf
--- /dev/null
+++ b/bsp/frdm-ke02/board/led.h
@@ -0,0 +1,25 @@
+/*
+ * File      : led.h
+ * This file is part of RT-Thread RTOS
+ * COPYRIGHT (C) 2009, RT-Thread Development Team
+ *
+ * The license and distribution terms for this file may be
+ * found in the file LICENSE in this distribution or at
+ * http://www.rt-thread.org/license/LICENSE
+ *
+ * Change Logs:
+ * Date           Author       Notes
+ *
+ */
+
+#ifndef __LED_H__
+#define __LED_H__
+
+#include <rtthread.h>
+
+
+void rt_hw_led_init(void);
+void rt_hw_led_uninit(void);
+void rt_hw_led_on(void);
+void rt_hw_led_off(void);
+#endif /* end  of __LED_H__ */
diff --git a/bsp/frdm-ke02/burn.txt b/bsp/frdm-ke02/burn.txt
new file mode 100755
index 0000000..a53645b
--- /dev/null
+++ b/bsp/frdm-ke02/burn.txt
@@ -0,0 +1,8 @@
+exec device=MKE02Z64xxx2
+r
+h
+speed 1500
+loadbin rtthread.bin,0x00000000
+r
+g
+qc
diff --git a/bsp/frdm-ke02/checkin.sh b/bsp/frdm-ke02/checkin.sh
new file mode 100755
index 0000000..f62ce22
--- /dev/null
+++ b/bsp/frdm-ke02/checkin.sh
@@ -0,0 +1,4 @@
+#! /bin/bash -e
+
+git commit -am "$1"
+git push origin dillon_ke02z
diff --git a/bsp/frdm-ke02/device/SConscript b/bsp/frdm-ke02/device/SConscript
new file mode 100755
index 0000000..32e22d9
--- /dev/null
+++ b/bsp/frdm-ke02/device/SConscript
@@ -0,0 +1,23 @@
+import rtconfig
+Import('RTT_ROOT')
+from building import *
+
+# get current directory
+cwd = GetCurrentDir()
+
+path = [cwd, cwd + '/lib/inc']
+src = Glob('lib/drivers/*.c')
+SrcRemove(src, 'lib/drivers/uif.c')
+#add for startup script 
+if rtconfig.CROSS_TOOL == 'gcc':
+     src = src + ['startup_gcc/startup_MKE02Z2.s']
+     path += [cwd + 'startup_gcc']
+elif rtconfig.CROSS_TOOL == 'keil':
+     src = src + ['startup_keil/startup_MKE02Z2.s']
+# elif rtconfig.CROSS_TOOL == 'iar':
+
+#CPPDEFINES = ['']
+group = DefineGroup('Device', src, depend = [''], CPPPATH = path)
+#CPPDEFINES = CPPDEFINES)
+
+Return('group')
diff --git a/bsp/frdm-ke02/device/lib/drivers/acmp.c b/bsp/frdm-ke02/device/lib/drivers/acmp.c
new file mode 100755
index 0000000..2a70592
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/drivers/acmp.c
@@ -0,0 +1,243 @@
+
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file acmp.c
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief providing APIs for configuring ACMP. 
+*
+*******************************************************************************
+*
+* provide APIs for configuring ACMP
+******************************************************************************/
+#include "common.h"
+#include "acmp.h"
+/******************************************************************************
+* Global variables
+******************************************************************************/
+
+/******************************************************************************
+* Constants and macros
+******************************************************************************/
+
+/******************************************************************************
+* Local types
+******************************************************************************/
+
+/******************************************************************************
+* Local function prototypes
+******************************************************************************/
+
+/******************************************************************************
+* Local variables
+******************************************************************************/
+
+ACMP_CallbackPtr ACMP_Callback[2] = {(ACMP_CallbackPtr)NULL};
+
+/******************************************************************************
+* Local functions
+******************************************************************************/
+/******************************************************************************
+* Global functions
+******************************************************************************/
+void ACMP0_Isr(void);
+void ACMP1_Isr(void);
+
+/******************************************************************************
+* ACMP api list.
+*
+*//*! @addtogroup acmp_api_list
+* @{
+*******************************************************************************/
+
+/*****************************************************************************//*!
+*
+* @brief initialize ACMP as per control field.
+*        
+* @param   pACMPx         pointer to an ACMP register base.
+* @param   pConfig        control parameters.  
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see   ACMP_DeInit.  
+*
+*****************************************************************************/
+void ACMP_Init(ACMP_Type *pACMPx, ACMP_ConfigType *pConfig) 
+{
+    if(ACMP0 == pACMPx)
+    {    
+        /* enable clock to ACMP */
+        SIM->SCGC |= SIM_SCGC_ACMP0_MASK;
+ 
+        /* enable ACMP interrupt */
+        if(pConfig->sCtrlStatus.bits.bIntEn)
+            NVIC_EnableIRQ(ACMP0_IRQn);
+    }
+    else
+    {
+        SIM->SCGC |= SIM_SCGC_ACMP1_MASK;
+        if(pConfig->sCtrlStatus.bits.bIntEn)
+            NVIC_EnableIRQ(ACMP1_IRQn);            
+    }
+    /* neg and pos pin are not equal */
+    pACMPx->C0 = pConfig->sPinSelect.byte;
+    ACMP_ConfigDAC(pACMPx, &pConfig->sDacSet );
+    //pACMPx->C1 = pConfig->sDacSet.byte;
+    pACMPx->C2 = pConfig->sPinEnable.byte;
+    pACMPx->CS = pConfig->sCtrlStatus.byte;
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief write ACMP register bits.
+*        
+* @param   pACMPx      pointer to an ACMP register base.
+* @param   pDACConfig   pointer to an ACMP DAC control structure.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*****************************************************************************/
+void ACMP_ConfigDAC(ACMP_Type *pACMPx, ACMP_DACType *pDACConfig) 
+{
+    pACMPx->C1 = pDACConfig->byte;  
+}
+
+/*****************************************************************************//*!
+*
+* @brief deinit ACMP module.
+*        
+* @param   pACMPx      pointer to an ACMP register base.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see   ACMP_Init.  
+*
+*****************************************************************************/
+void ACMP_DeInit(ACMP_Type *pACMPx) 
+{
+    if(ACMP0 == pACMPx)
+    {    
+        if(pACMPx->CS & ACMP_CS_ACIE_MASK)
+            NVIC_DisableIRQ(ACMP0_IRQn);
+    }
+    else
+    {
+        if(pACMPx->CS & ACMP_CS_ACIE_MASK)
+            NVIC_DisableIRQ(ACMP1_IRQn);            
+    }
+    
+    pACMPx->CS = 0;
+    pACMPx->C0 = 0;
+    pACMPx->C1 = 0;
+    pACMPx->C2 = 0;
+    
+    if(ACMP0 == pACMPx)
+    {    
+        SIM->SCGC &= ~SIM_SCGC_ACMP0_MASK;
+    }
+    else
+    {
+        SIM->SCGC &= ~SIM_SCGC_ACMP1_MASK;           
+    } 
+}
+
+/*****************************************************************************//*!
+*
+* @brief  set up ACMP callback routines to be called by interrupt service routine.
+*        
+* @param  pACMPx       pointer to an ACMP register base. 
+* @param   pfnCallback  callback routine.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*****************************************************************************/
+void ACMP_SetCallback(ACMP_Type *pACMPx, ACMP_CallbackPtr pfnCallback)
+{
+    if(ACMP0 == pACMPx)
+    {
+        ACMP_Callback[0] = pfnCallback;
+    }
+    else
+    {
+        ACMP_Callback[1] = pfnCallback;
+    }
+}
+
+/*! @} End of acmp_api_list                                                  */
+
+
+/*****************************************************************************//*!
+*
+* @brief  ACMP0 interrupt service routine.
+*        
+* @param  none. 
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*****************************************************************************/
+void ACMP0_Isr(void)
+{
+
+    if(ACMP_Callback[0])
+    {
+        ACMP_Callback[0]();             /* call callback routine */
+    }
+}
+
+/*****************************************************************************//*!
+*
+* @brief  ACMP1 interrupt service routine.
+*        
+* @param  none. 
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*****************************************************************************/
+void ACMP1_Isr(void)
+{
+
+    if(ACMP_Callback[1])
+    {
+        ACMP_Callback[1]();             /* call callback routine */
+    }
+}
+
+
diff --git a/bsp/frdm-ke02/device/lib/drivers/adc.c b/bsp/frdm-ke02/device/lib/drivers/adc.c
new file mode 100755
index 0000000..f2999bd
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/drivers/adc.c
@@ -0,0 +1,364 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file adc.c
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief providing APIs for configuring ADC module (ADC). 
+*
+*******************************************************************************
+*
+* provide APIs for configuring ADC module (ADC)
+******************************************************************************/
+#include "common.h"
+#include "adc.h"
+/******************************************************************************
+* Local function
+******************************************************************************/
+ADC_CallbackType ADC_Callback[1] = {NULL};
+/******************************************************************************
+* Local variables
+******************************************************************************/
+
+/******************************************************************************
+* Local function prototypes
+******************************************************************************/
+
+/******************************************************************************
+* define ADC APIs
+*
+*//*! @addtogroup adc_api_list
+* @{
+*******************************************************************************/
+
+
+/*****************************************************************************//**
+   *
+   * @brief initialize ADC module.
+   *
+   * @param[in]  pADC point to ADC module type. 
+   * @param[in]  pADC_Config point to ADC configuration structure. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+void ADC_Init(ADC_Type *pADC, ADC_ConfigTypePtr pADC_Config)
+{
+    if( pADC == ADC)
+    {
+        SIM->SCGC |= SIM_SCGC_ADC_MASK;
+    }
+
+    /* set clock cource for ADC */
+    ADC_SelectClock(pADC,pADC_Config->u8ClockSource);
+
+    /* set clock divide */
+    ADC_SelectClockDivide(pADC,pADC_Config->u8ClockDiv);
+
+    /* set ADC mode */
+    ADC_SetMode(pADC,pADC_Config->u8Mode);
+
+    /* set FIFO level */
+    ADC_SetFifoLevel(pADC,pADC_Config->u8FiFoLevel);
+
+    /* set pin control */
+    pADC->APCTL1 = pADC_Config->u16PinControl;
+
+    if( pADC_Config->sSetting.bCompareEn )
+    {
+        ADC_CompareEnable(pADC);
+    }
+    
+    if( pADC_Config->sSetting.bCompareGreaterEn )
+    {
+        ADC_CompareGreaterFunction(pADC);
+    }
+        
+    if( pADC_Config->sSetting.bContinuousEn )
+    {
+        ADC_ContinuousConversion(pADC);
+    }
+        
+    if( pADC_Config->sSetting.bCompareAndEn ) 
+    {
+        ADC_CompareFifoAnd(pADC);
+    }
+    
+    if( pADC_Config->sSetting.bFiFoScanModeEn )
+    {
+        ADC_FifoScanModeEnable(pADC);
+    }
+    
+    if( pADC_Config->sSetting.bHardwareTriggerEn )
+    {
+        ADC_SetHardwareTrigger(pADC);
+    }
+
+    if( pADC_Config->sSetting.bIntEn )
+    {
+        ADC_IntEnable(pADC);
+        NVIC_EnableIRQ( ADC0_IRQn );
+    } 
+
+    if( pADC_Config->sSetting.bLongSampleEn )
+    {
+        ADC_SetLongSample(pADC);
+    } 
+
+    if( pADC_Config->sSetting.bLowPowerEn )
+    {
+        ADC_SetLowPower(pADC);
+    }
+
+#if !defined(CPU_KE02)
+
+    if( pADC_Config->sSetting.bHTRGMEn )
+    {
+        ADC_HardwareTriggerMultiple(pADC);
+    }
+    else
+    {
+		ADC_HardwareTriggerSingle(pADC);
+    }
+    if( pADC_Config->sSetting.bHTRGMASKEn )
+    {
+        ADC_HardwareTriggerMaskEnable(pADC);
+    }
+    else
+    {
+		ADC_HardwareTriggerMaskDisable(pADC);
+    }
+    if( pADC_Config->sSetting.bHTRGMASKSEL )
+    {
+        ADC_HardwareTriggerMaskAuto(pADC);
+    }
+    else
+    {
+		ADC_HardwareTriggerMaskNonAuto(pADC);
+    }
+#endif
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief disable ADC module.
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   *
+   * @return none.
+   *
+   * @ Pass/ Fail criteria: none.
+   *****************************************************************************/
+void ADC_DeInit( ADC_Type *pADC )
+{
+    ADC_SetChannel(pADC,ADC_CHANNEL_DISABLE);
+
+    SIM->SCGC &= ~SIM_SCGC_ADC_MASK;
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief start a conversion and get conversion result
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   * @param[in]  u8Channel adc channel to conversion. 
+   *
+   * @return ADC conversion result.
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+unsigned int ADC_PollRead( ADC_Type *pADC, uint8_t u8Channel )
+{
+		ADC_SetChannel(pADC,u8Channel);
+		while( !ADC_IsCOCOFlag(pADC) );
+		return ADC_ReadResultReg(pADC);
+}
+
+
+/*****************************************************************************//*!
+   *
+   * @brief install ADC call back function.
+   *        
+   * @param[in]	 pADC_CallBack point to address of  adc call back function.
+   *
+   * @return none.
+   *
+   * @ Pass/ Fail criteria: none.
+   *****************************************************************************/
+void ADC_SetCallBack(ADC_CallbackType pADC_CallBack)
+{
+    ADC_Callback[0] = pADC_CallBack;
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief set ADC channel.
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   * @param[in]  u8Channel adc channel to conversion. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+void ADC_SetChannel( ADC_Type *pADC, uint8_t u8Channel )
+{
+    uint32_t u32temp;    
+    u32temp = pADC->SC1; 
+    u32temp &= ~ADC_SC1_ADCH_MASK;
+    pADC->SC1 = u32temp|ADC_SC1_ADCH(u8Channel);   
+}
+/*****************************************************************************//*!
+   *
+   * @brief Voltage Reference Selection.
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   * @param[in]  u8Vref adc reference voltage selection. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+void ADC_VrefSelect( ADC_Type *pADC, uint8_t u8Vref )
+{
+    uint32_t u32Temp;
+    u32Temp = pADC->SC2;
+    u32Temp &= ~ADC_SC2_REFSEL_MASK;
+    pADC->SC2 = u32Temp|ADC_SC2_REFSEL(u8Vref);
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief select clock divide
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   * @param[in]  u8Div Clock Divide Select. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+void ADC_SelectClockDivide( ADC_Type *pADC, uint8_t u8Div )
+{
+    uint32_t u32Temp;
+    u32Temp = pADC->SC3;
+    u32Temp &= ~ADC_SC3_ADIV_MASK;
+    pADC->SC3 = u32Temp|ADC_SC3_ADIV(u8Div);
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief set ADC mode.
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   * @param[in]  u8Mode Conversion Mode Selection. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+void ADC_SetMode( ADC_Type *pADC, uint8_t u8Mode )
+{
+    uint32_t u32Temp;
+    u32Temp = pADC->SC3;
+    u32Temp &= ~ADC_SC3_MODE_MASK;
+    pADC->SC3 = u32Temp|ADC_SC3_MODE(u8Mode);
+}
+/*****************************************************************************//*!
+   *
+   * @brief Input Clock Select.
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   * @param[in]  u8Clock Input Clock Select. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+void ADC_SelectClock( ADC_Type *pADC, uint8_t u8Clock )
+{
+    uint32_t u32Temp;
+    u32Temp = pADC->SC3;
+    u32Temp &= ~ADC_SC3_ADICLK_MASK;
+    pADC->SC3 = u32Temp|ADC_SC3_ADICLK(u8Clock);
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief FIFO Depth enables
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   * @param[in]  u8FifoLevel set FIFO level. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+void ADC_SetFifoLevel( ADC_Type *pADC, uint8_t u8FifoLevel )
+{
+    uint32_t u32Temp;
+    u32Temp = pADC->SC4;
+    u32Temp &= ~ADC_SC4_AFDEP_MASK;
+    pADC->SC4 = u32Temp|ADC_SC4_AFDEP(u8FifoLevel);
+}
+
+/*! @} End of adc_api_list                                               						*/
+
+
+/*****************************************************************************//*!
+   *
+   * @brief ADC interrupt service routine.
+   *        
+   * @param  none. 
+   *
+   * @return none.
+   *
+   * @ Pass/ Fail criteria: none.
+   *****************************************************************************/
+void ADC_Isr(void)
+{
+    if( ADC_Callback[0] )
+    {
+        ADC_Callback[0]();
+    }
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/bsp/frdm-ke02/device/lib/drivers/arm_cm0.c b/bsp/frdm-ke02/device/lib/drivers/arm_cm0.c
new file mode 100755
index 0000000..c88a852
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/drivers/arm_cm0.c
@@ -0,0 +1,106 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file arm_cm0.c
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief provide generic high-level routines for ARM Cortex M0/M0+ processors. 
+*
+*******************************************************************************/
+
+#include "common.h"
+
+/***********************************************************************/
+/*
+ * Configures the ARM system control register for STOP (deep sleep) mode
+ * and then executes the WFI instruction to enter the mode.
+ *
+ * Parameters:
+ * none
+ *
+ * Note: Might want to change this later to allow for passing in a parameter
+ *       to optionally set the sleep on exit bit.
+ */
+
+void stop (void)
+{
+	/* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
+	SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;	
+
+	/* WFI instruction will start entry into STOP mode */
+#ifndef KEIL
+        // If not using KEIL's uVision use the standard assembly command
+	asm("WFI");
+#else
+        // If using KEIL's uVision, use the CMSIS intrinsic
+	__wfi();
+#endif
+}
+/***********************************************************************/
+/*
+ * Configures the ARM system control register for WAIT (sleep) mode
+ * and then executes the WFI instruction to enter the mode.
+ *
+ * Parameters:
+ * none
+ *
+ * Note: Might want to change this later to allow for passing in a parameter
+ *       to optionally set the sleep on exit bit.
+ */
+
+void wait (void)
+{
+	/* Clear the SLEEPDEEP bit to make sure we go into WAIT (sleep) mode instead
+	 * of deep sleep.
+	 */
+	SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk;	
+
+	/* WFI instruction will start entry into WAIT mode */
+#ifndef KEIL
+        // If not using KEIL's uVision use the standard assembly command
+	asm("WFI");
+#else
+        // If using KEIL's uVision, use the CMSIS intrinsic
+    __wfi();
+#endif
+}
+/***********************************************************************/
+/*
+ * Change the value of the vector table offset register to the specified value.
+ *
+ * Parameters:
+ * vtor     new value to write to the VTOR
+ */
+
+void write_vtor (int vtor)
+{
+        /* Write the VTOR with the new value */
+        SCB->VTOR = vtor;	
+}
+
+/***********************************************************************/
+
diff --git a/bsp/frdm-ke02/device/lib/drivers/crc.c b/bsp/frdm-ke02/device/lib/drivers/crc.c
new file mode 100755
index 0000000..634eab5
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/drivers/crc.c
@@ -0,0 +1,285 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file     crc.c
+*
+* @author   Freescale
+*
+* @version  0.0.1
+*
+* @date     Jun 25, 2013
+*
+* @brief    Cyclic redundancy check (CRC) source code. 
+*
+******************************************************************************/
+#include "common.h"
+#include "crc.h"
+
+/******************************************************************************
+* Global variables
+******************************************************************************/
+
+/******************************************************************************
+* Constants and macros
+******************************************************************************/
+
+/******************************************************************************
+* Local types
+******************************************************************************/
+
+/******************************************************************************
+* Local function prototypes
+******************************************************************************/
+
+/******************************************************************************
+* Local variables
+******************************************************************************/
+
+/******************************************************************************
+* Local functions
+******************************************************************************/
+
+/******************************************************************************
+* Global functions
+******************************************************************************/
+
+/******************************************************************************
+* define CRC APIs
+*
+*//*! @addtogroup crc_api_list
+* @{
+*******************************************************************************/
+
+/*****************************************************************************//*!
+*
+* @brief initialize CRC with poly per control parameters
+*        
+* @param[in]  pConfig point to configuration. 
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+void CRC_Init(CRC_ConfigType *pConfig)
+{       
+    uint32_t     u32Sc ;
+    
+    u32Sc      = 0;
+    
+    SIM->SCGC |= SIM_SCGC_CRC_MASK;  
+    
+    u32Sc     |= ((pConfig->bWidth & 0x01)<<24);    
+    u32Sc     |= CRC_CTRL_TOTR(pConfig->bTransposeReadType & 0x03); 
+    u32Sc     |= CRC_CTRL_TOT(pConfig->bTransposeWriteType & 0x03);
+    
+    if (pConfig->bFinalXOR)
+    {
+        u32Sc |= CRC_CTRL_FXOR_MASK;        
+    }
+    
+    CRC0->CTRL  = u32Sc;
+
+    if ( pConfig->bWidth )      
+    {
+        CRC0->GPOLY = pConfig->u32PolyData;
+    }
+    else 
+    {
+        CRC0->GPOLY_ACCESS16BIT.GPOLYL = pConfig->u32PolyData;  /*!< only 16-bit write allowed */             
+    }  
+    
+}     
+
+
+/*****************************************************************************//*!
+*
+* @brief crc module 16-bit mode calculation.
+*        
+* @param[in]  seed  
+* @param[in]  msg  poiont to message buffer
+* @param[in]  sizeBytes  size of message
+*
+* @return data_out convertion result
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+uint32_t CRC_Cal16(uint32_t seed, uint8_t *msg, uint32_t sizeBytes)
+{
+  uint32_t ctrl_reg,data_out,data_in;
+  uint8_t  *pCRCBytes;
+  uint32_t sizeWords;
+  uint32_t i,j;  
+  
+  /* Input seed, Set WaS=1 */
+  ctrl_reg  = CRC0->CTRL;
+  CRC0->CTRL  = ctrl_reg | CRC_CTRL_WAS_MASK;
+  CRC0->ACCESS16BIT.DATAL = seed;
+  
+  /*Input data, Set WaS=0*/
+  CRC0->CTRL  = ctrl_reg & 0xFD000000;
+
+  /*Wait for calculation completion*/
+  sizeWords = sizeBytes>>1;
+  j = 0;
+  for(i=0;i<sizeWords;i++){ 
+      data_in = (msg[j] << 8) | (msg[j+1]);
+      j += 2;
+      CRC0->ACCESS16BIT.DATAL =data_in; 
+  }
+  if (j<sizeBytes)
+  { 
+     pCRCBytes = (uint8_t*)&CRC0->ACCESS8BIT.DATALL;
+     *pCRCBytes++ = msg[j];
+  }
+    data_out=CRC0->ACCESS16BIT.DATAL;
+  
+  return(data_out);
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief crc module 32-bit mode calculation.
+*        
+* @param[in]  seed 
+* @param[in]  msg  poiont to message buffer
+* @param[in]  sizeBytes  size of message
+*
+* @return data_out convertion result 
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+uint32_t CRC_Cal32(uint32_t seed, uint8_t *msg, uint32_t sizeBytes)
+{  
+  uint32_t ctrl_reg,data_out,data_in;
+  uint32_t sizeDwords;
+  uint8_t  *pCRCBytes;
+  uint32_t i,j;
+  
+  /*Input seed, Set WaS=1*/
+  ctrl_reg = CRC0->CTRL;
+  CRC0->CTRL = ctrl_reg | 0x02000000;
+  CRC0->DATA = seed;
+ 
+  /*Input data, Set WaS=0*/
+  CRC0->CTRL = ctrl_reg & 0xFD000000;
+  
+  /*Wait for calculation completion*/
+  sizeDwords = sizeBytes>>2;
+  j = 0;
+  for(i=0;i<sizeDwords;i++)
+  { 
+      data_in = ((msg[j] << 24) | (msg[j+1] << 16) | (msg[j+2] << 8) | msg[j+3]);
+      j += 4;
+      CRC0->DATA = data_in; 
+  }
+  if (j<sizeBytes)
+  {
+    pCRCBytes = (uint8_t*)&CRC0->ACCESS8BIT.DATALL;
+
+#if  defined(BYTE_ENABLES_1_2_4_8)    
+    
+    /*write single byte*/  
+    for(;j<sizeBytes;j++)
+    {     
+       *pCRCBytes++ = msg[j];
+    }
+#elif  defined(BYTE_ENABLES_3_6_C)
+    
+    /*write two bytes*/ 
+    data_in = 0;
+    i = 0;
+    for(;j<sizeBytes;j++)
+    {     
+      data_in = (data_in <<8) | msg[j];
+      i++;
+      if (i==2)
+      {
+        i = 0;
+        CRC0->ACCESS16BIT.DATAL = data_in;
+      }
+    }
+    if (i==1)
+    {
+       CRC0->ACCESS8BIT.DATALL = data_in;                /*!< write last byte */
+    }
+#elif  defined(BYTE_ENABLES_7_E)                         
+    /*!< write three bytes */
+    data_in = 0;
+    i = 0;
+    for(;j<sizeBytes;j++)
+    {     
+      data_in = (data_in <<8) | msg[j];
+      i++;
+      if (i==3)
+      {
+        i = 0;
+        /*write first  char*/
+        CRC0->ACCESS8BIT.DATAHL  = (data_in>>16) & 0xff; /*!< write low byte of high word */
+        /*write last two chars*/
+        CRC0->ACCESS16BIT.DATAL = data_in & 0x00ffff;    /*!< write low word */
+       }
+    }
+    if ( i == 2)
+    {
+       CRC0->ACCESS16BIT.DATAL = (data_in);              /*!< write last 2 bytes */
+    }
+    else if (i == 1)
+    {
+       CRC0->ACCESS8BIT.DATALL = data_in;                /*!< write last byte */      
+    }
+#else                                                    /*!< write low byte only */
+    for(;j<sizeBytes;j++)
+    {     
+       *pCRCBytes = msg[j];
+    }
+#endif            
+  }
+  data_out=CRC0->DATA;
+
+  return(data_out);
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief de-initialize crc module, reset crc register.
+*        
+* @param none 
+*
+* @return none 
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+void CRC_DeInit(void)
+{  
+   CRC0->CTRL  = 0x3000000; /*!< prepare for write 32-bit seed*/ 
+   CRC0->DATA  = 0xFFFFFFFF;/*!< write 32-bit seed to data register*/ 
+   while(!(CRC0->DATA == 0xFFFFFFFF));
+   CRC0->GPOLY = 0x00001021; 
+   CRC0->CTRL  = 0;         /*!< reset ctrl register*/  
+   SIM->SCGC &= ~SIM_SCGC_CRC_MASK;
+}
+
+/*! @} End of crc_api_list                                                   */
+
+
diff --git a/bsp/frdm-ke02/device/lib/drivers/flash.c b/bsp/frdm-ke02/device/lib/drivers/flash.c
new file mode 100755
index 0000000..ca35d68
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/drivers/flash.c
@@ -0,0 +1,1690 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file flash.c
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief providing APIs for configuring FLASH module (FLASH). 
+*
+*******************************************************************************
+*
+* provide APIs for configuring FLASH module (FLASH)
+******************************************************************************/
+#include "flash.h"
+/******************************************************************************
+* Global variables
+******************************************************************************/
+
+/******************************************************************************
+* Constants and macros
+******************************************************************************/
+
+/******************************************************************************
+* Local types
+******************************************************************************/
+
+/******************************************************************************
+* Local function prototypes
+******************************************************************************/
+
+/******************************************************************************
+* Local variables
+******************************************************************************/
+
+/******************************************************************************
+* Local functions
+******************************************************************************/
+
+/******************************************************************************
+* Global functions
+******************************************************************************/
+
+/******************************************************************************
+* define NVM APIs
+*
+*//*! @addtogroup nvm_api_list
+* @{
+*******************************************************************************/
+
+/*****************************************************************************//*!
+  *
+  * @brief initialize flash driver.
+  *        
+  * @param[in]  u32BusClock current bus clock.
+  *
+  * @return flash error status.
+  *
+  * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+
+uint16_t FLASH_Init(uint32_t u32BusClock)
+{
+	uint16_t u16Err = FLASH_ERR_SUCCESS;
+	uint8_t clkDIV = u32BusClock/1000000L - 1;
+	
+	if(!(FTMRH->FSTAT & FTMRH_FSTAT_CCIF_MASK))
+	{
+		u16Err |= FLASH_ERR_INIT_CCIF;
+		return u16Err;
+	}
+	/* initialize the flash clock to be within spec 1MHz 
+	 * 
+	 */
+	if(!(FTMRH->FCLKDIV & FTMRH_FCLKDIV_FDIVLCK_MASK))
+	{
+		/* FCLKDIV register is not locked */
+		if((FTMRH->FCLKDIV & FTMRH_FCLKDIV_FDIVLD_MASK) && 
+                  ((FTMRH->FCLKDIV & FTMRH_FCLKDIV_FDIV_MASK) != FTMRH_FCLKDIV_FDIV(clkDIV)))
+		{
+			/* flash clock prescaler is loaded but with wrong value */
+			u16Err |= FLASH_ERR_INIT_FDIV;
+			return (u16Err);
+		}
+		FTMRH->FCLKDIV = (FTMRH->FCLKDIV & ~(FTMRH_FCLKDIV_FDIV_MASK)) | FTMRH_FCLKDIV_FDIV(clkDIV);
+                
+#if 0
+		FTMRH->FCLKDIV  |= FTMRH_FCLKDIV_FDIVLCK_MASK; /* lock the prescaler */
+#endif
+	}
+	else
+	{
+		/* FCLKDIV register is locked */
+		if((FTMRH->FCLKDIV & FTMRH_FCLKDIV_FDIV_MASK) != FTMRH_FCLKDIV_FDIV(clkDIV))
+		{
+			/* flash clock prescaler is wrong */
+			u16Err |= FLASH_ERR_INIT_FDIV;
+		}
+	}
+	return (u16Err);	
+}
+
+/*****************************************************************************//*!
+  *
+  * @brief program flash routine.
+  *        
+  * @param[in]   u32NVMTargetAddress programed flash address.
+  * @param[in]   pData programming data pointer.
+  * @param[in]   u16SizeBytes programming data length.
+  *
+  * @return flash error status.
+  *
+  * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+
+uint16_t FLASH_Program(uint32_t u32NVMTargetAddress, uint8_t *pData, uint16_t u16SizeBytes)
+{
+	uint16_t u16Err = FLASH_ERR_SUCCESS;
+	uint16_t u16w2LongWordCount = u16SizeBytes>>3;
+	uint8_t  u8WrLeftBytes = (u16SizeBytes & 0x07);
+	uint16_t u16WrLeftLongWords = u8WrLeftBytes>>2;
+	uint32_t u32WrTargetAddress = u32NVMTargetAddress;
+	uint32_t u32DwData0,u32DwData1;
+	uint32_t *pDwData = (uint32_t*)pData;
+	int  i;
+	
+	// Check address to see if it is aligned to 4 bytes
+	// Global address [1:0] must be 00.
+	if(u32NVMTargetAddress & 0x03)
+	{
+		u16Err = FLASH_ERR_INVALID_PARAM;
+		return (u16Err);
+	}
+	// Loop for the two longwords (8 bytes) programming
+	for(i = 0; i < u16w2LongWordCount; i++)
+	{
+		u32DwData0 = *pDwData++;
+		u32DwData1 = *pDwData++;
+		u16Err = FLASH_Program2LongWords(u32WrTargetAddress, u32DwData0, u32DwData1);
+		if(u16Err)
+		{
+			goto EndP;
+			//break;
+		}
+		u32WrTargetAddress += 8;
+	}
+	// Loop for the single longword (4 bytes) programming
+	for(i = 0; i < u16WrLeftLongWords; i++)
+	{
+		u32DwData0 = *pDwData++;
+		u16Err = FLASH_Program1LongWord(u32WrTargetAddress, u32DwData0);
+		if(u16Err)
+		{			
+			goto EndP;
+			//break;
+		}
+		u32WrTargetAddress += 4;
+	}
+	u8WrLeftBytes = (u8WrLeftBytes-(u16WrLeftLongWords<<2));	// calculate the # of bytes that are not programmed
+	if(!u8WrLeftBytes){
+		return (u16Err);
+	}
+        
+#if     defined(BIG_ENDIAN)                
+	u32DwData0 = 0;
+	pData = (uint8_t*)pDwData;	// pointer to the left bytes
+	for(i = u8WrLeftBytes; i >0; i--)
+	{
+		u32DwData0 <<= 8;
+		u32DwData0 |= *pData++;	// MSB byte first
+	}
+	// Calculate how many bytes need to be filled with 0xFFs
+	// in order to form a single longword for the left bytes of data
+	u8WrLeftBytes = 4 - u8WrLeftBytes;	
+	//  
+	for(i = u8WrLeftBytes; i >0; i--)
+	{
+		u32DwData0 <<= 8;
+		u32DwData0 |= 0xFF;	// MSB byte first
+	}
+#else
+	u32DwData0 = 0xFFFFFFFFL;        
+	pData = (uint8_t*)pDwData+u8WrLeftBytes-1;	// pointer to the left bytes
+	for(i = u8WrLeftBytes; i >0; i--)
+	{
+		u32DwData0 <<= 8;
+		u32DwData0 |= *pData--;	// MSB byte first
+	}
+#endif	
+	// Now program the last longword
+	u16Err = FLASH_Program1LongWord(u32WrTargetAddress, u32DwData0);	
+EndP:	
+	return (u16Err);
+}
+/*****************************************************************************//*!
+  *
+  * @brief program flash routine, program 1 long word to flash.
+  *        
+  * @param[in]   u32NVMTargetAddress programed flash address.
+  * @param[in]   u32DwData programming data.
+  *
+  * @return flash error status.
+  *
+  * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+
+uint16_t FLASH_Program1LongWord(uint32_t u32NVMTargetAddress, uint32_t u32DwData)
+{
+	uint16_t u16Err = FLASH_ERR_SUCCESS;
+	
+	// Check address to see if it is aligned to 4 bytes
+	// Global address [1:0] must be 00.
+	if(u32NVMTargetAddress & 0x03)
+	{
+		u16Err = FLASH_ERR_INVALID_PARAM;
+		return (u16Err);
+	}
+	// Clear error flags
+	FTMRH->FSTAT = 0x30;
+	
+	// Write index to specify the command code to be loaded
+	FTMRH->FCCOBIX = 0x0;
+	// Write command code and memory address bits[23:16]	
+	FTMRH->FCCOBHI = FLASH_CMD_PROGRAM;// program FLASH command
+	FTMRH->FCCOBLO = u32NVMTargetAddress>>16;// memory address bits[23:16]
+	// Write index to specify the lower byte memory address bits[15:0] to be loaded
+	FTMRH->FCCOBIX = 0x1;
+	// Write the lower byte memory address bits[15:0]
+	FTMRH->FCCOBLO = u32NVMTargetAddress;
+	FTMRH->FCCOBHI = u32NVMTargetAddress>>8;
+	// Write index to specify the word0 (MSB word) to be programmed
+	FTMRH->FCCOBIX = 0x2;
+#if     defined(BIG_ENDIAN)        
+	// Write the word  0
+	FTMRH->FCCOBHI = (u32DwData>>16)>>8;
+	FTMRH->FCCOBLO = (u32DwData>>16);
+#else        
+	FTMRH->FCCOBHI = (u32DwData) >>8;	
+	FTMRH->FCCOBLO = (u32DwData);	
+#endif        
+	// Write index to specify the word1 (LSB word) to be programmed
+	FTMRH->FCCOBIX = 0x3;
+	// Write the word1 
+#if     defined(BIG_ENDIAN)        
+	FTMRH->FCCOBHI = (u32DwData) >>8;	
+	FTMRH->FCCOBLO = (u32DwData);	
+#else
+	FTMRH->FCCOBHI = (u32DwData>>16)>>8;
+	FTMRH->FCCOBLO = (u32DwData>>16);
+#endif        
+	// Launch the command
+	FLASH_LaunchCMD(TRUE);
+	
+	// Check error status
+	if(FTMRH->FSTAT & FTMRH_FSTAT_ACCERR_MASK)
+	{
+		u16Err |= FLASH_ERR_ACCESS;
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_FPVIOL_MASK)
+	{
+		u16Err |= FLASH_ERR_PROTECTION;		
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT0_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT0;		
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT1_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT1;		
+	}	
+	
+	return (u16Err);
+}
+
+/*****************************************************************************//*!
+  *
+  * @brief program flash routine, program 2long word to flash.
+  *        
+  * @param[in]   u32NVMTargetAddress programed flash address.
+  * @param[in]   u32DwData0 programming data0.
+  * @param[in]   u32DwData1 programming data1.
+  *
+  * @return flash error status.
+  *
+  * @ Pass/ Fail criteria: none
+*****************************************************************************/
+
+uint16_t FLASH_Program2LongWords(uint32_t u32NVMTargetAddress, uint32_t u32DwData0, uint32_t u32DwData1)
+{
+	uint16_t u16Err = FLASH_ERR_SUCCESS;
+	
+	// Check address to see if it is aligned to 4 bytes
+	// Global address [1:0] must be 00.
+	if(u32NVMTargetAddress & 0x03)
+	{
+		u16Err = FLASH_ERR_INVALID_PARAM;
+		return (u16Err);
+	}
+	// Clear error flags
+	FTMRH->FSTAT = 0x30;
+	
+	// Write index to specify the command code to be loaded
+	FTMRH->FCCOBIX = 0x0;
+	// Write command code and memory address bits[23:16]	
+	FTMRH->FCCOBHI = FLASH_CMD_PROGRAM;// program FLASH command
+	FTMRH->FCCOBLO = u32NVMTargetAddress>>16;// memory address bits[23:16]
+	// Write index to specify the lower byte memory address bits[15:0] to be loaded
+	FTMRH->FCCOBIX = 0x1;
+	// Write the lower byte memory address bits[15:0]
+	FTMRH->FCCOBLO = u32NVMTargetAddress;
+	FTMRH->FCCOBHI = u32NVMTargetAddress>>8;
+        
+	// Write index to specify the word0 (MSB word) to be programmed
+	FTMRH->FCCOBIX = 0x2;
+	// Write the word 0
+#if     defined(BIG_ENDIAN)                
+	//FTMRH_FCCOB = (u32DwData0>>16) & 0xFFFF;
+	FTMRH->FCCOBHI = (u32DwData0>>16)>>8;
+	FTMRH->FCCOBLO = (u32DwData0>>16);
+        
+	// Write index to specify the word1 (LSB word) to be programmed
+	FTMRH->FCCOBIX = 0x3;
+	// Write word 1
+	//FTMRH_FCCOB = (u32DwData0) & 0xFFFF;
+	FTMRH->FCCOBHI = (u32DwData0) >>8;
+	FTMRH->FCCOBLO = (u32DwData0);
+	
+	// Write index to specify the word0 (MSB word) to be programmed
+	FTMRH->FCCOBIX = 0x4;
+	// Write the word2
+	//FTMRH_FCCOB = (u32DwData1>>16) & 0xFFFF;
+	FTMRH->FCCOBHI = (u32DwData1>>16)>>8;
+	FTMRH->FCCOBLO = (u32DwData1>>16);
+        
+	// Write index to specify the word1 (LSB word) to be programmed
+	FTMRH->FCCOBIX = 0x5;
+	// Write word 3
+	//FTMRH_FCCOB = (u32DwData1) & 0xFFFF;
+	FTMRH->FCCOBHI = (u32DwData1) >>8;
+	FTMRH->FCCOBLO = (u32DwData1);
+#else
+	//FTMRH_FCCOB = (u32DwData0) & 0xFFFF;
+	FTMRH->FCCOBHI = (u32DwData0) >>8;
+	FTMRH->FCCOBLO = (u32DwData0);
+        
+	// Write index to specify the word1 (LSB word) to be programmed
+	FTMRH->FCCOBIX = 0x3;
+	// Write word 1
+	FTMRH->FCCOBHI = (u32DwData0>>16)>>8;
+	FTMRH->FCCOBLO = (u32DwData0>>16);
+	
+	// Write index to specify the word0 (MSB word) to be programmed
+	FTMRH->FCCOBIX = 0x4;
+	// Write the word2
+	//FTMRH_FCCOB = (u32DwData1) & 0xFFFF;
+	FTMRH->FCCOBHI = (u32DwData1) >>8;
+	FTMRH->FCCOBLO = (u32DwData1);        
+        
+	// Write index to specify the word1 (LSB word) to be programmed
+	FTMRH->FCCOBIX = 0x5;
+	// Write word 3
+	//FTMRH_FCCOB = (u32DwData1>>16) & 0xFFFF;
+	FTMRH->FCCOBHI = (u32DwData1>>16)>>8;
+	FTMRH->FCCOBLO = (u32DwData1>>16);
+#endif
+	// Launch the command
+	FLASH_LaunchCMD(TRUE);
+	
+	// Check error status
+	if(FTMRH->FSTAT & FTMRH_FSTAT_ACCERR_MASK)
+	{
+		u16Err |= FLASH_ERR_ACCESS;
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_FPVIOL_MASK)
+	{
+		u16Err |= FLASH_ERR_PROTECTION;		
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT0_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT0;		
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT1_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT1;		
+	}	
+	
+	return (u16Err);
+}
+
+
+
+/*****************************************************************************//*!
+  *
+  * @brief erase flash sector, each flash sector is of 512 bytes long.
+  *      
+  *        
+  * @param[in]   u32NVMTargetAddress erase sector address.
+  *
+  * @return error status.
+  *
+  * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+uint16_t FLASH_EraseSector(uint32_t u32NVMTargetAddress)
+{
+	uint16_t u16Err = FLASH_ERR_SUCCESS;
+	
+	// Check address to see if it is aligned to 4 bytes
+	// Global address [1:0] must be 00.
+	if(u32NVMTargetAddress & 0x03)
+	{
+		u16Err = FLASH_ERR_INVALID_PARAM;
+		return (u16Err);
+	}
+	// Clear error flags
+	FTMRH->FSTAT = 0x30;
+	
+	// Write index to specify the command code to be loaded
+	FTMRH->FCCOBIX = 0x0;
+	// Write command code and memory address bits[23:16]	
+	FTMRH->FCCOBHI = FLASH_CMD_ERASE_SECTOR;// EEPROM FLASH command
+	FTMRH->FCCOBLO = u32NVMTargetAddress>>16;// memory address bits[23:16]
+	// Write index to specify the lower byte memory address bits[15:0] to be loaded
+	FTMRH->FCCOBIX = 0x1;
+	// Write the lower byte memory address bits[15:0]
+	FTMRH->FCCOBLO = u32NVMTargetAddress;
+	FTMRH->FCCOBHI = u32NVMTargetAddress>>8;
+	
+	// Launch the command
+	FLASH_LaunchCMD(TRUE);
+	
+	// Check error status
+	if(FTMRH->FSTAT & FTMRH_FSTAT_ACCERR_MASK)
+	{
+		u16Err |= FLASH_ERR_ACCESS;
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_FPVIOL_MASK)
+	{
+		u16Err |= FLASH_ERR_PROTECTION;		
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT0_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT0;		
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT1_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT1;		
+	}	
+#if defined(CPU_KE02) 
+	if(FTMRH->FERSTAT & (FTMRH_FERSTAT_SFDIF_MASK))
+	{
+		u16Err |= EEPROM_ERR_SINGLE_BIT_FAULT;
+	}
+	if(FTMRH->FERSTAT & (FTMRH_FERSTAT_DFDIF_MASK))
+	{
+		u16Err |= EEPROM_ERR_DOUBLE_BIT_FAULT;
+	}
+#endif	
+	return (u16Err);
+}
+
+#if defined(CPU_KE02) 
+/*****************************************************************************//*!
+  *
+  * @brief program EEPROM routine, each program operation supports up to 4 bytes
+  * 		 programming.
+  *        
+  * @param[in]   u32NVMTargetAddress programed EEPROM address.
+  * @param[in]   pData programming data pointer.
+  * @param[in]   u16SizeBytes programming data length.
+  *
+  * @return error status.
+  *
+  * @ Pass/ Fail criteria: none
+*****************************************************************************/
+
+uint16_t EEPROM_Program(uint32_t u32NVMTargetAddress, uint8_t *pData, uint16_t u16SizeBytes)
+{
+	uint16_t u16Err = FLASH_ERR_SUCCESS;
+	uint8_t  u8WrLeftBytes = (u16SizeBytes & 0x3);
+	uint16_t u16WrLeftLongWords = u16SizeBytes>>2;
+	uint32_t u32WrTargetAddress = u32NVMTargetAddress;
+	int  i;
+	
+
+	// Loop for 4 bytes programming
+	for(i = 0; i < u16WrLeftLongWords; i++)
+	{
+		u16Err = EEPROM_ProgramUpto4Bytes(u32WrTargetAddress, pData, 4);
+		if(u16Err)
+		{
+			goto EndP;
+			//break;
+		}
+		u32WrTargetAddress += 4;
+		pData += 4;
+	}
+	if(u8WrLeftBytes>0)
+	{
+		u16Err = EEPROM_ProgramUpto4Bytes(u32WrTargetAddress, pData, u8WrLeftBytes);	
+	}
+EndP:	
+	return (u16Err);
+}
+
+#endif
+
+
+
+
+
+
+/*****************************************************************************//*!
+  *
+  * @brief unsecure device with unsecure command.
+  * 
+  *        
+  * @param none. 
+  *
+  * @return error status.
+  *
+  * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+
+uint16_t FLASH_Unsecure(void)
+{
+	uint16_t u16Err = FLASH_ERR_SUCCESS;
+	
+	// Clear error flags
+	FTMRH->FSTAT = 0x30;
+	
+	// Write index to specify the command code to be loaded
+	FTMRH->FCCOBIX = 0x0;
+	// Write command code and memory address bits[23:16]	
+	FTMRH->FCCOBHI = FTMRH_CMD_UNSECURE;// EEPROM FLASH command
+	FTMRH->FCCOBLO = 0;// memory address bits[23:16]
+	
+	// Launch the command
+	FLASH_LaunchCMD(TRUE);
+	
+	// Check error status
+	if(FTMRH->FSTAT & FTMRH_FSTAT_ACCERR_MASK)
+	{
+		u16Err |= FLASH_ERR_ACCESS;
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_FPVIOL_MASK)
+	{
+		u16Err |= FLASH_ERR_PROTECTION;		
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT0_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT0;		
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT1_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT1;		
+	}	
+#if defined(CPU_KE02) 	
+	if(FTMRH->FERSTAT & (FTMRH_FERSTAT_SFDIF_MASK))
+	{
+		u16Err |= EEPROM_ERR_SINGLE_BIT_FAULT;
+	}
+	if(FTMRH->FERSTAT & (FTMRH_FERSTAT_DFDIF_MASK))
+	{
+		u16Err |= EEPROM_ERR_DOUBLE_BIT_FAULT;
+	}
+#endif	
+	return (u16Err);
+}
+
+
+/*****************************************************************************//*!
+  *
+  * @brief erase flash/EEPROM block.
+  *        
+  * @param[in] u32NVMTargetAddress: target address in NVM. 
+  * @param[in] bIsEEPROM: specify the target address is within EEPROM,1 if in EEPROM block, 0 if in FLASH block.  
+  *					
+  * @return error status.
+  *
+  * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+#if (defined(IAR))
+__ramfunc uint16_t FLASH_EraseBlock(uint32_t u32NVMTargetAddress, uint8_t bIsEEPROM)
+#else
+uint16_t FLASH_EraseBlock(uint32_t u32NVMTargetAddress, uint8_t bIsEEPROM)
+#endif
+{
+	uint16_t u16Err = FLASH_ERR_SUCCESS;
+	
+	// Clear error flags
+	FTMRH->FSTAT = 0x30;
+	
+	// Write index to specify the command code to be loaded
+	FTMRH->FCCOBIX = 0x0;
+	// Write command code and memory address bits[23:16]	
+	FTMRH->FCCOBHI = FTMRH_CMD_ERASE_BLOCK;// erase FLASH block command
+	FTMRH->FCCOBLO = u32NVMTargetAddress>>16;// memory address bits[23:16] with bit23 = 0 for Flash block, 1 for EEPROM block
+	if(bIsEEPROM)
+	{
+		FTMRH->FCCOBLO |= 0x80;	// bit 23 = 1 for EEPROM block
+	}
+	// Write index to specify the lower byte memory address bits[15:0] to be loaded
+	FTMRH->FCCOBIX = 0x1;
+	// Write the lower byte memory address bits[15:0]
+	FTMRH->FCCOBLO = u32NVMTargetAddress;
+	FTMRH->FCCOBHI = u32NVMTargetAddress>>8;
+	
+	// Launch the command
+	FLASH_LaunchCMD(TRUE);
+	
+	// Check error status
+	if(FTMRH->FSTAT & FTMRH_FSTAT_ACCERR_MASK)
+	{
+		u16Err |= FLASH_ERR_ACCESS;
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_FPVIOL_MASK)
+	{
+		u16Err |= FLASH_ERR_PROTECTION;		
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT0_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT0;		
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT1_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT1;		
+	}	
+#if defined(CPU_KE02) 	
+	if(FTMRH->FERSTAT & (FTMRH_FERSTAT_SFDIF_MASK))
+	{
+		u16Err |= EEPROM_ERR_SINGLE_BIT_FAULT;
+	}
+	if(FTMRH->FERSTAT & (FTMRH_FERSTAT_DFDIF_MASK))
+	{
+		u16Err |= EEPROM_ERR_DOUBLE_BIT_FAULT;
+	}
+#endif	
+	return (u16Err);
+}
+
+
+/*****************************************************************************//*!
+  *
+  * @brief erase verify flash/EEPROM block.
+  *        
+  * @param[in] u32NVMTargetAddress: target address in NVM. 
+  * @param[in] bIsEEPROM: specify the target address is within EEPROM,1 if in EEPROM block, 0 if in FLASH block.  
+  *
+  * @return error status.
+  *
+  * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+uint16_t FLASH_EraseVerifyBlock(uint32_t u32NVMTargetAddress, uint8_t bIsEEPROM)
+{
+	uint16_t u16Err = FLASH_ERR_SUCCESS;
+	
+	// Clear error flags
+	FTMRH->FSTAT = 0x30;
+	
+	// Write index to specify the command code to be loaded
+	FTMRH->FCCOBIX = 0x0;
+	// Write command code and memory address bits[23:16]	
+	FTMRH->FCCOBHI = FTMRH_CMD_ERASE_VERIFY_BLOCK;// erase FLASH block command
+	FTMRH->FCCOBLO = u32NVMTargetAddress>>16;// memory address bits[23:16] with bit23 = 0 for Flash block, 1 for EEPROM block
+	if(bIsEEPROM)
+	{
+		FTMRH->FCCOBLO |= 0x80;	// bit 23 = 1 for EEPROM block
+	}
+	// Write index to specify the lower byte memory address bits[15:0] to be loaded
+	FTMRH->FCCOBIX = 0x1;
+	// Write the lower byte memory address bits[15:0]
+	FTMRH->FCCOBLO = u32NVMTargetAddress;
+	FTMRH->FCCOBHI = u32NVMTargetAddress>>8;
+	
+	// Launch the command
+	FLASH_LaunchCMD(TRUE);
+	
+	// Check error status
+	if(FTMRH->FSTAT & FTMRH_FSTAT_ACCERR_MASK)
+	{
+		u16Err |= FLASH_ERR_ACCESS;
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT0_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT0;		
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT1_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT1;		
+	}	
+#if defined(CPU_KE02) 	
+	if(FTMRH->FERSTAT & (FTMRH_FERSTAT_SFDIF_MASK))
+	{
+		u16Err |= EEPROM_ERR_SINGLE_BIT_FAULT;
+	}
+	if(FTMRH->FERSTAT & (FTMRH_FERSTAT_DFDIF_MASK))
+	{
+		u16Err |= EEPROM_ERR_DOUBLE_BIT_FAULT;
+	}
+#endif	
+	return (u16Err);
+}
+
+/*****************************************************************************//*!
+  *
+  * @brief erase verify flash section.
+  *        
+  * @param[in]  u32NVMTargetAddress: target address in NVM, must be longword aligned. 
+  * @param[in]  u16LongWordCount:   number of longwords to be verified.
+  *	
+  * @return error status.
+  *
+  * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+uint16_t FLASH_EraseVerifySection(uint32_t u32NVMTargetAddress, uint16_t u16LongWordCount)
+{
+	uint16_t u16Err = FLASH_ERR_SUCCESS;
+	// Check address to see if it is aligned to 4 bytes
+	// Global address [1:0] must be 00.
+	if(u32NVMTargetAddress & 0x03)
+	{
+		u16Err = FLASH_ERR_INVALID_PARAM;
+		return (u16Err);
+	}	
+	// Clear error flags
+	FTMRH->FSTAT = 0x30;
+	
+	// Write index to specify the command code to be loaded
+	FTMRH->FCCOBIX = 0x0;
+	// Write command code and memory address bits[23:16]	
+	FTMRH->FCCOBHI = FLASH_CMD_ERASE_VERIFY_SECTION;// erase verify FLASH section command
+	FTMRH->FCCOBLO = u32NVMTargetAddress>>16;// memory address bits[23:16] with bit23 = 0 for Flash block, 1 for EEPROM block
+	// Write index to specify the lower byte memory address bits[15:0] to be loaded
+	FTMRH->FCCOBIX = 0x1;
+	// Write the lower byte memory address bits[15:0]
+	FTMRH->FCCOBLO = u32NVMTargetAddress;
+	FTMRH->FCCOBHI = u32NVMTargetAddress>>8;
+
+	// Write index to specify the # of longwords to be verified
+	FTMRH->FCCOBIX = 0x2;
+	// Write the # of longwords 
+	FTMRH->FCCOBLO = u16LongWordCount;
+	FTMRH->FCCOBHI = u16LongWordCount>>8;
+	
+	// Launch the command
+	FLASH_LaunchCMD(TRUE);
+	
+	// Check error status
+	if(FTMRH->FSTAT & FTMRH_FSTAT_ACCERR_MASK)
+	{
+		u16Err |= FLASH_ERR_ACCESS;
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT0_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT0;		
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT1_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT1;		
+	}	
+#if defined(CPU_KE02) 
+	if(FTMRH->FERSTAT & (FTMRH_FERSTAT_SFDIF_MASK))
+	{
+		u16Err |= EEPROM_ERR_SINGLE_BIT_FAULT;
+	}
+	if(FTMRH->FERSTAT & (FTMRH_FERSTAT_DFDIF_MASK))
+	{
+		u16Err |= EEPROM_ERR_DOUBLE_BIT_FAULT;
+	}
+#endif
+#if 0	
+	if(FTMRH->FSTAT & FTMRH_FSTAT_FPVIOL_MASK)
+	{
+		u16Err |= FLASH_ERR_PROTECTION;		
+	}
+#endif	
+	return (u16Err);
+}
+
+/*****************************************************************************//*!
+  *
+  * @brief erase verify all flash and EEPROM blocks.
+  *        
+  * @param  none.
+  *	
+  * @return error status.
+  *
+  * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+uint16_t FLASH_EraseVerifyAll(void)
+{
+	uint16_t u16Err = FLASH_ERR_SUCCESS;
+	
+	// Clear error flags
+	FTMRH->FSTAT = 0x30;
+	
+	// Write index to specify the command code to be loaded
+	FTMRH->FCCOBIX = 0x0;
+	// Write command code and memory address bits[23:16]	
+	FTMRH->FCCOBHI = FTMRH_CMD_ERASE_VERIFY_ALL;// erase verify all flash & EEPROM blocks
+	
+	// Launch the command
+	FLASH_LaunchCMD(TRUE);
+	
+	// Check error status
+	if(FTMRH->FSTAT & FTMRH_FSTAT_ACCERR_MASK)
+	{
+		u16Err |= FLASH_ERR_ACCESS;
+	}
+	
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT0_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT0;		
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT1_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT1;		
+	}	
+#if 0	
+	if(FTMRH->FERSTAT & (FTMRH_FERSTAT_SFDIF_MASK))
+	{
+		u16Err |= EEPROM_ERR_SINGLE_BIT_FAULT;
+	}
+	if(FTMRH->FERSTAT & (FTMRH_FERSTAT_DFDIF_MASK))
+	{
+		u16Err |= EEPROM_ERR_DOUBLE_BIT_FAULT;
+	}
+
+	if(FTMRH->FSTAT & FTMRH_FSTAT_FPVIOL_MASK)
+	{
+		u16Err |= FLASH_ERR_PROTECTION;		
+	}
+#endif	
+	return (u16Err);
+}
+
+/*****************************************************************************//*!
+  *
+  * @brief erase all flash and EEPROM blocks.
+  *        
+  * @param  none.
+  *	
+  * @return error status.
+  *
+  * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+uint16_t FLASH_EraseAll(void)
+{
+	uint16_t u16Err = FLASH_ERR_SUCCESS;
+	// Clear error flags
+	FTMRH->FSTAT = 0x30;
+	
+	// Write index to specify the command code to be loaded
+	FTMRH->FCCOBIX = 0x0;
+	// Write command code and memory address bits[23:16]	
+	FTMRH->FCCOBHI = FTMRH_CMD_ERASE_ALL;// erase  all flash & EEPROM blocks
+	
+	// Launch the command
+	FLASH_LaunchCMD(TRUE);
+	
+	// Check error status
+	if(FTMRH->FSTAT & FTMRH_FSTAT_ACCERR_MASK)
+	{
+		u16Err |= FLASH_ERR_ACCESS;
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT0_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT0;		
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT1_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT1;		
+	}	
+#if 0	
+	if(FTMRH->FERSTAT & (FTMRH_FERSTAT_SFDIF_MASK))
+	{
+		u16Err |= EEPROM_ERR_SINGLE_BIT_FAULT;
+	}
+	if(FTMRH->FERSTAT & (FTMRH_FERSTAT_DFDIF_MASK))
+	{
+		u16Err |= EEPROM_ERR_DOUBLE_BIT_FAULT;
+	}
+#endif	
+
+	if(FTMRH->FSTAT & FTMRH_FSTAT_FPVIOL_MASK)
+	{
+		u16Err |= FLASH_ERR_PROTECTION;		
+	}
+	
+	return (u16Err);
+}
+
+/*****************************************************************************//*!
+  *
+  * @brief program once command, write data buff to IFR.
+  *        
+  * @param[in]  u8PhraseIndex phrase index.
+  * @param[in]  pData8Bytes  programming data pointer.
+  *
+  * @return error status.
+  *
+  * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+
+uint16_t FLASH_ProgramOnce(uint8_t u8PhraseIndex, uint8_t *pData8Bytes)
+{
+	uint16_t u16Err = FLASH_ERR_SUCCESS;
+	int i;
+	
+	// Check the phrase index to if it is out of boundary
+	if(u8PhraseIndex > 7)
+	{
+		u16Err = FLASH_ERR_INVALID_PARAM;
+		return (u16Err);
+	}
+	// Clear error flags
+	FTMRH->FSTAT = 0x30;
+	
+	// Write index to specify the command code to be loaded
+	FTMRH->FCCOBIX = 0x0;
+	// Write command code and memory address bits[17:16]	
+	FTMRH->FCCOBHI = FLASH_CMD_PROGRAMONCE;// command
+	FTMRH->FCCOBLO = 0;// memory address bits[17:16]
+	// Write index to specify the lower byte memory address bits[15:0] to be loaded
+	FTMRH->FCCOBIX = 0x1;
+	// Write the phrase index
+	FTMRH->FCCOBLO = u8PhraseIndex;
+	FTMRH->FCCOBHI = u8PhraseIndex>>8;
+	
+	// Write 4 words
+	for(i = 0; i < 4; i++)
+	{
+		// Write index to specify the word (MSB word) to be programmed
+		FTMRH->FCCOBIX = 0x2+i;
+		// Write the word 0
+		FTMRH->FCCOBHI = ((uint16_t)pData8Bytes[(i<<1)+1]);
+                FTMRH->FCCOBLO = pData8Bytes[(i<<1)];
+	}
+	// Launch the command
+	FLASH_LaunchCMD(TRUE);
+	
+	// Check error status
+	if(FTMRH->FSTAT & FTMRH_FSTAT_ACCERR_MASK)
+	{
+		u16Err |= FLASH_ERR_ACCESS;
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_FPVIOL_MASK)
+	{
+		u16Err |= FLASH_ERR_PROTECTION;		
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT0_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT0;		
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT1_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT1;		
+	}	
+	
+	return (u16Err);
+}
+/*****************************************************************************//*!
+  *
+  * @brief read data from IFR address.
+  *        
+  * @param[in]  u8PhraseIndex phrase index.
+  * @param[out]  pData8Bytes  read data pointer.
+  *	
+  * @return error status.
+  *
+  * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+
+uint16_t FLASH_ReadOnce(uint8_t u8PhraseIndex, uint8_t *pData8Bytes)
+{
+	uint16_t u16Err = FLASH_ERR_SUCCESS;
+	int i;
+	
+	// Check the phrase index to if it is out of boundary
+	if(u8PhraseIndex > 7)
+	{
+		u16Err = FLASH_ERR_INVALID_PARAM;
+		return (u16Err);
+	}
+	// Clear error flags
+	FTMRH->FSTAT = 0x30;
+	
+	// Write index to specify the command code to be loaded
+	FTMRH->FCCOBIX = 0x0;
+	// Write command code and memory address bits[17:16]	
+	FTMRH->FCCOBHI = FLASH_CMD_READONCE;// command
+	FTMRH->FCCOBLO = 0;// memory address bits[17:16]
+	// Write index to specify the lower byte memory address bits[15:0] to be loaded
+	FTMRH->FCCOBIX = 0x1;
+	// Write the phrase index
+	FTMRH->FCCOBLO = u8PhraseIndex;	
+	FTMRH->FCCOBHI = u8PhraseIndex >>8;	
+	// Launch the command
+	FLASH_LaunchCMD(TRUE);
+	// Read 4 words
+	for(i = 0; i < 4; i++)
+	{
+		// Read the word (MSB word) indexed by FCCOBIX 
+		FTMRH->FCCOBIX = 0x2+i;
+		pData8Bytes[i<<1] = FTMRH->FCCOBLO; 
+		pData8Bytes[(i<<1)+1] = FTMRH->FCCOBHI; 
+	}	
+	// Check error status
+	if(FTMRH->FSTAT & FTMRH_FSTAT_ACCERR_MASK)
+	{
+		u16Err |= FLASH_ERR_ACCESS;
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_FPVIOL_MASK)
+	{
+		u16Err |= FLASH_ERR_PROTECTION;		
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT0_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT0;		
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT1_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT1;		
+	}
+
+	return (u16Err);
+}
+
+
+#if defined(CPU_KE02) 
+/*****************************************************************************//*!
+  *
+  * @brief erase verify flash section.
+  *        
+  * @param[in] u32NVMTargetAddress: target address in NVM, must be longword aligned.  
+  * @param[in] u16LongWordCount:   number of bytes to be verified.
+  *	
+  * @return none
+  *
+  * @ Pass/ Fail criteria: none
+*****************************************************************************/
+uint16_t EEPROM_EraseVerifySection(uint32_t u32NVMTargetAddress, uint16_t u16ByteCount)
+{
+	uint16_t u16Err = FLASH_ERR_SUCCESS;
+	// Check address to see if it is aligned to 4 bytes
+	// Global address [1:0] must be 00.
+	if(u32NVMTargetAddress & 0x03)
+	{
+		u16Err = FLASH_ERR_INVALID_PARAM;
+		return (u16Err);
+	}
+	// Clear error flags
+	FTMRH->FSTAT = 0x30;
+	
+	// Write index to specify the command code to be loaded
+	FTMRH->FCCOBIX = 0x0;
+	// Write command code and memory address bits[23:16]	
+	FTMRH->FCCOBHI = EEPROM_CMD_ERASE_VERIFY_SECTION;// erase verify FLASH section command
+	FTMRH->FCCOBLO = u32NVMTargetAddress>>16;// memory address bits[23:16] with bit23 = 0 for Flash block, 1 for EEPROM block
+	// Write index to specify the lower byte memory address bits[15:0] to be loaded
+	FTMRH->FCCOBIX = 0x1;
+	// Write the lower byte memory address bits[15:0]
+	FTMRH->FCCOBHI = u32NVMTargetAddress>>8;
+	FTMRH->FCCOBLO = u32NVMTargetAddress;
+	// Write index to specify the # of longwords to be verified
+	FTMRH->FCCOBIX = 0x2;
+	// Write the # of longwords 
+	FTMRH->FCCOBLO = u16ByteCount;
+	FTMRH->FCCOBHI = u16ByteCount>>8;
+	
+	// Launch the command
+	FLASH_LaunchCMD(TRUE);
+	
+	// Check error status
+	if(FTMRH->FSTAT & FTMRH_FSTAT_ACCERR_MASK)
+	{
+		u16Err |= FLASH_ERR_ACCESS;
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT0_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT0;		
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT1_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT1;		
+	}
+#if 0	
+	if(FTMRH->FERSTAT & (FTMRH_FERSTAT_SFDIF_MASK))
+	{
+		u16Err |= EEPROM_ERR_SINGLE_BIT_FAULT;
+	}
+	if(FTMRH->FERSTAT & (FTMRH_FERSTAT_DFDIF_MASK))
+	{
+		u16Err |= EEPROM_ERR_DOUBLE_BIT_FAULT;
+	}	
+	
+	if(FTMRH->FSTAT & FTMRH_FSTAT_FPVIOL_MASK)
+	{
+		u16Err |= FLASH_ERR_PROTECTION;		
+	}
+#endif	
+	return (u16Err);
+}
+/*****************************************************************************//*!
+  *
+  * @brief program one byte to EEPROM.
+  *        
+  * @param[in] u32NVMTargetAddress: target address in EEPROM.  
+  * @param[in] u8Data:   programming data.
+  *	
+  * @return error status.
+  *
+  * @ Pass/ Fail criteria: none
+*****************************************************************************/
+uint16_t EEPROM_Program1Byte(uint32_t u32NVMTargetAddress, uint8_t u8Data)
+{
+	uint16_t u16Err = FLASH_ERR_SUCCESS;
+	
+	// Clear error flags
+	FTMRH->FSTAT = 0x30;
+	
+	// Write index to specify the command code to be loaded
+	FTMRH->FCCOBIX = 0x0;
+	// Write command code and memory address bits[23:16]	
+	FTMRH->FCCOBHI = EEPROM_CMD_PROGRAM;// EEPROM FLASH command
+	FTMRH->FCCOBLO = u32NVMTargetAddress>>16;// memory address bits[23:16]
+	// Write index to specify the lower byte memory address bits[15:0] to be loaded
+	FTMRH->FCCOBIX = 0x1;
+	// Write the lower byte memory address bits[15:0]
+	FTMRH->FCCOBHI = u32NVMTargetAddress>>8;
+	FTMRH->FCCOBLO = u32NVMTargetAddress;
+	// Write index to specify the byte0 (MSB word) to be programmed
+	FTMRH->FCCOBIX = 0x2;
+	// Write the byte 0
+	FTMRH->FCCOBLO = u8Data;
+	// Launch the command
+	FLASH_LaunchCMD(TRUE);
+
+	
+	// Check error status
+	if(FTMRH->FSTAT & FTMRH_FSTAT_ACCERR_MASK)
+	{
+		u16Err |= FLASH_ERR_ACCESS;
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_FPVIOL_MASK)
+	{
+		u16Err |= FLASH_ERR_PROTECTION;		
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT0_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT0;		
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT1_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT1;		
+	}	
+#if 0	
+	if(FTMRH->FERSTAT & (FTMRH_FERSTAT_SFDIF_MASK))
+	{
+		u16Err |= EEPROM_ERR_SINGLE_BIT_FAULT;
+	}
+	if(FTMRH->FERSTAT & (FTMRH_FERSTAT_DFDIF_MASK))
+	{
+		u16Err |= EEPROM_ERR_DOUBLE_BIT_FAULT;
+	}
+#endif	
+	
+	return (u16Err);
+}
+
+/*****************************************************************************//*!
+  *
+  * @brief program up to 4 bytes to EEPROM.
+  *        
+  * @param[in] u32NVMTargetAddress: target address in EEPROM.  
+  * @param[in] pData:   programming data pointer.
+  * @param[in] u8ByteCount number of programming data.
+  *	
+  * @return error status.
+  *
+  * @ Pass/ Fail criteria: none
+*****************************************************************************/
+uint16_t EEPROM_ProgramUpto4Bytes(uint32_t u32NVMTargetAddress, uint8_t *pData, uint8_t u8ByteCount)
+{
+	int i;
+	uint16_t u16Err = FLASH_ERR_SUCCESS;
+	if(u8ByteCount >4 || u8ByteCount == 0)
+	{
+		u16Err = FLASH_ERR_INVALID_PARAM;
+		return (u16Err);		
+	}
+	// Clear error flags
+	FTMRH->FSTAT = 0x30;
+	
+	// Write index to specify the command code to be loaded
+	FTMRH->FCCOBIX = 0x0;
+	// Write command code and memory address bits[23:16]	
+	FTMRH->FCCOBHI = EEPROM_CMD_PROGRAM;// EEPROM FLASH command
+	FTMRH->FCCOBLO = u32NVMTargetAddress>>16;// memory address bits[23:16]
+	// Write index to specify the lower byte memory address bits[15:0] to be loaded
+	FTMRH->FCCOBIX = 0x1;
+	// Write the lower byte memory address bits[15:0]
+	FTMRH->FCCOBHI = u32NVMTargetAddress>>8;
+	FTMRH->FCCOBLO = u32NVMTargetAddress;
+	
+	for (i = 0; i < u8ByteCount; i++)
+	{
+		// Write index to specify the byte0 (MSB word) to be programmed
+		FTMRH->FCCOBIX = 0x2+i;
+		// Write the byte 0
+		FTMRH->FCCOBLO = *pData++;
+	}
+	// Launch the command
+	FLASH_LaunchCMD(TRUE);
+	
+	// Check error status
+	if(FTMRH->FSTAT & FTMRH_FSTAT_ACCERR_MASK)
+	{
+		u16Err |= FLASH_ERR_ACCESS;
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_FPVIOL_MASK)
+	{
+		u16Err |= FLASH_ERR_PROTECTION;		
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT0_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT0;		
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT1_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT1;		
+	}	
+#if 0	
+	if(FTMRH->FERSTAT & (FTMRH_FERSTAT_SFDIF_MASK))
+	{
+		u16Err |= EEPROM_ERR_SINGLE_BIT_FAULT;
+	}
+	if(FTMRH->FERSTAT & (FTMRH_FERSTAT_DFDIF_MASK))
+	{
+		u16Err |= EEPROM_ERR_DOUBLE_BIT_FAULT;
+	}
+#endif	
+	return (u16Err);
+}
+
+
+/*****************************************************************************//*!
+  *
+  * @brief erase EEPROM sector, each EEPROM sector is of 2 bytes long.
+  * 		 
+  * @param[in]  u32NVMTargetAddress target EEPROM address. 
+  *
+  * @return error status.
+  *
+  * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+uint16_t EEPROM_EraseSector(uint32_t u32NVMTargetAddress)
+{
+	uint16_t u16Err = FLASH_ERR_SUCCESS;
+
+	// Clear error flags
+	FTMRH->FSTAT = 0x30;
+	
+	// Write index to specify the command code to be loaded
+	FTMRH->FCCOBIX = 0x0;
+	// Write command code and memory address bits[23:16]	
+	FTMRH->FCCOBHI = EEPROM_CMD_ERASE_SECTOR;// EEPROM FLASH command
+	FTMRH->FCCOBLO = u32NVMTargetAddress>>16;// memory address bits[23:16]
+	// Write index to specify the lower byte memory address bits[15:0] to be loaded
+	FTMRH->FCCOBIX = 0x1;
+	// Write the lower byte memory address bits[15:0]
+	FTMRH->FCCOBHI = u32NVMTargetAddress>>8;
+	FTMRH->FCCOBLO = u32NVMTargetAddress;        
+	
+	// Launch the command
+        FLASH_LaunchCMD(TRUE);
+	
+	// Check error status
+	if(FTMRH->FSTAT & FTMRH_FSTAT_ACCERR_MASK)
+	{
+		u16Err |= FLASH_ERR_ACCESS;
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_FPVIOL_MASK)
+	{
+		u16Err |= FLASH_ERR_PROTECTION;		
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT0_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT0;		
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT1_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT1;		
+	}	
+#if 0	
+	if(FTMRH->FERSTAT & (FTMRH_FERSTAT_SFDIF_MASK))
+	{
+		u16Err |= EEPROM_ERR_SINGLE_BIT_FAULT;
+	}
+	if(FTMRH->FERSTAT & (FTMRH_FERSTAT_DFDIF_MASK))
+	{
+		u16Err |= EEPROM_ERR_DOUBLE_BIT_FAULT;
+	}
+#endif	
+	return (u16Err);
+}
+
+/*****************************************************************************//*!
+  *
+  * @brief program one byte to EEPROM, don't wait complete flag.
+  *        
+  * @param[in] u32NVMTargetAddress: target address in EEPROM.  
+  * @param[in] u8Data:   programming data.
+  *	
+  * @return error status.
+  *
+  * @ Pass/ Fail criteria: none
+*****************************************************************************/
+uint16_t EEPROM_Program1Byte_NoWait(uint32_t u32NVMTargetAddress, uint8_t u8Data)
+{
+	uint16_t u16Err = FLASH_ERR_SUCCESS;
+	
+	// Clear error flags
+	FTMRH->FSTAT = 0x30;
+	
+	// Write index to specify the command code to be loaded
+	FTMRH->FCCOBIX = 0x0;
+	// Write command code and memory address bits[23:16]	
+	FTMRH->FCCOBHI = EEPROM_CMD_PROGRAM;// EEPROM FLASH command
+	FTMRH->FCCOBLO = u32NVMTargetAddress>>16;// memory address bits[23:16]
+	// Write index to specify the lower byte memory address bits[15:0] to be loaded
+	FTMRH->FCCOBIX = 0x1;
+	// Write the lower byte memory address bits[15:0]
+	FTMRH->FCCOBHI = u32NVMTargetAddress>>8;
+	FTMRH->FCCOBLO = u32NVMTargetAddress;
+	// Write index to specify the byte0 (MSB word) to be programmed
+	FTMRH->FCCOBIX = 0x2;
+	// Write the byte 0
+	FTMRH->FCCOBLO = u8Data;
+	// Launch the command
+	FTMRH->FSTAT = 0x80;
+
+	return (u16Err);
+}
+
+/*****************************************************************************//*!
+  *
+  * @brief program up to 4 bytes to EEPROM, don't wait complete flag.
+  *        
+  * @param[in] u32NVMTargetAddress: target address in EEPROM.  
+  * @param[in] pData:   programming data pointer.
+  * @param[in] u8ByteCount number of programming data.
+  *	
+  * @return error status.
+  *
+  * @ Pass/ Fail criteria: none
+*****************************************************************************/
+uint16_t EEPROM_ProgramUpto4Bytes_NoWait(uint32_t u32NVMTargetAddress, uint8_t *pData, uint8_t u8ByteCount)
+{
+	int i;
+	uint16_t u16Err = FLASH_ERR_SUCCESS;
+	if(u8ByteCount >4 || u8ByteCount == 0)
+	{
+		u16Err = FLASH_ERR_INVALID_PARAM;
+		return (u16Err);		
+	}
+	// Clear error flags
+	FTMRH->FSTAT = 0x30;
+	
+	// Write index to specify the command code to be loaded
+	FTMRH->FCCOBIX = 0x0;
+	// Write command code and memory address bits[23:16]	
+	FTMRH->FCCOBHI = EEPROM_CMD_PROGRAM;// EEPROM FLASH command
+	FTMRH->FCCOBLO = u32NVMTargetAddress>>16;// memory address bits[23:16]
+	// Write index to specify the lower byte memory address bits[15:0] to be loaded
+	FTMRH->FCCOBIX = 0x1;
+	// Write the lower byte memory address bits[15:0]
+	FTMRH->FCCOBHI = u32NVMTargetAddress>>8;
+	FTMRH->FCCOBLO = u32NVMTargetAddress;
+	
+	for (i = 0; i < u8ByteCount; i++)
+	{
+		// Write index to specify the byte0 (MSB word) to be programmed
+		FTMRH->FCCOBIX = 0x2+i;
+		// Write the byte 0
+		FTMRH->FCCOBLO = *pData++;
+	}
+	// Launch the command
+	FTMRH->FSTAT = 0x80;
+      
+	return (u16Err);
+}
+/*****************************************************************************//*!
+  *
+  * @brief erase EEPROM sector, each EEPROM sector is of 2 bytes long, don't wait complete flag.
+  * 		 
+  * @param[in]  u32NVMTargetAddress target EEPROM address. 
+  *
+  * @return error status.
+  *
+  * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+uint16_t EEPROM_EraseSector_NoWait(uint32_t u32NVMTargetAddress)
+{
+	uint16_t u16Err = FLASH_ERR_SUCCESS;
+
+	// Clear error flags
+	FTMRH->FSTAT = 0x30;
+	
+	// Write index to specify the command code to be loaded
+	FTMRH->FCCOBIX = 0x0;
+	// Write command code and memory address bits[23:16]	
+	FTMRH->FCCOBHI = EEPROM_CMD_ERASE_SECTOR;// EEPROM FLASH command
+	FTMRH->FCCOBLO = u32NVMTargetAddress>>16;// memory address bits[23:16]
+	// Write index to specify the lower byte memory address bits[15:0] to be loaded
+	FTMRH->FCCOBIX = 0x1;
+	// Write the lower byte memory address bits[15:0]
+	FTMRH->FCCOBHI = u32NVMTargetAddress>>8;
+	FTMRH->FCCOBLO = u32NVMTargetAddress;        
+	
+	// Launch the command
+	FTMRH->FSTAT = 0x80;
+	
+	return (u16Err);
+}
+
+#endif
+/*****************************************************************************//*!
+  *
+  * @brief erase flash/Flash block without wait.
+  *        
+  * @param[in] u32NVMTargetAddress: target address in NVM.  
+  * @param[in] bIsEEPROM: specify the target address is within EEPROM, 
+  *						1 if in EEPROM block, 0 if in FLASH block. 
+  *					
+  * @return error status.
+  *
+  * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+uint16_t FLASH_EraseBlock_NoWait(uint32_t u32NVMTargetAddress, uint8_t bIsEEPROM)
+{
+	uint16_t u16Err = FLASH_ERR_SUCCESS;
+	
+	// Clear error flags
+	FTMRH->FSTAT = 0x30;
+	
+	// Write index to specify the command code to be loaded
+	FTMRH->FCCOBIX = 0x0;
+	// Write command code and memory address bits[23:16]	
+	FTMRH->FCCOBHI = FTMRH_CMD_ERASE_BLOCK;// erase FLASH block command
+	FTMRH->FCCOBLO = u32NVMTargetAddress>>16;// memory address bits[23:16] with bit23 = 0 for Flash block, 1 for EEPROM block
+	if(bIsEEPROM)
+	{
+		FTMRH->FCCOBLO |= 0x80;	// bit 23 = 1 for EEPROM block
+	}
+	// Write index to specify the lower byte memory address bits[15:0] to be loaded
+	FTMRH->FCCOBIX = 0x1;
+	// Write the lower byte memory address bits[15:0]
+	FTMRH->FCCOBLO = u32NVMTargetAddress;
+	FTMRH->FCCOBHI = u32NVMTargetAddress>>8;
+	
+	// Launch the command
+	FTMRH->FSTAT = 0x80;
+
+	return (u16Err);
+}
+
+
+/*****************************************************************************//*!
+  *
+  * @brief verify backdoor key. NOTE: this routine must be running from RAM or EEPROM.
+  *        
+  * @param[in] u32NVMTargetAddress: target address in NVM, must be longword aligned.  
+  * @param[in] pKey:   pointer to 8-byte key.
+  *	
+  * @return error status.
+  *
+  * @ Pass/ Fail criteria: none
+*****************************************************************************/
+ 
+uint16_t FLASH_VerifyBackdoorKey(uint8_t *pKey)
+{
+	uint16_t u16Err = FLASH_ERR_SUCCESS;
+    uint16_t i;
+        
+	// Clear error flags
+	FTMRH->FSTAT = 0x30;
+	
+	// Write index to specify the command code to be loaded
+	FTMRH->FCCOBIX = 0x0;
+	// Write command code and memory address bits[23:16]	
+	FTMRH->FCCOBHI = FLASH_CMD_BACKDOOR_ACCESS;// erase verify FLASH section command
+	FTMRH->FCCOBLO = 0;// memory address bits[23:16] with bit23 = 0 for Flash block, 1 for EEPROM block	
+        // Write index to specify the lower byte memory address bits[15:0] to be loaded
+ 
+        for(i = 0; i < 4; i++)
+        {
+            FTMRH->FCCOBIX = 0x1+i;
+            FTMRH->FCCOBLO = *pKey++;
+            FTMRH->FCCOBHI = *pKey++;      
+        }
+	
+	// Launch the command
+	FLASH_LaunchCMD(TRUE);
+
+	// Check error status
+	if(FTMRH->FSTAT & FTMRH_FSTAT_ACCERR_MASK)
+	{
+		u16Err |= FLASH_ERR_ACCESS;
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT0_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT0;		
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT1_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT1;		
+	}	
+#if defined(CPU_KE02) 
+	if(FTMRH->FERSTAT & (FTMRH_FERSTAT_SFDIF_MASK))
+	{
+		u16Err |= EEPROM_ERR_SINGLE_BIT_FAULT;
+	}
+	if(FTMRH->FERSTAT & (FTMRH_FERSTAT_DFDIF_MASK))
+	{
+		u16Err |= EEPROM_ERR_DOUBLE_BIT_FAULT;
+	}
+#endif
+	return (u16Err);
+}
+
+/*****************************************************************************//*!
+  *
+  * @brief set user margin level.
+  *        
+  * @param[in] u32NVMTargetAddress: target address in NVM, must be longword aligned.  
+  * @param[in] u16MarginLevel:  user margin level.
+  * @param[in] bIsEEPROM:  true if EEPROM address, false if flash address.
+  *       
+  * @return error status.
+  *
+  * @ Pass/ Fail criteria: none.
+  *
+*****************************************************************************/
+ 
+uint16_t FLASH_SetUserMarginLevel(uint32_t u32NVMTargetAddress, uint16_t u16MarginLevel, uint8_t bIsEEPROM)
+{
+	uint16_t u16Err = FLASH_ERR_SUCCESS;
+ 	if(u16MarginLevel > 2)
+	{
+		u16Err = FLASH_ERR_INVALID_PARAM;
+		return (u16Err);		
+	}
+       
+	// Clear error flags
+	FTMRH->FSTAT = 0x30;
+	
+	// Write index to specify the command code to be loaded
+	FTMRH->FCCOBIX = 0x0;
+	// Write command code and memory address bits[23:16]	
+	FTMRH->FCCOBHI = FLASH_CMD_SET_USER_MARGIN_LEVEL;// erase verify FLASH section command
+	FTMRH->FCCOBLO = u32NVMTargetAddress >> 16;// memory address bits[23:16] with bit23 = 0 for Flash block, 1 for EEPROM block	
+	if(bIsEEPROM)
+	{
+		FTMRH->FCCOBLO |= 0x80;	// bit 23 = 1 for EEPROM block
+	}
+	FTMRH->FCCOBIX = 0x1;
+	FTMRH->FCCOBHI = u32NVMTargetAddress >> 8;// 
+	FTMRH->FCCOBLO = u32NVMTargetAddress;	
+
+        FTMRH->FCCOBIX = 0x2;
+	FTMRH->FCCOBHI = u16MarginLevel >> 8;// 
+	FTMRH->FCCOBLO = u16MarginLevel;	
+
+	// Launch the command
+	FLASH_LaunchCMD(TRUE);
+
+	// Check error status
+	if(FTMRH->FSTAT & FTMRH_FSTAT_ACCERR_MASK)
+	{
+		u16Err |= FLASH_ERR_ACCESS;
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT0_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT0;		
+	}
+	if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT1_MASK)
+	{
+		u16Err |= FLASH_ERR_MGSTAT1;		
+	}
+#if defined(CPU_KE02) 
+	if(FTMRH->FERSTAT & (FTMRH_FERSTAT_SFDIF_MASK))
+	{
+		u16Err |= EEPROM_ERR_SINGLE_BIT_FAULT;
+	}
+	if(FTMRH->FERSTAT & (FTMRH_FERSTAT_DFDIF_MASK))
+	{
+		u16Err |= EEPROM_ERR_DOUBLE_BIT_FAULT;
+	}
+#endif
+
+	return (u16Err);
+}
+/*****************************************************************************//*!
+  *
+  * @brief check flash error status.
+  *        
+  * @param none.
+  *       
+  * @return flash error status.
+  *
+  * @ Pass/ Fail criteria: none.
+  *
+*****************************************************************************/
+uint16_t FLASH_CheckErrStatus(void)
+{
+    uint16_t u16Err = FLASH_ERR_SUCCESS;  
+    if(FTMRH->FSTAT & FTMRH_FSTAT_ACCERR_MASK)
+    {
+            u16Err |= FLASH_ERR_ACCESS;
+    }
+    if(FTMRH->FSTAT & FTMRH_FSTAT_FPVIOL_MASK)
+    {
+            u16Err |= FLASH_ERR_PROTECTION;		
+    }
+    if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT0_MASK)
+    {
+            u16Err |= FLASH_ERR_MGSTAT0;		
+    }
+    if(FTMRH->FSTAT & FTMRH_FSTAT_MGSTAT1_MASK)
+    {
+            u16Err |= FLASH_ERR_MGSTAT1;		
+    }
+    return (u16Err);
+}
+
+/*****************************************************************************//*!
+  *
+  * @brief launch NVM command. if bWaitComplete is true, then wait till command
+  *        is completed. It should be placed in RAM for some commands like
+  *        verify backdoor key if enabling flash controller bit is cleared. Otherwise,
+  *        it can be executed in flash.
+  *        
+  * @param[in] bWaitComplete:  true if need wait till command completed before return.  
+  *	
+  *
+  * @return none
+  *
+  * @ Pass/ Fail criteria: none
+*****************************************************************************/
+#if (defined(IAR))
+__ramfunc  void FLASH_LaunchCMD(uint8_t bWaitComplete)
+#else
+void FLASH_LaunchCMD(uint8_t bWaitComplete)
+#endif
+{
+#if     defined(FLASH_ENABLE_STALLING_FLASH_CONTROLLER)
+     MCM->PLACR |= MCM_PLACR_ESFC_MASK;          /* enable stalling flash controller when flash is busy */
+#endif
+    FTMRH->FSTAT = 0x80;    
+    if(bWaitComplete)
+    {
+      // Wait till command is completed
+      while (!(FTMRH->FSTAT & FTMRH_FSTAT_CCIF_MASK));
+    }
+}
+/*! @} End of nvm_api_list                                               						*/
+
diff --git a/bsp/frdm-ke02/device/lib/drivers/ftm.c b/bsp/frdm-ke02/device/lib/drivers/ftm.c
new file mode 100755
index 0000000..4caaf26
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/drivers/ftm.c
@@ -0,0 +1,970 @@
+
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file ftm.c
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief providing APIs for configuring FTM. 
+*
+*******************************************************************************
+*
+* provide APIs for configuring FTM
+******************************************************************************/
+#include "common.h"
+#include "ftm.h"
+
+/******************************************************************************
+* Global variables
+******************************************************************************/
+
+/******************************************************************************
+* Constants and macros
+******************************************************************************/
+
+/******************************************************************************
+* Local types
+******************************************************************************/
+
+/******************************************************************************
+* Local function prototypes
+******************************************************************************/
+
+/******************************************************************************
+* Local variables
+******************************************************************************/
+
+/******************************************************************************
+* Local functions
+******************************************************************************/
+
+/******************************************************************************
+* Global functions
+******************************************************************************/
+FTM_CallbackPtr FTM_Callback[3] = {(FTM_CallbackPtr)NULL};
+
+
+/******************************************************************************
+* FTM api lists
+*
+*//*! @addtogroup ftm_api_list
+* @{
+*******************************************************************************/
+/*******************************************************************************//*!
+*
+* @brief set the ftm moule clock source and prescale.
+*        
+* @param[in]    pFTM                  pointer to one of three FTM base register address.
+* @param[in]    ClockSource           ftm clock source.
+* @param[in]    ClockPrescale         prescale factor.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*********************************************************************************/
+void FTM_ClockSet(FTM_Type *pFTM, uint8_t u8ClockSource, uint8_t u8ClockPrescale)
+{
+    uint8_t   u8Temp;
+    u8Temp  = (pFTM->SC & 0xE0);
+    u8Temp |= (FTM_SC_CLKS(u8ClockSource & 0x3) | FTM_SC_PS(u8ClockPrescale & 0x7));
+    pFTM->SC = u8Temp;
+}
+
+/*********************************************************************************//*!
+*
+* @brief general configuration to FTM_No to high ture EPWM mode, clock soure is the 
+*        system clock, MOD, CnV are the initial value.
+*        
+* @param[in]    pFTM                  pointer to one of three FTM base register address.
+* @param[in]    PWMModeSelect         select CPWM , EPWM  or combine pwm mode.
+* @param[in]    PWMEdgeSelect         select high true or low true pulse.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*********************************************************************************/
+void FTM_PWMInit(FTM_Type *pFTM, uint8_t u8PWMModeSelect, uint8_t u8PWMEdgeSelect)
+{
+    uint8_t   channels, i;
+    
+    ASSERT((FTM0== pFTM) || (FTM1== pFTM) || (FTM2== pFTM));
+    
+    /* open the clock gate */
+	if (FTM0 == pFTM)
+    {
+        channels = 2;
+        SIM->SCGC |= SIM_SCGC_FTM0_MASK;
+    }
+    else if(FTM1 == pFTM)
+    {
+        channels = 2;
+#if !defined(CPU_KE04)
+        SIM->SCGC |= SIM_SCGC_FTM1_MASK;
+#endif
+    }        
+    else
+    {
+        channels = 6;
+        SIM->SCGC  |= SIM_SCGC_FTM2_MASK;
+    }
+    
+    pFTM->SC  = 0x0;                                    /* disable counter */  
+	pFTM->MOD = FTM_MOD_INIT; 
+    
+    if(FTM_PWMMODE_CENTERALLIGNED == u8PWMModeSelect)   /* enable CPWM */
+    {
+        pFTM->SC |= FTM_SC_CPWMS_MASK; 
+    }
+    else if(FTM_PWMMODE_COMBINE == u8PWMModeSelect)     /* enable combine pwm mode */
+    {
+        ASSERT(FTM2 == pFTM);
+        pFTM->MODE    |= FTM_MODE_WPDIS_MASK | FTM_MODE_FTMEN_MASK;
+        pFTM->COMBINE = FTM_COMBINE_COMBINE0_MASK | FTM_COMBINE_COMP0_MASK | FTM_COMBINE_SYNCEN0_MASK | FTM_COMBINE_DTEN0_MASK |
+                        FTM_COMBINE_COMBINE1_MASK | FTM_COMBINE_COMP1_MASK | FTM_COMBINE_SYNCEN1_MASK | FTM_COMBINE_DTEN1_MASK |
+                        FTM_COMBINE_COMBINE2_MASK | FTM_COMBINE_COMP2_MASK | FTM_COMBINE_SYNCEN2_MASK | FTM_COMBINE_DTEN2_MASK 
+                        ;     
+        pFTM->SC &= ~FTM_SC_CPWMS_MASK; 
+    }
+    if(FTM_PWM_HIGHTRUEPULSE == u8PWMEdgeSelect)
+    {
+        /* Configure timers PWM High True Pulses */
+        for(i=0; i<channels; i++)
+        {
+            pFTM->CONTROLS[i].CnSC = FTM_CnSC_MSB_MASK | FTM_CnSC_ELSB_MASK;  
+            pFTM->CONTROLS[i].CnV  = FTM_C0V_INIT + i*100; 
+        }
+    }
+    else if(FTM_PWM_LOWTRUEPULSE == u8PWMEdgeSelect)
+    {
+        /* Configure timers for PWM Low True Pulses */
+        for(i=0; i<channels; i++) 
+        {
+            pFTM->CONTROLS[i].CnSC = FTM_CnSC_MSB_MASK | FTM_CnSC_ELSA_MASK; 
+            pFTM->CONTROLS[i].CnV  = FTM_C0V_INIT + i*100 ; 
+        }
+    }  
+}
+
+/*********************************************************************************//*!
+*
+* @brief general configuration to FTM_No to input capture mode, enable interrupt.
+*        
+* @param[in]    pFTM                  pointer to one of three FTM base register address.
+* @param[in]    Channel               channel number to be configured.
+* @param[in]    CaptureMode           select capture edge: rising, falling or both.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*********************************************************************************/
+void FTM_InputCaptureInit(FTM_Type *pFTM, uint8_t u8FTM_Channel, uint8_t u8CaptureMode)
+{ 
+    ASSERT(((FTM0 == pFTM) && (u8FTM_Channel < 2))   || 
+           ((FTM1 == pFTM) && (u8FTM_Channel < 2))   || 
+           ((FTM2 == pFTM) && (u8FTM_Channel < 6))
+           );
+
+    
+    /* open the clock gate */
+	if ((FTM0 == pFTM) && (u8FTM_Channel < 2))
+    {
+        SIM->SCGC |= SIM_SCGC_FTM0_MASK;
+        NVIC_EnableIRQ(FTM0_IRQn);
+    }
+    else if((FTM1 == pFTM)  && (u8FTM_Channel < 2))
+    {
+#if !defined(CPU_KE04)
+        SIM->SCGC |= SIM_SCGC_FTM1_MASK;
+        NVIC_EnableIRQ(FTM1_IRQn);
+#endif
+    }        
+    else 
+    {
+        SIM->SCGC |= SIM_SCGC_FTM2_MASK;
+        NVIC_EnableIRQ(FTM2_IRQn);
+    }
+    
+    pFTM->SC  = 0x0;     /* diable counter */ 
+    pFTM->MOD = 0xFFFF;  /* free running */
+    
+    if(FTM_INPUTCAPTURE_RISINGEDGE == u8CaptureMode)        /* enable interrupt, Capture on rising edge */
+    {
+        pFTM->CONTROLS[u8FTM_Channel].CnSC = FTM_CnSC_CHIE_MASK | FTM_CnSC_ELSA_MASK;
+    }
+    else if(FTM_INPUTCAPTURE_FALLINGEDGE == u8CaptureMode)  /* Capture on falling edge */
+    {
+        pFTM->CONTROLS[u8FTM_Channel].CnSC = FTM_CnSC_CHIE_MASK | FTM_CnSC_ELSB_MASK;
+    }
+    else if(FTM_INPUTCAPTURE_BOTHEDGE == u8CaptureMode)     /* Capture on rising or falling edge */
+    {
+        pFTM->CONTROLS[u8FTM_Channel].CnSC = FTM_CnSC_CHIE_MASK | FTM_CnSC_ELSA_MASK | FTM_CnSC_ELSB_MASK;       
+    }
+}
+
+/*********************************************************************************//*!
+*
+* @brief general configuration to FTM_No to Dual Edge Capture mode to measure the
+*        width or the period  of a pulse.
+*        
+* @param[in]    pFTM                  pointer to one of three FTM base register address.
+* @param[in]    ChannelPair           ChannelPair number to be configured: 0, 2, 4.
+* @param[in]    CaptureMode           select capture edge: one shot and continuous mode.
+* @param[in]    Channel_N_Edge        channel N detect edge. 
+* @param[in]    Channel_Np1_Edge      channel N+1 detect edge.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*********************************************************************************/
+void FTM_DualEdgeCaptureInit(FTM_Type *pFTM, uint8_t u8ChannelPair, uint8_t u8CaptureMode, 
+                                 uint8_t u8Channel_N_Edge, uint8_t u8Channel_Np1_Edge)
+{ 
+    ASSERT((FTM2 == pFTM)  && (u8ChannelPair < 6) && !(u8ChannelPair & 1) );
+    
+    SIM->SCGC |= SIM_SCGC_FTM2_MASK;
+    if((0 == u8ChannelPair) || (2== u8ChannelPair))
+    {
+                                        /* channel filter is active */
+    }
+       
+    pFTM->SC    = 0x0;                  /* diable counter */ 
+    pFTM->MOD   = 0xFFFF;
+    pFTM->MODE |= FTM_MODE_FTMEN_MASK;  /* FTMEN = 1 */  
+    /* DECAPEN = 1,  ChannelPair/2 * 8 */
+    pFTM->COMBINE |=  ((FTM_COMBINE_DECAPEN0_MASK) << (u8ChannelPair * 4)); 
+    
+    pFTM->CONTROLS[u8ChannelPair].CnSC &= ~FTM_CnSC_CHF_MASK;       /* CH(n)F and CH(n+1)F bits must be cleared first */
+    pFTM->CONTROLS[u8ChannelPair + 1].CnSC &= ~FTM_CnSC_CHF_MASK;
+    
+    if(FTM_INPUTCAPTURE_DUALEDGE_ONESHOT == u8CaptureMode)          /* oneshot mode */
+    {
+        pFTM->CONTROLS[u8ChannelPair].CnSC &= ~FTM_CnSC_MSA_MASK;
+        pFTM->CONTROLS[u8ChannelPair+1].CnSC &= ~FTM_CnSC_MSA_MASK;
+    }
+    else if(FTM_INPUTCAPTURE_DUALEDGE_CONTINUOUS == u8CaptureMode)  /* continuouse mode */
+    {
+        pFTM->CONTROLS[u8ChannelPair].CnSC |= FTM_CnSC_MSA_MASK;
+        pFTM->CONTROLS[u8ChannelPair+1].CnSC |= FTM_CnSC_MSA_MASK;
+    }
+    
+    pFTM->CONTROLS[u8ChannelPair].CnSC |= (u8Channel_N_Edge << 2);   /* select detec edge */
+    pFTM->CONTROLS[u8ChannelPair + 1].CnSC |= (u8Channel_Np1_Edge << 2);   
+    
+    pFTM->COMBINE |=  (FTM_COMBINE_DECAP0_MASK << (u8ChannelPair * 4)); 
+}
+
+/*********************************************************************************//*!
+*
+* @brief general configuration to FTM_No to input capture mode.
+*        
+* @param[in]    pFTM                  pointer to one of three FTM base register address.
+* @param[in]    Channel               channel number to be configured.
+* @param[in]    CompareMode           select compare edge: toggle, set and clear.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*********************************************************************************/
+void FTM_OutputCompareInit(FTM_Type *pFTM, uint8_t u8FTM_Channel, uint8_t u8CompareMode)
+{
+    ASSERT(((FTM0 == pFTM) && (u8FTM_Channel < 2))   || 
+           ((FTM1 == pFTM) && (u8FTM_Channel < 2))   || 
+           ((FTM2 == pFTM) && (u8FTM_Channel < 6))
+           );
+    
+    /* open the clock gate */
+	if(FTM0 == pFTM)
+    {
+        SIM->SCGC |= SIM_SCGC_FTM0_MASK;
+    }
+    else if(FTM1 == pFTM)
+    {
+#if !defined(CPU_KE04)
+        SIM->SCGC |= SIM_SCGC_FTM1_MASK;
+#endif
+    }        
+    else
+    {
+        SIM->SCGC |= SIM_SCGC_FTM2_MASK;
+    }
+    
+    pFTM->SC  = 0x0;                                                                    /* diable counter */
+    pFTM->MOD = FTM_MOD_INIT; 
+    pFTM->CONTROLS[u8FTM_Channel].CnSC = (FTM_CnSC_MSA_MASK | (u8CompareMode << 2));    /* select detec edge */
+    pFTM->CONTROLS[u8FTM_Channel].CnV  = FTM_C0V_INIT;
+}
+
+/*********************************************************************************//*!
+*
+* @brief general configuration to FTM2 to start software synchronization.
+*        
+* @param[in]    pFTM                  pointer to one of three FTM base register address.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*********************************************************************************/
+void FTM_SoftwareSync(FTM_Type *pFTM)
+{
+    ASSERT(FTM2 == pFTM);
+
+    pFTM->SYNCONF   |= FTM_SYNCONF_SYNCMODE_MASK;   /* recommend enhanced sync mode */
+    pFTM->SYNC      |= FTM_SYNC_SWSYNC_MASK;
+}
+
+/*********************************************************************************//*!
+*
+* @brief general configuration to FTM to enable hardware synchronization.
+*        
+* @param[in]    pFTM                  pointer to one of three FTM base register address.
+* @param[in]    u8TriggerN            select the hardware trigger source.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*********************************************************************************/
+void FTM_HardwareSync(FTM_Type *pFTM, uint8_t u8TriggerN)
+{
+    ASSERT(FTM2 == pFTM);
+    
+    pFTM->SYNCONF   |= FTM_SYNCONF_SYNCMODE_MASK;   /* recommend enhanced sync mode */
+    
+    switch(u8TriggerN)
+    {
+        case FTM_SYNC_TRIGGER_TRIGGER2: 
+                pFTM->SYNC |= FTM_SYNC_TRIG2_MASK;
+                break;  
+        case FTM_SYNC_TRIGGER_TRIGGER1: 
+                pFTM->SYNC |= FTM_SYNC_TRIG1_MASK;
+                break;     /* need configure FTM0CH0 first */
+        case FTM_SYNC_TRIGGER_TRIGGER0:
+                pFTM->SYNC |= FTM_SYNC_TRIG0_MASK; 
+                break;     /* need configure CMP0 first */
+        default: 
+                break;
+    }
+}
+
+/*********************************************************************************//*!
+*
+* @brief general configuration to FTM to enable hardware synchronization, more then 1 trigger.
+*        
+* @param[in]    pFTM               pointer to one of three FTM base register address.
+* @param[in]    u8TriggerMask      select the hardware trigger source. combine TRIG0~TREG2.(x000xxxx~x111xxxx)
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*********************************************************************************/
+void FTM_HardwareSyncCombine(FTM_Type *pFTM, uint8_t u8TriggerMask)
+{
+    ASSERT(FTM2 == pFTM);
+    
+    pFTM->SYNCONF   |= FTM_SYNCONF_SYNCMODE_MASK;   /* recommend enhanced sync mode */
+    pFTM->SYNC      &= 0x8F;
+    pFTM->SYNC      |= (u8TriggerMask & 0x70);
+}
+
+/*********************************************************************************//*!
+*
+* @brief generate FTM2 hardware trigger 2,Note: please call FTM_HardwareSyncCombine first.
+*        
+* @param[in]    pFTM               pointer to one of three FTM base register address.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*********************************************************************************/
+void FTM_GenerateTrig2(FTM_Type *pFTM)
+{
+    ASSERT(FTM2 == pFTM);
+    
+    if(pFTM->SYNC & FTM_SYNC_TRIG2_MASK)
+    {
+#if defined(CPU_KE02)
+        SIM->SOPT  |= SIM_SOPT_FTMSYNC_MASK;
+#elif defined(CPU_KE04)
+        SIM->SOPT  |= SIM_SOPT_FTMSYNC_MASK;
+#elif defined(CPU_KE06)
+        SIM->SOPT0  |= SIM_SOPT0_FTMSYNC_MASK;
+#endif
+    }
+}
+
+
+/*********************************************************************************//*!
+*
+* @brief general configuration to FTM_No to start software synchronization.
+*        
+* @param[in]    pFTM                  pointer to one of three FTM base register address.
+* @param[in]    PrescalerValue        system clock divide value, 0 to 3.
+* @param[in]    DeadtimeValue         n count clock is inserted, 0 to 63.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*********************************************************************************/
+void FTM_PWMDeadtimeSet(FTM_Type *pFTM, uint8_t u8PrescalerValue, uint8_t u8DeadtimeValue)
+{
+    ASSERT(FTM2 == pFTM);
+    
+    pFTM->COMBINE |= 0x101010;              /* enable dead time insertion */
+
+    if(!(pFTM->MODE & FTM_MODE_WPDIS_MASK)) /* if write protection is enabled */
+    {
+        pFTM->MODE |= FTM_MODE_WPDIS_MASK;  /* disable the write protection */
+        pFTM->DEADTIME = (FTM_DEADTIME_DTVAL(u8DeadtimeValue & 0x3F) | FTM_DEADTIME_DTPS(u8PrescalerValue & 0x3));
+        pFTM->MODE &= ~FTM_MODE_WPDIS_MASK; /* enable the write protection */       
+    }
+    else 
+    {
+        /* if no protection */
+        pFTM->DEADTIME = (FTM_DEADTIME_DTVAL(u8DeadtimeValue & 0x3F) | FTM_DEADTIME_DTPS(u8PrescalerValue & 0x3));
+    }
+    pFTM->SYNC |= FTM_SYNC_SWSYNC_MASK;     /* software sync */
+}    
+
+/*********************************************************************************//*!
+*
+* @brief set output mask.
+*        
+* @param[in]    pFTM                  pointer to one of three FTM base register address.
+* @param[in]    Channel               pwm channel needed to be masked.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*********************************************************************************/
+void FTM_OutputMaskSet(FTM_Type *pFTM, uint8_t u8FTM_Channel)
+{
+    ASSERT((FTM2 == pFTM) && (u8FTM_Channel < 6));
+
+    pFTM->OUTMASK |= (1 << u8FTM_Channel);
+    
+    if(pFTM->SYNC & FTM_SYNC_SYNCHOM_MASK)              /* if PWM sync is needed */
+    {
+        pFTM->SYNCONF |= FTM_SYNCONF_SYNCMODE_MASK;     /* recommend enhanced sync mode */
+        if(pFTM->SYNCONF & FTM_SYNCONF_SWOM_MASK)       /* if software sync is needed*/
+        {
+            pFTM->SYNC |= FTM_SYNC_SWSYNC_MASK;
+        }
+        else if(pFTM->SYNCONF & FTM_SYNCONF_HWOM_MASK)  /* if hardware sync is needed*/
+        {
+            pFTM->SYNC |= FTM_SYNC_TRIG2_MASK;
+            
+#if defined(CPU_KE02)
+            SIM->SOPT  |= SIM_SOPT_FTMSYNC_MASK;         /* hardware sync */ 
+#elif defined(CPU_KE04)
+            SIM->SOPT  |= SIM_SOPT_FTMSYNC_MASK;         /* hardware sync */ 
+#elif defined(CPU_KE06)
+            SIM->SOPT0  |= SIM_SOPT0_FTMSYNC_MASK;         /* hardware sync */ 
+#endif
+        }
+        else
+        {
+        }
+    }
+    else  /* no need to sync, update on the next rising edge of system clock  */
+    {
+    }
+}
+
+/*********************************************************************************//*!
+*
+* @brief general configuration to FTM_No to start software synchronization.
+*        
+* @param[in]    pFTM                  pointer to one of three FTM base register address.
+* @param[in]    Channel               pwm channel needed to be controlled by software.
+* @param[in]    ChannelValue          the value to be set,  0 or 1.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*********************************************************************************/
+void FTM_SWOutputControlSet(FTM_Type *pFTM, uint8_t u8FTM_Channel, uint8_t u8ChannelValue)
+{
+    ASSERT((FTM2 == pFTM) && (u8FTM_Channel < 6));
+    
+    if(FTM_SWOCTRL_HIGH == u8ChannelValue)
+    {
+        pFTM->SWOCTRL |= (0x0101 << u8FTM_Channel);
+    }
+    else if(FTM_SWOCTRL_LOW == u8ChannelValue)
+    {
+        pFTM->SWOCTRL |= (1 << u8FTM_Channel);
+        pFTM->SWOCTRL &= ~(0x100 << u8FTM_Channel);
+    }
+    if(pFTM->SYNCONF & FTM_SYNCONF_SWOC_MASK)               /* if PWM sync is needed */
+    {
+        pFTM->SYNCONF |= FTM_SYNCONF_SYNCMODE_MASK;         /* recommend enhanced sync mode */
+        if(pFTM->SYNCONF & FTM_SYNCONF_SWSOC_MASK)          /* if software sync is needed*/
+        {
+            pFTM->SYNC |= FTM_SYNC_SWSYNC_MASK;             /* software sync */ 
+        }
+        else if(pFTM->SYNCONF & FTM_SYNCONF_HWSOC_MASK)     /* if hardware sync is needed*/
+        {
+            pFTM->SYNC |= FTM_SYNC_TRIG2_MASK;
+
+#if defined(CPU_KE02)
+            SIM->SOPT  |= SIM_SOPT_FTMSYNC_MASK;             /* hardware sync */ 
+#elif defined(CPU_KE04)
+            SIM->SOPT  |= SIM_SOPT_FTMSYNC_MASK;             /* hardware sync */ 
+#elif defined(CPU_KE06)
+            SIM->SOPT0  |= SIM_SOPT0_FTMSYNC_MASK;             /* hardware sync */ 
+#endif
+        }
+    }
+    else  /* no need to sync, update on the next rising edge of system clock  */
+    {
+    }
+}
+
+/*********************************************************************************//*!
+*
+* @brief set PWM polarity.
+*        
+* @param[in]    pFTM                  pointer to one of three FTM base register address.
+* @param[in]    Channel               pwm channel needed to be controlled by software.
+* @param[in]    ActiveValue           the value to be set,  0 or 1.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*********************************************************************************/
+void FTM_PolaritySet(FTM_Type *pFTM, uint8_t u8FTM_Channel, uint8_t u8ActiveValue)
+{
+    ASSERT((FTM2 == pFTM) && (u8FTM_Channel < 6));
+    
+    if(FTM_POLARITY_HIGHACTIVE == u8ActiveValue)
+    {
+        pFTM->POL &=  ~(1 << u8FTM_Channel);
+    }
+    else if(FTM_POLARITY_LOWACTIVE == u8ActiveValue)
+    {
+        pFTM->POL |=  (1 << u8FTM_Channel);
+    }
+}
+
+/*********************************************************************************//*!
+*
+* @brief set FTM behavior in debug mode.
+*        
+* @param[in]    pFTM             pointer to one of three FTM base register address.
+* @param[in]    u8DebugMode      debug mode select from 00 to 11.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*********************************************************************************/
+void FTM_SetDebugModeBehavior(FTM_Type *pFTM, uint8_t u8DebugMode)
+{
+    ASSERT((FTM2 == pFTM));
+    pFTM->CONF &= ~FTM_CONF_BDMMODE_MASK;
+    pFTM->CONF |= FTM_CONF_BDMMODE(u8DebugMode);
+}
+
+/*********************************************************************************//*!
+*
+* @brief Selects the ratio between the number of counter overflows to the number of times the TOF bit is set.
+*        
+* @param[in]    pFTM             pointer to one of three FTM base register address.
+* @param[in]    u8TOFNUM         TOF numbers before setting TOF bit, 0~31.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*********************************************************************************/
+void FTM_SetTOFFrequency(FTM_Type *pFTM, uint8_t u8TOFNUM)
+{
+    ASSERT((FTM2 == pFTM));
+    pFTM->CONF &= ~FTM_CONF_NUMTOF_MASK;
+    pFTM->CONF |= FTM_CONF_NUMTOF(u8TOFNUM);
+}
+
+/*********************************************************************************//*!
+*
+* @brief swap the output of CH(n) and CH(n+1).
+*        
+* @param[in]    pFTM                  pointer to one of three FTM base register address.
+* @param[in]    ChannelPair           the pair to be swapped, 0,1,2.
+*    
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*********************************************************************************/
+void FTM_InvertChannel(FTM_Type *pFTM, uint8_t u8ChannelPair)
+{
+    ASSERT((FTM2 == pFTM)  && u8ChannelPair <= 2);
+
+    pFTM->INVCTRL |= 1<<u8ChannelPair;
+    if(pFTM->SYNCONF & FTM_SYNCONF_INVC_MASK)       /* if PWM sync is needed */
+    {
+        pFTM->SYNCONF |= FTM_SYNCONF_SYNCMODE_MASK; /* recommend enhanced sync mode */
+        if(pFTM->SYNCONF & FTM_SYNCONF_SWINVC_MASK) /* if software sync is needed*/
+        {
+            pFTM->SYNC |= FTM_SYNC_SWSYNC_MASK;     /* software sync */ 
+        }
+        else if(pFTM->SYNCONF & FTM_SYNCONF_HWINVC_MASK)    /* if hardware sync is needed*/
+        {
+            pFTM->SYNC |= FTM_SYNC_TRIG2_MASK;
+
+#if defined(CPU_KE02)
+            SIM->SOPT  |= SIM_SOPT_FTMSYNC_MASK;             /* hardware sync */ 
+#elif defined(CPU_KE04)
+            SIM->SOPT  |= SIM_SOPT_FTMSYNC_MASK;             /* hardware sync */ 
+#elif defined(CPU_KE06)
+            SIM->SOPT0  |= SIM_SOPT0_FTMSYNC_MASK;             /* hardware sync */ 
+#endif
+        }
+    }
+    else  /* no need to sync, update on the next rising edge of system clock  */
+    {
+    }
+}  
+
+/*****************************************************************************//*!
+*
+* @brief configure the FTM as specified control parameters, CnSC and CnV not 
+*        included.
+*        
+* @param[in]    pFTM          pointer to one of three FTM base register address.
+* @param[in]    pConfig     pointer to FTM general parameters.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*****************************************************************************/
+void FTM_Init(FTM_Type *pFTM, FTM_ConfigType *pConfig)
+{
+    ASSERT((FTM0 == pFTM) || (FTM1 == pFTM) || (FTM2 == pFTM));
+    if(FTM0 == pFTM)
+    {
+        SIM->SCGC |= SIM_SCGC_FTM0_MASK;
+    }
+#if !defined(CPU_KE04)
+    else if(FTM1 == pFTM)
+    {
+        SIM->SCGC |= SIM_SCGC_FTM1_MASK;
+    }
+#endif
+    else
+    {
+        SIM->SCGC |= SIM_SCGC_FTM2_MASK;
+    }
+        
+    /* diable counter */
+    pFTM->SC = 0; 
+ 	pFTM->MODE = pConfig->mode;       
+	pFTM->MOD = pConfig->modulo;
+	pFTM->CNT = pConfig->cnt;
+        
+    if( pFTM->MODE & FTM_MODE_FTMEN_MASK  ) 
+    {
+        /* when FTMEN = 1, all other registers can be written */
+        pFTM->COMBINE   = pConfig->combine;      
+        pFTM->CNTIN     = pConfig->cntin;      
+        pFTM->SYNC      = pConfig->sync;      
+        pFTM->OUTINIT   = pConfig->outinit;      
+        pFTM->OUTMASK   = pConfig->outmask;      
+        pFTM->DEADTIME  = pConfig->deadtime;      
+        pFTM->EXTTRIG   = pConfig->exttrig;      
+        pFTM->POL       = pConfig->pol;      
+        pFTM->FMS       = pConfig->fms;      
+        pFTM->FILTER    = pConfig->filter;      
+        pFTM->FLTCTRL   = pConfig->fltctrl;    /* fault control */ 
+        pFTM->FLTPOL    = pConfig->fltpol;      
+        pFTM->CONF      = pConfig->conf;      
+        pFTM->SYNCONF   = pConfig->synconf;      
+        pFTM->SWOCTRL   = pConfig->swoctrl;      
+        pFTM->PWMLOAD   = pConfig->pwmload;      
+    }
+    /* write SC to enable clock */
+    pFTM->SC = pConfig->sc;
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief  close the FTM moudle.
+*        
+* @param[in]    pFTM          pointer to one of three FTM base register address.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*****************************************************************************/
+void FTM_DeInit(FTM_Type *pFTM)
+{
+    ASSERT((FTM0 == pFTM) || (FTM1 == pFTM) || (FTM2 == pFTM));
+    pFTM->SC = 0;       
+	pFTM->MOD = 0;
+	pFTM->CNT = 0;
+    if(FTM2 == pFTM) 
+    {
+          pFTM->MODE = 0x4; 
+          pFTM->COMBINE = 0;      
+          pFTM->CNTIN = 0;      
+          pFTM->SYNC = 0;      
+          pFTM->OUTINIT = 0;      
+          pFTM->OUTMASK = 0;      
+          pFTM->DEADTIME = 0;      
+          pFTM->EXTTRIG = 0;      
+          pFTM->POL = 0;      
+          pFTM->FMS = 0;      
+          pFTM->FILTER = 0;      
+          pFTM->FLTCTRL = 0;  
+          pFTM->FLTPOL = 0;      
+          pFTM->CONF = 0;      
+          pFTM->SYNCONF = 0;      
+          pFTM->SWOCTRL = 0;      
+          pFTM->PWMLOAD = 0;      
+    }
+    /* close the clock gate */
+	if (FTM0 == pFTM)
+    {
+        SIM->SCGC &= ~SIM_SCGC_FTM0_MASK;
+        NVIC_DisableIRQ(FTM0_IRQn);
+    }
+#if !defined(CPU_KE04)    
+    else if(FTM1 == pFTM)
+    {
+        SIM->SCGC &= ~SIM_SCGC_FTM1_MASK;
+        NVIC_DisableIRQ(FTM1_IRQn);
+    } 
+#endif
+    else if (FTM2 == pFTM)
+    {
+        SIM->SCGC &= ~SIM_SCGC_FTM2_MASK;
+        NVIC_DisableIRQ(FTM2_IRQn);
+    }
+}
+    
+/*****************************************************************************//*!
+*
+* @brief configure the FTM  channels, CnSC and CnV are included.
+*        
+* @param[in]    pFTM               pointer to one of three FTM base register address.
+* @param[in]    FTM_Channel        FTM channel number.
+* @param[in]    pTFTMCH_Params     pointer to FTM channel general parameters.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*****************************************************************************/
+void FTM_ChannelInit(FTM_Type *pFTM, uint8_t u8FTM_Channel, FTM_ChParamsType *pTFTMCH_Params)
+{
+    ASSERT((FTM0 == pFTM) || (FTM1 == pFTM) || (FTM2 == pFTM));  
+    
+	if (FTM0 == pFTM)
+    {
+        ASSERT(u8FTM_Channel < 2);
+        SIM->SCGC |= SIM_SCGC_FTM0_MASK;
+    }
+ #if !defined(CPU_KE04)
+    else if(FTM1 == pFTM)
+    {
+        ASSERT(u8FTM_Channel < 2);
+        SIM->SCGC |= SIM_SCGC_FTM1_MASK;
+    }        
+#endif
+    else
+    {
+        ASSERT(u8FTM_Channel < 6);
+        SIM->SCGC |= SIM_SCGC_FTM2_MASK;
+    }
+    
+    pFTM->CONTROLS[u8FTM_Channel].CnSC = pTFTMCH_Params->u8CnSC;
+    pFTM->CONTROLS[u8FTM_Channel].CnV = pTFTMCH_Params->u16CnV; 
+    
+    return;
+}
+
+/*****************************************************************************//*!
+*
+* @brief set the FTM channel value register per duty cycle and modulo for combine mode
+*        odd channel no must be provided and even channel value register is not changed.
+*
+* @param[in]    pFTM            pointer to one of three FTM base register address.
+* @param[in]    FTM_Channel     odd channel no:1,3,5.
+* @param[in]    dutyCycle       duty cycle in percentage. e.g. 10, means 10%.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*****************************************************************************/
+void  FTM_SetDutyCycleCombine(FTM_Type *pFTM, uint8_t u8FTM_Channel, uint8_t u8DutyCycle)
+{
+    uint16_t   cnv = pFTM->CONTROLS[u8FTM_Channel-1].CnV;
+    uint16_t   modulo = pFTM->MOD; 
+    
+    ASSERT((1 == u8FTM_Channel) || (3 == u8FTM_Channel) || (5 == u8FTM_Channel));
+    
+    cnv += (u8DutyCycle * (modulo+1))  / 100;
+    if(cnv > modulo)
+    {
+        cnv = modulo - 1;
+    }
+    pFTM->CONTROLS[u8FTM_Channel].CnV = cnv ;    
+    
+    pFTM->PWMLOAD |= FTM_PWMLOAD_LDOK_MASK | (1<<u8FTM_Channel);     
+}
+
+/*****************************************************************************//*!
+*
+* @brief configure the FTMx_SYNCONF register including SW and HW Sync selection.
+*
+* @param[in]    pFTM             pointer to one of three FTM base register address.
+* @param[in]    u32ConfigValue   FTMx_SYNCONF register config value.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*****************************************************************************/
+void  FTM_SyncConfigActivate(FTM_Type *pFTM, uint32_t u32ConfigValue)
+{
+    ASSERT((FTM2 == pFTM));
+    pFTM->SYNCONF |= u32ConfigValue;   
+}
+
+/*****************************************************************************//*!
+*
+* @brief configure the FTMx_SYNCONF register including SW and HW Sync selection.
+*
+* @param[in]    pFTM             pointer to one of three FTM base register address.
+* @param[in]    u32ConfigValue   FTMx_SYNCONF register config value.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*****************************************************************************/
+void  FTM_SyncConfigDeactivate(FTM_Type *pFTM, uint32_t u32ConfigValue)
+{
+    ASSERT((FTM2 == pFTM));
+    pFTM->SYNCONF &= ~u32ConfigValue;   
+}
+
+/*****************************************************************************//*!
+*
+* @brief This function sets the callback function.
+*
+* @param[in]    pFTM          pointer to one of three FTM base register address.
+* @param[in]    pfnCallback     functon address.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none
+*
+*****************************************************************************/
+void  FTM_SetCallback(FTM_Type *pFTM, FTM_CallbackPtr pfnCallback)
+{
+   FTM_Callback[((uint32_t)pFTM - (uint32_t)FTM0_BASE)>>12] = pfnCallback;
+}
+
+/*! @} End of ftm_api_list                                                    */
+
+
+/*****************************************************************************//*!
+*
+* @brief  FTM0_Isr interrupt service routine.
+*        
+* @param  none.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*****************************************************************************/
+void FTM0_Isr(void)
+{
+    if(FTM_Callback[0])
+    {
+        FTM_Callback[0]();
+    }
+}
+
+/*****************************************************************************//*!
+*
+* @brief  FTM1_Isr interrupt service routine.
+*        
+* @param  none. 
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*****************************************************************************/
+void FTM1_Isr(void)
+{
+    if(FTM_Callback[1])
+    {
+        FTM_Callback[1]();
+    }
+}
+
+/*****************************************************************************//*!
+*
+* @brief  FTM2_Isr interrupt service routine.
+*        
+* @param  none. 
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*****************************************************************************/
+void FTM2_Isr(void)
+{
+    if(FTM_Callback[2])
+    {
+        FTM_Callback[2]();
+    }
+}
+
+
+
diff --git a/bsp/frdm-ke02/device/lib/drivers/gpio.c b/bsp/frdm-ke02/device/lib/drivers/gpio.c
new file mode 100755
index 0000000..55cd972
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/drivers/gpio.c
@@ -0,0 +1,672 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file gpio.c
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun 12, 2013
+*
+* @brief providing common gpio API. 
+*
+******************************************************************************/
+#include "gpio.h"
+
+/******************************************************************************
+* Local variables
+******************************************************************************/
+
+
+/******************************************************************************
+* Local function prototypes
+******************************************************************************/
+
+/******************************************************************************
+* Local functions
+*****************************************************************************/
+
+/******************************************************************************
+* Global functions
+******************************************************************************/
+
+/******************************************************************************
+* define GPIO APIs
+*
+*//*! @addtogroup gpio_api_list
+* @{
+*******************************************************************************/
+
+/*****************************************************************************//*!
+* @brief    Initialize the GPIO registers to the default reset values.
+*        
+* @param[in] pGPIO      Pointer to GPIO module, can be GPIOA/GPIOB.
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+void GPIO_DeInit(GPIO_Type *pGPIO)
+{
+    /* Sanity check */
+#if defined(CPU_KE02)
+     ASSERT((pGPIO == GPIOA) || (pGPIO == GPIOB));
+#endif
+#if defined(CPU_KE04)
+    ASSERT(pGPIO == GPIOA);
+#endif
+#if defined(CPU_KE06)
+      ASSERT((pGPIO == GPIOA) || (pGPIO == GPIOB) || (pGPIO == GPIOC));
+#endif
+
+    pGPIO->PCOR = 0x00000000;   /* Port Clear Output Register */
+    pGPIO->PDDR = 0x00000000;   /* Port Data Direction */
+    //pGPIO->PDIR = 0x00000000;   /* Port Data Input Register */
+    pGPIO->PDOR = 0x00000000;   /* Port Data Output Register */
+    pGPIO->PIDR = 0xFFFFFFFF;   /* Port Input Disable Register */
+    pGPIO->PSOR = 0x00000000;   /* Port Set Output Register */
+    pGPIO->PTOR = 0x00000000;   /* Port Toggle Output Register */
+}
+
+/*****************************************************************************//*!
+* @brief    Initialize GPIO pins which are specified by u32PinMask
+*        
+* @param[in] pGPIO      Pointer to GPIO module, can be GPIOA/GPIOB.
+* @param[in] u32PinMask GPIO pin mask need to be set
+* @param[in] sGpioType  pin attribute 
+*
+* @return   none
+*
+* @Note
+*   . High-current drive function is disabled, if the pin is configured as an input
+*   . Internal pullup is disabled if the pin is configured as an output
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+void GPIO_Init(GPIO_Type *pGPIO, uint32_t u32PinMask, GPIO_PinConfigType sGpioType)
+{
+    /* Sanity check */
+#if defined(CPU_KE02)
+     ASSERT((pGPIO == GPIOA) || (pGPIO == GPIOB));
+#endif
+#if defined(CPU_KE04)
+    ASSERT(pGPIO == GPIOA);
+#endif
+#if defined(CPU_KE06)
+      ASSERT((pGPIO == GPIOA) || (pGPIO == GPIOB) || (pGPIO == GPIOC));
+#endif
+    
+    /* Config GPIO for Input or Output */
+    if ((sGpioType == GPIO_PinOutput) || (sGpioType == GPIO_PinOutput_HighCurrent))
+    {
+        pGPIO->PDDR |= u32PinMask;      /* Enable Port Data Direction Register */
+        pGPIO->PIDR |= u32PinMask;      /* Set Port Input Disable Register */   
+    }
+    else if ((sGpioType == GPIO_PinInput) || (sGpioType == GPIO_PinInput_InternalPullup))
+    {
+        pGPIO->PDDR &= ~u32PinMask;   /* Disable Port Data Direction Register */
+        pGPIO->PIDR &= ~u32PinMask;   /* Clear Port Input Disable Register */
+    }
+    /* Config PORT Pull select for GPIO */
+#if defined(CPU_KE02)
+    switch((uint32_t)pGPIO)
+    {
+        case GPIOA_BASE:
+            (sGpioType == GPIO_PinInput_InternalPullup)?(PORT->PUEL |= u32PinMask):(PORT->PUEL &= ~u32PinMask);
+            break;
+        case GPIOB_BASE:
+            (sGpioType == GPIO_PinInput_InternalPullup)?(PORT->PUEH |= u32PinMask):(PORT->PUEH &= ~u32PinMask);
+            break;
+        default:
+            break;
+     }
+#endif
+    
+#if defined(CPU_KE04)
+    switch((uint32_t)pGPIO)
+    {
+        case GPIOA_BASE:
+            (sGpioType == GPIO_PinInput_InternalPullup)?(PORT->PUEL |= u32PinMask):(PORT->PUEL &= ~u32PinMask);
+            break;
+        default:
+            break;
+     }
+#endif
+    
+#if defined(CPU_KE06)
+    switch((uint32_t)pGPIO)
+    {
+        case GPIOA_BASE:
+            (sGpioType == GPIO_PinInput_InternalPullup)?(PORT->PUE0 |= u32PinMask):(PORT->PUE0 &= ~u32PinMask);
+            break;
+        case GPIOB_BASE:
+            (sGpioType == GPIO_PinInput_InternalPullup)?(PORT->PUE1 |= u32PinMask):(PORT->PUE1 &= ~u32PinMask);
+            break;
+        case GPIOC_BASE:
+            (sGpioType == GPIO_PinInput_InternalPullup)?(PORT->PUE2 |= u32PinMask):(PORT->PUE2 &= ~u32PinMask);
+            break;
+        default:
+            break;
+     }
+#endif   
+    
+    /* Config PORT GPIO_PinOutput_HighCurrent for GPIO */
+#if defined(CPU_KE04)
+    if (u32PinMask & GPIO_PTC5_MASK)
+    {   
+        PORT->HDRVE |= PORT_HDRVE_PTC5_MASK;
+    }   
+    if (u32PinMask & GPIO_PTC1_MASK)
+    {   
+        PORT->HDRVE |= PORT_HDRVE_PTC1_MASK;
+    }   
+    if (u32PinMask & GPIO_PTB5_MASK)
+    {   
+        PORT->HDRVE |= PORT_HDRVE_PTB5_MASK;
+    }   
+#endif
+    
+#if defined(CPU_KE02) | defined(CPU_KE06)
+    if (pGPIO == GPIOA)
+    {
+        if (u32PinMask & GPIO_PTB4_MASK)
+        {   
+            PORT->HDRVE |= PORT_HDRVE_PTB4_MASK;
+        }   
+        if (u32PinMask & GPIO_PTB5_MASK)
+        {   
+            PORT->HDRVE |= PORT_HDRVE_PTB5_MASK;
+        }   
+        if (u32PinMask & GPIO_PTD0_MASK)
+        {   
+            PORT->HDRVE |= PORT_HDRVE_PTD0_MASK;
+        }   
+        if (u32PinMask & GPIO_PTD1_MASK)
+        {   
+            PORT->HDRVE |= PORT_HDRVE_PTD1_MASK;
+        }   
+    }
+    if (pGPIO == GPIOB)
+    {
+        if (u32PinMask & GPIO_PTE0_MASK)
+        {   
+            PORT->HDRVE |= PORT_HDRVE_PTE0_MASK;
+        }   
+        if (u32PinMask & GPIO_PTE1_MASK)
+        {   
+            PORT->HDRVE |= PORT_HDRVE_PTE1_MASK;
+        }   
+        if (u32PinMask & GPIO_PTH0_MASK)
+        {   
+            PORT->HDRVE |= PORT_HDRVE_PTH0_MASK;
+        }   
+        if (u32PinMask & GPIO_PTH1_MASK)
+        {   
+            PORT->HDRVE |= PORT_HDRVE_PTH1_MASK;
+        }   
+    }
+
+#endif
+    
+}
+
+/*****************************************************************************//*!
+* @brief    Toggle the pins which are specified by u32PinMask
+*        
+* @param[in] pGPIO       Pointer to GPIO module, can be GPIOA/GPIOB.
+* @param[in] u32PinMask  Specify GPIO pin need to be toggled
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+void GPIO_Toggle(GPIO_Type *pGPIO, uint32_t u32PinMask)
+{
+    /* Sanity check */
+#if defined(CPU_KE02)
+     ASSERT((pGPIO == GPIOA) || (pGPIO == GPIOB));
+#endif
+#if defined(CPU_KE04)
+    ASSERT(pGPIO == GPIOA);
+#endif
+#if defined(CPU_KE06)
+      ASSERT((pGPIO == GPIOA) || (pGPIO == GPIOB) || (pGPIO == GPIOC));
+#endif
+
+    pGPIO->PTOR = u32PinMask;   /* Toggle the pins specified by u32PinMask */
+}
+
+/*****************************************************************************//*!
+* @brief Read input data from GPIO which is specified by pGPIO
+*        
+* @param[in] pGPIO       Pointer to GPIO module, can be GPIOA/GPIOB.
+*
+* @return   GPIO input value unsigned int 32-bit
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+uint32_t GPIO_Read(GPIO_Type *pGPIO)
+{
+    /* Sanity check */
+#if defined(CPU_KE02)
+     ASSERT((pGPIO == GPIOA) || (pGPIO == GPIOB));
+#endif
+#if defined(CPU_KE04)
+    ASSERT(pGPIO == GPIOA);
+#endif
+#if defined(CPU_KE06)
+      ASSERT((pGPIO == GPIOA) || (pGPIO == GPIOB) || (pGPIO == GPIOC));
+#endif
+
+    return (pGPIO->PDIR);   /* Read Port Data Input Register */
+  
+}
+
+/*****************************************************************************//*!
+* @brief    Write output data to GPIO which is specified by pGPIO
+*        
+* @param[in] pGPIO       Pointer to GPIO module, can be GPIOA/GPIOB.
+* @param[in] u32Value    value to output
+*
+* @return   none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+void GPIO_Write(GPIO_Type *pGPIO, uint32_t u32Value)
+{
+    /* Sanity check */
+#if defined(CPU_KE02)
+     ASSERT((pGPIO == GPIOA) || (pGPIO == GPIOB));
+#endif
+#if defined(CPU_KE04)
+    ASSERT(pGPIO == GPIOA);
+#endif
+#if defined(CPU_KE06)
+      ASSERT((pGPIO == GPIOA) || (pGPIO == GPIOB) || (pGPIO == GPIOC));
+#endif
+    
+    pGPIO->PDOR = u32Value;    /* Write Port Ouput Data Register */
+  
+}
+
+/*****************************************************************************//*!
+* @brief    Initialize GPIO single pin which is specified by GPIO_Pin
+*        
+* @param[in] GPIO_Pin        GPIO pin name, can be GPIO_PTA0,1 ...
+* @param[in] GPIO_PinConfig  Config output or input
+*
+* @return   none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+void GPIO_PinInit(GPIO_PinType GPIO_Pin, GPIO_PinConfigType GPIO_PinConfig)
+{
+    /* Sanity check */
+    ASSERT(GPIO_Pin <= GPIO_PTI7);
+      
+    /* Config GPIO and pull select*/
+#if defined(CPU_KE02)
+      if (GPIO_Pin < GPIO_PTE0)
+      {
+        switch (GPIO_PinConfig)
+        {
+        case GPIO_PinOutput:
+            GPIOA->PDDR |= (1<<GPIO_Pin);      /* Enable Port Data Direction Register */
+            GPIOA->PIDR |= (1<<GPIO_Pin);      /* Set Port Input Disable Register */
+            PORT->PUEL &= ~(1<<GPIO_Pin);    /* Disable Pullup */
+          break;
+        case GPIO_PinInput:
+            GPIOA->PDDR &= ~(1<<GPIO_Pin);     /* Disable Port Data Direction Register */
+            GPIOA->PIDR &= ~(1<<GPIO_Pin);     /* Clear Port Input Disable Register */
+            PORT->PUEL &= ~(1<<GPIO_Pin);    /* Disable Pullup */
+          break;
+        case GPIO_PinInput_InternalPullup:
+            GPIOA->PDDR &= ~(1<<GPIO_Pin);     /* Disable Port Data Direction Register */
+            GPIOA->PIDR &= ~(1<<GPIO_Pin);     /* Clear Port Input Disable Register */
+            PORT->PUEL |= (1<<GPIO_Pin);    /* Enable Pullup */
+          break;
+        case GPIO_PinOutput_HighCurrent:
+            GPIOA->PDDR |= (1<<GPIO_Pin);      /* Enable Port Data Direction Register */
+            GPIOA->PIDR |= (1<<GPIO_Pin);      /* Set Port Input Disable Register */
+            PORT->PUEL &= ~(1<<GPIO_Pin);    /* Disable Pullup */
+          break;
+        }
+      }
+      else if (GPIO_Pin < GPIO_PTI0)
+      {
+        GPIO_Pin = (GPIO_PinType)(GPIO_Pin - 32);
+        switch (GPIO_PinConfig)
+        {
+        case GPIO_PinOutput:
+            GPIOB->PDDR |= (1<<GPIO_Pin);      /* Enable Port Data Direction Register */
+            GPIOB->PIDR |= (1<<GPIO_Pin);      /* Set Port Input Disable Register */
+            PORT->PUEH &= ~(1<<GPIO_Pin);    /* Disable Pullup */
+          break;
+        case GPIO_PinInput:
+            GPIOB->PDDR &= ~(1<<GPIO_Pin);     /* Disable Port Data Direction Register */
+            GPIOB->PIDR &= ~(1<<GPIO_Pin);     /* Clear Port Input Disable Register */
+            PORT->PUEH &= ~(1<<GPIO_Pin);    /* Disable Pullup */
+          break;
+        case GPIO_PinInput_InternalPullup:
+            GPIOB->PDDR &= ~(1<<GPIO_Pin);     /* Disable Port Data Direction Register */
+            GPIOB->PIDR &= ~(1<<GPIO_Pin);     /* Clear Port Input Disable Register */
+            PORT->PUEH |= (1<<GPIO_Pin);    /* Enable Pullup */
+          break;
+        case GPIO_PinOutput_HighCurrent:
+            GPIOB->PDDR |= (1<<GPIO_Pin);      /* Enable Port Data Direction Register */
+            GPIOB->PIDR |= (1<<GPIO_Pin);      /* Set Port Input Disable Register */
+            PORT->PUEH &= ~(1<<GPIO_Pin);    /* Disable Pullup */
+          break;
+        }
+      }
+#endif
+      
+#if defined(CPU_KE04)
+      if (GPIO_Pin < GPIO_PTE0)
+      {
+        switch (GPIO_PinConfig)
+        {
+        case GPIO_PinOutput:
+            GPIOA->PDDR |= (1<<GPIO_Pin);      /* Enable Port Data Direction Register */
+            GPIOA->PIDR |= (1<<GPIO_Pin);      /* Set Port Input Disable Register */
+            PORT->PUEL &= ~(1<<GPIO_Pin);    /* Disable Pullup */
+          break;
+        case GPIO_PinInput:
+            GPIOA->PDDR &= ~(1<<GPIO_Pin);     /* Disable Port Data Direction Register */
+            GPIOA->PIDR &= ~(1<<GPIO_Pin);     /* Clear Port Input Disable Register */
+            PORT->PUEL &= ~(1<<GPIO_Pin);    /* Disable Pullup */
+          break;
+        case GPIO_PinInput_InternalPullup:
+            GPIOA->PDDR &= ~(1<<GPIO_Pin);     /* Disable Port Data Direction Register */
+            GPIOA->PIDR &= ~(1<<GPIO_Pin);     /* Clear Port Input Disable Register */
+            PORT->PUEL |= (1<<GPIO_Pin);    /* Enable Pullup */
+          break;
+        case GPIO_PinOutput_HighCurrent:
+            GPIOA->PDDR |= (1<<GPIO_Pin);      /* Enable Port Data Direction Register */
+            GPIOA->PIDR |= (1<<GPIO_Pin);      /* Set Port Input Disable Register */
+            PORT->PUEL &= ~(1<<GPIO_Pin);    /* Disable Pullup */
+          break;
+        }
+      }
+#endif
+    
+    
+#if defined(CPU_KE06)
+      if (GPIO_Pin < GPIO_PTE0)
+      {
+        switch (GPIO_PinConfig)
+        {
+        case GPIO_PinOutput:
+            GPIOA->PDDR |= (1<<GPIO_Pin);      /* Enable Port Data Direction Register */
+            GPIOA->PIDR |= (1<<GPIO_Pin);      /* Set Port Input Disable Register */
+            PORT->PUE0 &= ~(1<<GPIO_Pin);    /* Disable Pullup */
+          break;
+        case GPIO_PinInput:
+            GPIOA->PDDR &= ~(1<<GPIO_Pin);     /* Disable Port Data Direction Register */
+            GPIOA->PIDR &= ~(1<<GPIO_Pin);     /* Clear Port Input Disable Register */
+            PORT->PUE0 &= ~(1<<GPIO_Pin);    /* Disable Pullup */
+          break;
+        case GPIO_PinInput_InternalPullup:
+            GPIOA->PDDR &= ~(1<<GPIO_Pin);     /* Disable Port Data Direction Register */
+            GPIOA->PIDR &= ~(1<<GPIO_Pin);     /* Clear Port Input Disable Register */
+            PORT->PUE0 |= (1<<GPIO_Pin);    /* Enable Pullup */
+          break;
+        case GPIO_PinOutput_HighCurrent:
+            GPIOA->PDDR |= (1<<GPIO_Pin);      /* Enable Port Data Direction Register */
+            GPIOA->PIDR |= (1<<GPIO_Pin);      /* Set Port Input Disable Register */
+            PORT->PUE0 &= ~(1<<GPIO_Pin);    /* Disable Pullup */
+          break;
+        }
+      }
+      else if (GPIO_Pin < GPIO_PTI0)
+      {
+        GPIO_Pin = (GPIO_PinType)(GPIO_Pin - 32);
+        switch (GPIO_PinConfig)
+        {
+        case GPIO_PinOutput:
+            GPIOB->PDDR |= (1<<GPIO_Pin);      /* Enable Port Data Direction Register */
+            GPIOB->PIDR |= (1<<GPIO_Pin);      /* Set Port Input Disable Register */
+            PORT->PUE1 &= ~(1<<GPIO_Pin);    /* Disable Pullup */
+          break;
+        case GPIO_PinInput:
+            GPIOB->PDDR &= ~(1<<GPIO_Pin);     /* Disable Port Data Direction Register */
+            GPIOB->PIDR &= ~(1<<GPIO_Pin);     /* Clear Port Input Disable Register */
+            PORT->PUE1 &= ~(1<<GPIO_Pin);    /* Disable Pullup */
+          break;
+        case GPIO_PinInput_InternalPullup:
+            GPIOB->PDDR &= ~(1<<GPIO_Pin);     /* Disable Port Data Direction Register */
+            GPIOB->PIDR &= ~(1<<GPIO_Pin);     /* Clear Port Input Disable Register */
+            PORT->PUE1 |= (1<<GPIO_Pin);    /* Enable Pullup */
+          break;
+        case GPIO_PinOutput_HighCurrent:
+            GPIOB->PDDR |= (1<<GPIO_Pin);      /* Enable Port Data Direction Register */
+            GPIOB->PIDR |= (1<<GPIO_Pin);      /* Set Port Input Disable Register */
+            PORT->PUE1 &= ~(1<<GPIO_Pin);    /* Disable Pullup */
+          break;
+        }
+      }
+      else
+      {
+        GPIO_Pin = (GPIO_PinType)(GPIO_Pin - 64);
+        switch (GPIO_PinConfig)
+        {
+        case GPIO_PinOutput:
+            GPIOC->PDDR |= (1<<GPIO_Pin);      /* Enable Port Data Direction Register */
+            GPIOC->PIDR |= (1<<GPIO_Pin);      /* Set Port Input Disable Register */
+            PORT->PUE2 &= ~(1<<GPIO_Pin);    /* Disable Pullup */
+          break;
+        case GPIO_PinInput:
+            GPIOC->PDDR &= ~(1<<GPIO_Pin);     /* Disable Port Data Direction Register */
+            GPIOC->PIDR &= ~(1<<GPIO_Pin);     /* Clear Port Input Disable Register */
+            PORT->PUE2 &= ~(1<<GPIO_Pin);    /* Disable Pullup */
+          break;
+        case GPIO_PinInput_InternalPullup:
+            GPIOC->PDDR &= ~(1<<GPIO_Pin);     /* Disable Port Data Direction Register */
+            GPIOC->PIDR &= ~(1<<GPIO_Pin);     /* Clear Port Input Disable Register */
+            PORT->PUE2 |= (1<<GPIO_Pin);    /* Enable Pullup */
+          break;
+        case GPIO_PinOutput_HighCurrent:
+            GPIOC->PDDR |= (1<<GPIO_Pin);      /* Enable Port Data Direction Register */
+            GPIOC->PIDR |= (1<<GPIO_Pin);      /* Set Port Input Disable Register */
+            PORT->PUE2 &= ~(1<<GPIO_Pin);    /* Disable Pullup */
+          break;
+        }
+      }
+#endif
+      
+    /* Config GPIO HDRV */
+    if(GPIO_PinConfig == GPIO_PinOutput_HighCurrent)
+    {
+#if defined(CPU_KE04)
+        switch (GPIO_Pin)
+        {
+            case GPIO_PTB5:
+                PORT->HDRVE |= PORT_HDRVE_PTB5_MASK;
+                break;
+            case GPIO_PTC1:
+                PORT->HDRVE |= PORT_HDRVE_PTC1_MASK;
+                break;
+            case GPIO_PTC5:
+                PORT->HDRVE |= PORT_HDRVE_PTC5_MASK;
+                break;
+            default:
+                break;
+        }
+#endif
+    
+#if defined(CPU_KE06) | defined(CPU_KE02)
+        switch (GPIO_Pin)
+        {
+            case GPIO_PTB4:
+                PORT->HDRVE |= PORT_HDRVE_PTB4_MASK;
+                break;
+            case GPIO_PTB5:
+                PORT->HDRVE |= PORT_HDRVE_PTB5_MASK;
+                break;
+            case GPIO_PTD0:
+                PORT->HDRVE |= PORT_HDRVE_PTD0_MASK;
+                break;
+            case GPIO_PTD1:
+                PORT->HDRVE |= PORT_HDRVE_PTD1_MASK;
+                break;
+            case GPIO_PTE0:
+                PORT->HDRVE |= PORT_HDRVE_PTE0_MASK;
+                break;
+            case GPIO_PTE1:
+                PORT->HDRVE |= PORT_HDRVE_PTE1_MASK;
+                break;
+            case GPIO_PTH0:
+                PORT->HDRVE |= PORT_HDRVE_PTH0_MASK;
+                break;
+            case GPIO_PTH1:
+                PORT->HDRVE |= PORT_HDRVE_PTH1_MASK;
+                break;
+            default:
+                break; 
+        }
+#endif
+    }
+}
+
+/*****************************************************************************//*!
+* @brief    Toggle GPIO single pin which is specified by GPIO_Pin
+*        
+* @param[in] GPIO_Pin        GPIO pin name, can be GPIO_PTA0,1 ...
+*
+* @return   none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+void GPIO_PinToggle(GPIO_PinType GPIO_Pin)
+{
+    /* Sanity check */
+    ASSERT(GPIO_Pin <= GPIO_PTI7);
+
+    if (GPIO_Pin < GPIO_PTE0)
+    {
+        /* PTA0-7, PTB0-7, PTC0-7, PTD0-7 */
+        GPIOA->PTOR = (1<<GPIO_Pin);
+    }
+
+#if (defined(CPU_KE02) | defined(CPU_KE06))
+
+    else if (GPIO_Pin < GPIO_PTI0)
+    {
+        /* PTE0-7, PTF0-7, PTH0-7, PTI0-7 */
+        GPIO_Pin = (GPIO_PinType)(GPIO_Pin - GPIO_PTE0);
+        GPIOB->PTOR = (1<<GPIO_Pin);
+    }
+#endif
+
+#if defined(CPU_KE06)  
+    else if(GPIO_Pin < GPIO_PIN_MAX)
+    {
+        /* PTI0-7 */
+        GPIO_Pin = (GPIO_PinType)(GPIO_Pin - GPIO_PTI0);
+        GPIOC->PTOR = (1<<GPIO_Pin);
+    }
+#endif
+}
+
+/*****************************************************************************//*!
+* @brief    Set GPIO single pin which is specified by GPIO_Pin
+*        
+* @param[in] GPIO_Pin        GPIO pin name, can be GPIO_PTA0,1 ...
+*
+* @return   none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+void GPIO_PinSet(GPIO_PinType GPIO_Pin)
+{
+    /* Sanity check */
+    ASSERT(GPIO_Pin <= GPIO_PTI7);
+    
+    if (GPIO_Pin < GPIO_PTE0)
+    {
+        /* PTA0-7, PTB0-7, PTC0-7, PTD0-7 */
+        GPIOA->PSOR = (1<<GPIO_Pin);
+    }
+
+#if (defined(CPU_KE02) | defined(CPU_KE06))
+
+    else if (GPIO_Pin < GPIO_PTI0)
+    {
+        /* PTE0-7, PTF0-7, PTH0-7, PTI0-7 */
+        GPIO_Pin = (GPIO_PinType)(GPIO_Pin - GPIO_PTE0);
+        GPIOB->PSOR = (1<<GPIO_Pin);
+    }
+#endif
+
+#if defined(CPU_KE06) 
+    else if(GPIO_Pin < GPIO_PIN_MAX)
+    {
+        /* PTI0-7 */
+        GPIO_Pin = (GPIO_PinType)(GPIO_Pin - GPIO_PTI0);
+        GPIOC->PSOR = (1<<GPIO_Pin);
+    }
+#endif
+}
+
+/*****************************************************************************//*!
+* @brief    Clear GPIO single pin which is specified by GPIO_Pin
+*        
+* @param[in] GPIO_Pin        GPIO pin name, can be GPIO_PTA0,1 ...
+*
+* @return   none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+void GPIO_PinClear(GPIO_PinType GPIO_Pin)
+{
+    /* Sanity check */
+    ASSERT(GPIO_Pin <= GPIO_PTI7);
+    
+    if (GPIO_Pin < GPIO_PTE0)
+    {
+        /* PTA0-7, PTB0-7, PTC0-7, PTD0-7 */
+        GPIOA->PCOR = (1<<GPIO_Pin);
+    }
+
+#if (defined(CPU_KE02) | defined(CPU_KE06))
+
+    else if (GPIO_Pin < GPIO_PTI0)
+    {
+        /* PTE0-7, PTF0-7, PTH0-7, PTI0-7 */
+        GPIO_Pin = (GPIO_PinType)(GPIO_Pin - GPIO_PTE0);
+        GPIOB->PCOR = (1<<GPIO_Pin);
+    }
+#endif
+
+#if defined(CPU_KE06)
+    else if(GPIO_Pin < GPIO_PIN_MAX)
+    {
+        /* PTI0-7 */
+        GPIO_Pin = (GPIO_PinType)(GPIO_Pin - GPIO_PTI0);
+        GPIOC->PCOR = (1<<GPIO_Pin);
+    }
+#endif
+}
+
+/*! @} End of gpio_api_list */
+
diff --git a/bsp/frdm-ke02/device/lib/drivers/i2c.c b/bsp/frdm-ke02/device/lib/drivers/i2c.c
new file mode 100755
index 0000000..d904d8a
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/drivers/i2c.c
@@ -0,0 +1,684 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file i2c.c
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief providing APIs for configuring I2C module (I2C). 
+*
+*******************************************************************************
+*
+* provide APIs for configuring I2C module (I2C).
+******************************************************************************/
+#include "common.h"
+#include "i2c.h"
+
+/******************************************************************************
+* Global variables
+******************************************************************************/
+
+/******************************************************************************
+* Constants and macros
+******************************************************************************/
+
+/******************************************************************************
+* Local types
+******************************************************************************/
+
+/******************************************************************************
+* Local function prototypes
+******************************************************************************/
+
+/******************************************************************************
+* Local variables
+******************************************************************************/
+static I2C_CallbackType I2C_Callback[2] = {(I2C_CallbackType)NULL};
+/******************************************************************************
+* Local functions
+******************************************************************************/
+void I2C0_Isr( void );
+
+/******************************************************************************
+* Global functions
+******************************************************************************/
+
+
+/******************************************************************************
+* define I2C APIs
+*
+*//*! @addtogroup i2c_api_list
+* @{
+*******************************************************************************/
+/*****************************************************************************//*!
+   *
+   * @brief Initialize I2C module.
+   *        
+   * @param[in] pI2Cx      point to I2C module type.
+ 	 * @param[in] pI2CConfig point to I2C configure structure.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+
+void I2C_Init(I2C_Type *pI2Cx,I2C_ConfigPtr pI2CConfig)
+{
+    uint8_t u8Temp;
+
+#if defined(CPU_KE02)
+    SIM->SCGC |= SIM_SCGC_IIC_MASK;
+#elif defined(CPU_KE04)
+    SIM->SCGC |= SIM_SCGC_IIC_MASK;
+#elif defined(CPU_KE06)
+    if(pI2Cx == I2C0)
+    {
+        SIM->SCGC |= SIM_SCGC_I2C0_MASK;
+    }
+    else
+    {
+        SIM->SCGC |= SIM_SCGC_I2C1_MASK;
+    }
+#endif
+
+	I2C_SetBaudRate(pI2Cx,pI2CConfig->u16F);
+    I2C_SetSlaveAddress(pI2Cx,pI2CConfig->u16OwnA1);
+    pI2Cx->FLT = (uint8_t)pI2CConfig->u16Filt;
+    pI2Cx->RA = (uint8_t)pI2CConfig->u16RangeA & 0xfe;
+    I2C_SetSCLLowTimeout(pI2Cx,pI2CConfig->u16Slt);
+
+    /* configure C2 control register */
+    u8Temp = 0;
+    if( pI2CConfig->sSetting.bGCAEn )
+    {
+        u8Temp |= I2C_C2_GCAEN_MASK;
+    }
+    if( pI2CConfig->sSetting.bAddressExt )
+    {
+        u8Temp |= I2C_C2_ADEXT_MASK;
+    }
+    if( pI2CConfig->sSetting.bRangeAddEn )
+    {
+        u8Temp |= I2C_C2_RMEN_MASK;
+    }
+    pI2Cx->C2 |= u8Temp;
+
+    /* configure SMB rehister */
+    u8Temp = 0;
+    if( pI2CConfig->sSetting.bFackEn )
+    {
+        u8Temp |= I2C_SMB_FACK_MASK;
+    }
+    if( pI2CConfig->sSetting.bSMB_AlertEn )
+    {
+        u8Temp |= I2C_SMB_ALERTEN_MASK;
+    }
+    if( pI2CConfig->sSetting.bSecondAddressEn )
+    {
+        u8Temp |= I2C_SMB_SIICAEN_MASK;
+    }
+    if( pI2CConfig->sSetting.bSHTF2IntEn )
+    {
+        u8Temp |= I2C_SMB_SHTF2IE_MASK;
+    }
+    pI2Cx->SMB = u8Temp;
+    
+    /* configure C1 rehister */
+    u8Temp = 0;
+    if( pI2CConfig->sSetting.bIntEn )
+    {
+        u8Temp |= I2C_C1_IICIE_MASK;
+        if(pI2Cx == I2C0)
+        {
+            NVIC_EnableIRQ(I2C0_IRQn);
+        }
+    #if defined(CPU_KE06)     
+        else if(pI2Cx == I2C1)
+        {
+            NVIC_EnableIRQ(I2C1_IRQn);
+        }
+    #endif    
+        else
+        {
+            //
+        }
+    }
+    if( pI2CConfig->sSetting.bWakeUpEn )
+    {
+        u8Temp |= I2C_C1_WUEN_MASK;
+    }
+    if( pI2CConfig->sSetting.bI2CEn )
+    {
+        u8Temp |= I2C_C1_IICEN_MASK;
+    }
+    pI2Cx->C1 = u8Temp;
+
+
+}
+/*****************************************************************************//*!
+   *
+   * @brief send out start signals.
+   *        
+   * @param[in] pI2Cx      point to I2C module type.
+   *
+   * @return error status
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+uint8_t I2C_Start(I2C_Type *pI2Cx)
+{
+    uint32_t u32Timeout;
+    uint8_t u8ErrorStatus;
+    
+    u32Timeout = 0; 
+    u8ErrorStatus = 0x00;
+
+    I2C_TxEnable(pI2Cx);
+    pI2Cx->C1 |= I2C_C1_MST_MASK;
+
+    while( (!I2C_IsBusy(pI2Cx)) && ( u32Timeout < I2C_WAIT_STATUS_TIMEOUT))
+     {
+        u32Timeout ++;
+     }
+
+     if( u32Timeout == I2C_WAIT_STATUS_TIMEOUT )
+     {
+        u8ErrorStatus |= I2C_ERROR_START_NO_BUSY_FLAG;
+     }
+
+     return u8ErrorStatus;
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief send out stop signals.
+   *        
+   * @param[in] pI2Cx      point to I2C module type.
+   *
+   * @return error status
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+uint8_t I2C_Stop(I2C_Type *pI2Cx)
+{
+    uint32_t u32Timeout;
+    uint8_t u8ErrorStatus;
+    
+    u32Timeout = 0; 
+    u8ErrorStatus = 0x00;
+    
+    pI2Cx->C1 &= ~I2C_C1_MST_MASK;
+
+    while( (I2C_IsBusy(pI2Cx) ) && ( u32Timeout < I2C_WAIT_STATUS_TIMEOUT))
+     {
+        u32Timeout ++;
+     }
+
+     if( u32Timeout == I2C_WAIT_STATUS_TIMEOUT )
+     {
+        u8ErrorStatus |= I2C_ERROR_STOP_BUSY_FLAG;
+     }
+
+     return u8ErrorStatus;
+}
+
+
+/*****************************************************************************//*!
+   *
+   * @brief send out repeat start signals.
+   *        
+   * @param[in] pI2Cx      point to I2C module type.
+   *
+   * @return error status.
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+uint8_t I2C_RepeatStart(I2C_Type *pI2Cx)
+{
+    uint32_t u32Timeout;
+    uint8_t u8ErrorStatus;
+    
+    u32Timeout = 0; 
+    u8ErrorStatus = 0x00;
+    
+    pI2Cx->C1 |= I2C_C1_RSTA_MASK;
+
+    while( (!I2C_IsBusy(I2C0) ) && ( u32Timeout < I2C_WAIT_STATUS_TIMEOUT))
+     {
+        u32Timeout ++;
+     }
+
+     if( u32Timeout == I2C_WAIT_STATUS_TIMEOUT )
+     {
+        u8ErrorStatus |= I2C_ERROR_START_NO_BUSY_FLAG;
+     }
+
+     return u8ErrorStatus;
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief set slave address.
+   *        
+   * @param[in] pI2Cx      point to I2C module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+void I2C_SetSlaveAddress(I2C_Type *pI2Cx,uint16_t u16SlaveAddress)
+{
+    /* write low 8bit address */
+    pI2Cx->A1 = (uint8_t)u16SlaveAddress;
+
+    /* write high 3bit address if it support 10bit slave address */
+    pI2Cx->C2 &= ~I2C_C2_AD_MASK;
+    pI2Cx->C2 |= (uint8_t)(u16SlaveAddress>>8)&0x03;
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief disable IICIF interrupt.
+   *        
+   * @param[in] pI2Cx      point to I2C module type.
+   *
+   * @return none.
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+void I2C_IntDisable(I2C_Type *pI2Cx)
+{
+    pI2Cx->C1 &= ~I2C_C1_IICIE_MASK;
+    if(pI2Cx == I2C0)
+    {
+        NVIC_DisableIRQ(I2C0_IRQn);
+    }
+    #if defined(CPU_KE06)
+    else if(pI2Cx == I2C1)
+    {
+        NVIC_DisableIRQ(I2C1_IRQn);
+    }
+    #endif
+    else
+    {
+        
+    }
+}
+/*****************************************************************************//*!
+   *
+   * @brief enable IICIF interrupt.
+   *        
+   * @param[in] pI2Cx      point to I2C module type.
+   *
+   * @return none.
+   *
+   * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+void I2C_IntEnable(I2C_Type *pI2Cx)
+{
+    pI2Cx->C1 |= I2C_C1_IICIE_MASK;
+    if(pI2Cx == I2C0)
+    {
+        NVIC_EnableIRQ(I2C0_IRQn);
+    }
+    #if defined(CPU_KE06)
+    else if(pI2Cx == I2C1)
+    {
+        NVIC_EnableIRQ(I2C1_IRQn);
+    }
+    #endif
+    else
+    {
+        
+    }
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief SCL low timeout value that determines the timeout period of SCL low.
+   *        
+   * @param[in] pI2Cx      point to I2C module type.
+   *
+   * @return none.
+   *
+   * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+void I2C_SetSCLLowTimeout(I2C_Type *pI2Cx, uint16_t u16Timeout)
+{
+    pI2Cx->SLTL = (uint8_t)u16Timeout;
+    pI2Cx->SLTH = (uint8_t)(u16Timeout>>8);
+}
+/*****************************************************************************//*!
+   *
+   * @brief deinit I2C module.
+   *        
+   * @param[in] pI2Cx    point to I2C module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+void I2C_Deinit(I2C_Type *pI2Cx)
+{
+     pI2Cx->C1 &= ~I2C_C1_IICEN_MASK;
+#if defined(CPU_KE02)
+    SIM->SCGC &= ~SIM_SCGC_IIC_MASK;
+#elif defined(CPU_KE04)
+    SIM->SCGC &= ~SIM_SCGC_IIC_MASK;
+#elif defined(CPU_KE06)
+    if(pI2Cx == I2C0)
+    {
+        SIM->SCGC &= ~SIM_SCGC_I2C0_MASK;
+    }
+    else
+    {
+        SIM->SCGC &= ~SIM_SCGC_I2C1_MASK;
+    }
+#endif
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief write a byte to I2C module.
+   *        
+   * @param[in] pI2Cx    point to I2C module type.
+   * @param[in] u8WrBuff  data buffer for writing. 
+   *
+   * @return error status
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+
+uint8_t I2C_WriteOneByte(I2C_Type *pI2Cx, uint8_t u8WrBuff)
+{
+    uint32_t u32Timeout;
+    uint8_t u8ErrorStatus;
+    
+    u32Timeout = 0; 
+    u8ErrorStatus = 0x00;
+    while (((I2C_GetStatus(pI2Cx)&I2C_S_TCF_MASK) !=  I2C_S_TCF_MASK)
+            && (u32Timeout<I2C_WAIT_STATUS_TIMEOUT))
+    {
+        u32Timeout ++;
+    }
+    if (u32Timeout >= I2C_WAIT_STATUS_TIMEOUT)
+    {
+        u8ErrorStatus |= I2C_ERROR_NO_WAIT_TCF_FLAG; 
+        return u8ErrorStatus;
+    }
+    
+    I2C_TxEnable(pI2Cx);
+    I2C_WriteDataReg(pI2Cx,u8WrBuff);
+
+    u32Timeout = 0;
+    while (((I2C_GetStatus(pI2Cx)&I2C_S_IICIF_MASK) !=  I2C_S_IICIF_MASK)
+            && (u32Timeout<I2C_WAIT_STATUS_TIMEOUT))
+    {
+        u32Timeout ++;
+    }
+    if (u32Timeout >= I2C_WAIT_STATUS_TIMEOUT)
+    {
+        u8ErrorStatus |= I2C_ERROR_NO_WAIT_IICIF_FLAG; 
+        return u8ErrorStatus;
+    }
+
+    /* clear IICIF flag */
+    I2C_ClearStatus(pI2Cx,I2C_S_IICIF_MASK);
+    if (I2C_GetStatus(pI2Cx) & I2C_S_RXAK_MASK) 
+    {
+        u8ErrorStatus |= I2C_ERROR_NO_GET_ACK;
+    }
+    return u8ErrorStatus;
+}
+/*****************************************************************************//*!
+   *
+   * @brief read a byte from slave I2C.
+   *        
+   * @param[in] pI2Cx    point to I2C module type.
+   * @param[out] pRdBuff point to the data read from slave I2C.
+   * @param[out] u8Ack   send out ack or nack.
+   *
+   * @return error status
+   *
+   * @ Pass/ Fail criteria:  none
+*****************************************************************************/
+
+uint8_t I2C_ReadOneByte(I2C_Type *pI2Cx, uint8_t *pRdBuff, uint8_t u8Ack)
+{
+    uint32_t u32Timeout;
+    uint8_t u8ErrorStatus;
+    
+    u32Timeout = 0; 
+    u8ErrorStatus = 0x00;
+    while (((I2C_GetStatus(pI2Cx)&I2C_S_TCF_MASK) !=  I2C_S_TCF_MASK)
+            && (u32Timeout<I2C_WAIT_STATUS_TIMEOUT))
+    {
+        u32Timeout ++;
+    }
+    if (u32Timeout >= I2C_WAIT_STATUS_TIMEOUT)
+    {
+        u8ErrorStatus |= I2C_ERROR_NO_WAIT_TCF_FLAG; 
+        return u8ErrorStatus;
+    }
+    
+    I2C_RxEnable(pI2Cx);
+
+    if( u8Ack )
+    {
+        /* send out nack */
+        I2C_SendNack(pI2Cx);
+       
+    }
+    else
+    {
+         /* send out ack */
+        I2C_SendAck(pI2Cx);
+    }
+    *pRdBuff = I2C_ReadDataReg(pI2Cx);
+
+    u32Timeout = 0;
+    while (((I2C_GetStatus(pI2Cx)&I2C_S_IICIF_MASK) !=  I2C_S_IICIF_MASK)
+            && (u32Timeout<I2C_WAIT_STATUS_TIMEOUT))
+    {
+        u32Timeout ++;
+    }
+    if (u32Timeout >= I2C_WAIT_STATUS_TIMEOUT)
+    {
+        u8ErrorStatus |= I2C_ERROR_NO_WAIT_IICIF_FLAG; 
+        return u8ErrorStatus;
+    }
+
+    /* clear IICIF flag */
+    I2C_ClearStatus(pI2Cx,I2C_S_IICIF_MASK);
+
+    return u8ErrorStatus;
+}
+/*****************************************************************************//*!
+   *
+   * @brief send data to I2C, and wait to complete transfering.
+   *   
+   * @param[in]  pI2Cx    point to I2C module type.
+   * @param[in]  u16SlaveAddress slave address. 
+   * @param[in]  pWrBuff point the first address of transfering data buffer. 
+   * @param[in]  the length of transfering data.
+   *
+   * @return error status
+   *
+   * @ Pass/ Fail criteria:  none
+*****************************************************************************/
+
+uint8_t I2C_MasterSendWait(I2C_Type *pI2Cx,uint16_t u16SlaveAddress,uint8_t *pWrBuff,uint32_t u32Length)
+{
+    uint32_t i;
+    uint8_t u8ErrorStatus;
+
+    /* send start signals to bus */
+    u8ErrorStatus = I2C_Start(pI2Cx);
+
+    /* send device address to slave */
+    u8ErrorStatus = I2C_WriteOneByte(pI2Cx,((uint8_t)u16SlaveAddress<<1) | I2C_WRITE);
+
+    /* if no error occur, received the correct ack from slave
+            continue to send data to slave
+        */
+    if( u8ErrorStatus == I2C_ERROR_NULL )
+    {
+        for(i=0;i<u32Length;i++)
+        {
+            u8ErrorStatus = I2C_WriteOneByte(pI2Cx,pWrBuff[i]);
+            if( u8ErrorStatus != I2C_ERROR_NULL )
+            {
+                return u8ErrorStatus;
+            }
+        }
+     }
+
+     /* send stop signals to bus */
+     u8ErrorStatus = I2C_Stop(pI2Cx);
+
+     return u8ErrorStatus;
+            
+}
+/*****************************************************************************//*!
+   *
+   * @brief read data from I2C,and wait to complete transferring.
+   *        
+   * @param[in] pI2Cx    point to I2C module type.
+   * @param[in]  u16SlaveAddress slave address. 
+   * @param[in]  pRdBuff point the first address of reading data buffer. 
+   * @param[in]  the length of transfering data.
+   *
+   * @return error status
+   *
+   * @ Pass/ Fail criteria:  none
+*****************************************************************************/
+
+uint8_t I2C_MasterReadWait(I2C_Type *pI2Cx,uint16_t u16SlaveAddress,uint8_t *pRdBuff,uint32_t u32Length)
+{
+    uint32_t i;
+    uint8_t u8ErrorStatus;
+
+    /* send start signals to bus */
+    u8ErrorStatus = I2C_Start(pI2Cx);
+
+    /* send device address to slave */
+    u8ErrorStatus = I2C_WriteOneByte(pI2Cx,((uint8_t)u16SlaveAddress<<1) | I2C_READ);
+
+    /* if no error occur, received the correct ack from slave
+            continue to send data to slave
+        */
+    /* dummy read one byte to switch to Rx mode */
+    I2C_ReadOneByte(pI2Cx,&pRdBuff[0],I2C_SEND_ACK);
+    
+    if( u8ErrorStatus == I2C_ERROR_NULL )
+    {
+        for(i=0;i<u32Length-1;i++)
+        {
+            u8ErrorStatus = I2C_ReadOneByte(pI2Cx,&pRdBuff[i],I2C_SEND_ACK);
+            if( u8ErrorStatus != I2C_ERROR_NULL )
+            {
+                return u8ErrorStatus;
+            }
+        }
+        u8ErrorStatus = I2C_ReadOneByte(pI2Cx,&pRdBuff[i],I2C_SEND_NACK);
+     }
+     /* send stop signals to bus */
+     u8ErrorStatus = I2C_Stop(pI2Cx);
+     
+     return u8ErrorStatus;
+            
+}
+/*****************************************************************************//*!
+   *
+   * @brief set call back function for I2C1 module.
+   *        
+   * @param[in] pCallBack point to address of I2C1 call back function.
+   *
+   * @return none.
+   *
+   * @ Pass/ Fail criteria:  none.
+*****************************************************************************/
+
+void I2C1_SetCallBack( I2C_CallbackType pCallBack )
+{
+    I2C_Callback[1] = pCallBack;
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief set call back function for I2C0 module.
+   *        
+   * @param[in] pCallBack point to address of I2C0 call back function.
+   *
+   * @return none.
+   *
+   * @ Pass/ Fail criteria:  none.
+*****************************************************************************/
+
+void I2C0_SetCallBack( I2C_CallbackType pCallBack )
+{
+    I2C_Callback[0] = pCallBack;
+}
+/*! @} End of i2c_api_list                                               						*/
+
+
+/*****************************************************************************//*!
+   *
+   * @brief I2C0 interrupt service routine.
+   *        
+   * @param  
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria:  none
+*****************************************************************************/
+void I2C0_Isr( void )
+{
+    if( I2C_Callback[0] )
+    {
+        I2C_Callback[0]();
+    }
+}
+/*****************************************************************************//*!
+   *
+   * @brief I2C1 interrupt service routine.
+   *        
+   * @param  
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria:  none
+*****************************************************************************/
+void I2C1_Isr( void )
+{
+    if( I2C_Callback[1] )
+    {
+        I2C_Callback[1]();
+    }
+}
+
+
+
diff --git a/bsp/frdm-ke02/device/lib/drivers/ics.c b/bsp/frdm-ke02/device/lib/drivers/ics.c
new file mode 100755
index 0000000..c5d5853
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/drivers/ics.c
@@ -0,0 +1,1119 @@
+/*****************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file ics.c
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief providing APIs for configuring internal clock sources (ICS). 
+*
+*******************************************************************************
+*
+* provide APIs for configuring internal clock sources (ICS)
+******************************************************************************/
+#include "common.h"
+#include "ics.h"
+
+/******************************************************************************
+* Global variables
+******************************************************************************/
+
+/******************************************************************************
+* Constants and macros
+******************************************************************************/
+
+/* default value of ICS and OSC registers after reset */
+#define ICS_C1_DEFAULT  0x04
+#define ICS_C2_DEFAULT  0x20
+#define ICS_C3_DEFAULT  0x54
+#define ICS_C4_DEFAULT  0x00
+#define ICS_S_DEFAULT   0x50
+#define OSC_CR_DEFAULT  0
+
+
+/******************************************************************************
+* Local types
+******************************************************************************/
+
+/******************************************************************************
+* Local function prototypes
+******************************************************************************/
+
+
+/******************************************************************************
+* Local variables
+******************************************************************************/
+
+/******************************************************************************
+* Local functions
+******************************************************************************/
+
+/******************************************************************************
+* Global functions
+******************************************************************************/
+
+
+/*****************************************************************************//*!
+   *
+   * @brief change clock from FEI mode to FEE mode and divide clock by 2.
+   *        
+   * @param[in] pConfig pointer to the ICS configuration structure
+   *
+   * @return none
+   *
+   * @Pass/ Fail criteria: none
+   *****************************************************************************/
+void FEI_to_FEE(ICS_ConfigType *pConfig)
+{
+	/* enable OSC
+	 * 
+	 */
+	OSC_Init(&pConfig->oscConfig); /* enable OSC */
+	
+	/* divide down external clock frequency to be within 31.25K to 39.0625K
+	 * 
+	 */
+ 
+    ICS_SetClkDivider(pConfig->u32ClkFreq);
+
+	/* change FLL reference clock to external clock */
+	ICS->C1 =  ICS->C1 & ~ICS_C1_IREFS_MASK;
+         
+	
+	/* wait for the reference clock to be changed to external */
+#if defined(IAR)        
+	asm(
+		"nop \n"
+		"nop \n"
+	);
+#elif defined(__MWERKS__)
+	asm{
+		nop 
+		nop
+};        
+#endif        
+	while(ICS->S & ICS_S_IREFST_MASK);
+	
+	/* wait for FLL to lock */
+	while(!(ICS->S & ICS_S_LOCK_MASK));
+		
+	/* now FLL output clock is FLL reference clock* FLL multiplication factor. 
+	 * See Reference Manual for multiplication factor.
+	 */
+#if defined(CPU_KE02)
+	if(((ICS->C2 & ICS_C2_BDIV_MASK)>>5) != 1)
+	{
+		ICS->C2 = (ICS->C2 & ~(ICS_C2_BDIV_MASK)) | ICS_C2_BDIV(1);
+	}
+#else
+    ICS->C2 = (ICS->C2 & ~(ICS_C2_BDIV_MASK)) | ICS_C2_BDIV(0);
+#endif
+	/* now system/bus clock is the target frequency
+	 * 
+	 */
+	/* clear Loss of lock sticky bit */
+	ICS->S |= ICS_S_LOLS_MASK;	
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief change clock from FEI mode to FBI mode and divide clock by 2.
+   *        
+   * @param  pConfig    pointer to configuration strucure. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   * @see   ICS_ConfigType
+   *****************************************************************************/
+void FEI_to_FBI(ICS_ConfigType *pConfig)
+{
+	/* change clock source to internal reference clock */
+	ICS->C1 = (ICS->C1 & ~(ICS_C1_CLKS_MASK)) | ICS_C1_CLKS(1);   
+	ICS->C2 = ICS->C2 & ~(ICS_C2_LP_MASK); 
+	/* wait for the reference clock to be changed  */
+#if defined(IAR)        
+	asm(
+		"nop \n"
+		"nop \n"
+	);
+#elif defined(__MWERKS__)
+	asm{
+		nop 
+		nop
+        };        
+#endif        
+	while(((ICS->S & ICS_S_CLKST_MASK) >> ICS_S_CLKST_SHIFT) !=1);
+			
+	/* now internal reference clock is the system clock
+	 * 
+	 */
+#if defined(BUS_CLK_EQU_CORE_DIVIDE_BY_2)||defined(CPU_KE02)        
+	if(((ICS->C2 & ICS_C2_BDIV_MASK)>>5) != 1)
+	{
+		ICS->C2 = (ICS->C2 & ~(ICS_C2_BDIV_MASK)) | ICS_C2_BDIV(1);
+	}
+
+#else
+	ICS->C2 = (ICS->C2 & ~(ICS_C2_BDIV_MASK));     
+#endif        
+	/* clear Loss of lock sticky bit */
+	ICS->S |= ICS_S_LOLS_MASK;	
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief change clock from FEI mode to FBE mode and divide clock by 2.
+   *        
+   * @param  pConfig    pointer to configuration strucure. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   * @see   ICS_ConfigType
+   *****************************************************************************/
+void FEI_to_FBE(ICS_ConfigType *pConfig)
+{
+	OSC_Init(&pConfig->oscConfig); /* enable OSC */
+
+	/* change clock source to external reference clock */
+    ICS->C1 =  ICS->C1 & ~(ICS_C1_IREFS_MASK);
+	ICS->C1 = (ICS->C1 & ~(ICS_C1_CLKS_MASK)) | ICS_C1_CLKS(2);   
+	ICS->C2 = ICS->C2 & ~(ICS_C2_LP_MASK); 
+        
+	/* wait for the reference clock to be changed  */
+#if defined(IAR)        
+	asm(
+		"nop \n"
+		"nop \n"
+	);
+#elif defined(__MWERKS__)
+	asm{
+		nop 
+		nop
+        };        
+#endif        
+
+	while(((ICS->S & ICS_S_CLKST_MASK) >> ICS_S_CLKST_SHIFT) !=2);
+        while(ICS->S & ICS_S_IREFST_MASK);
+			
+	/* now external  clock is the system clock
+	 * 
+	 */
+#if defined(CPU_KE02)
+	if(((ICS->C2 & ICS_C2_BDIV_MASK)>>5) != 1)
+	{
+		ICS->C2 = (ICS->C2 & ~(ICS_C2_BDIV_MASK)) | ICS_C2_BDIV(1);
+	}
+#else
+    ICS->C2 = (ICS->C2 & ~(ICS_C2_BDIV_MASK)) | ICS_C2_BDIV(0);
+#endif
+	/* now system/bus clock is external clock
+	 * 
+	 */
+	/* clear Loss of lock sticky bit */
+	ICS->S |= ICS_S_LOLS_MASK;	
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief change clock from FEI mode to FBE mode with external clock/oscillator 
+   * and divide clock by 2.
+   *        
+   * @param  pConfig    pointer to configuration strcuture. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   * @see   ICS_ConfigType
+   *****************************************************************************/
+void FEI_to_FBE_OSC(ICS_ConfigType *pConfig)
+{
+    
+	OSC_Init(&pConfig->oscConfig); /* enable OSC */
+
+	/* change RDIV  reference divider to divide reference clock to be with FLL input spec
+	 * 
+	 */
+    ICS_SetClkDivider(pConfig->u32ClkFreq);
+    
+	/* assume external oscillator is 8Mhz or 4MHz
+	 * 
+	 */
+	/* change clock source to external reference clock */
+        ICS->C1 =  ICS->C1 & ~(ICS_C1_IREFS_MASK);
+	ICS->C1 = (ICS->C1 & ~(ICS_C1_CLKS_MASK)) | ICS_C1_CLKS(2);   
+	ICS->C2 = ICS->C2 & ~(ICS_C2_LP_MASK); 
+        
+	/* wait for the reference clock to be changed  */
+#if defined(IAR)        
+	asm(
+		"nop \n"
+		"nop \n"
+	);
+#elif defined(__MWERKS__)
+	asm{
+		nop 
+		nop
+        };        
+#endif     
+	while(((ICS->S & ICS_S_CLKST_MASK) >> ICS_S_CLKST_SHIFT) !=2);
+        while(ICS->S & ICS_S_IREFST_MASK);
+			
+	/* now external  clock is the system clock
+	 * 
+	 */
+#if defined(CPU_KE02)
+	if(((ICS->C2 & ICS_C2_BDIV_MASK)>>5) != 1)
+	{
+		ICS->C2 = (ICS->C2 & ~(ICS_C2_BDIV_MASK)) | ICS_C2_BDIV(1);
+	}
+#else
+    ICS->C2 = (ICS->C2 & ~(ICS_C2_BDIV_MASK)) | ICS_C2_BDIV(0);
+#endif
+	/* now system/bus clock is external clock
+	 * 
+	 */
+	/* clear Loss of lock sticky bit */
+	ICS->S |= ICS_S_LOLS_MASK;	
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief change clock from FEI mode to FEE mode with external clock/oscillator 
+   * and divide clock by 2.
+   *        
+   * @param  pConfig     pointer to configuration. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   * @see   ICS_ConfigType
+   *****************************************************************************/
+void FEI_to_FEE_OSC(ICS_ConfigType *pConfig)
+{
+
+	OSC_Init(&pConfig->oscConfig); /* enable OSC */
+
+	/* change RDIV  reference divider to divide reference clock to be with FLL input spec
+	 * 
+	 */
+    ICS_SetClkDivider(pConfig->u32ClkFreq);
+
+	/* change FLL reference clock to external clock */
+    ICS->C1 =  ICS->C1 & ~(ICS_C1_IREFS_MASK);
+	
+	/* wait for the reference clock to be changed to external */
+#if defined(IAR)        
+	asm(
+		"nop \n"
+		"nop \n"
+	);
+#elif defined(__MWERKS__)
+	asm{
+		nop 
+		nop
+        };        
+#endif     
+	while(ICS->S & ICS_S_IREFST_MASK);
+	
+	/* wait for FLL to lock */
+	while(!(ICS->S & ICS_S_LOCK_MASK));
+#if defined(CPU_KE02)		
+	if(((ICS->C2 & ICS_C2_BDIV_MASK)>>5) != 1)
+	{
+		ICS->C2 = (ICS->C2 & ~(ICS_C2_BDIV_MASK)) | ICS_C2_BDIV(1);
+	}
+#else
+    ICS->C2 = (ICS->C2 & ~(ICS_C2_BDIV_MASK)) | ICS_C2_BDIV(0);
+#endif
+	/* now system/bus clock is the target frequency
+	 * 
+	 */
+	/* clear Loss of lock sticky bit */
+	ICS->S |= ICS_S_LOLS_MASK;	
+}
+
+
+/*****************************************************************************//*!
+   *
+   * @brief change clock from FEE mode to FEI mode.
+   *        
+   * @param  pConfig     pointer to configuration. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   * @see   ICS_ConfigType
+   *****************************************************************************/
+void FEE_to_FEI(ICS_ConfigType *pConfig)
+{
+	/* select internal reference for FLL */ 
+    ICS->C1 =  ICS->C1 | (ICS_C1_IREFS_MASK);
+	
+	/* wait for the reference clock to be changed */
+#if defined(IAR)        
+	asm(
+		"nop \n"
+		"nop \n"
+	);
+#elif defined(__MWERKS__)
+	asm{
+		nop 
+		nop
+        };        
+#endif     
+	while(!(ICS->S & ICS_S_IREFST_MASK));
+	
+	/* wait for FLL to lock */
+	while(!(ICS->S & ICS_S_LOCK_MASK));
+
+	/* clear Loss of lock sticky bit */
+	ICS->S |= ICS_S_LOLS_MASK;
+
+	/* now FLL output clock is target frequency
+	 * 
+	 */
+#if defined(CPU_KE02)
+	if(((ICS->C2 & ICS_C2_BDIV_MASK)>>5) != 1)
+	{
+		ICS->C2 = (ICS->C2 & ~(ICS_C2_BDIV_MASK)) | ICS_C2_BDIV(1);
+	}
+#else
+    ICS->C2 = (ICS->C2 & ~(ICS_C2_BDIV_MASK)) | ICS_C2_BDIV(0);
+#endif
+	/* now system/bus clock is around 16MHz
+	 * 
+	 */
+      OSC_Disable();            /* disable OSC */
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief change clock from FEE mode to FBI mode.
+   *        
+   * @param  pConfig     pointer to configuration. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   * @see   ICS_ConfigType
+   *****************************************************************************/
+void FEE_to_FBI(ICS_ConfigType *pConfig)
+{
+	/* clear Loss of lock sticky bit */
+	ICS->S |= ICS_S_LOLS_MASK;
+	
+	/* select internal clock as clock source */
+	/* select internal reference for FLL */ 
+	/* LP = 0 */
+
+    ICS->C1 =  ICS->C1 | (ICS_C1_IREFS_MASK);
+	ICS->C1 = (ICS->C1 & ~(ICS_C1_CLKS_MASK)) | ICS_C1_CLKS(1);   
+	ICS->C2 = ICS->C2 & ~(ICS_C2_LP_MASK); 
+	
+	/* wait for the reference clock to be changed */
+#if defined(IAR)        
+	asm(
+		"nop \n"
+		"nop \n"
+	);
+#elif defined(__MWERKS__)
+	asm{
+		nop 
+		nop
+        };        
+#endif     
+	while(!(ICS->S & ICS_S_IREFST_MASK));
+	while(((ICS->S & ICS_S_CLKST_MASK) >> ICS_S_CLKST_SHIFT) !=1);
+	
+#if defined(BUS_CLK_EQU_CORE_DIVIDE_BY_2)||defined(CPU_KE02)        
+	if(((ICS->C2 & ICS_C2_BDIV_MASK)>>5) != 1)
+	{
+		ICS->C2 = (ICS->C2 & ~(ICS_C2_BDIV_MASK)) | ICS_C2_BDIV(1);
+	}
+
+#else
+	ICS->C2 = (ICS->C2 & ~(ICS_C2_BDIV_MASK));
+       
+#endif    
+        OSC_Disable();            
+}
+
+
+/*****************************************************************************//*!
+   *
+   * @brief change clock from FEE mode to FBE mode.
+   *        
+   * @param  pConfig     pointer to configuration .
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   * @see   ICS_ConfigType
+   *****************************************************************************/
+void FEE_to_FBE(ICS_ConfigType *pConfig)
+{
+	/* clear Loss of lock sticky bit */
+	ICS->S |= ICS_S_LOLS_MASK;
+	
+	/* select the external clock as clock source */
+        /* LP = 0 */
+	ICS->C1 = (ICS->C1 & ~(ICS_C1_CLKS_MASK)) | ICS_C1_CLKS(2);   
+	ICS->C2 = ICS->C2 & ~(ICS_C2_LP_MASK); 
+	
+	/* wait for the clock source to be changed */
+#if defined(IAR)        
+	asm(
+		"nop \n"
+		"nop \n"
+	);
+#elif defined(__MWERKS__)
+	asm{
+		nop 
+		nop
+        };        
+#endif     
+	while(((ICS->S & ICS_S_CLKST_MASK) >> ICS_S_CLKST_SHIFT) !=2);
+	
+	/* now system clock source is external clock
+	 * NOTE: make sure that the external clock is within 20MHz 
+	 */
+#if defined(CPU_KE02)	 
+	if(((ICS->C2 & ICS_C2_BDIV_MASK)>>5) != 1)
+	{
+		ICS->C2 = (ICS->C2 & ~(ICS_C2_BDIV_MASK)) | ICS_C2_BDIV(1);
+	}	
+#else
+    ICS->C2 = (ICS->C2 & ~(ICS_C2_BDIV_MASK)) | ICS_C2_BDIV(0);
+#endif
+}
+
+
+/*****************************************************************************//*!
+   *
+   * @brief change clock from FBI mode to FBE mode.
+   *        
+   * @param  pConfig     pointer to configuration. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   * @see   ICS_ConfigType
+   *****************************************************************************/
+void FBI_to_FBE(ICS_ConfigType *pConfig)
+{
+	OSC_Init(&pConfig->oscConfig); /* enable OSC */
+    
+	/* select external reference clock */
+	/* select the external clock as clock source */
+
+    ICS->C1 =  ICS->C1 & ~(ICS_C1_IREFS_MASK);
+	ICS->C1 = (ICS->C1 & ~(ICS_C1_CLKS_MASK)) | ICS_C1_CLKS(2);   
+	
+	/* wait for the clock source to be changed */
+#if defined(IAR)        
+	asm(
+		"nop \n"
+		"nop \n"
+	);
+#elif defined(__MWERKS__)
+	asm{
+		nop 
+		nop
+        };        
+#endif     
+	while(((ICS->S & ICS_S_CLKST_MASK) >> ICS_S_CLKST_SHIFT) !=2);
+	while((ICS->S & ICS_S_IREFST_MASK));
+	
+	/* now system clock source is external clock
+	 * NOTE: make sure that the external clock is within 20MHz 
+	 */
+#if defined(CPU_KE02)
+	if(((ICS->C2 & ICS_C2_BDIV_MASK)>>5) != 1)
+	{
+		ICS->C2 = (ICS->C2 & ~(ICS_C2_BDIV_MASK)) | ICS_C2_BDIV(1);
+	}	
+#else
+    ICS->C2 = (ICS->C2 & ~(ICS_C2_BDIV_MASK)) | ICS_C2_BDIV(0);
+#endif
+}
+
+
+/*****************************************************************************//**
+   *
+   * @brief change clock from FBI mode to FEE mode.
+   *        
+   * @param  pConfig     pointer to configuration. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   * @see   ICS_ConfigType
+   *****************************************************************************/
+void FBI_to_FEE(ICS_ConfigType *pConfig)
+{
+	OSC_Init(&pConfig->oscConfig); /* enable OSC */
+  
+	/* select external reference clock */
+	/* select the FLL output as clock source */
+
+    ICS->C1 =  ICS->C1 & ~(ICS_C1_IREFS_MASK);
+	ICS->C1 = (ICS->C1 & ~(ICS_C1_CLKS_MASK));   
+	
+	/* wait for the clock source to be changed */
+#if defined(IAR)        
+	asm(
+		"nop \n"
+		"nop \n"
+	);
+#elif defined(__MWERKS__)
+	asm{
+		nop 
+		nop
+        };        
+#endif     
+
+	while((ICS->S & ICS_S_CLKST_MASK));
+	while((ICS->S & ICS_S_IREFST_MASK));
+	
+	
+	/* now system clock source is external clock
+	 * NOTE: make sure that the external clock is within 20MHz 
+	 */
+#if defined(CPU_KE02)
+	if(((ICS->C2 & ICS_C2_BDIV_MASK)>>5) != 1)
+	{
+		ICS->C2 = (ICS->C2 & ~(ICS_C2_BDIV_MASK)) | ICS_C2_BDIV(1);
+	}
+#else
+    ICS->C2 = (ICS->C2 & ~(ICS_C2_BDIV_MASK)) | ICS_C2_BDIV(0);
+#endif
+	/* clear Loss of lock sticky bit */
+	ICS->S |= ICS_S_LOLS_MASK;	
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief change clock from FBI mode to FBILP mode. 
+   * 
+   * @param  pConfig     pointer to configuration 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   * @warning   must run without debug interface attached.
+   * @see   ICS_ConfigType
+   *****************************************************************************/
+void FBI_to_FBILP(ICS_ConfigType *pConfig)
+{
+	/* assume external crystal is 8Mhz or 4MHz
+	 * 
+	 */
+	ICS->C2 |= ICS_C2_LP_MASK;	/* enter low power mode */
+}
+
+
+/*****************************************************************************//*!
+   *
+   * @brief change clock from FBI mode to FEI mode. 
+   * 
+   * @param  pConfig     pointer to configuration. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   * @see   ICS_ConfigType
+   *****************************************************************************/
+void FBI_to_FEI(ICS_ConfigType *pConfig)
+{
+	/* select internal reference clock */
+	/* select the FLL output as clock source */
+    ICS->C1 =  ICS->C1 | (ICS_C1_IREFS_MASK);
+	ICS->C1 = (ICS->C1 & ~(ICS_C1_CLKS_MASK));   
+	
+	/* wait for the clock source to be changed */
+#if defined(IAR)        
+	asm(
+		"nop \n"
+		"nop \n"
+	);
+#elif defined(__MWERKS__)
+	asm{
+		nop 
+		nop
+        };        
+#endif     
+	while((ICS->S & ICS_S_CLKST_MASK));
+	while(!(ICS->S & ICS_S_IREFST_MASK));
+
+        
+	/* now system clock source is FLL output
+	 * 
+	 */
+#if defined(CPU_KE02)
+	if(((ICS->C2 & ICS_C2_BDIV_MASK)>>5) != 1)
+	{
+		ICS->C2 = (ICS->C2 & ~(ICS_C2_BDIV_MASK)) | ICS_C2_BDIV(1);
+	}	
+#else
+    ICS->C2 = (ICS->C2 & ~(ICS_C2_BDIV_MASK)) | ICS_C2_BDIV(0);
+#endif
+	/* clear Loss of lock sticky bit */
+	ICS->S |= ICS_S_LOLS_MASK;	
+}
+
+
+
+/*****************************************************************************//*!
+   *
+   * @brief change clock from FBE mode to FBI mode.
+   *        
+   * @param  pConfig     pointer to configuration. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   * @see   ICS_ConfigType
+   *****************************************************************************/
+void FBE_to_FBI(ICS_ConfigType *pConfig)
+{
+	/* select internal reference clock */
+	/* select the internal clock as clock source */
+    ICS->C1 =  ICS->C1 | (ICS_C1_IREFS_MASK);
+	ICS->C1 = (ICS->C1 & ~(ICS_C1_CLKS_MASK)) | ICS_C1_CLKS(1);   
+	
+	/* wait for the clock source to be changed */
+#if defined(IAR)        
+	asm(
+		"nop \n"
+		"nop \n"
+	);
+#elif defined(__MWERKS__)
+	asm{
+		nop 
+		nop
+        };        
+#endif     
+	while(((ICS->S & ICS_S_CLKST_MASK) >> ICS_S_CLKST_SHIFT) != 1);
+	while(!(ICS->S & ICS_S_IREFST_MASK));
+	
+	/* now system clock source is internal clock
+	 * 
+	 */
+	 
+#if defined(CPU_KE02)
+	if(((ICS->C2 & ICS_C2_BDIV_MASK)>>5) != 1)
+	{
+		ICS->C2 = (ICS->C2 & ~(ICS_C2_BDIV_MASK)) | ICS_C2_BDIV(1);
+	}	
+#else
+    ICS->C2 = (ICS->C2 & ~(ICS_C2_BDIV_MASK)) | ICS_C2_BDIV(0);
+#endif
+        
+    /* Disable OSC to save power
+     */
+    OSC_Disable();
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief change clock from FBE mode to FEE mode.
+   *        
+   * @param  pConfig     pointer to configuration. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   * @see   ICS_ConfigType
+   *****************************************************************************/
+void FBE_to_FEE(ICS_ConfigType *pConfig)
+{
+	/* select the FLL output as clock source */
+	ICS->C1 = (ICS->C1 & ~(ICS_C1_CLKS_MASK));   
+	
+	/* wait for the clock source to be changed */
+#if defined(IAR)        
+	asm(
+		"nop \n"
+		"nop \n"
+	);
+#elif defined(__MWERKS__)
+	asm{
+		nop 
+		nop
+        };        
+#endif     
+	while(ICS->S & ICS_S_CLKST_MASK);
+
+	
+	/* now system clock source is FLL output
+	 * NOTE: external clock <= 20MHz
+	 */
+#if defined(CPU_KE02)
+	if(((ICS->C2 & ICS_C2_BDIV_MASK)>>5) != 1)
+	{
+		ICS->C2 = (ICS->C2 & ~(ICS_C2_BDIV_MASK)) | ICS_C2_BDIV(1);
+	}	
+#else
+    ICS->C2 = (ICS->C2 & ~(ICS_C2_BDIV_MASK)) | ICS_C2_BDIV(0);
+#endif	
+	/* clear Loss of lock sticky bit */
+	ICS->S |= ICS_S_LOLS_MASK;	
+}
+
+
+/*****************************************************************************//*!
+   *
+   * @brief change clock from FBE mode to FEI mode.
+   *        
+   * @param  pConfig     pointer to configuration. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   * @see   ICS_ConfigType
+   *****************************************************************************/
+void FBE_to_FEI(ICS_ConfigType *pConfig)
+{
+	/* select internal reference clock */
+	/* select the internal clock as clock source */
+
+    ICS->C1 =  ICS->C1 | (ICS_C1_IREFS_MASK);
+	ICS->C1 = (ICS->C1 & ~(ICS_C1_CLKS_MASK));   
+	
+	/* wait for the clock source to be changed */
+#if defined(IAR)        
+	asm(
+		"nop \n"
+		"nop \n"
+	);
+#elif defined(__MWERKS__)
+	asm{
+		nop 
+		nop
+        };        
+#endif     
+	while((ICS->S & ICS_S_CLKST_MASK));
+	while(!(ICS->S & ICS_S_IREFST_MASK));
+#if defined(CPU_KE02)	
+	/* now system clock source is internal clock
+	 * 
+	 */
+	if(((ICS->C2 & ICS_C2_BDIV_MASK)>>5) != 1)
+	{
+		ICS->C2 = (ICS->C2 & ~(ICS_C2_BDIV_MASK)) | ICS_C2_BDIV(1);
+	}
+#else
+        ICS->C2 = (ICS->C2 & ~(ICS_C2_BDIV_MASK)) | ICS_C2_BDIV(0);
+#endif	
+	/* clear Loss of lock sticky bit */
+	ICS->S |= ICS_S_LOLS_MASK;	
+        
+    /* Disable OSC to save power
+     */
+    OSC_Disable();
+}
+
+
+
+/*****************************************************************************//*!
+   *
+   * @brief change clock from FBE mode to FBELP mode. 
+   *
+   * @param  pConfig     pointer to configuration. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   * @see   ICS_ConfigType
+   *****************************************************************************/
+void FBE_to_FBELP(ICS_ConfigType *pConfig)
+{
+	/* enter low power mode */
+ 	ICS->C2 = ICS->C2 | (ICS_C2_LP_MASK); 
+}
+
+
+/*****************************************************************************//*!
+   *
+   * @brief change clock from FBELP mode to FBE mode. 
+   * 
+   * @param  pConfig     pointer to configuration. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   * @see   ICS_ConfigType
+   *****************************************************************************/
+void FBELP_to_FBE(ICS_ConfigType *pConfig)
+{
+	/* enter low power mode */
+ 	ICS->C2 = ICS->C2 & ~(ICS_C2_LP_MASK); 
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief change clock from FBILP mode to FBI mode. 
+   * 
+   * @param  pConfig     pointer to configuration. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   * @see   ICS_ConfigType
+   *****************************************************************************/
+void FBILP_to_FBI(ICS_ConfigType *pConfig)
+{
+	/* enter low power mode */
+	ICS->C2 = ICS->C2 & ~(ICS_C2_LP_MASK); 
+}
+
+/******************************************************************************
+* define ICS API list
+*
+*//*! @addtogroup ics_api_list
+* @{
+*******************************************************************************/
+
+
+/*****************************************************************************//*!
+   *
+   * @brief  trim internal clock (IRC). 
+   * 
+   * @param  u16TrimValue    trim value 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+
+void ICS_Trim(uint16_t u16TrimValue)
+{
+	ICS->C3 =  (uint8_t) u16TrimValue;
+   	ICS->C4 = (ICS->C4 & ~(ICS_C4_SCFTRIM_MASK)) | ((u16TrimValue>>8) & 0x01);
+   	while(!(ICS->S & ICS_S_LOCK_MASK));    
+}
+
+
+/*****************************************************************************//*!
+   *
+   * @brief set clock divider so that the reference clock for FLL/PLL is within 
+   *    spec.
+   *
+   * @param  u32ClkFreqKHz  reference clock frequency in KHz.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+
+void ICS_SetClkDivider(uint32_t u32ClkFreqKHz)
+{
+    
+    switch(u32ClkFreqKHz)
+    {
+        case 8000L:
+        case 10000L:
+            /* 8MHz or 10MHz */
+            ICS->C1 = (ICS->C1 & ~(ICS_C1_RDIV_MASK)) | ICS_C1_RDIV(3);	/* now the divided frequency is 8000/256 = 31.25K */
+                                                                        /* now the divided frequency is 10000/256 = 39.0625K */
+            break;
+        case 4000L:
+            /* 4MHz */
+            ICS->C1 = (ICS->C1 & ~(ICS_C1_RDIV_MASK)) | ICS_C1_RDIV(2);	/* now the divided frequency is 4000/128 = 31.25K */
+            break;
+        case 16000L:
+            /* 16MHz */
+            ICS->C1 = (ICS->C1 & ~(ICS_C1_RDIV_MASK)) | ICS_C1_RDIV(4);	/* now the divided frequency is 16000/512 = 31.25K */
+            break;
+        case 20000L:
+            /* 20MHz */
+            ICS->C1 = (ICS->C1 & ~(ICS_C1_RDIV_MASK)) | ICS_C1_RDIV(4);     /* now the divided frequency is 20000/512 = 39.0625K */
+            break;
+        case 32L:
+            /* 32KHz */
+            ICS->C1  &= ~(ICS_C1_RDIV_MASK);
+            break;
+        default:
+            break;
+    }
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief initialize ICS to the desired clock as defined in BUS_CLK_HZ.
+   * 
+   * @param  pConfig    pointer to ICS configuration.  
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   * @see   ICS_ConfigType
+   *****************************************************************************/
+
+void ICS_Init(ICS_ConfigType *pConfig)
+{
+  if(pConfig->u8ClkMode == ICS_CLK_MODE_FEE)
+  {    
+        pConfig->oscConfig.bIsCryst = 1;        /* is crystal */      
+        pConfig->oscConfig.bWaitInit = 1;        /* wait init complete */      
+        FEI_to_FEE(pConfig);                     /* switch to FEE mode with external crystal  */
+  }
+  else if (pConfig->u8ClkMode == ICS_CLK_MODE_FEE_OSC)
+  {     
+        pConfig->oscConfig.bIsCryst = 0;        /* is clock */      
+        FEI_to_FEE_OSC(pConfig);                /* switch to FEE mode with active oscillator input */
+  }
+  else if (pConfig->u8ClkMode == ICS_CLK_MODE_FBE_OSC)
+  {
+        pConfig->oscConfig.bIsCryst = 0;        /* is clock */            
+        FEI_to_FBE_OSC(pConfig);                /* switch to FBE mode with active oscillator input */
+  } 
+  else
+  {
+        /* FEI mode by default */
+        #if defined(CPU_KE02)
+        if(((ICS->C2 & ICS_C2_BDIV_MASK)>>5) != 1)
+        {
+            ICS->C2 = (ICS->C2 & ~(ICS_C2_BDIV_MASK)) | ICS_C2_BDIV(1);
+        }
+        #else
+            ICS->C2 = (ICS->C2 & ~(ICS_C2_BDIV_MASK)) | ICS_C2_BDIV(0);
+        #endif
+  }
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief initialize ICS to the default state.
+   * 
+   * @param  none      
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   * @see   ICS_Init
+   *****************************************************************************/
+
+void ICS_DeInit(void)
+{
+    ICS->C1 = ICS_C1_DEFAULT;
+    ICS->C2 = ICS_C2_DEFAULT;
+    ICS->C3 = ICS_C3_DEFAULT;
+    ICS->C4 = ICS_C4_DEFAULT;
+    while(ICS->S != ICS_S_DEFAULT)
+        ;       
+}
+
+/*! @} End of ics_api_list                                                    					*/
+
+
+/******************************************************************************
+* define OSC API list
+*
+*//*! @addtogroup osc_api_list
+* @{
+*******************************************************************************/
+
+/*****************************************************************************//*!
+   *
+   * @brief initialize XOSC with given parameters: GAIN, RANGE in control structure.
+   * 
+   * @param  pConfig    pointer to OSC configuration. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+void OSC_Init(OSC_ConfigType *pConfig)
+{
+	uint8   cr = 0;
+	/* 
+	 * 
+	 */
+	if(pConfig->bGain)
+	{
+		/* high gain */
+		cr |= OSC_CR_HGO_MASK ;		/* Rs must be added and be large up to 200K */
+	}
+	
+	if(pConfig->bRange)
+	{
+		cr |= OSC_CR_RANGE_MASK; /* high range */	
+	}
+
+	if(pConfig->bStopEnable)
+	{
+		cr |= OSC_CR_OSCSTEN_MASK; 
+	}
+
+	if(pConfig->bIsCryst)
+	{
+		cr |= OSC_CR_OSCOS_MASK;
+	}
+
+	if(pConfig->bEnable)
+	{
+		cr |= OSC_CR_OSCEN_MASK;
+	}
+    
+    OSC->CR = cr;
+    
+	if(pConfig->bWaitInit)
+	{
+
+		/* wait for OSC to be initialized
+		 * 
+		 */
+		while(!(OSC->CR & OSC_CR_OSCINIT_MASK));
+		
+	}
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief initialize OSC to the default state.
+   * 
+   * @param  none      
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   * @see   ICS_Init
+   *****************************************************************************/
+
+void OSC_DeInit(void)
+{
+    OSC->CR = OSC_CR_DEFAULT;
+}
+
+
+/*! @} End of osc_api_list                                                    					*/
+
+
+
+
diff --git a/bsp/frdm-ke02/device/lib/drivers/kbi.c b/bsp/frdm-ke02/device/lib/drivers/kbi.c
new file mode 100755
index 0000000..53fe61f
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/drivers/kbi.c
@@ -0,0 +1,324 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file kbi.c
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief providing APIs for configuring KBI. 
+*
+*******************************************************************************
+*
+* provide APIs for configuring KBI
+******************************************************************************/
+#include "common.h"
+#include "kbi.h"
+/******************************************************************************
+* External objects
+******************************************************************************/
+
+/******************************************************************************
+* Global variables
+******************************************************************************/
+KBI_CallbackType KBI_Callback[KBI_MAX_NO] = {(KBI_CallbackType)NULL};
+
+/******************************************************************************
+* Constants and macros
+******************************************************************************/
+
+/******************************************************************************
+* Local types
+******************************************************************************/
+
+/******************************************************************************
+* Local function prototypes
+******************************************************************************/
+
+/******************************************************************************
+* Local variables
+******************************************************************************/
+
+/******************************************************************************
+* Local functions
+******************************************************************************/
+/******************************************************************************
+* KBI api list
+*
+*//*! @addtogroup kbi_api_list
+* @{
+*******************************************************************************/
+
+
+/******************************************************************************
+* Global functions
+******************************************************************************/
+
+/*****************************************************************************//*!
+*
+* @brief initialize KBI module.
+*        
+* @param[in]  pKBI        pointer to KBI module.
+* @param[in]  pConfig     pointer to KBI configuration structure.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see KBI_DeInit.
+*
+*****************************************************************************/
+void KBI_Init(KBI_Type *pKBI, KBI_ConfigType *pConfig)
+{
+#if defined(CPU_KE02)
+    uint16_t    i;
+    uint8_t     sc = 0;
+    uint8_t     u8Port;
+    uint8_t     u8PinPos;
+    uint16_t    u16PinMapping[KBI_MAX_NO][8] = 
+    {
+        {
+            0, 1, 2, 3, 8, 9, 10, 11           /* KBI0 pins position in GPIOA register */
+        },
+        {
+            24, 25, 26, 27, 28, 29, 30, 31      /* KBI1 pins position in GPIOA register */
+        }
+    };
+#elif defined(CPU_KE04)
+    uint16_t    i;
+    uint8_t     sc = 0;
+    uint8_t     u8Port;
+    uint8_t     u8PinPos;
+    uint16_t    u16PinMapping[KBI_MAX_NO][8] = 
+    {
+        {
+            0, 1, 2, 3, 8, 9, 10, 11           /* KBI0 pins position in GPIOA register */
+        },
+        {
+            20, 21, 16, 17, 18, 19, 12, 13      /* KBI1 pins position in GPIOA register */
+        }
+    };
+#elif defined(CPU_KE06)
+     uint32_t    i;
+     uint32_t     sc = 0;
+     uint32_t     u8Port;
+     uint32_t     u8PinPos;
+
+     uint32_t    u16PinMapping[KBI_MAX_NO][KBI_MAX_PINS_PER_PORT] =
+    {
+        {/* KBI0P0~KBI0P31 pins position in GPIOA register */
+            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31           
+        },
+        {/* KBI1P0~KBI1P31 pins position in GPIOB register */
+			0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31		   
+        }
+    };
+#endif	 
+ 
+    
+    if(KBI0 == pKBI)
+    {
+        SIM->SCGC   |= SIM_SCGC_KBI0_MASK;             /* enable clock to KBI0 */\
+        u8Port      =  0;
+    }
+    else if (KBI1 == pKBI)
+    {        
+        SIM->SCGC   |= SIM_SCGC_KBI1_MASK;             /* enable clock to KBI1 */
+        u8Port      =  1;
+    }
+    
+    /* mask keyboard interrupts first */
+    sc          = pConfig->sBits.bMode;
+    pKBI->SC    = sc;
+
+    /* configure KBI pin polarity and others */
+    for (i = 0; i < KBI_MAX_PINS_PER_PORT; i++)
+    {
+        if(pConfig->sPin[i].bEn)
+        {
+            pKBI->PE    |= (1<<i);                      /* enable this KBI pin */
+            pKBI->ES    = (pKBI->ES & ~(1<<i)) | (pConfig->sPin[i].bEdge << i);     
+            u8PinPos = u16PinMapping[u8Port][i];
+            ASSERT(!(u8PinPos & 0x80));
+		#if defined(CPU_KE02)|| defined(CPU_KE04)	
+            FGPIOA->PIDR  &= ~(1<<u8PinPos);              /* enable GPIO input */     
+            FGPIOA->PDDR  &= ~(1<<u8PinPos);              /* configure pin as input */  
+            PORT->PUEL  |= (1<<u8PinPos);                 /* enable pullup for the pin */
+        #elif defined(CPU_KE06)
+		   if (u8Port == 0)   /* KBI0 */
+           {
+		   	FGPIOA->PIDR  &= ~(1<<u8PinPos);              /* enable GPIO input */    
+            FGPIOA->PDDR  &= ~(1<<u8PinPos);              /* configure pin as input */ 
+            PORT->PUE0  |= (1<<u8PinPos);                 /*enable pullup for the pin */
+           }
+		   else if (u8Port == 1)   /* KBI1 */
+           {
+		   	FGPIOB->PIDR  &= ~(1<<u8PinPos);              /* enable GPIO input */     
+            FGPIOB->PDDR  &= ~(1<<u8PinPos);              /* configure pin as input */ 
+            PORT->PUE1  |= (1<<u8PinPos);                 /*enable pullup for the pin */
+           }
+		#endif  
+		}
+    }
+    
+    #if defined(CPU_KE06)
+    /*Reset KBI_SP register*/
+	sc = pConfig->sBits.bRstKbsp<<KBI_SC_RSTKBSP_SHIFT;
+	pKBI->SC    |= sc;
+	
+    /*Real KBI_SP register enable*/
+	sc = pConfig->sBits.bKbspEn<<KBI_SC_KBSPEN_SHIFT;
+	pKBI->SC    |= sc;
+	#endif
+  
+	/* write to KBACK to clear any false interrupts */
+    pKBI->SC    = sc;
+    
+    /* enable interrupt if needed */
+    if(pConfig->sBits.bIntEn)
+    {
+        pKBI->SC    |=  KBI_SC_KBIE_MASK;
+        
+        if(KBI0 == pKBI)
+        {
+            NVIC_EnableIRQ(KBI0_IRQn);
+        }
+        else
+        {
+            NVIC_EnableIRQ(KBI1_IRQn);            
+        }
+    }
+}
+
+/*****************************************************************************//*!
+*
+* @brief set up KBI callback routine.
+*        
+* @param[in] pKBI          pointer to KBI module.
+* @param[in] pfnCallback   pointer to callback routine.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*****************************************************************************/
+void KBI_SetCallback(KBI_Type *pKBI, KBI_CallbackType pfnCallback)
+{
+    if(KBI0 == pKBI)
+    {
+        KBI_Callback[0] = pfnCallback;
+    }
+    else
+    {
+        KBI_Callback[1] = pfnCallback;        
+    }
+}
+
+/*****************************************************************************//*!
+*
+* @brief deinit the kbi module.
+*        
+* @param[in]  pKBI       pointer to KBI module.
+*         
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see KBI_Init.
+*
+*****************************************************************************/
+void KBI_DeInit(KBI_Type *pKBI)
+{
+    if(KBI0 == pKBI)
+    {
+        NVIC_DisableIRQ(KBI0_IRQn);
+    }
+    else
+    {
+        NVIC_DisableIRQ(KBI1_IRQn);        
+    }
+    
+    pKBI->PE = 0;
+    pKBI->SC = 0;
+    pKBI->ES = 0;
+    
+    if(KBI0 == pKBI)
+    {
+        SIM->SCGC   &= ~SIM_SCGC_KBI0_MASK;             /* disable clock to KBI0 */
+    }
+    else
+    {
+        SIM->SCGC   &= ~SIM_SCGC_KBI1_MASK;             /* disable clock to KBI1 */       
+    }
+}
+
+/*! @} End of acmp_api_list                                                  */
+
+/*****************************************************************************//*!
+*
+* @brief button group 0 (KBI0) interrupt service routine.
+*        
+* @param  none. 
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*****************************************************************************/
+
+void KBI0_Isr(void)	
+{
+  KBI0->SC |= KBI_SC_KBACK_MASK;                        /* clear interrupt flag */
+
+  if(KBI_Callback[0])
+  {
+      KBI_Callback[0]();
+  }
+}
+
+
+
+/*****************************************************************************//*!
+*
+* @brief button group 0 (KBI0) interrupt service routine.
+*        
+* @param  none. 
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*****************************************************************************/
+
+void KBI1_Isr(void)	
+{
+  KBI1->SC |= KBI_SC_KBACK_MASK;                        /* clear interrupt flag */
+ 
+  if(KBI_Callback[1])
+  {
+      KBI_Callback[1]();
+  }
+}
+
diff --git a/bsp/frdm-ke02/device/lib/drivers/memtest.c b/bsp/frdm-ke02/device/lib/drivers/memtest.c
new file mode 100755
index 0000000..b6a6af1
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/drivers/memtest.c
@@ -0,0 +1,239 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file memtest.c
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief provide general-purpose memory testing functions. 
+*
+*******************************************************************************/
+
+
+#include "memtest.h"
+
+
+/**********************************************************************
+ *
+ * Function:    memTestDataBus()
+ *
+ * Description: Test the data bus wiring in a memory region by
+ *              performing a walking 1's test at a fixed address
+ *              within that region.  The address (and hence the
+ *              memory region) is selected by the caller.
+ *
+ * Notes:       
+ *
+ * Returns:     0 if the test succeeds.  
+ *              A non-zero result is the first pattern that failed.
+ *
+ **********************************************************************/
+datum
+memTestDataBus(volatile datum * address)
+{
+    datum pattern;
+
+
+    /*
+     * Perform a walking 1's test at the given address.
+     */
+    for (pattern = 1; pattern != 0; pattern <<= 1)
+    {
+        /*
+         * Write the test pattern.
+         */
+        *address = pattern;
+
+        /*
+         * Read it back (immediately is okay for this test).
+         */
+        if (*address != pattern) 
+        {
+            return (pattern);
+        }
+    }
+
+    return (0);
+
+}   /* memTestDataBus() */
+
+
+/**********************************************************************
+ *
+ * Function:    memTestAddressBus()
+ *
+ * Description: Test the address bus wiring in a memory region by
+ *              performing a walking 1's test on the relevant bits
+ *              of the address and checking for aliasing. This test
+ *              will find single-bit address failures such as stuck
+ *              -high, stuck-low, and shorted pins.  The base address
+ *              and size of the region are selected by the caller.
+ *
+ * Notes:       For best results, the selected base address should
+ *              have enough LSB 0's to guarantee single address bit
+ *              changes.  For example, to test a 64-Kbyte region, 
+ *              select a base address on a 64-Kbyte boundary.  Also, 
+ *              select the region size as a power-of-two--if at all 
+ *              possible.
+ *
+ * Returns:     NULL if the test succeeds.  
+ *              A non-zero result is the first address at which an
+ *              aliasing problem was uncovered.  By examining the
+ *              contents of memory, it may be possible to gather
+ *              additional information about the problem.
+ *
+ **********************************************************************/
+datum * 
+memTestAddressBus(volatile datum * baseAddress, unsigned long nBytes)
+{
+    unsigned long addressMask = (nBytes/sizeof(datum) - 1);
+    unsigned long offset;
+    unsigned long testOffset;
+
+    datum pattern     = (datum) 0xAAAAAAAA;
+    datum antipattern = (datum) 0x55555555;
+
+
+    /*
+     * Write the default pattern at each of the power-of-two offsets.
+     */
+    for (offset = 1; (offset & addressMask) != 0; offset <<= 1)
+    {
+        baseAddress[offset] = pattern;
+    }
+
+    /* 
+     * Check for address bits stuck high.
+     */
+    testOffset = 0;
+    baseAddress[testOffset] = antipattern;
+
+    for (offset = 1; (offset & addressMask) != 0; offset <<= 1)
+    {
+        if (baseAddress[offset] != pattern)
+        {
+            return ((datum *) &baseAddress[offset]);
+        }
+    }
+
+    baseAddress[testOffset] = pattern;
+
+    /*
+     * Check for address bits stuck low or shorted.
+     */
+    for (testOffset = 1; (testOffset & addressMask) != 0; testOffset <<= 1)
+    {
+        baseAddress[testOffset] = antipattern;
+
+		if (baseAddress[0] != pattern)
+		{
+			return ((datum *) &baseAddress[testOffset]);
+		}
+
+        for (offset = 1; (offset & addressMask) != 0; offset <<= 1)
+        {
+            if ((baseAddress[offset] != pattern) && (offset != testOffset))
+            {
+                return ((datum *) &baseAddress[testOffset]);
+            }
+        }
+
+        baseAddress[testOffset] = pattern;
+    }
+
+    return (NULL);
+
+}   /* memTestAddressBus() */
+
+
+/**********************************************************************
+ *
+ * Function:    memTestDevice()
+ *
+ * Description: Test the integrity of a physical memory device by
+ *              performing an increment/decrement test over the
+ *              entire region.  In the process every storage bit 
+ *              in the device is tested as a zero and a one.  The
+ *              base address and the size of the region are
+ *              selected by the caller.
+ *
+ * Notes:       
+ *
+ * Returns:     NULL if the test succeeds.
+ *
+ *              A non-zero result is the first address at which an
+ *              incorrect value was read back.  By examining the
+ *              contents of memory, it may be possible to gather
+ *              additional information about the problem.
+ *
+ **********************************************************************/
+datum * 
+memTestDevice(volatile datum * baseAddress, unsigned long nBytes)	
+{
+    unsigned long offset;
+    unsigned long nWords = nBytes / sizeof(datum);
+
+    datum pattern;
+    datum antipattern;
+
+
+    /*
+     * Fill memory with a known pattern.
+     */
+    for (pattern = 1, offset = 0; offset < nWords; pattern++, offset++)
+    {
+        baseAddress[offset] = pattern;
+    }
+
+    /*
+     * Check each location and invert it for the second pass.
+     */
+    for (pattern = 1, offset = 0; offset < nWords; pattern++, offset++)
+    {
+        if (baseAddress[offset] != pattern)
+        {
+            return ((datum *) &baseAddress[offset]);
+        }
+
+        antipattern = ~pattern;
+        baseAddress[offset] = antipattern;
+    }
+
+    /*
+     * Check each location for the inverted pattern and zero it.
+     */
+    for (pattern = 1, offset = 0; offset < nWords; pattern++, offset++)
+    {
+        antipattern = ~pattern;
+        if (baseAddress[offset] != antipattern)
+        {
+            return ((datum *) &baseAddress[offset]);
+        }
+    }
+
+    return (NULL);
+
+}   /* memTestDevice() */
diff --git a/bsp/frdm-ke02/device/lib/drivers/pit.c b/bsp/frdm-ke02/device/lib/drivers/pit.c
new file mode 100755
index 0000000..926e1fb
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/drivers/pit.c
@@ -0,0 +1,242 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file     pit.c
+*
+* @author   Freescale
+*
+* @version  0.0.1
+*
+* @date     Jun 25, 2013
+*
+* @brief    Periodic Interrupt Timer (PIT) source code. 
+*
+******************************************************************************/
+#include "common.h"
+#include "pit.h"
+
+/******************************************************************************
+* Global variables
+******************************************************************************/
+
+/******************************************************************************
+* Constants and macros
+******************************************************************************/
+
+/******************************************************************************
+* Local types
+******************************************************************************/
+
+/******************************************************************************
+* Local function prototypes
+******************************************************************************/
+
+/******************************************************************************
+* Local variables
+******************************************************************************/
+/*!
+ * @brief global variable to store PIT callbacks.
+ *
+ */
+PIT_CallbackType PIT_Callback[2] = {(PIT_CallbackType)NULL}; /*!< PIT initial callback */
+
+/******************************************************************************
+* Local functions
+******************************************************************************/
+void PIT_Ch0Isr(void);
+void PIT_Ch1Isr(void);
+
+
+/******************************************************************************
+* Global functions
+******************************************************************************/
+
+/******************************************************************************
+* define PIT APIs
+*
+*//*! @addtogroup pit_api_list
+* @{
+*******************************************************************************/
+
+/*****************************************************************************//*!
+*
+* @brief initialize pit module.
+*        
+* @param[in]   u8Channel_No channel number
+* @param[in]   pConfig point to configuration  
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+void PIT_Init(uint8_t u8Channel_No, PIT_ConfigType *pConfig)
+{  
+    SIM->SCGC |= SIM_SCGC_PIT_MASK;     /*!< enable clock to PIT */
+    
+    if (pConfig->bFreeze)            
+    {                                               
+        PIT_SetDebugFreeze();            
+    } 
+    
+    if (pConfig->bModuleDis == 0) 
+    {                                              
+        PIT_Enable();       /*!< enable pit module */                                                                                
+    }  
+    
+    PIT_SetLoadVal(u8Channel_No, pConfig->u32LoadValue);  
+    
+    if (pConfig->bInterruptEn)            
+    {                                   
+        if (u8Channel_No)
+        {        
+             NVIC_EnableIRQ(PIT_CH1_IRQn);             
+        }
+        else
+        {                  
+            NVIC_EnableIRQ(PIT_CH0_IRQn);
+        }
+        PIT_ChannelEnableInt(u8Channel_No);
+    }                   
+    else                                     
+    {                     
+        NVIC_DisableIRQ(PIT_CH0_IRQn);       
+    }
+
+    if (pConfig->bChainMode)            
+    {                                               
+        PIT_ChannelEnableChain(u8Channel_No);            
+    }
+    
+    if (pConfig->bTimerEn)            
+    {                                               
+        PIT_ChannelEnable(u8Channel_No);            
+    }             
+
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief initialize pit module.
+*        
+* @param[in]   u8Channel_No channel number
+* @param[in]   u32loadvalue load value for pit register  
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+void PIT_SetLoadVal(uint8_t u8Channel, uint32_t u32loadvalue)
+
+{
+    PIT->CHANNEL[u8Channel].LDVAL = u32loadvalue;   
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief pit module set call back.
+*        
+* @param[in] u8Channel_No channel number.   
+* @param[in] pfnCallback point to call back.   
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+void PIT_SetCallback(uint8_t u8Channel_No, PIT_CallbackType pfnCallback)
+{
+  PIT_Callback[u8Channel_No] = pfnCallback;
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief pit module de-initialize, reset pit register
+*        
+* @param none  
+*
+* @return none 
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+void PIT_DeInit(void)
+{
+    NVIC_DisableIRQ(PIT_CH0_IRQn);
+    NVIC_DisableIRQ(PIT_CH1_IRQn);    
+    PIT_SetLoadVal(0,0);
+    PIT_SetLoadVal(1,0);
+    PIT_ChannelDisable(0);
+    PIT_ChannelDisable(1);
+    PIT_ChannelDisableInt(0);
+    PIT_ChannelDisableInt(1);
+    PIT_ChannelDisableChain(0);
+    PIT_ChannelDisableChain(1);    
+    PIT_ChannelClrFlags(0);
+    PIT_ChannelClrFlags(1);    
+    PIT_SetDebugOn();
+    PIT_Disable();
+    SIM->SCGC &= ~SIM_SCGC_PIT_MASK;
+}
+/*! @} End of pit_api_list                                                   */
+
+
+/*****************************************************************************//*!
+*
+* @brief pit module channel 0 isr.
+*        
+* @param none
+*
+* @return none 
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+void PIT_Ch0Isr(void) 
+{   
+   PIT_ChannelClrFlags(0);  
+    
+    if (PIT_Callback[0])
+    {    
+        PIT_Callback[0]();     
+    }
+}
+    
+/*****************************************************************************//*!
+*
+* @brief pit module channel 1 isr.
+*        
+* @param none
+*
+* @return none 
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+void PIT_Ch1Isr(void) 
+{   
+    PIT_ChannelClrFlags(1);
+    if (PIT_Callback[1])
+    {    
+        PIT_Callback[1]();     
+    }
+}    
+
+
diff --git a/bsp/frdm-ke02/device/lib/drivers/pmc.c b/bsp/frdm-ke02/device/lib/drivers/pmc.c
new file mode 100755
index 0000000..b99313a
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/drivers/pmc.c
@@ -0,0 +1,142 @@
+
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file pmc.c
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief providing APIs for configuring PMC. 
+*
+*******************************************************************************
+*
+* provide APIs for configuring PMC
+******************************************************************************/
+#include "common.h"
+#include "pmc.h"
+
+/******************************************************************************
+* Constants
+******************************************************************************/
+/******************************************************************************
+* Macros
+******************************************************************************/
+/******************************************************************************
+* Types
+******************************************************************************/
+/******************************************************************************
+* Global variables
+******************************************************************************/
+/******************************************************************************
+* Global functions
+******************************************************************************/
+
+/******************************************************************************
+* PMC api list.
+*
+*//*! @addtogroup pmc_api_list
+* @{
+*******************************************************************************/
+/*****************************************************************************//*!
+*
+* @brief  configure PMC with given parameters.
+* 
+* @param[in]   pPMC_Config       PMC configuration structure.
+* @param[in]   pPMC             pointer to the PMC module.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see PMC_DeInit.
+*
+*****************************************************************************/
+void PMC_Init(PMC_Type *pPMC, PMC_ConfigType *pPMC_Config)
+{
+    pPMC->SPMSC1 = pPMC_Config->sCtrlstatus.byte;
+    pPMC->SPMSC2 = pPMC_Config->sDetectVoltSelect.byte;         
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief  config the pmc register to the default mode.
+* 
+* @param[in]  pPMC              pointer to the PMC module.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see PMC_Init.
+*
+*****************************************************************************/
+void PMC_DeInit(PMC_Type *pPMC)
+{
+    pPMC->SPMSC1 = 0x1C;
+    pPMC->SPMSC2 = 0;         
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief  config the pmc mode among run, wait and stop modes.
+* 
+* @param[in]  u8PmcMode         PMC mode select.
+* @param[in]  pPMC              pointer to the PMC module.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*****************************************************************************/
+void PMC_SetMode(PMC_Type *pPMC,uint8_t u8PmcMode)
+{
+    switch(u8PmcMode & 0x3) 
+    {
+        case PmcModeRun:    
+            break;
+        case PmcModeWait:
+            wait();
+            break;
+        case PmcModeStop4:
+            /* enable LVD in stop mode */
+            pPMC->SPMSC1 |= (PMC_SPMSC1_LVDE_MASK | PMC_SPMSC1_LVDSE_MASK);	
+            stop();   
+            break;
+        case PmcModeStop3: 
+            /* disable LVD in stop mode */
+            pPMC->SPMSC1 &= ~(PMC_SPMSC1_LVDE_MASK | PMC_SPMSC1_LVDRE_MASK | PMC_SPMSC1_LVDSE_MASK);	
+            stop();  
+            break;
+        default: 
+            break;
+    }
+ 
+}
+
+/*! @} End of pmc_api_list                                                    */
+
diff --git a/bsp/frdm-ke02/device/lib/drivers/printf.c b/bsp/frdm-ke02/device/lib/drivers/printf.c
new file mode 100755
index 0000000..659cd74
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/drivers/printf.c
@@ -0,0 +1,652 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file printk.c
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief provide the standard C library routine printf(), but without all the baggage. 
+*
+*******************************************************************************/
+
+#include "common.h"
+#include <stdarg.h>
+
+/********************************************************************/
+
+typedef struct
+{
+    int dest;
+    void (*func)(char);
+    char *loc;
+} PRINTK_INFO;
+
+int 
+printk (PRINTK_INFO *, const char *, va_list);
+
+/********************************************************************/
+
+#define DEST_CONSOLE    (1)
+#define DEST_STRING     (2)
+
+#define FLAGS_MINUS     (0x01)
+#define FLAGS_PLUS      (0x02)
+#define FLAGS_SPACE     (0x04)
+#define FLAGS_ZERO      (0x08)
+#define FLAGS_POUND     (0x10)
+
+#define IS_FLAG_MINUS(a)    (a & FLAGS_MINUS)
+#define IS_FLAG_PLUS(a)     (a & FLAGS_PLUS)
+#define IS_FLAG_SPACE(a)    (a & FLAGS_SPACE)
+#define IS_FLAG_ZERO(a)     (a & FLAGS_ZERO)
+#define IS_FLAG_POUND(a)    (a & FLAGS_POUND)
+
+#define LENMOD_h        (0x01)
+#define LENMOD_l        (0x02)
+#define LENMOD_L        (0x04)
+
+#define IS_LENMOD_h(a)  (a & LENMOD_h)
+#define IS_LENMOD_l(a)  (a & LENMOD_l)
+#define IS_LENMOD_L(a)  (a & LENMOD_L)
+
+#define FMT_d   (0x0001)
+#define FMT_o   (0x0002)
+#define FMT_x   (0x0004)
+#define FMT_X   (0x0008)
+#define FMT_u   (0x0010)
+#define FMT_c   (0x0020)
+#define FMT_s   (0x0040)
+#define FMT_p   (0x0080)
+#define FMT_n   (0x0100)
+
+#define IS_FMT_d(a)     (a & FMT_d)
+#define IS_FMT_o(a)     (a & FMT_o)
+#define IS_FMT_x(a)     (a & FMT_x)
+#define IS_FMT_X(a)     (a & FMT_X)
+#define IS_FMT_u(a)     (a & FMT_u)
+#define IS_FMT_c(a)     (a & FMT_c)
+#define IS_FMT_s(a)     (a & FMT_s)
+#define IS_FMT_p(a)     (a & FMT_p)
+#define IS_FMT_n(a)     (a & FMT_n)
+
+/********************************************************************/
+static void
+printk_putc (int c, int *count, PRINTK_INFO *info)
+{
+    switch (info->dest)
+    {
+        case DEST_CONSOLE:
+            info->func((char)c);
+            break;
+        case DEST_STRING:
+            *(info->loc) = (unsigned char)c;
+            ++(info->loc);
+            break;
+        default:
+            break;
+    }
+    *count += 1;
+}
+
+/********************************************************************/
+static int
+printk_mknumstr (char *numstr, void *nump, int neg, int radix)
+{
+    int a,b,c;
+    unsigned int ua,ub,uc;
+
+    int nlen;
+    char *nstrp;
+
+    nlen = 0;
+    nstrp = numstr;
+    *nstrp++ = '\0';
+
+    if (neg)
+    {
+        a = *(int *)nump;
+        if (a == 0)
+        {
+            *nstrp = '0';
+            ++nlen;
+            goto done;
+        }
+        while (a != 0)
+        {
+            b = (int)a / (int)radix;
+            c = (int)a - ((int)b * (int)radix);
+            if (c < 0)
+            {
+                c = ~c + 1 + '0';
+            }
+            else
+            {
+                c = c + '0';
+            }
+            a = b;
+            *nstrp++ = (char)c;
+            ++nlen;
+        }
+    }
+    else
+    {
+        ua = *(unsigned int *)nump;
+        if (ua == 0)
+        {
+            *nstrp = '0';
+            ++nlen;
+            goto done;
+        }
+        while (ua != 0)
+        {
+            ub = (unsigned int)ua / (unsigned int)radix;
+            uc = (unsigned int)ua - ((unsigned int)ub * (unsigned int)radix);
+            if (uc < 10)
+            {
+                uc = uc + '0';
+            }
+            else
+            {
+                uc = uc - 10 + 'A';
+            }
+            ua = ub;
+            *nstrp++ = (char)uc;
+            ++nlen;
+        }
+    }
+    done:
+    return nlen;
+}
+
+/********************************************************************/
+static void
+printk_pad_zero (int curlen, int field_width, int *count, PRINTK_INFO *info)
+{
+    int i;
+
+    for (i = curlen; i < field_width; i++)
+    {
+        printk_putc('0',count, info);
+    }
+}
+
+/********************************************************************/
+static void
+printk_pad_space (int curlen, int field_width, int *count, PRINTK_INFO *info)
+{
+    int i;
+
+    for (i = curlen; i < field_width; i++)
+    {
+        printk_putc(' ',count, info);
+    }
+}
+
+/********************************************************************/
+int
+printk (PRINTK_INFO *info, const char *fmt, va_list ap)
+{
+    /* va_list ap; */
+    char *p;
+    int c;
+
+    char vstr[33];
+    char *vstrp;
+    int vlen;
+
+    int done;
+    int count = 0;
+
+    int flags_used;
+    int field_width;
+#if 0
+    int precision_used;
+    int precision_width;
+    int length_modifier;
+#endif
+
+    int ival;
+    int schar, dschar;
+    int *ivalp;
+    char *sval;
+    int cval;
+    unsigned int uval;
+
+    /*
+     * Start parsing apart the format string and display appropriate
+     * formats and data.
+     */
+    for (p = (char *)fmt; (c = *p) != 0; p++)
+    {
+        /*
+         * All formats begin with a '%' marker.  Special chars like
+         * '\n' or '\t' are normally converted to the appropriate
+         * character by the __compiler__.  Thus, no need for this
+         * routine to account for the '\' character.
+         */
+        if (c != '%')
+        {
+            /*
+             * This needs to be replaced with something like
+             * 'out_char()' or call an OS routine.
+             */
+#ifndef UNIX_DEBUG
+            if (c != '\n')
+            {
+                printk_putc(c, &count, info);
+            }
+            else
+            {
+                printk_putc(0x0D /* CR */, &count, info);
+                printk_putc(0x0A /* LF */, &count, info);
+            }
+#else
+            printk_putc(c, &count, info);
+#endif
+
+            /*
+             * By using 'continue', the next iteration of the loop
+             * is used, skipping the code that follows.
+             */
+            continue;
+        }
+
+        /*
+         * First check for specification modifier flags.
+         */
+        flags_used = 0;
+        done = FALSE;
+        while (!done)
+        {
+            switch (/* c = */ *++p)
+            {
+                case '-':
+                    flags_used |= FLAGS_MINUS;
+                    break;
+                case '+':
+                    flags_used |= FLAGS_PLUS;
+                    break;
+                case ' ':
+                    flags_used |= FLAGS_SPACE;
+                    break;
+                case '0':
+                    flags_used |= FLAGS_ZERO;
+                    break;
+                case '#':
+                    flags_used |= FLAGS_POUND;
+                    break;
+                default:
+                    /* we've gone one char too far */
+                    --p;
+                    done = TRUE;
+                    break;
+            }
+        }
+
+        /*
+         * Next check for minimum field width.
+         */
+        field_width = 0;
+        done = FALSE;
+        while (!done)
+        {
+            switch (c = *++p)
+            {
+                case '0':
+                case '1':
+                case '2':
+                case '3':
+                case '4':
+                case '5':
+                case '6':
+                case '7':
+                case '8':
+                case '9':
+                    field_width = (field_width * 10) + (c - '0');
+                    break;
+                default:
+                    /* we've gone one char too far */
+                    --p;
+                    done = TRUE;
+                    break;
+            }
+        }
+
+        /*
+         * Next check for the width and precision field separator.
+         */
+        if (/* (c = *++p) */ *++p == '.')
+        {
+            /* precision_used = TRUE; */
+
+            /*
+             * Must get precision field width, if present.
+             */
+            /* precision_width = 0; */
+            done = FALSE;
+            while (!done)
+            {
+                switch (/* c = uncomment if used below */ *++p)
+                {
+                    case '0':
+                    case '1':
+                    case '2':
+                    case '3':
+                    case '4':
+                    case '5':
+                    case '6':
+                    case '7':
+                    case '8':
+                    case '9':
+#if 0
+                        precision_width = (precision_width * 10) +
+                            (c - '0');
+#endif
+                        break;
+                    default:
+                        /* we've gone one char too far */
+                        --p;
+                        done = TRUE;
+                        break;
+                }
+            }
+        }
+        else
+        {
+            /* we've gone one char too far */
+            --p;
+#if 0
+            precision_used = FALSE;
+            precision_width = 0;
+#endif
+        }
+
+        /*
+         * Check for the length modifier.
+         */
+        /* length_modifier = 0; */
+        switch (/* c = */ *++p)
+        {
+            case 'h':
+                /* length_modifier |= LENMOD_h; */
+                break;
+            case 'l':
+                /* length_modifier |= LENMOD_l; */
+                break;
+            case 'L':
+                /* length_modifier |= LENMOD_L; */
+                break;
+            default:
+                /* we've gone one char too far */
+                --p;
+                break;
+        }
+
+        /*
+         * Now we're ready to examine the format.
+         */
+        switch (c = *++p)
+        {
+            case 'd':
+            case 'i':
+                ival = (int)va_arg(ap, int);
+                vlen = printk_mknumstr(vstr,&ival,TRUE,10);
+                vstrp = &vstr[vlen];
+
+                if (ival < 0)
+                {
+                    schar = '-';
+                    ++vlen;
+                }
+                else
+                {
+                    if (IS_FLAG_PLUS(flags_used))
+                    {
+                        schar = '+';
+                        ++vlen;
+                    }
+                    else
+                    {
+                        if (IS_FLAG_SPACE(flags_used))
+                        {
+                            schar = ' ';
+                            ++vlen;
+                        }
+                        else
+                        {
+                            schar = 0;
+                        }
+                    }
+                }
+                dschar = FALSE;
+            
+                /*
+                 * do the ZERO pad.
+                 */
+                if (IS_FLAG_ZERO(flags_used))
+                {
+                    if (schar)
+                        printk_putc(schar, &count, info);
+                    dschar = TRUE;
+            
+                    printk_pad_zero (vlen, field_width, &count, info);
+                    vlen = field_width;
+                }
+                else
+                {
+                    if (!IS_FLAG_MINUS(flags_used))
+                    {
+                        printk_pad_space (vlen, field_width, &count, info);
+            
+                        if (schar)
+                            printk_putc(schar, &count, info);
+                        dschar = TRUE;
+                    }
+                }
+            
+                /* the string was built in reverse order, now display in */
+                /* correct order */
+                if (!dschar && schar)
+                {
+                    printk_putc(schar, &count, info);
+                }
+                goto cont_xd;
+
+            case 'x':
+            case 'X':
+                uval = (unsigned int)va_arg(ap, unsigned int);
+                vlen = printk_mknumstr(vstr,&uval,FALSE,16);
+                vstrp = &vstr[vlen];
+
+                dschar = FALSE;
+                if (IS_FLAG_ZERO(flags_used))
+                {
+                    if (IS_FLAG_POUND(flags_used))
+                    {
+                        printk_putc('0', &count, info);
+                        printk_putc('x', &count, info);
+                        /*vlen += 2;*/
+                        dschar = TRUE;
+                    }
+                    printk_pad_zero (vlen, field_width, &count, info);
+                    vlen = field_width;
+                }
+                else
+                {
+                    if (!IS_FLAG_MINUS(flags_used))
+                    {
+                        if (IS_FLAG_POUND(flags_used))
+                        {
+                            vlen += 2;
+                        }
+                        printk_pad_space (vlen, field_width, &count, info);
+                        if (IS_FLAG_POUND(flags_used))
+                        {
+                            printk_putc('0', &count, info);
+                            printk_putc('x', &count, info);
+                            dschar = TRUE;
+                        }
+                    }
+                }
+
+                if ((IS_FLAG_POUND(flags_used)) && !dschar)
+                {
+                    printk_putc('0', &count, info);
+                    printk_putc('x', &count, info);
+                    vlen += 2;
+                }
+                goto cont_xd;
+
+            case 'o':
+                uval = (unsigned int)va_arg(ap, unsigned int);
+                vlen = printk_mknumstr(vstr,&uval,FALSE,8);
+                goto cont_u;
+            case 'b':
+                uval = (unsigned int)va_arg(ap, unsigned int);
+                vlen = printk_mknumstr(vstr,&uval,FALSE,2);
+                goto cont_u;
+            case 'p':
+                uval = (unsigned int)va_arg(ap, void *);
+                vlen = printk_mknumstr(vstr,&uval,FALSE,16);
+                goto cont_u;
+            case 'u':
+                uval = (unsigned int)va_arg(ap, unsigned int);
+                vlen = printk_mknumstr(vstr,&uval,FALSE,10);
+
+                cont_u:
+                    vstrp = &vstr[vlen];
+
+                    if (IS_FLAG_ZERO(flags_used))
+                    {
+                        printk_pad_zero (vlen, field_width, &count, info);
+                        vlen = field_width;
+                    }
+                    else
+                    {
+                        if (!IS_FLAG_MINUS(flags_used))
+                        {
+                            printk_pad_space (vlen, field_width, &count, info);
+                        }
+                    }
+
+                cont_xd:
+                    while (*vstrp)
+                        printk_putc(*vstrp--, &count, info);
+
+                    if (IS_FLAG_MINUS(flags_used))
+                    {
+                        printk_pad_space (vlen, field_width, &count, info);
+                    }
+                break;
+
+            case 'c':
+                cval = (char)va_arg(ap, unsigned int);
+                printk_putc(cval,&count, info);
+                break;
+            case 's':
+                sval = (char *)va_arg(ap, char *);
+                if (sval)
+                {
+                    vlen = strlen(sval);
+                    if (!IS_FLAG_MINUS(flags_used))
+                    {
+                        printk_pad_space (vlen, field_width, &count, info);
+                    }
+                    while (*sval)
+                        printk_putc(*sval++,&count, info);
+                    if (IS_FLAG_MINUS(flags_used))
+                    {
+                        printk_pad_space (vlen, field_width, &count, info);
+                    }
+                }
+                break;
+            case 'n':
+                ivalp = (int *)va_arg(ap, int *);
+                *ivalp = count;
+                break;
+            default:
+                printk_putc(c,&count, info);
+                break;
+        }
+    }
+    return count;
+}
+#if 1
+/********************************************************************/
+int
+printf (const char *fmt, ...)
+{
+    va_list ap;
+    int rvalue;
+    PRINTK_INFO info;
+
+
+    info.dest = DEST_CONSOLE;
+    info.func = &out_char;
+    /*
+     * Initialize the pointer to the variable length argument list.
+     */
+    va_start(ap, fmt);
+    rvalue = printk(&info, fmt, ap);
+    /*
+     * Cleanup the variable length argument list.
+     */
+    va_end(ap);
+    return rvalue;
+}
+
+/********************************************************************/
+int
+sprintf (char *s, const char *fmt, ...)
+{
+    va_list ap;
+    int rvalue = 0;
+    PRINTK_INFO info;
+
+    /*
+     * Initialize the pointer to the variable length argument list.
+     */
+    if (s != 0)
+    {
+        info.dest = DEST_STRING;
+        info.loc = s;
+        va_start(ap, fmt);
+        rvalue = printk(&info, fmt, ap);
+        *info.loc = '\0';
+        va_end(ap);
+    }
+    return rvalue;
+}
+#endif
+#if defined(__GNUC__)
+int  puts(const char * s)
+{
+	printf(s);
+	return 0;
+}
+#endif
+
+/********************************************************************/
diff --git a/bsp/frdm-ke02/device/lib/drivers/queue.c b/bsp/frdm-ke02/device/lib/drivers/queue.c
new file mode 100755
index 0000000..5c1de4a
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/drivers/queue.c
@@ -0,0 +1,151 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file queue.c
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief Implement a first in, first out linked list. 
+*
+*******************************************************************************/
+
+#include "common.h"
+#include "queue.h"
+
+/********************************************************************/
+/* 
+ * Initialize the specified queue to an empty state
+ * 
+ * Parameters:
+ *  q   Pointer to queue structure
+ */
+void
+queue_init(QUEUE *q)
+{
+    q->head = NULL;
+}
+/********************************************************************/
+/* 
+ * Check for an empty queue
+ *
+ * Parameters:
+ *  q       Pointer to queue structure
+ * 
+ * Return Value:
+ *  1 if Queue is empty
+ *  0 otherwise
+ */
+int
+queue_isempty(QUEUE *q)
+{
+    return (q->head == NULL);
+}
+/********************************************************************/
+/* 
+ * Add an item to the end of the queue 
+ *
+ * Parameters:
+ *  q       Pointer to queue structure
+ *  node    New node to add to the queue
+ */
+void
+queue_add(QUEUE *q, QNODE *node)
+{
+    if (queue_isempty(q))
+    {
+        q->head = q->tail = node;
+    }
+    else
+    {
+        q->tail->next = node;
+        q->tail = node;
+    }
+    
+    node->next = NULL;
+}
+
+/********************************************************************/
+/* 
+ * Remove and return first (oldest) entry from the specified queue 
+ *
+ * Parameters:
+ *  q       Pointer to queue structure
+ *
+ * Return Value:
+ *  Node at head of queue - NULL if queue is empty
+ */
+QNODE*
+queue_remove(QUEUE *q)
+{
+    QNODE *oldest;
+    
+    if (queue_isempty(q))
+        return NULL;
+    
+    oldest = q->head;
+    q->head = oldest->next;
+    return oldest;
+}
+/********************************************************************/
+/* 
+ * Peek into the queue and return pointer to first (oldest) entry.
+ * The queue is not modified
+ *
+ * Parameters:
+ *  q       Pointer to queue structure
+ *
+ * Return Value:
+ *  Node at head of queue - NULL if queue is empty
+ */
+QNODE*
+queue_peek(QUEUE *q)
+{
+    return q->head;
+}
+/********************************************************************/
+/* 
+ * Move entire contents of one queue to the other
+ *
+ * Parameters:
+ *  src     Pointer to source queue
+ *  dst     Pointer to destination queue
+ */
+void
+queue_move(QUEUE *dst, QUEUE *src)
+{
+    if (queue_isempty(src))
+        return;
+    
+    if (queue_isempty(dst))
+        dst->head = src->head;
+    else
+        dst->tail->next = src->head;
+
+    dst->tail = src->tail;
+    src->head = NULL;
+    return;
+}
+/********************************************************************/
diff --git a/bsp/frdm-ke02/device/lib/drivers/rtc.c b/bsp/frdm-ke02/device/lib/drivers/rtc.c
new file mode 100755
index 0000000..001fcde
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/drivers/rtc.c
@@ -0,0 +1,194 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file     rtc.c
+*
+* @author   Freescale
+*
+* @version  0.0.1
+*
+* @date     Jun 25, 2013
+*
+* @brief    Real-time counter (RTC) driver source code.  
+*
+******************************************************************************/
+#include "common.h"
+#include "rtc.h"
+
+/******************************************************************************
+* Global variables
+******************************************************************************/
+
+/******************************************************************************
+* Constants and macros
+******************************************************************************/
+
+/******************************************************************************
+* Local types
+******************************************************************************/
+
+/******************************************************************************
+* Local function prototypes
+******************************************************************************/
+
+/******************************************************************************
+* Local variables
+******************************************************************************/
+/*!
+ * @brief global variable to store RTC callbacks.
+ *
+ */
+RTC_CallbackType RTC_Callback[1] = {(RTC_CallbackType)NULL};    /*!< RTC initial callback */
+
+/******************************************************************************
+* Local functions
+******************************************************************************/
+void RTC_Isr(void);
+
+/******************************************************************************
+* Global functions
+******************************************************************************/
+
+/******************************************************************************
+* define RTC APIs
+*
+*//*! @addtogroup rtc_api_list
+* @{
+*******************************************************************************/
+
+/*****************************************************************************//*!
+*
+* @brief inital RTC module
+*        
+* @param[in] pConfig point to configuration  
+*
+* @return none 
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+void RTC_Init(RTC_ConfigType *pConfig)
+{
+    uint16_t    u16Clocksource, u16Prescler;
+    uint16_t    u16ModVal;
+    
+    u16Clocksource =0;  
+    u16Prescler    =0;
+    u16ModVal      =0;
+
+    SIM->SCGC     |= SIM_SCGC_RTC_MASK; 
+    
+    u16ModVal      = pConfig->u16ModuloValue;
+    RTC_SetModulo(u16ModVal); 
+    
+    if (pConfig->bRTCOut)
+    {
+    
+        RTC->SC= RTC_SC_RTCO_MASK;       
+    } 
+    
+    if (pConfig->bInterruptEn)
+    {
+         NVIC_EnableIRQ(RTC_IRQn);
+         RTC_EnableInt(); 
+    }
+    else      
+    {   
+        NVIC_DisableIRQ(RTC_IRQn);
+    }
+    
+    if (pConfig->bFlag)
+    {   
+        RTC_ClrFlags();         
+    }
+
+    u16Clocksource = pConfig->bClockSource; 
+    u16Prescler    = pConfig->bClockPresaler;
+     
+    RTC_SetClock(u16Clocksource,u16Prescler );
+}
+
+
+
+/*****************************************************************************//*!
+*
+* @brief set call back function for rtc module 
+*        
+* @param[in] pfnCallback point to call back function
+*
+* @return none 
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+void RTC_SetCallback(RTC_CallbackType pfnCallback)
+{
+  RTC_Callback[0] = pfnCallback;
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief de-initialize rtc module , reset rtc register
+*        
+* @param none  
+*
+* @return none 
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+void RTC_DeInit(void)
+{
+    NVIC_DisableIRQ(RTC_IRQn);    
+    RTC->MOD = 0;
+    while(RTC->MOD);
+    
+    if(RTC_GetFlags())
+    {
+        RTC_ClrFlags();
+    }
+    
+    RTC->SC = 0;
+    while(RTC->SC);
+    SIM->SCGC &= ~SIM_SCGC_RTC_MASK;
+}
+
+/*! @} End of rtc_api_list                                                   */
+
+/*****************************************************************************//*!
+*
+* @brief RTC module interrupt service routine
+*        
+* @param none  
+*
+* @return none 
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+void RTC_Isr(void) 
+{
+    RTC_ClrFlags();	       
+    if (RTC_Callback[0])
+    {    
+        RTC_Callback[0]();     
+    }
+}
+
+
diff --git a/bsp/frdm-ke02/device/lib/drivers/sim.c b/bsp/frdm-ke02/device/lib/drivers/sim.c
new file mode 100755
index 0000000..bd77404
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/drivers/sim.c
@@ -0,0 +1,376 @@
+
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file sim.c
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief providing APIs for system integration module (SIM). 
+*
+*******************************************************************************
+*
+* provide APIs for SIM
+******************************************************************************/
+#include "common.h"
+#include "sim.h"
+
+/******************************************************************************
+* Global variables
+******************************************************************************/
+
+/******************************************************************************
+* Constants and macros
+******************************************************************************/
+
+/******************************************************************************
+* Local types
+******************************************************************************/
+
+/******************************************************************************
+* Local function prototypes
+******************************************************************************/
+
+/******************************************************************************
+* Local variables
+******************************************************************************/
+
+/******************************************************************************
+* Local functions
+******************************************************************************/
+
+/******************************************************************************
+* Global functions
+******************************************************************************/
+
+/******************************************************************************
+* define SIM API list
+*
+*//*! @addtogroup sim_api_list
+* @{
+*******************************************************************************/
+#if defined(CPU_KE02)
+/*****************************************************************************//*!
+   *
+   * @brief initialize SIM registers.
+   * 
+   * @param[in]  pConfig    pointer to SIM configuration.  
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   * @see SIM_ConfigType
+   *****************************************************************************/
+void SIM_Init(SIM_ConfigType *pConfig)
+{
+    uint32_t    u32Sopt;
+    uint32_t    u32PinSel;
+    uint32_t    u32Scgc;
+    uint32_t    u32BusDiv;
+    /*
+     * intialize the registers to reset default values
+     */
+    u32Sopt     = 0x0E;                 /* enable SWD, RESET, and NMI pins */
+    u32PinSel   = 0;
+    u32Scgc     = 0x00003000;           /* enable SWD and FLASH */
+    u32BusDiv   = 0;
+    u32BusDiv = pConfig->sBits.bBusDiv;
+    if(pConfig->sBits.bDisableNMI)
+    {
+        u32Sopt &= ~SIM_SOPT_NMIE_MASK;        
+    }
+    if(pConfig->sBits.bDisableRESET)
+    {
+        u32Sopt &= ~SIM_SOPT_RSTPE_MASK;        
+    }   
+    if(pConfig->sBits.bDisableSWD)
+    {
+        u32Sopt &= ~SIM_SOPT_SWDE_MASK;        
+    } 
+    if(pConfig->sBits.bEnableCLKOUT)
+    {
+        u32Sopt |= SIM_SOPT_CLKOE_MASK;        
+    } 
+    if(pConfig->sBits.bFTMSYNC)
+    {
+        u32Sopt |= SIM_SOPT_FTMSYNC_MASK;        
+    }  
+    if(pConfig->sBits.bRXDCE)
+    {
+        u32Sopt |= SIM_SOPT_RXDCE_MASK;        
+    }
+    if(pConfig->sBits.bTXDME)
+    {
+        u32Sopt |= SIM_SOPT_TXDME_MASK;        
+    }
+    if(pConfig->sBits.bACIC)
+    {
+        u32Sopt |= SIM_SOPT_ACIC_MASK;
+    }
+        if(pConfig->sBits.bRTCC)
+    {
+        u32Sopt |= SIM_SOPT_RTCC_MASK;        
+    }
+        if(pConfig->sBits.bRXDFE)
+    {
+        u32Sopt |= SIM_SOPT_RXDFE_MASK;        
+    }
+    u32Sopt |= ((pConfig->u8BusRef & 0x07) << 16);        
+    u32Sopt |= ((pConfig->u8Delay) << 24);        
+    u32Sopt |= ((pConfig->sBits.u8ADHWT & 0x03) << 8);
+    u32PinSel = pConfig->u32PinSel;
+    u32Scgc = pConfig->u32SCGC;   
+    
+/* write SIM registers */
+    SIM->SOPT = u32Sopt;
+    SIM->PINSEL = u32PinSel;
+    SIM->SCGC = u32Scgc; 
+    SIM->BUSDIV = u32BusDiv;
+}
+#elif defined(CPU_KE04)
+/*****************************************************************************//*!
+   *
+   * @brief initialize SIM registers.
+   * 
+   * @param[in]  pConfig    pointer to SIM configuration.  
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   * @see SIM_ConfigType
+   *****************************************************************************/
+
+void SIM_Init(SIM_ConfigType *pConfig)
+{
+    uint32_t    u32Sopt;
+    uint32_t    u32PinSel;
+    uint32_t    u32Scgc;
+    uint32_t    u32ClockDiv;
+    /*
+     * intialize the registers to reset default values
+     */
+    u32Sopt     = 0x0E;                 /* enable SWD, RESET, and NMI pins */
+    u32PinSel   = 0;
+    u32Scgc     = 0x00003000;           /* enable SWD and FLASH */
+    u32ClockDiv = 0;
+    u32ClockDiv = pConfig->u32CLKDIV;
+    if(pConfig->sBits.bDisableNMI)
+    {
+        u32Sopt &= ~SIM_SOPT_NMIE_MASK;        
+    }
+    if(pConfig->sBits.bDisableRESET)
+    {
+        u32Sopt &= ~SIM_SOPT_RSTPE_MASK;        
+    }   
+    if(pConfig->sBits.bDisableSWD)
+    {
+        u32Sopt &= ~SIM_SOPT_SWDE_MASK;        
+    } 
+    if(pConfig->sBits.bEnableCLKOUT)
+    {
+        u32Sopt |= SIM_SOPT_CLKOE_MASK;        
+    } 
+    if(pConfig->sBits.bFTMSYNC)
+    {
+        u32Sopt |= SIM_SOPT_FTMSYNC_MASK;        
+    }  
+    if(pConfig->sBits.bRXDCE)
+    {
+        u32Sopt |= SIM_SOPT_RXDCE_MASK;        
+    }
+    if(pConfig->sBits.bTXDME)
+    {
+        u32Sopt |= SIM_SOPT_TXDME_MASK;        
+    }
+    if(pConfig->sBits.bACTRG)
+    {
+        u32Sopt |= SIM_SOPT_ACTRG_MASK;
+    }
+    u32Sopt |= ((pConfig->u8BusRef & 0x07) << 16);        
+    u32Sopt |= ((pConfig->u8Delay) << 24);        
+    u32Sopt |= ((pConfig->sBits.u8ADHWT & 0x07) << 20);
+    u32Sopt |= ((pConfig->sBits.bRXDFE)&0x03<<8);
+    u32Sopt |= ((pConfig->sBits.bFTMIC)&0x03<<6);
+
+    u32PinSel = pConfig->u32PinSel;
+    u32Scgc = pConfig->u32SCGC;    
+/* write SIM registers */
+    SIM->SOPT = u32Sopt;
+    SIM->PINSEL = u32PinSel;
+    SIM->SCGC = u32Scgc;
+    SIM->CLKDIV = u32ClockDiv;
+}
+#elif defined(CPU_KE06)
+/*****************************************************************************//*!
+   *
+   * @brief initialize SIM registers.
+   * 
+   * @param[in]  pConfig    pointer to SIM configuration.  
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   * @see SIM_ConfigType
+   *****************************************************************************/
+void SIM_Init(SIM_ConfigType *pConfig)
+{
+    uint32_t    u32Sopt;
+    uint32_t    u32PinSel;
+    uint32_t    u32Scgc;
+    uint32_t    u32ClockDiv;
+    /*
+     * intialize the registers to reset default values
+     */
+    u32Sopt     = 0x0E;                 /* enable SWD, RESET, and NMI pins */
+    u32PinSel   = 0;
+    u32Scgc     = 0x00003000;           /* enable SWD and FLASH */
+    u32ClockDiv = 0;
+    u32ClockDiv = pConfig->u32CLKDIV;
+    if(pConfig->sBits.bDisableNMI)
+    {
+        u32Sopt &= ~SIM_SOPT0_NMIE_MASK;        
+    }
+    if(pConfig->sBits.bDisableRESET)
+    {
+        u32Sopt &= ~SIM_SOPT0_RSTPE_MASK;        
+    }   
+    if(pConfig->sBits.bDisableSWD)
+    {
+        u32Sopt &= ~SIM_SOPT0_SWDE_MASK;        
+    } 
+    if(pConfig->sBits.bEnableCLKOUT)
+    {
+        u32Sopt |= SIM_SOPT0_CLKOE_MASK;        
+    } 
+    if(pConfig->sBits.bFTMSYNC)
+    {
+        u32Sopt |= SIM_SOPT0_FTMSYNC_MASK;        
+    }  
+    if(pConfig->sBits.bRXDCE)
+    {
+        u32Sopt |= SIM_SOPT0_RXDCE_MASK;        
+    }
+    if(pConfig->sBits.bTXDME)
+    {
+        u32Sopt |= SIM_SOPT0_TXDME_MASK;        
+    }
+    if(pConfig->sBits.bACTRG)
+    {
+        u32Sopt |= SIM_SOPT0_ACTRG_MASK;
+    }
+    u32Sopt |= ((pConfig->u8BusRef & 0x07) << 16);        
+    u32Sopt |= ((pConfig->u8Delay) << 24);        
+    u32Sopt |= ((pConfig->sBits.u8ADHWT & 0x07) << 20);
+    u32Sopt |= ((pConfig->sBits.bRXDFE)&0x03<<8);
+    //u32Sopt |= ((pConfig->sBits.bFTMIC)&0x03<<6);
+
+    u32PinSel = pConfig->u32PinSel;
+    u32Scgc = pConfig->u32SCGC;    
+/* write SIM registers */
+    SIM->SOPT0 = u32Sopt;
+    SIM->PINSEL = u32PinSel;
+    SIM->SCGC = u32Scgc;
+    SIM->CLKDIV = u32ClockDiv;
+}
+#endif
+
+/*****************************************************************************//*!
+   *
+   * @brief set SIM clock gating registers to enable or disable peripheral clocks.
+   * 
+   * @param[in]  u32PeripheralMask    peripherial bits mask.  
+   * @param[in]  u8GateOn             1: ON, 0: OFF.  
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+
+void SIM_SetClockGating(uint32_t u32PeripheralMask, uint8_t u8GateOn)
+{
+    uint32_t    u32Scgc;
+
+    /*
+     * save original clock gating value
+     */
+    u32Scgc     = SIM->SCGC;
+    
+    if(u8GateOn)
+    {
+        u32Scgc |= u32PeripheralMask;
+    }
+    else
+    {
+        u32Scgc &= ~u32PeripheralMask;        
+    }
+
+    SIM->SCGC = u32Scgc;
+}
+
+
+/*****************************************************************************//*!
+   *
+   * @brief read the corresponding status flags.
+   * 
+   * @param[in]  u32StatusMask    indicates which status to be read. 
+   *
+   * @return status.
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+uint32_t SIM_GetStatus(uint32_t u32StatusMask)
+{
+    uint32_t    u32Status;
+
+    u32Status = SIM->SRSID & u32StatusMask;
+    return (u32Status);
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief read the corresponding ID.
+   * 
+   * @param[in]  u8ID    type of ID. 
+   *
+   * @return ID
+   *
+   * @ Pass/ Fail criteria: none.
+   * @see   IDType.
+   *****************************************************************************/
+uint8_t SIM_ReadID(IDType sID)
+{
+    uint32_t    u32ID;
+    uint8_t u8IDOffset[4] = 
+    { 
+        28, 24, 20,16
+    };  
+    u32ID = (SIM->SRSID >> u8IDOffset[sID]) & 0x0F;
+    return (u32ID);
+}
+/*! @} End of sim_api_list                                                    */
+
+
+
diff --git a/bsp/frdm-ke02/device/lib/drivers/spi.c b/bsp/frdm-ke02/device/lib/drivers/spi.c
new file mode 100755
index 0000000..352211d
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/drivers/spi.c
@@ -0,0 +1,356 @@
+
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file spi.c
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief providing APIs for configuring SPI module (SPI). 
+*
+*******************************************************************************
+*
+* provide APIs for configuring SPI module (SPI).
+******************************************************************************/
+#include "common.h"
+#include "spi.h"
+
+
+/******************************************************************************
+* Local variables
+******************************************************************************/
+
+SPI_CallbackType SPI_Callback[MAX_SPI_NO] = {(SPI_CallbackType)NULL};
+
+
+/******************************************************************************
+* Local function prototypes
+******************************************************************************/
+
+/******************************************************************************
+* Local functions
+*****************************************************************************/
+
+/******************************************************************************
+* Global functions
+******************************************************************************/
+
+/******************************************************************************
+* define SPI APIs
+*
+*//*! @addtogroup spi_api_list
+* @{
+*******************************************************************************/
+/*****************************************************************************//*!
+   *
+   * @brief initialize SPI as per params.
+   *        
+   * @param[in]  pSPI   point to SPI module type.
+   * @param[in]  pConfig point to configuration parameters.
+   *
+   * @return none.
+   *
+   * @ Pass/ Fail criteria: none.
+   *****************************************************************************/
+void SPI_Init(SPI_Type *pSPI, SPI_ConfigType *pConfig)
+{
+#if defined(CPU_KE04)  
+     /* sanity check */
+    ASSERT((pSPI == SPI0));
+    SIM->SCGC |= SIM_SCGC_SPI0_MASK;
+#else
+    /* sanity check */
+    ASSERT((pSPI == SPI0) ||  (pSPI == SPI1));
+    
+    /* enable SPI clock gating on */
+    if( pSPI == SPI0)
+    {
+        SIM->SCGC |= SIM_SCGC_SPI0_MASK;
+    }
+    else
+    {
+        SIM->SCGC |= SIM_SCGC_SPI1_MASK;     
+    }
+#endif
+    /* configure other control bits */
+    if( pConfig->sSettings.bIntEn)
+    {
+        SPI_IntEnable(pSPI);
+#if defined(CPU_KE04)  
+        NVIC_EnableIRQ(SPI0_IRQn);  
+#else
+        if( pSPI == SPI0 )
+        {
+			NVIC_EnableIRQ(SPI0_IRQn);
+        }
+        else
+        {
+			NVIC_EnableIRQ(SPI1_IRQn);
+        }
+#endif
+    }
+
+    if( pConfig->sSettings.bTxIntEn)
+    {
+        SPI_TxIntEnable(pSPI);
+#if defined(CPU_KE04)  
+        NVIC_EnableIRQ(SPI0_IRQn);  
+#else
+        if( pSPI == SPI0 )
+        {
+			NVIC_EnableIRQ(SPI0_IRQn);
+        }
+        else
+        {
+			NVIC_EnableIRQ(SPI1_IRQn);
+        }
+#endif
+    }
+    if( pConfig->sSettings.bMasterMode)
+    {
+        SPI_SetMasterMode(pSPI);
+    }
+    else
+    {
+		SPI_SetSlaveMode(pSPI);
+    }
+
+    if( pConfig->sSettings.bClkPolarityLow)
+    {
+    	SPI_SetClockPol(pSPI,1);
+    }
+    if( pConfig->sSettings.bClkPhase1)
+    {
+        SPI_SetClockPhase(pSPI,1);
+    }
+      
+    if( pConfig->sSettings.bShiftLSBFirst)
+    {
+        SPI_SetLSBFirst(pSPI);
+    }
+    if( pConfig->sSettings.bMatchIntEn)
+    {
+        SPI_MatchIntEnable(pSPI);
+    }
+    if( pConfig->sSettings.bModeFaultEn)
+    {
+        SPI_ModfEnable(pSPI);
+    }
+    if( pConfig->sSettings.bMasterAutoDriveSS)
+    {
+        /* set both SSOE and MODFEN bits when auto drive slave SS is enabled */
+        SPI_SSOutputEnable(pSPI);
+        SPI_ModfEnable(pSPI);
+    }    
+ 
+    if( pConfig->sSettings.bPinAsOuput)
+    {
+        SPI_BidirPinEnable(pSPI);
+    }
+
+    if( pConfig->sSettings.bBidirectionModeEn)
+    {
+        SPI_BidirOutEnable(pSPI);
+    }
+    if( pConfig->sSettings.bStopInWaitMode)
+    {
+        SPI_ClockStopEnable(pSPI);
+    }
+    
+    if(pConfig->sSettings.bMasterMode)
+    {
+        SPI_SetBaudRate(pSPI,pConfig->u32BusClkHz,pConfig->u32BitRate);
+    }
+
+	/* enable SPI module */
+    if( pConfig->sSettings.bModuleEn)
+    {
+        SPI_Enable(pSPI);
+    }
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief SPI set band rate.
+   *        
+   * @param[in]  pSPI   point to SPI module type.
+   * @param[in]  u32BusClock   Bus clock.
+   * @param[in]  u32Bps   set spi's baudrate.
+   *
+   * @return  none.
+   *
+   * @ Pass/ Fail criteria: none.
+   *****************************************************************************/
+void SPI_SetBaudRate(SPI_Type *pSPI,uint32_t u32BusClock,uint32_t u32Bps)
+{
+	uint32_t u32BitRateDivisor;
+	uint8_t u8Sppr;
+	uint8_t u8Spr;
+    uint8_t u8ReadFlag;
+	u32BitRateDivisor = u32BusClock/u32Bps; /* calculate bit rate divisor */
+       
+    u8ReadFlag = 0;
+    /* find best fit SPPR and SPR */
+    for (u8Spr = 0; u8Spr <= 8; u8Spr++)
+    {
+        for(u8Sppr = 0; u8Sppr <= 7; u8Sppr++)
+        {
+            if((u32BitRateDivisor>>(u8Spr+1))<=(u8Sppr+1))
+            {
+                u8ReadFlag = 1;
+                break;
+            }
+        }
+        if(u8ReadFlag)
+        {
+            break;
+        }
+    }
+    if(u8Sppr >=8)
+    {
+        u8Sppr = 7;
+    }
+    if(u8Spr >8)
+    {
+        u8Spr = 8;
+    }
+    /* set bit rate */
+    pSPI->BR = SPI_BR_SPPR(u8Sppr) | SPI_BR_SPR(u8Spr);
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief implement write data to SPI.
+   *        
+   * @param[in]   pSPI  pointer to SPI module type.
+   * @param[in]   pWrBuff -- write data buffer pointer. 
+   * @param[in]   uiLength -- read/write data length.
+   * @param[out]   pRdBuff -- read data buffer pointer. 
+   * 
+   * @return  if <0, means error, 0: success.
+   *
+   * @ Pass/ Fail criteria: none.
+   *****************************************************************************/
+ResultType SPI_TransferWait(SPI_Type *pSPI, SPI_WidthType* pRdBuff, SPI_WidthType *pWrBuff,uint32 uiLength)
+{
+    ResultType err = SPI_ERR_SUCCESS;
+    uint32_t  i;
+    
+    if(!uiLength)
+    {
+        return (err);
+    }
+    for(i = 0; i < uiLength; i++)
+    {
+        while(!SPI_IsSPTEF(pSPI));
+        SPI_WriteDataReg(pSPI,pWrBuff[i]);
+        while(!SPI_IsSPRF(pSPI));
+        pRdBuff[i] = SPI_ReadDataReg(pSPI);
+    }
+    return (err);        
+}
+
+
+
+/*****************************************************************************//*!
+   *
+   * @brief Deinitialize SPI to the default state (reset value).
+   *        
+   * @param[in]   pSPI  pointer to SPI module type.
+   *         
+   * @return none.
+   *
+   * @ Pass/ Fail criteria: none.
+   *****************************************************************************/
+void SPI_DeInit(SPI_Type *pSPI)
+{  
+    int16 i;
+    pSPI->C1 = SPI_C1_DEFAULT;
+    pSPI->C2 = SPI_C2_DEFAULT;
+    pSPI->BR = SPI_BR_DEFAULT;
+    pSPI->M  = SPI_M_DEFAULT;
+    for(i = 0; i<100; i++);                 /* wait for some cycles for the ISR exit */
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief  set up SPI callback routines to be called by interrupt service routine.
+   *        
+   * @param[in]   pSPI  pointer to SPI module type.
+   * @param[in]  pfnCallback  callback routine. 
+   *  
+   * @return none.
+   *
+   * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+void SPI_SetCallback(SPI_Type *pSPI,SPI_CallbackType pfnCallback)
+{
+    uint32_t    u32Port = ((uint32_t)pSPI-(uint32_t)SPI0)>>12;
+    ASSERT(u32Port <2);
+    SPI_Callback[u32Port] = pfnCallback;
+}
+
+/*! @} End of spi_api_list                                               						*/
+
+
+/*****************************************************************************//*!
+   *
+   * @brief SPI0 interrupt service routine.
+   *        
+   * @param   none.
+   * @return  none.
+   *
+   * @ Pass/ Fail criteria: none.
+   *****************************************************************************/
+
+void SPI0_Isr(void)
+{
+    if( SPI_Callback[0] )
+    {
+		SPI_Callback[0]();
+    }
+}
+#ifndef CPU_KE04
+/*****************************************************************************//*!
+   *
+   * @brief SPI1 interrupt service routine.
+   *        
+   * @param   none.
+   * @return  none.
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+
+void SPI1_Isr(void)
+{
+    if( SPI_Callback[1] )
+    {
+		SPI_Callback[1]();
+    }
+}
+#endif
+
+
diff --git a/bsp/frdm-ke02/device/lib/drivers/start.c b/bsp/frdm-ke02/device/lib/drivers/start.c
new file mode 100755
index 0000000..ccb4293
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/drivers/start.c
@@ -0,0 +1,125 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file start.c
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief provide high-level startup routines for KExx.
+*
+*******************************************************************************/
+
+#include "start.h"
+#include "common.h"
+#include "wdog.h"
+#include "sysinit.h"
+
+void start(void);
+void SystemInit( void );
+/********************************************************************/
+/*!
+ * \brief   Kinetis Start
+ * \return  None
+ *
+ * This function calls all of the needed starup routines and then 
+ * branches to the main process.
+ */
+void start(void)
+{ 
+
+	/* Disable the watchdog timer but enable update */
+    WDOG_DisableWDOGEnableUpdate();    
+    
+#ifndef __GNUC__ 
+#ifndef KEIL
+	/* Copy any vector or data sections that need to be in RAM */
+	common_startup();
+#endif
+#endif
+
+	/* Jump to main process */
+	main();
+
+	/* No actions to perform after this so wait forever */
+	while(1);
+}
+/********************************************************************/
+/*!
+ * \brief   Kinetis Identify
+ * \return  None
+ *
+ * This is primarly a reporting function that displays information
+ * about the specific CPU to the default terminal including:
+ * - Kinetis family
+ * - package
+ * - die revision
+ * - P-flash size
+ * - Ram size
+ */
+void cpu_identify (void)
+{
+
+}
+/********************************************************************/
+/*!
+ * \brief   flash Identify
+ * \return  None
+ *
+ * This is primarly a reporting function that displays information
+ * about the specific flash parameters and flash version ID for 
+ * the current device. These parameters are obtained using a special
+ * flash command call "read resource." The first four bytes returned
+ * are the flash parameter revision, and the second four bytes are
+ * the flash version ID.
+ */
+void flash_identify (void)
+{
+    /* Get the flash parameter version */
+}
+/********************************************************************/
+/********************************************************************/
+/*!
+ * \brief   flash SystemInit
+ * \return  None
+ *
+ * this is a system initialization function which dediu16Cated in Keil 
+ * others complier don't use it.
+ * it is similar to start function
+ */
+void SystemInit( void )
+{
+#if !defined(ENABLE_WDOG)   
+	/* Disable the watchdog timer */
+    WDOG_Disable();
+#else
+	/* Disable the watchdog timer but enable update */
+    WDOG_DisableWDOGEnableUpdate();    
+#endif
+	sysinit();
+}
+
+
+
diff --git a/bsp/frdm-ke02/device/lib/drivers/startup.c b/bsp/frdm-ke02/device/lib/drivers/startup.c
new file mode 100755
index 0000000..ae216c5
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/drivers/startup.c
@@ -0,0 +1,105 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file startup.c
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief Implement generic Kinetis startup code. 
+*
+*******************************************************************************/
+
+#include "common.h"
+
+#pragma section = ".data"
+#pragma section = ".data_init"
+#pragma section = ".bss"
+#pragma section = "CodeRelocate"
+#pragma section = "CodeRelocateRam" 
+
+/********************************************************************/
+void
+common_startup(void)
+{
+//    extern char __DATA_ROM[];
+//    extern char __DATA_RAM[];
+//    extern char __DATA_END[];
+  #if 0
+    /* Declare a counter we'll use in all of the copy loops */
+    uint32 n;
+ 
+ 
+    /* Addresses for VECTOR_TABLE and VECTOR_RAM come from the linker file */  
+    extern uint32 __VECTOR_TABLE[];
+    extern uint32 __VECTOR_RAM[];
+
+    /* Copy the vector table to RAM */
+    if (__VECTOR_RAM != __VECTOR_TABLE)
+    {
+        for (n = 0; n < 48 ; n++)     //  for small memory space, excluding flash configuration field
+          
+            __VECTOR_RAM[n] = __VECTOR_TABLE[n];
+    }
+    /* Point the VTOR to the new copy of the vector table */
+    write_vtor((uint32)__VECTOR_RAM);    
+
+    /* Get the addresses for the .data section (initialized data section) */
+    uint8* data_ram = __section_begin(".data");
+    uint8* data_rom = __section_begin(".data_init");
+    uint8* data_rom_end = __section_end(".data_init");
+    
+    /* Copy initialized data from ROM to RAM */
+    n = data_rom_end - data_rom;
+    while (n--)
+      *data_ram++ = *data_rom++;
+ 
+ 
+    /* Get the addresses for the .bss section (zero-initialized data) */
+    uint8* bss_start = __section_begin(".bss");
+    uint8* bss_end = __section_end(".bss");
+    
+    /* Clear the zero-initialized data section */
+    n = bss_end - bss_start;
+    while(n--)
+      *bss_start++ = 0;    
+    
+    /* Get addresses for any code sections that need to be copied from ROM to RAM.
+     * The IAR tools have a predefined keyword that can be used to mark individual
+     * functions for execution from RAM. Add "__ramfunc" before the return type in
+     * the function prototype for any routines you need to execute from RAM instead 
+     * of ROM. ex: __ramfunc void foo(void);
+     */
+    uint8* code_relocate_ram = __section_begin("CodeRelocateRam");
+    uint8* code_relocate = __section_begin("CodeRelocate");
+    uint8* code_relocate_end = __section_end("CodeRelocate");
+    
+    /* Copy functions from ROM to RAM */
+    n = code_relocate_end - code_relocate;
+    while (n--)
+      *code_relocate_ram++ = *code_relocate++;
+#endif
+}
+/********************************************************************/
diff --git a/bsp/frdm-ke02/device/lib/drivers/sysinit.c b/bsp/frdm-ke02/device/lib/drivers/sysinit.c
new file mode 100755
index 0000000..50badd7
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/drivers/sysinit.c
@@ -0,0 +1,289 @@
+/*****************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file sysinit.c
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief provide system init routine/configuration for KExx.
+*
+*******************************************************************************/
+
+#include "common.h"
+#include "sysinit.h"
+#include "sim.h"
+#include "uart.h"
+#include "ics.h"
+
+/********************************************************************/
+
+uint16_t global_pass_count = 0;
+uint16_t global_fail_count = 0;
+
+
+void print_sys_log(void);
+void UART_InitPrint(void);
+
+/*****************************************************************************//*!
++FUNCTION----------------------------------------------------------------
+* @function name: sysinit
+*
+* @brief  initalize system including SIM, ICS, UART, etc
+*        
+* @param  none 
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+void sysinit (void)
+{
+    SIM_ConfigType  sSIMConfig = {{0},0};
+    ICS_ConfigType  sICSConfig = {0};
+    
+    /* initialize the Pass/Fail counts to 0 */
+    global_pass_count = 0;
+    global_fail_count = 0; 
+
+#if defined(TRIM_IRC)    
+    /* if not trimmed, do trim first */
+    ICS_Trim(ICS_TRIM_VALUE);
+#endif  
+    BLUE_Init();
+	BLUE_Clear();
+    /* 
+     * Enable SWD pin, RESET pin 
+     */
+    /* 
+     * NOTE: please make sure other register bits are also write-once and
+     * need add other bit mask here if needed.
+     */
+#if defined(SPI0_PINREMAP)        
+    sSIMConfig.u32PinSel |= SIM_PINSEL_SPI0PS_MASK;
+#endif
+
+#if defined(OUTPUT_BUSCLK)
+    sSIMConfig.sBits.bEnableCLKOUT = 1;      /* output bus clock if enabled */
+#endif
+    
+#if defined(DISABLE_NMI)
+    sSIMConfig.sBits.bDisableNMI = 1;
+#endif
+    
+    #if !defined(CPU_KE04) 
+    /* make sure clocks to peripheral modules are enabled */
+    sSIMConfig.u32SCGC |= SIM_SCGC_SWD_MASK | SIM_SCGC_FLASH_MASK |
+                         SIM_SCGC_UART0_MASK | SIM_SCGC_UART1_MASK | 
+                         SIM_SCGC_UART2_MASK
+                         ;
+    #else
+    sSIMConfig.u32SCGC |= SIM_SCGC_SWD_MASK | SIM_SCGC_FLASH_MASK |
+                         SIM_SCGC_UART0_MASK 
+                         ;
+    #endif
+    
+    #if !defined(CPU_KE02)
+    /* bus clock divided by 2 */
+    sSIMConfig.u32CLKDIV |= SIM_CLKDIV_OUTDIV2_MASK;                           
+    #endif
+      
+    SIM_Init(&sSIMConfig);                   /* initialize SIM */
+        
+#if defined(XOSC_STOP_ENABLE)   
+    sICSConfig.oscConfig.bStopEnable = 1;    /*  enabled in stop mode */   
+#endif          
+    
+#if defined(CRYST_HIGH_GAIN)    
+    sICSConfig.oscConfig.bGain = 1;           /* high gain */      
+#endif
+
+    
+#if  (EXT_CLK_FREQ_KHZ >=4000)
+    sICSConfig.oscConfig.bRange = 1;           /* high range */
+#endif
+	
+    sICSConfig.oscConfig.bEnable = 1;          /* enable OSC */
+    sICSConfig.u32ClkFreq = EXT_CLK_FREQ_KHZ;
+    
+#if     defined(USE_FEE)    
+    sICSConfig.u8ClkMode = ICS_CLK_MODE_FEE;    
+#elif	defined(USE_FBE_OSC)
+    sICSConfig.u8ClkMode = ICS_CLK_MODE_FBE_OSC;    
+#elif	defined(USE_FEE_OSC)   
+    sICSConfig.u8ClkMode = ICS_CLK_MODE_FEE_OSC;      
+#endif      
+
+    ICS_Init(&sICSConfig);   /* initialize ICS */
+
+    /* initialize UART for printing */
+  //  UART_InitPrint();                        
+
+#if	defined(PRINT_SYS_LOG)
+    print_sys_log();
+#endif
+    
+ }
+
+/*****************************************************************************//*!
++FUNCTION----------------------------------------------------------------
+* @function name: print_sys_log
+*
+* @brief  print system reset sources
+*        
+* @param  none 
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+void print_sys_log(void) 
+{
+    uint8_t u8Rst = 0;
+    uint8_t u8FamID,u8SubFamID,u8RevID,u8PinID;
+    uint32_t u32Status;
+    
+    u32Status = SIM_GetStatus(0xFF);        /* get all status bits */
+    
+    /* get all IDs */
+    u8FamID = SIM_ReadID(ID_TYPE_FAMID);    
+    u8SubFamID = SIM_ReadID(ID_TYPE_SUBFAMID);    
+    u8RevID = SIM_ReadID(ID_TYPE_REVID);    
+    u8PinID = SIM_ReadID(ID_TYPE_PINID);    
+   
+    printf("\n\n--System Log BEGINS--\n\n");
+    printf("\n Familly ID = 0x%x, Sub-family ID = 0x%x, Revision ID = 0x%x, Pin ID = 0x%x \n",
+            u8FamID, u8SubFamID, u8RevID, u8PinID);
+
+    if((u32Status & SIM_SRSID_POR_MASK) && (u32Status & SIM_SRSID_LVD_MASK)) 
+    {
+      u8Rst = 1;
+      printf(" Power On Reset\n");
+    }
+    
+    if(!(u32Status & SIM_SRSID_POR_MASK) && (u32Status & SIM_SRSID_LVD_MASK)) 
+    {
+      u8Rst = 1;
+      printf(" LVD Reset\n");
+    }
+    
+    if(u32Status & SIM_SRSID_WDOG_MASK)                 
+    {
+      u8Rst = 1;
+      printf(" WDOG Reset\n");
+    }
+    
+    
+    if(u32Status & SIM_SRSID_PIN_MASK)
+    {
+      u8Rst = 1;
+      printf(" Pin Reset\n");
+    }
+    if(u32Status & SIM_SRSID_LOC_MASK)
+    {
+      u8Rst = 1;
+      printf(" Loss of Clock Reset\n");
+    }    
+    if(u32Status & SIM_SRSID_SACKERR_MASK)
+    {
+      u8Rst = 1;
+      printf(" Stop Mode Acknowledge Error Reset\n");
+    }    
+    if(u32Status & SIM_SRSID_MDMAP_MASK)
+    {
+      u8Rst = 1;
+      printf(" MDM-AP System Reset Request\n");
+    }    
+    if(u32Status & SIM_SRSID_SW_MASK)
+    {
+      u8Rst = 1;
+      printf(" Software/SYSRESETREQ Reset\n");
+    }    
+    if(u32Status & SIM_SRSID_LOCKUP_MASK)
+    {
+      u8Rst = 1;
+      printf(" Core lockup Reset\n");
+    }    
+
+    if(u8Rst != 1)
+    {
+      printf("SWD Reset\n");
+    }
+    
+    printf("\n--System Log ENDS--\n\n");
+  }
+
+
+/*****************************************************************************//*!
++FUNCTION----------------------------------------------------------------
+* @function name: end_test
+*
+* @brief  print test result (pass/fail counts) after end of test
+*        
+* @param  none 
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+
+void end_test(void)
+{
+
+  if(global_fail_count==0){
+    printf("\n global_pass_count = 0x%02x%02x",(uint8)(global_pass_count>>8),(uint8)global_pass_count);
+    printf("\n\n TEST PASSED");       
+  } else{
+    printf("\n global_pass_count = 0x%02x%02x",(uint8)(global_pass_count>>8),(uint8)global_pass_count);
+    printf("\n global_fail_count = 0x%02x%02x",(uint8)(global_fail_count>>8),(uint8)global_fail_count);
+    printf("\n\n TEST FAILED");
+  }
+  
+  printf("\n\n TEST FINISHED");  
+  
+}
+
+/*****************************************************************************//*!
++FUNCTION----------------------------------------------------------------
+* @function name: UART_InitPrint
+*
+* @brief initialize UART for print on port defined by TERM_PORT.
+*        
+* @param  none 
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+
+void UART_InitPrint(void)
+{
+    UART_ConfigType sConfig;
+
+    sConfig.u32SysClkHz = BUS_CLK_HZ;
+    sConfig.u32Baudrate  = UART_PRINT_BITRATE;
+    
+    UART_Init (TERM_PORT, &sConfig);
+}
diff --git a/bsp/frdm-ke02/device/lib/drivers/systick.c b/bsp/frdm-ke02/device/lib/drivers/systick.c
new file mode 100755
index 0000000..33f6fba
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/drivers/systick.c
@@ -0,0 +1,77 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file systick.c
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief provide systick utility routines.
+*
+*******************************************************************************/
+
+#include "common.h"
+#include "systick.h"
+
+uint32_t cnt_start_value;
+uint32_t cnt_end_value;
+uint32_t overhead;
+
+#if 0
+  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
+  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
+  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
+  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
+#endif
+void systick_init(void)
+{
+	SysTick->VAL = 0x0;	/* clear current timer value */
+    SysTick->LOAD = 0x00FFFFFF;
+    SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;   
+}
+
+void systick_disable(void)
+{
+    SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;
+}
+
+void cal_systick_read_overhead(void)
+{
+  	uint32_t cnt_start_value;
+    uint32_t cnt_end_value;
+	
+	cnt_start_value = SysTick->VAL;
+  
+    cnt_end_value = SysTick->VAL;
+	
+	overhead = cnt_start_value - cnt_end_value;
+	
+#ifdef DEBUG_PRINT
+	printf("systick start value: 0x%x\n\r", (unsigned int)cnt_start_value);
+	printf("systick end value: 0x%x\n\r", (unsigned int) cnt_end_value);
+	printf("systick current value read overhead: 0x%x\n\r", (unsigned int)overhead);
+#endif
+
+}
diff --git a/bsp/frdm-ke02/device/lib/drivers/uart.c b/bsp/frdm-ke02/device/lib/drivers/uart.c
new file mode 100755
index 0000000..77ec16d
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/drivers/uart.c
@@ -0,0 +1,488 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file uart.c
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date June-6-2013
+*
+* @brief providing common UART API. 
+*
+******************************************************************************/
+#include "uart.h"
+
+/******************************************************************************
+* Local variables
+******************************************************************************/
+UART_CallbackType UART_Callback = NULL;
+/******************************************************************************
+* Local function prototypes
+******************************************************************************/
+
+/******************************************************************************
+* Local functions
+*****************************************************************************/
+
+/******************************************************************************
+* Global functions
+******************************************************************************/
+
+/******************************************************************************
+* define UART APIs
+*
+*//*! @addtogroup uart_api_list
+* @{
+*******************************************************************************/
+
+/*****************************************************************************//*!
+*
+* @brief initialize the UART, interrupts disabled, and no hardware flow-control.
+*        
+* @param[in] pUART       base of UART port
+* @param[in] pConfig     pointer to UART configuration structure
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+void UART_Init(UART_Type *pUART, UART_ConfigType *pConfig)
+{
+    uint16_t u16Sbr;
+    uint8_t u8Temp;
+    uint32_t u32SysClk = pConfig->u32SysClkHz;
+    uint32_t u32Baud = pConfig->u32Baudrate;
+
+    /* Sanity check */
+    ASSERT((pUART == UART0) || (pUART == UART1) || (pUART == UART2));
+  
+	/* Enable the clock to the selected UART */    
+    if (pUART == UART0)
+	{
+		SIM->SCGC |= SIM_SCGC_UART0_MASK;
+	}
+#if defined(CPU_KE02)  | defined(CPU_KE06)
+	else if (pUART == UART1)
+	{
+        SIM->SCGC |= SIM_SCGC_UART1_MASK;
+	}
+    else
+	{
+        SIM->SCGC |= SIM_SCGC_UART2_MASK;
+	}
+#endif    
+    /* Make sure that the transmitter and receiver are disabled while we 
+     * change settings.
+     */
+    pUART->C2 &= ~(UART_C2_TE_MASK | UART_C2_RE_MASK );
+    
+    /* Configure the UART for 8-bit mode, no parity */
+    pUART->C1 = 0;
+    
+    /* Calculate baud settings */
+    u16Sbr = (((u32SysClk)>>4) + (u32Baud>>1))/u32Baud;
+    
+    /* Save off the current value of the UARTx_BDH except for the SBR field */
+    u8Temp = pUART->BDH & ~(UART_BDH_SBR_MASK);
+    
+    pUART->BDH = u8Temp |  UART_BDH_SBR(u16Sbr >> 8);
+    pUART->BDL = (uint8_t)(u16Sbr & UART_BDL_SBR_MASK);
+
+    /* Enable receiver and transmitter */
+    pUART->C2 |= (UART_C2_TE_MASK | UART_C2_RE_MASK );
+}
+
+/*****************************************************************************//*!
+*
+* @brief receive a character.
+*        
+* @param[in] pUART       base of UART port
+*
+* @return unsigned char
+*
+*****************************************************************************/
+uint8_t UART_GetChar(UART_Type *pUART)
+{
+
+    /* Sanity check */
+    ASSERT((pUART == UART0) || (pUART == UART1) || (pUART == UART2));
+ 
+    /* Wait until character has been received */
+    while (!(pUART->S1 & UART_S1_RDRF_MASK));
+    
+    /* Return the 8-bit data from the receiver */
+    return pUART->D;
+}
+/*****************************************************************************//*!
+*
+* @brief send a character.
+*        
+* @param[in] pUART       base of UART port
+* @param[in] u8Char      char to send
+*
+* @return none
+*
+*****************************************************************************/
+void UART_PutChar(UART_Type *pUART, uint8_t u8Char)
+{    
+    /* Wait until space is available in the FIFO */
+    while (!(pUART->S1 & UART_S1_TDRE_MASK));
+    
+    /* Send the character */
+    pUART->D = (uint8_t)u8Char;
+}
+
+/*****************************************************************************//*!
+*
+* @brief set baudrate.
+*        
+* @param[in] pUART       base of UART port
+* @param[in] pConfig     baudrate config parameters
+*
+* @return none
+*
+* @ Pass/ Fail criteria:
+*****************************************************************************/
+void UART_SetBaudrate(UART_Type *pUART, UART_ConfigBaudrateType *pConfig)
+{
+    uint8_t u8Temp;
+    uint16_t u16Sbr;
+    uint32_t u32SysClk    = pConfig->u32SysClkHz;
+    uint32_t u32baud       = pConfig->u32Baudrate;
+ 
+    /* Sanity check */
+    ASSERT((pUART == UART0) || (pUART == UART1) || (pUART == UART2));
+
+    /* Calculate baud settings */
+    u16Sbr = (((u32SysClk)>>4) + (u32baud>>1))/u32baud;
+
+    /* Save off the current value of the UARTx_BDH except for the SBR field */
+    u8Temp = pUART->BDH & ~(UART_BDH_SBR_MASK);
+    
+    pUART->BDH = u8Temp |  UART_BDH_SBR(u16Sbr >> 8);
+    pUART->BDL = (uint8_t)(u16Sbr & UART_BDL_SBR_MASK);
+
+    /* Enable receiver and transmitter */
+    pUART->C2 |= (UART_C2_TE_MASK | UART_C2_RE_MASK );
+
+}
+
+/*****************************************************************************//*!
+*
+* @brief enable interrupt.
+*        
+* @param[in] pUART          base of UART port
+* @param[in] InterruptType  interrupt type
+*
+* @return none
+*
+* @ Pass/ Fail criteria:
+*****************************************************************************/
+void UART_EnableInterrupt(UART_Type *pUART, UART_InterruptType InterruptType)
+{
+
+    /* Sanity check */
+    ASSERT((pUART == UART0) || (pUART == UART1) || (pUART == UART2));
+
+    if (InterruptType == UART_TxBuffEmptyInt)
+    {
+        pUART->C2 |= UART_C2_TIE_MASK;
+    }
+    else if (InterruptType == UART_TxCompleteInt)
+    {
+        pUART->C2 |= UART_C2_TCIE_MASK;
+    }
+    else if (InterruptType == UART_RxBuffFullInt)
+    {
+        pUART->C2 |= UART_C2_RIE_MASK;
+    }
+    else if (InterruptType == UART_IdleLineInt)
+    {
+        pUART->C2 |= UART_C2_ILIE_MASK;
+    }
+    else if (InterruptType == UART_RxOverrunInt)
+    {
+        pUART->C3 |= UART_C3_ORIE_MASK;
+    }
+    else if (InterruptType == UART_NoiseErrorInt)
+    {
+        pUART->C3 |= UART_C3_NEIE_MASK;
+    }
+    else if (InterruptType == UART_FramingErrorInt)
+    {
+        pUART->C3 |= UART_C3_FEIE_MASK;
+    } 
+    else if (InterruptType == UART_ParityErrorInt)
+    {
+        pUART->C3 |= UART_C3_FEIE_MASK;
+    } 
+    else
+    {
+        /* un-supported Interrupt type */
+    }  
+}
+
+/*****************************************************************************//*!
+*
+* @brief disable interrupt.
+*        
+* @param[in] pUART base of UART port
+* @param[in] InterruptType interrupt type
+*
+* @return none
+*
+* @ Pass/ Fail criteria:
+*****************************************************************************/
+void UART_DisableInterrupt(UART_Type *pUART, UART_InterruptType InterruptType)
+{
+    /* Sanity check */
+    ASSERT((pUART == UART0) || (pUART == UART1) || (pUART == UART2));
+
+
+    if (InterruptType == UART_TxBuffEmptyInt)
+    {
+        pUART->C2 &= (~UART_C2_TIE_MASK);
+    }
+    else if (InterruptType == UART_TxCompleteInt)
+    {
+        pUART->C2 &= (~UART_C2_TCIE_MASK);
+    }
+    else if (InterruptType == UART_RxBuffFullInt)
+    {
+        pUART->C2 &= (~UART_C2_RIE_MASK);
+    }
+    else if (InterruptType == UART_IdleLineInt)
+    {
+        pUART->C2 &= (~UART_C2_ILIE_MASK);
+    }
+    else if (InterruptType == UART_RxOverrunInt)
+    {
+        pUART->C3 &= (~UART_C3_ORIE_MASK);
+    }
+    else if (InterruptType == UART_NoiseErrorInt)
+    {
+        pUART->C3 &= (~UART_C3_NEIE_MASK);
+    }
+    else if (InterruptType == UART_FramingErrorInt)
+    {
+        pUART->C3 &= (~UART_C3_FEIE_MASK);
+    } 
+    else if (InterruptType == UART_ParityErrorInt)
+    {
+        pUART->C3 &= (~UART_C3_FEIE_MASK);
+    } 
+    else
+    {
+        /* un-supported interrupt type */
+    }  
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief get flags from 2 UART status registers.
+*        
+* @param[in] pUART  base of UART port
+*
+* @return       16-bit flags
+*
+* @ Pass/ Fail criteria:
+*****************************************************************************/
+uint16_t UART_GetFlags(UART_Type *pUART)
+{
+    uint16_t u16StatusFlags = 0;
+
+    u16StatusFlags = pUART->S2;
+    u16StatusFlags = (u16StatusFlags<<8)| pUART->S1; 
+
+    return u16StatusFlags;
+}
+/*****************************************************************************//*!
+*
+* @brief check whether the specified flag is set.
+*        
+* @param[in] pUART      base of UART port
+* @param[in] FlagType   flag type
+*
+* @return       
+*               1, flag is set
+*               0, flag is clear
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+uint8_t UART_CheckFlag(UART_Type *pUART, UART_FlagType FlagType)
+{
+    uint16_t u16StatusFlags = 0;
+
+    u16StatusFlags = UART_GetFlags(pUART);
+
+    return (u16StatusFlags & (1<<FlagType));
+}
+
+/*****************************************************************************//*!
+*
+* @brief send a series of charecters using polling mode.
+*        
+* @param[in] pUART      base of UART port
+* @param[in] pSendBuff  pointer of charecters to send
+* @param[in] u32Length  number of charecters
+*
+* @return       none
+*
+* @ Pass/ Fail criteria:
+*****************************************************************************/
+void UART_SendWait(UART_Type *pUART, uint8_t *pSendBuff, uint32_t u32Length)
+{
+    uint8_t u8TxChar;
+    uint32_t  i;
+    
+    for (i = 0; i < u32Length; i++)
+    {
+        u8TxChar = pSendBuff[i];
+        while (!UART_IsTxBuffEmpty(pUART))
+        {
+            #if defined(ENABLE_WDOG)
+                WDOG_Feed();
+            #endif        
+        }
+        UART_WriteDataReg(pUART, u8TxChar);        
+    }
+}
+
+/*****************************************************************************//*!
+*
+* @brief receive a series of charecters using polling mode.
+*        
+* @param[in] pUART          base of UART port
+* @param[in] pReceiveBuff   pointer of charecters to receive
+* @param[in] u32Length      number of charecters
+*
+* @return       none
+*
+* @ Pass/ Fail criteria:
+*****************************************************************************/
+void UART_ReceiveWait(UART_Type *pUART, uint8_t *pReceiveBuff, uint32_t u32Length)
+{
+    uint8_t u8RxChar;
+    uint32_t i;
+    
+    for (i = 0; i < u32Length; i++)
+    {
+        while (!UART_IsRxBuffFull(pUART))
+        {
+            #if defined(ENABLE_WDOG)
+                WDOG_Feed();
+            #endif       
+        }    
+        u8RxChar = UART_ReadDataReg(pUART);
+        pReceiveBuff[i] = u8RxChar;
+    }
+}
+
+/*****************************************************************************//*!
+*
+* @brief wait tx complete.
+*        
+* @param[in] pUART      base of UART port
+*
+* @return       none
+*
+* @ Pass/ Fail criteria: none*****************************************************************************/
+void UART_WaitTxComplete(UART_Type *pUART)
+{
+    while (!UART_IsTxComplete(pUART));
+}
+
+/*****************************************************************************//*!
+*
+* @brief set up UART callback routines to be called by interrupt service routine.
+*        
+* @param[in]  pUART         pointer to an UART register base 
+* @param[in]  pfnCallback   callback routine
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+void UART_SetCallback(UART_CallbackType pfnCallback)
+{
+    //uint8_t    u8Port = ((uint32_t)pUART-(uint32_t)UART0)>>12;
+    UART_Callback = pfnCallback;
+}
+
+
+/*! @} End of uart_api_list */
+
+
+/*****************************************************************************//*!
+*
+* @brief uart0 interrupt service routine.
+*        
+* @param        none
+*
+* @return       none
+*
+* @ Pass/ Fail criteria:
+*****************************************************************************/
+void UART0_Isr(void)
+{
+    UART_Callback(UART0);
+}
+
+
+#if defined(CPU_KE02) | defined(CPU_KE06)
+/*****************************************************************************//*!
+*
+* @brief uart1 interrupt service routine.
+*        
+* @param        none
+*
+* @return       none
+*
+* @ Pass/ Fail criteria:
+*****************************************************************************/
+void UART1_Isr(void)
+{
+    UART_Callback(UART1);
+}
+/*****************************************************************************//*!
+*
+* @brief uart2 interrupt service routine.
+*        
+* @param        none
+*
+* @return       none
+*
+* @ Pass/ Fail criteria:
+*****************************************************************************/
+void UART2_Isr(void)
+{
+    UART_Callback(UART2);
+}
+
+
+#endif
+
+
+
diff --git a/bsp/frdm-ke02/device/lib/drivers/uif.c b/bsp/frdm-ke02/device/lib/drivers/uif.c
new file mode 100755
index 0000000..cb3d029
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/drivers/uif.c
@@ -0,0 +1,356 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file uif.c
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief provide an interactive user interface. 
+*
+*   The commands, set/show parameters, and prompt are configured at the project level.
+*******************************************************************************/
+
+#include "common.h"
+#include "uif.h"
+
+/********************************************************************/
+/*
+ * Global messages -- constant strings
+ */
+const char HELPMSG[] =
+    "Enter 'help' for help.\n";
+
+const char INVARG[] =
+    "Error: Invalid argument: %s\n";
+
+const char INVALUE[] = 
+    "Error: Invalid value: %s\n";
+
+/*
+ * Strings used by this file only
+ */
+static const char INVCMD[] =
+    "Error: No such command: %s\n";
+
+static const char HELPFORMAT[] = 
+    "%8s  %-25s %s %s\n";
+
+static const char SYNTAX[] = 
+    "Error: Invalid syntax for: %s\n";
+
+static const char INVOPT[] = 
+    "Error:  Invalid set/show option: %s\n";
+
+static const char OPTFMT[] = 
+    "%12s: ";
+
+static char cmdline1 [UIF_MAX_LINE];
+static char cmdline2 [UIF_MAX_LINE];
+
+/********************************************************************/
+char *
+get_line (char *line)
+{
+    int pos;
+    int ch;
+
+    pos = 0;
+    ch = (int)in_char();
+    while ( (ch != 0x0D /* CR */) &&
+            (ch != 0x0A /* LF/NL */) &&
+            (pos < UIF_MAX_LINE))
+    {
+        switch (ch)
+        {
+            case 0x08:      /* Backspace */
+            case 0x7F:      /* Delete */
+                if (pos > 0)
+                {
+                    pos -= 1;
+                    out_char(0x08);    /* backspace */
+                    out_char(' ');
+                    out_char(0x08);    /* backspace */
+                }
+                break;
+            default:
+                if ((pos+1) < UIF_MAX_LINE)
+                {
+                    if ((ch > 0x1f) && (ch < 0x80))
+                    {
+                        line[pos++] = (char)ch;
+                        out_char((char)ch);
+                    }
+                }
+                break;
+        }
+        ch = (int)in_char();
+    }
+    line[pos] = '\0';
+    out_char(0x0D);    /* CR */
+    out_char(0x0A);    /* LF */
+
+    return line;
+}
+
+/********************************************************************/
+int
+make_argv (char *cmdline, char *argv[])
+{
+    int argc, i, in_text;
+
+    /* 
+     * Break cmdline into strings and argv
+     * It is permissible for argv to be NULL, in which case
+     * the purpose of this routine becomes to count args
+     */
+    argc = 0;
+    i = 0;
+    in_text = FALSE;
+    while (cmdline[i] != '\0')  /* getline() must place 0x00 on end */
+    {
+        if (((cmdline[i] == ' ')   ||
+             (cmdline[i] == '\t')) )
+        {
+            if (in_text)
+            {
+                /* end of command line argument */
+                cmdline[i] = '\0';
+                in_text = FALSE;
+            }
+            else
+            {
+                /* still looking for next argument */
+                
+            }
+        }
+        else
+        {
+            /* got non-whitespace character */
+            if (in_text)
+            {
+            }
+            else
+            {
+                /* start of an argument */
+                in_text = TRUE;
+                if (argc < UIF_MAX_ARGS)
+                {
+                    if (argv != NULL)
+                        argv[argc] = &cmdline[i];
+                    argc++;
+                }
+                else
+                    /*return argc;*/
+                    break;
+            }
+
+        }
+        i++;    /* proceed to next character */
+    }
+    if (argv != NULL)
+        argv[argc] = NULL;
+    return argc;
+}
+
+/********************************************************************/
+void
+run_cmd (void)
+{
+    /*
+     * Global array of pointers to emulate C argc,argv interface
+     */
+    int argc;
+    char *argv[UIF_MAX_ARGS + 1];   /* one extra for null terminator */
+
+    get_line(cmdline1);
+
+    if (!(argc = make_argv(cmdline1,argv)))
+    {
+        /* no command entered, just a blank line */
+        strcpy(cmdline1,cmdline2);
+        argc = make_argv(cmdline1,argv);
+    }
+    cmdline2[0] = '\0';
+
+    if (argc)
+    {
+        int i;
+        for (i = 0; i < UIF_NUM_CMD; i++)
+        {
+            if (strcasecmp(UIF_CMDTAB[i].cmd,argv[0]) == 0)
+            {
+                if (((argc-1) >= UIF_CMDTAB[i].min_args) &&
+                    ((argc-1) <= UIF_CMDTAB[i].max_args))
+                {
+                    if (UIF_CMDTAB[i].flags & UIF_CMD_FLAG_REPEAT)
+                    {
+                        strcpy(cmdline2,argv[0]);
+                    }
+                    UIF_CMDTAB[i].func(argc,argv);
+                    return;
+                }
+                else
+                {
+                    printf(SYNTAX,argv[0]);
+                    return;
+                }
+            }
+        }
+        printf(INVCMD,argv[0]);
+        printf(HELPMSG);
+    }
+}
+/********************************************************************/
+uint32
+get_value (char *s, int *success, int base)
+{
+    uint32 value;
+    char *p;
+
+    value = strtoul(s,&p,base);
+    if ((value == 0) && (p == s))
+    {
+        *success = FALSE;
+        return 0;
+    }
+    else
+    {
+        *success = TRUE;
+        return value;
+    }
+}
+/********************************************************************/
+void
+uif_cmd_help (int argc, char **argv)
+{
+    int index;
+    
+    (void)argc;
+    (void)argv;
+    
+    printf("\n");
+    for (index = 0; index < UIF_NUM_CMD; index++)
+    {
+        printf(HELPFORMAT,
+            UIF_CMDTAB[index].cmd,
+            UIF_CMDTAB[index].description,
+            UIF_CMDTAB[index].cmd,
+            UIF_CMDTAB[index].syntax);
+    }
+    printf("\n");
+}
+/********************************************************************/
+void
+uif_cmd_set (int argc, char **argv)
+{
+    int index;
+
+    printf("\n");
+    if (argc == 1)
+    {
+        printf("Valid 'set' options:\n");
+        for (index = 0; index < UIF_NUM_SETCMD; ++index)
+        {
+            printf(OPTFMT,UIF_SETCMDTAB[index].option);
+            printf("%s\n",UIF_SETCMDTAB[index].syntax);
+        }
+        printf("\n");
+        return;
+    }
+
+    if (argc != 3)
+    {
+        printf("Error: Invalid argument list\n");
+        return;
+    }
+
+    for (index = 0; index < UIF_NUM_SETCMD; index++)
+    {
+        if (strcasecmp(UIF_SETCMDTAB[index].option,argv[1]) == 0)
+        {
+            if (((argc-1-1) >= UIF_SETCMDTAB[index].min_args) &&
+                ((argc-1-1) <= UIF_SETCMDTAB[index].max_args))
+            {
+                UIF_SETCMDTAB[index].func(argc,argv);
+                return;
+            }
+            else
+            {
+                printf(INVARG,argv[1]);
+                return;
+            }
+        }
+    }
+    printf(INVOPT,argv[1]);
+}
+
+/********************************************************************/
+void
+uif_cmd_show (int argc, char **argv)
+{
+    int index;
+
+    printf("\n");
+    if (argc == 1)
+    {
+        /*
+         * Show all Option settings
+         */
+        argc = 2;
+        argv[2] = NULL;
+        for (index = 0; index < UIF_NUM_SETCMD; index++)
+        {
+            printf(OPTFMT,UIF_SETCMDTAB[index].option);
+            UIF_SETCMDTAB[index].func(argc,argv);
+            printf("\n");
+        }
+        printf("\n");
+        return;
+    }
+
+    for (index = 0; index < UIF_NUM_SETCMD; index++)
+    {
+        if (strcasecmp(UIF_SETCMDTAB[index].option,argv[1]) == 0)
+        {
+            if (((argc-1-1) >= UIF_SETCMDTAB[index].min_args) &&
+                ((argc-1-1) <= UIF_SETCMDTAB[index].max_args))
+            {
+                printf(OPTFMT,UIF_SETCMDTAB[index].option);
+                UIF_SETCMDTAB[index].func(argc,argv);
+                printf("\n\n");
+                return;
+            }
+            else
+            {
+                printf(INVARG,argv[1]);
+                return;
+            }
+        }
+    }
+    printf(INVOPT,argv[1]);
+}
+
+/********************************************************************/
diff --git a/bsp/frdm-ke02/device/lib/drivers/wdog.c b/bsp/frdm-ke02/device/lib/drivers/wdog.c
new file mode 100755
index 0000000..5e57465
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/drivers/wdog.c
@@ -0,0 +1,352 @@
+
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file wdog.c
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief Provide common watchdog module routines. 
+*
+* @history:
+* 	Jun. 25, 2013	modified the watch dog unlock sequence and disable sequence
+******************************************************************************/
+#include "common.h"
+#include "wdog.h"
+ 
+/******************************************************************************
+* Global variables
+******************************************************************************/
+
+/******************************************************************************
+* Constants and macros
+******************************************************************************/
+
+/******************************************************************************
+* Local types
+******************************************************************************/
+
+/******************************************************************************
+* Local function prototypes
+******************************************************************************/
+
+/******************************************************************************
+* Local variables
+******************************************************************************/
+
+/******************************************************************************
+* Local functions
+******************************************************************************/
+
+/******************************************************************************
+* Global functions
+******************************************************************************/
+
+/******************************************************************************
+* define watchdog API list
+*
+*//*! @addtogroup wdog_api_list
+* @{
+*******************************************************************************/
+
+/*****************************************************************************//*!
+*
+* @brief Watchdog timer disable routine.
+*        
+* @param  none 
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+* @see WDOG_Enable
+*****************************************************************************/
+
+void WDOG_Disable(void)
+{
+    uint8_t u8Cs1 =  WDOG->CS1;  
+    uint8_t u8Cs2 =  WDOG->CS2;  
+    uint16_t u16TOVAL =  WDOG->TOVAL;  
+    uint16_t u16WIN =  WDOG->WIN;  
+
+    u8Cs1       &= ~WDOG_CS1_EN_MASK;
+
+	/* First unlock the watchdog so that we can write to registers */
+    WDOG_Unlock(); 
+    WDOG->CS2    =  u8Cs2;
+    WDOG->TOVAL  =  u16TOVAL;
+    WDOG->WIN    =  u16WIN;
+    WDOG->CS1    =  u8Cs1;
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief Watchdog timer disable routine with update enabled.
+*        
+*   Disable watchdog but the watchdog can be enabled and updated later.
+*
+* @param  none 
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+* @see WDOG_Enable
+*****************************************************************************/
+
+void WDOG_DisableWDOGEnableUpdate(void)
+{
+    uint8_t u8Cs1 =  WDOG->CS1;  
+    uint8_t u8Cs2 =  WDOG->CS2;  
+    uint16_t u16TOVAL =  WDOG->TOVAL;  
+    uint16_t u16WIN =  WDOG->WIN;  
+
+    u8Cs1       &= ~WDOG_CS1_EN_MASK;
+    u8Cs1       |= WDOG_CS1_UPDATE_MASK;
+
+	/* First unlock the watchdog so that we can write to registers */
+    WDOG_Unlock(); 
+    WDOG->CS2    =  u8Cs2;
+    WDOG->TOVAL  =  u16TOVAL;
+    WDOG->WIN    =  u16WIN;
+    WDOG->CS1    =  u8Cs1;
+}
+
+/*****************************************************************************//*!
+*
+* @brief Watchdog timer enable routine.
+*        
+* @param  none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+* @see  WDOG_Disable
+*****************************************************************************/
+
+void WDOG_Enable(void)
+{
+    uint8_t u8Cs1 =  WDOG->CS1;
+    
+    u8Cs1       |= WDOG_CS1_EN_MASK;
+
+	/* First unlock the watchdog so that we can write to registers */
+    WDOG_Unlock();
+    WDOG->CS1    = u8Cs1;
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief initialize watchdog.
+*        
+* @param[in]   pConfig  poiner to watchdog configuration strcture.
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+* 
+* @warning make sure that WDOG is not initialized after reset or WDOG update is enabled 
+* after reset by calling WDOG_EnableUpdate / WDOG_DisableWDOGEnableUpdate.
+*
+* @see WDOG_EnableUpdate, WDOG_DisableWDOGEnableUpdate
+*
+*****************************************************************************/
+
+void WDOG_Init(WDOG_ConfigPtr pConfig)
+{
+    uint8_t     u8Cs1;
+    uint8_t     u8Cs2;
+    uint16_t    u16Toval;
+    uint16_t    u16Win;
+    
+    u8Cs1       = 0x80;                                   /* default CS1 register value */
+    u8Cs2       = 0;
+    u16Toval    = pConfig->u16TimeOut;
+    u16Win      = pConfig->u16WinTime;
+        
+    if(pConfig->sBits.bDisable)
+    {
+        u8Cs1 &= ~WDOG_CS1_EN_MASK;
+    }
+    if(pConfig->sBits.bIntEnable)
+    {
+        u8Cs1 |= WDOG_CS1_INT_MASK;
+    }
+    if(pConfig->sBits.bStopEnable)
+    {
+        u8Cs1 |= WDOG_CS1_STOP_MASK;
+    }
+    if(pConfig->sBits.bDbgEnable)
+    {
+        u8Cs1 |= WDOG_CS1_DBG_MASK;
+    }
+    if(pConfig->sBits.bWaitEnable)
+    {
+        u8Cs1 |= WDOG_CS1_WAIT_MASK;
+    }
+    if(pConfig->sBits.bUpdateEnable)
+    {
+        u8Cs1 |= WDOG_CS1_UPDATE_MASK;
+    }
+    if(pConfig->sBits.bWinEnable)
+    {
+        u8Cs2 |= WDOG_CS2_WIN_MASK;
+    }
+    if(pConfig->sBits.bPrescaler)
+    {
+        u8Cs2 |= WDOG_CS2_PRES_MASK;
+    }
+    u8Cs2   |= (pConfig->sBits.bClkSrc & 0x03);
+    
+    /* write regisers */
+    WDOG_Unlock();              /* unlock watchdog first */
+    WDOG->CS2   = u8Cs2;
+
+    WDOG->TOVAL8B.TOVALL  = u16Toval;
+    WDOG->TOVAL8B.TOVALH  = u16Toval >> 8;
+    
+    WDOG->WIN8B.WINL  = u16Win;
+    WDOG->WIN8B.WINH  = u16Win >> 8;
+    
+    WDOG->CS1   = u8Cs1;                            
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief initialize watchdog to the default state.
+*        
+* @param   none 
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+* @warning make sure that WDOG update is enabled after reset by calling WDOG_EnableUpdate.
+* or by calling WDOG_DisableWDOGEnableUpdate.
+*
+* @see WDOG_DisableWDOGEnableUpdate, WDOG_EnableUpdate
+*
+*****************************************************************************/
+
+void WDOG_DeInit(void)
+{
+    WDOG_Unlock();
+    
+    WDOG->CS2    =  WDOG_CS2_DEFAULT_VALUE;
+    WDOG->TOVAL  =  WDOG_TOVAL_DEFAULT_VALUE;
+    WDOG->WIN    =  WDOG_WIN_DEFAULT_VALUE;    
+    WDOG->CS1    =  WDOG_CS1_DEFAULT_VALUE;
+}
+
+/*****************************************************************************//*!
+*
+* @brief feed/refresh watchdog.
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+
+void WDOG_Feed(void)
+{
+    DisableInterrupts;
+    WDOG->CNT = 0x02A6;
+    WDOG->CNT = 0x80B4;
+    EnableInterrupts;
+}
+
+
+
+/*****************************************************************************//*!
+*
+* @brief enable update of WDOG. 
+*        
+* @param  none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+* @warning  this must be the last step of writing control bits sequence.
+*****************************************************************************/
+
+void WDOG_EnableUpdate(void)
+{
+    uint8_t u8Cs1 =  WDOG->CS1;  
+    uint8_t u8Cs2 =  WDOG->CS2;  
+    uint16_t u16TOVAL =  WDOG->TOVAL;  
+    uint16_t u16WIN =  WDOG->WIN;  
+
+    u8Cs1 |= WDOG_CS1_UPDATE_MASK;
+
+	/* First unlock the watchdog so that we can write to registers */
+    WDOG_Unlock(); 
+    WDOG->CS2    =  u8Cs2;
+    WDOG->TOVAL  =  u16TOVAL;
+    WDOG->WIN    =  u16WIN;
+    WDOG->CS1    =  u8Cs1;  
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief disable update of WDOG. 
+*        
+* @param  none 
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+* @warning  this must be the last step of writing control bits sequence.
+*****************************************************************************/
+
+void WDOG_DisableUpdate(void)
+{
+    uint8_t u8Cs1 =  WDOG->CS1;  
+    uint8_t u8Cs2 =  WDOG->CS2;  
+    uint16_t u16TOVAL =  WDOG->TOVAL;  
+    uint16_t u16WIN =  WDOG->WIN;  
+
+    u8Cs1 &= ~WDOG_CS1_UPDATE_MASK;
+
+	/* First unlock the watchdog so that we can write to registers */
+    WDOG_Unlock(); 
+    WDOG->CS2    =  u8Cs2;
+    WDOG->TOVAL  =  u16TOVAL;
+    WDOG->WIN    =  u16WIN;
+    WDOG->CS1    =  u8Cs1;  
+    
+}
+
+
+/********************************************************************/
+
+/*! @} End of wdog_api_list                                                    					*/
+
+
+
+
diff --git a/bsp/frdm-ke02/device/lib/inc/BME.h b/bsp/frdm-ke02/device/lib/inc/BME.h
new file mode 100755
index 0000000..c59d76d
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/BME.h
@@ -0,0 +1,639 @@
+
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file bme.h
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief Provide BME utilities. 
+*
+* @history:
+* 	Jun. 25, 2013	created macros
+******************************************************************************/
+
+#ifndef __BME_H
+#define __BME_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+/******************************************************************************
+* BME operation code
+*
+*//*! @addtogroup BME_OPCode
+* @{
+*******************************************************************************/
+
+#define BME_OPCODE_AND		1               /*!< AND opcode */
+#define BME_OPCODE_OR		2               /*!< OR opcode */
+#define BME_OPCODE_XOR		3               /*!< XOR opcode */
+#define BME_OPCODE_BITFIELD	4               /*!< Bit field opcode */
+
+#define BME_OPCODE_BIT_CLEAR    2           /*!< Bit clear opcode */
+#define BME_OPCODE_BIT_SET      3           /*!< Bit set opcode */
+/*! @} End of BME_OPCode                                                   */
+
+/******************************************************************************
+* BME macro used to generate hardcoded BME addresses
+*
+*//*! @addtogroup BME_Utilities
+* @{
+*******************************************************************************/
+
+/******************************************************************************
+* macro used to generate hardcoded AND address.
+*
+*******************************************************************************/
+
+/*****************************************************************************//*!
+   *
+   * @brief  generates BME AND operation addresss (hardcoded 32-bit address).
+   *        
+   * @param[in]   ADDR  32-bit address.
+   *  
+   * @return  hardcoded 32-bit address.
+   *
+   * @ Pass/ Fail criteria: none.
+   *
+*****************************************************************************/
+#define BME_AND(ADDR)           (*(volatile uint32_t *)(((uint32_t)ADDR) | (BME_OPCODE_AND<<26)))  
+
+/******************************************************************************
+* macro used to generate hardcoded OR address.
+*
+*******************************************************************************/
+
+/*****************************************************************************//*!
+   *
+   * @brief  generates BME OR operation addresss (hardcoded 32-bit address).
+   *        
+   * @param[in]   ADDR  32-bit address.
+   *  
+   * @return  hardcoded 32-bit address.
+   *
+   * @ Pass/ Fail criteria: none.
+   *
+*****************************************************************************/
+
+#define BME_OR(ADDR)           (*(volatile uint32_t *)(((uint32_t)ADDR) | (BME_OPCODE_OR<<26)))     
+
+
+/******************************************************************************
+* macro used to generate hardcoded XOR address.
+*
+*******************************************************************************/
+
+/*****************************************************************************//*!
+   *
+   * @brief  generates BME XOR operation addresss (hardcoded 32-bit address).
+   *        
+   * @param[in]   ADDR  32-bit address.
+   *  
+   * @return  hardcoded 32-bit address.
+   *
+   * @ Pass/ Fail criteria: none.
+   *
+*****************************************************************************/
+
+#define BME_XOR(ADDR)           (*(volatile uint32_t *)(((uint32_t)ADDR) | (BME_OPCODE_XOR<<26)))   
+
+#if !defined(BME_SANITY_CHECK)
+   /*!
+     * @brief This is fastest way for BME without sanity check.
+     */
+  /******************************************************************************
+    * macro used to generate hardcoded load 1 bit clear address (LAC1).
+    *
+    *******************************************************************************/
+  /*****************************************************************************//*!
+       *
+       * @brief  generates BME bit clear operation addresss (hardcoded 32-bit address).
+       *        
+       * @param[in]   ADDR  32-bit address.
+       * @param[in]   bit     bit number, 0-based.
+       *  
+       * @return  hardcoded 32-bit address.
+       *
+       * @ Pass/ Fail criteria: none.
+       *
+    *****************************************************************************/
+    
+    #define BME_BIT_CLEAR(ADDR,bit)        (*(volatile uint32_t *)(((uint32_t)ADDR)   \
+                                  | (BME_OPCODE_BIT_CLEAR <<26)  \
+                                  | ((bit)<<21)))                                                
+
+  /******************************************************************************
+    * macro used to generate hardcoded load 1 bit set address (LAS1).
+    *
+    *******************************************************************************/
+   /*****************************************************************************//*!
+         *
+         * @brief  generates BME bit set operation addresss (hardcoded 32-bit address).
+         *        
+         * @param[in]   ADDR  32-bit address.
+         * @param[in]   bit     bit number, 0-based.
+         *  
+         * @return  hardcoded 32-bit address.
+         *
+         * @ Pass/ Fail criteria: none.
+         *
+      *****************************************************************************/
+
+    #define BME_BIT_SET(ADDR,bit)        (*(volatile uint32_t *)(((uint32_t)ADDR)   \
+                                  | (BME_OPCODE_BIT_SET <<26)  \
+                                  | ((bit)<<21)))                                                
+
+  /******************************************************************************
+    * macro used to generate hardcoded bit field insert address (BFI).
+    *
+    *******************************************************************************/
+   /*****************************************************************************//*!
+         *
+         * @brief  generates BME bitfield insert operation addresss (hardcoded 32-bit address).
+         *        
+         * @param[in]   ADDR  32-bit address.
+         * @param[in]   bit      bit number, 0-based.
+         * @param[in]   width  bitfield width, 1-based.
+         *  
+         * @return  hardcoded 32-bit address.
+         *
+         * @ Pass/ Fail criteria: none.
+         *
+      *****************************************************************************/    
+    #define BME_BITFIELD_INSERT(ADDR,bit,width)        (*(volatile uint32_t *)(((uint32_t)ADDR)   \
+                                  | (BME_OPCODE_BITFIELD <<26)  \
+                                  | ((bit)<<23) | ((width-1))<<19))                        
+
+
+  /******************************************************************************
+    * macro used to generate hardcoded bit field extract address (UBFX).
+    *
+    *******************************************************************************/
+      /*****************************************************************************//*!
+              *
+              * @brief  generates BME bitfield extract operation addresss (hardcoded 32-bit address).
+              *        
+              * @param[in]   ADDR  32-bit address.
+              * @param[in]   bit      bit number, 0-based.
+              * @param[in]   width  bitfield width, 1-based.
+              *  
+              * @return  hardcoded 32-bit address.
+              *
+              * @ Pass/ Fail criteria: none.
+              *
+           *****************************************************************************/    
+
+    #define BME_BITFIELD_EXTRACT(ADDR,bit,width)        (*(volatile uint32_t *)(((uint32_t)ADDR)    \
+                                  | (BME_OPCODE_BITFIELD <<26)  \
+                                  | ((bit)<<23) | ((width-1))<<19))                            
+#else
+    /*!
+     * @brief This is slow way for BME as it has sanity check.
+     */
+    /******************************************************************************
+    * macro used to generate hardcoded load 1 bit clear address (LAC1).
+    *
+    *******************************************************************************/
+    #define BME_BIT_CLEAR(ADDR,bit)        (*(volatile uint32_t *)(((uint32_t)ADDR)   \
+                                  | (BME_OPCODE_BIT_CLEAR <<26)  \
+                                  | ((bit & 0x1F)<<21)))                                                /*!< Bit clear operation */
+
+    /******************************************************************************
+    * macro used to generate hardcoded load 1 bit set address (LAS1).
+    *
+    *******************************************************************************/
+    #define BME_BIT_SET(ADDR,bit)        (*(volatile uint32_t *)(((uint32_t)ADDR)   \
+                                  | (BME_OPCODE_BIT_SET <<26)  \
+                                  | ((bit & 0x1F)<<21)))                                                /*!< Bit set operation */
+
+    /******************************************************************************
+    * macro used to generate hardcoded bit field insert address (BFI).
+    *
+    *******************************************************************************/
+    #define BME_BITFIELD_INSERT(ADDR,bit,width)        (*(volatile uint32_t *)(((uint32_t)ADDR)   \
+                                  | (BME_OPCODE_BITFIELD <<26)  \
+                                  | ((bit & 0x1F)<<23) | ((width-1) & 0xF)<<19))                        /*!< Bitfield insert operation */
+
+
+    /******************************************************************************
+    * macro used to generate hardcoded bit field extract address (UBFX).
+    *
+    *******************************************************************************/
+    #define BME_BITFIELD_EXTRACT(ADDR,bit,width)        (*(volatile uint32_t *)(((uint32_t)ADDR)    \
+                                  | (BME_OPCODE_BITFIELD <<26)  \
+                                  | ((bit & 0x1F)<<23) | ((width-1) & 0xF)<<19))                        /*!< Bitfield extract operation */
+
+#endif
+
+/******************************************************************************
+* The following macros are used to generate hardcoded address for 8-bit operation.
+*
+*******************************************************************************/
+
+/******************************************************************************
+* macro used to generate hardcoded AND address for 8-bit operation.
+*
+*******************************************************************************/
+/*****************************************************************************//*!
+   *
+   * @brief  generates BME AND operation addresss (hardcoded 32-bit address) for 8-bit data.
+   *        
+   * @param[in]   ADDR  32-bit address.
+   *  
+   * @return  hardcoded 32-bit address.
+   *
+   * @ Pass/ Fail criteria: none.
+   *
+*****************************************************************************/
+
+#define BME_AND_8b(ADDR)           (*(volatile uint8_t *)(((uint32_t)ADDR) | (BME_OPCODE_AND<<26)))   
+
+/******************************************************************************
+* macro used to generate hardcoded OR address.
+*
+*******************************************************************************/
+/*****************************************************************************//*!
+   *
+   * @brief  generates BME OR operation addresss (hardcoded 32-bit address) for 8-bit data.
+   *        
+   * @param[in]   ADDR  32-bit address.
+   *  
+   * @return  hardcoded 32-bit address.
+   *
+   * @ Pass/ Fail criteria: none.
+   *
+*****************************************************************************/
+
+#define BME_OR_8b(ADDR)           (*(volatile uint8_t *)(((uint32_t)ADDR) | (BME_OPCODE_OR<<26)))    
+
+
+/******************************************************************************
+* macro used to generate hardcoded XOR address.
+*
+*******************************************************************************/
+
+/*****************************************************************************//*!
+   *
+   * @brief  generates BME XOR operation addresss (hardcoded 32-bit address) for 8-bit data.
+   *        
+   * @param[in]   ADDR  32-bit address.
+   *  
+   * @return  hardcoded 32-bit address.
+   *
+   * @ Pass/ Fail criteria: none.
+   *
+*****************************************************************************/
+
+#define BME_XOR_8b(ADDR)           (*(volatile uint8_t *)(((uint32_t)ADDR) | (BME_OPCODE_XOR<<26)))   
+
+#if !defined(BME_SANITY_CHECK)
+     /*!
+         * @brief This is fastest way for BME without sanity check.
+         */
+    /******************************************************************************
+        * macro used to generate hardcoded load 1 bit clear address (LAC1).
+        *
+        *******************************************************************************/
+
+    /*****************************************************************************//*!
+         *
+         * @brief  generates BME bit clear operation addresss (hardcoded 32-bit address) for 8-bit data.
+         *        
+         * @param[in]   ADDR  32-bit address.
+         * @param[in]   bit     bit number, 0-based.
+         *  
+         * @return  hardcoded 32-bit address.
+         *
+         * @ Pass/ Fail criteria: none.
+         *
+      *****************************************************************************/
+    
+    #define BME_BIT_CLEAR_8b(ADDR,bit)        (*(volatile uint8_t *)(((uint32_t)ADDR)   \
+                                  | (BME_OPCODE_BIT_CLEAR <<26)  \
+                                  | ((bit)<<21)))                                                
+
+    /******************************************************************************
+        * macro used to generate hardcoded load 1 bit set address (LAS1).
+        *
+        *******************************************************************************/
+    /*****************************************************************************//*!
+             *
+             * @brief  generates BME bit set operation addresss (hardcoded 32-bit address) for 8-bit data.
+             *        
+             * @param[in]   ADDR  32-bit address.
+             * @param[in]   bit     bit number, 0-based.
+             *  
+             * @return  hardcoded 32-bit address.
+             *
+             * @ Pass/ Fail criteria: none.
+             *
+        *****************************************************************************/
+    
+    #define BME_BIT_SET_8b(ADDR,bit)        (*(volatile uint8_t *)(((uint32_t)ADDR)   \
+                                  | (BME_OPCODE_BIT_SET <<26)  \
+                                  | ((bit)<<21)))                                                
+
+  /******************************************************************************
+    * macro used to generate hardcoded bit field insert address (BFI).
+    *
+    *******************************************************************************/
+
+    /*****************************************************************************//*!
+          *
+          * @brief  generates BME bitfield insert operation addresss (hardcoded 32-bit address) for 8-bit data.
+          *        
+          * @param[in]   ADDR  32-bit address.
+          * @param[in]   bit      bit number, 0-based.
+          * @param[in]   width  bitfield width, 1-based.
+          *  
+          * @return  hardcoded 32-bit address.
+          *
+          * @ Pass/ Fail criteria: none.
+          *
+       *****************************************************************************/        
+
+    #define BME_BITFIELD_INSERT_8b(ADDR,bit,width)        (*(volatile uint8_t *)(((uint32_t)ADDR)   \
+                                  | (BME_OPCODE_BITFIELD <<26)  \
+                                  | ((bit)<<23) | ((width-1))<<19))                        
+  /******************************************************************************
+    * macro used to generate hardcoded bit field extract address (UBFX).
+    *
+    *******************************************************************************/
+   /*****************************************************************************//*!
+         *
+         * @brief  generates BME bitfield extract operation addresss (hardcoded 32-bit address) for 8-bit data.
+         *        
+         * @param[in]   ADDR  32-bit address.
+         * @param[in]   bit      bit number, 0-based.
+         * @param[in]   width  bitfield width, 1-based.
+         *  
+         * @return  hardcoded 32-bit address.
+         *
+         * @ Pass/ Fail criteria: none.
+         *
+      *****************************************************************************/        
+    #define BME_BITFIELD_EXTRACT_8b(ADDR,bit,width)        (*(volatile uint8_t *)(((uint32_t)ADDR)    \
+                                  | (BME_OPCODE_BITFIELD <<26)  \
+                                  | ((bit<<23) | ((width-1))<<19))                        
+#else
+    /*!
+     * @brief This is slow way for BME as it has sanity check.
+     */
+    /******************************************************************************
+    * macro used to generate hardcoded load 1 bit clear address (LAC1).
+    *
+    *******************************************************************************/
+    #define BME_BIT_CLEAR_8b(ADDR,bit)        (*(volatile uint8_t *)(((uint32_t)ADDR)   \
+                                  | (BME_OPCODE_BIT_CLEAR <<26)  \
+                                  | ((bit & 0x1F)<<21)))                                                /*!< Bit clear operation on 8-bit*/
+
+    /******************************************************************************
+    * macro used to generate hardcoded load 1 bit set address (LAS1).
+    *
+    *******************************************************************************/
+    #define BME_BIT_SET_8b(ADDR,bit)        (*(volatile uint8_t *)(((uint32_t)ADDR)   \
+                                  | (BME_OPCODE_BIT_SET <<26)  \
+                                  | ((bit & 0x1F)<<21)))                                                /*!< Bit set operation on 8-bit */
+
+    /******************************************************************************
+    * macro used to generate hardcoded bit field insert address (BFI).
+    *
+    *******************************************************************************/
+    #define BME_BITFIELD_INSERT_8b(ADDR,bit,width)        (*(volatile uint8_t *)(((uint32_t)ADDR)   \
+                                  | (BME_OPCODE_BITFIELD <<26)  \
+                                  | ((bit & 0x1F)<<23) | ((width-1) & 0xF)<<19))                        /*!< Bitfield insert operation on 8-bit */
+
+  /******************************************************************************
+    * macro used to generate hardcoded bit field extract address (UBFX).
+    *
+    *******************************************************************************/
+
+    #define BME_BITFIELD_EXTRACT_8b(ADDR,bit,width)        (*(volatile uint8_t *)(((uint32_t)ADDR)    \
+                                  | (BME_OPCODE_BITFIELD <<26)  \
+                                  | ((bit & 0x1F)<<23) | ((width-1) & 0xF)<<19))                        /*!< Bitfield extract operation on 8-bit*/
+#endif
+
+
+/******************************************************************************
+* The following macros are used to generate hardcoded address for 16-bit operation.
+*
+*******************************************************************************/
+
+/******************************************************************************
+* macro used to generate hardcoded AND address for 16-bit operation.
+*
+*******************************************************************************/
+/*****************************************************************************//*!
+   *
+   * @brief  generates BME AND operation addresss (hardcoded 32-bit address) for 16-bit data.
+   *        
+   * @param[in]   ADDR  32-bit address.
+   *  
+   * @return  hardcoded 32-bit address.
+   *
+   * @ Pass/ Fail criteria: none.
+   *
+*****************************************************************************/
+
+#define BME_AND_16b(ADDR)           (*(volatile uint16_t *)(((uint32_t)ADDR) | (BME_OPCODE_AND<<26)))   
+
+/******************************************************************************
+* macro used to generate hardcoded OR address.
+*
+*******************************************************************************/
+
+/*****************************************************************************//*!
+   *
+   * @brief  generates BME OR operation addresss (hardcoded 32-bit address) for 16-bit data.
+   *        
+   * @param[in]   ADDR  32-bit address.
+   *  
+   * @return  hardcoded 32-bit address.
+   *
+   * @ Pass/ Fail criteria: none.
+   *
+*****************************************************************************/
+
+#define BME_OR_16b(ADDR)           (*(volatile uint16_t *)(((uint32_t)ADDR) | (BME_OPCODE_OR<<26)))    
+
+
+/******************************************************************************
+* macro used to generate hardcoded XOR address.
+*
+*******************************************************************************/
+
+/*****************************************************************************//*!
+   *
+   * @brief  generates BME XOR operation addresss (hardcoded 32-bit address) for 16-bit data.
+   *        
+   * @param[in]   ADDR  32-bit address.
+   *  
+   * @return  hardcoded 32-bit address.
+   *
+   * @ Pass/ Fail criteria: none.
+   *
+*****************************************************************************/
+
+#define BME_XOR_16b(ADDR)           (*(volatile uint16_t *)(((uint32_t)ADDR) | (BME_OPCODE_XOR<<26)))   
+
+
+#if !defined(BME_SANITY_CHECK)
+  /*!
+     * @brief This is fastest way for BME without sanity check.
+     */
+
+  /******************************************************************************
+    * macro used to generate hardcoded load 1 bit clear address (LAC1).
+    *
+    *******************************************************************************/
+    /*****************************************************************************//*!
+             *
+             * @brief  generates BME bit clear operation addresss (hardcoded 32-bit address) for 16-bit data.
+             *        
+             * @param[in]   ADDR  32-bit address.
+             * @param[in]   bit     bit number, 0-based.
+             *  
+             * @return  hardcoded 32-bit address.
+             *
+             * @ Pass/ Fail criteria: none.
+             *
+        *****************************************************************************/
+    
+    #define BME_BIT_CLEAR_16b(ADDR,bit)        (*(volatile uint16_t *)(((uint32_t)ADDR)   \
+                                  | (BME_OPCODE_BIT_CLEAR <<26)  \
+                                  | ((bit)<<21)))                                               
+
+    /******************************************************************************
+        * macro used to generate hardcoded load 1 bit set address (LAS1).
+        *
+        *******************************************************************************/
+    /*****************************************************************************//*!
+             *
+             * @brief  generates BME bit set operation addresss (hardcoded 32-bit address) for 16-bit data.
+             *        
+             * @param[in]   ADDR  32-bit address.
+             * @param[in]   bit     bit number, 0-based.
+             *  
+             * @return  hardcoded 32-bit address.
+             *
+             * @ Pass/ Fail criteria: none.
+             *
+        *****************************************************************************/
+    
+    #define BME_BIT_SET_16b(ADDR,bit)        (*(volatile uint16_t *)(((uint32_t)ADDR)   \
+                                  | (BME_OPCODE_BIT_SET <<26)  \
+                                  | ((bit)<<21)))                                                
+
+  /******************************************************************************
+    * macro used to generate hardcoded bit field insert address (BFI).
+    *
+    *******************************************************************************/
+    /*****************************************************************************//*!
+          *
+          * @brief  generates BME bitfield insert operation addresss (hardcoded 32-bit address) for 16-bit data.
+          *        
+          * @param[in]   ADDR  32-bit address.
+          * @param[in]   bit      bit number, 0-based.
+          * @param[in]   width  bitfield width, 1-based.
+          *  
+          * @return  hardcoded 32-bit address.
+          *
+          * @ Pass/ Fail criteria: none.
+          *
+       *****************************************************************************/        
+    
+    #define BME_BITFIELD_INSERT_16b(ADDR,bit,width)        (*(volatile uint16_t *)(((uint32_t)ADDR)   \
+                                  | (BME_OPCODE_BITFIELD <<26)  \
+                                  | ((bit)<<23) | ((width-1))<<19))                        
+
+
+  /******************************************************************************
+    * macro used to generate hardcoded bit field extract address (UBFX).
+    *
+    *******************************************************************************/
+    /*****************************************************************************//*!
+          *
+          * @brief  generates BME bitfield extract operation addresss (hardcoded 32-bit address) for 16-bit data.
+          *        
+          * @param[in]   ADDR  32-bit address.
+          * @param[in]   bit      bit number, 0-based.
+          * @param[in]   width  bitfield width, 1-based.
+          *  
+          * @return  hardcoded 32-bit address.
+          *
+          * @ Pass/ Fail criteria: none.
+          *
+       *****************************************************************************/        
+
+    #define BME_BITFIELD_EXTRACT_16b(ADDR,bit,width)        (*(volatile uint16_t *)(((uint32_t)ADDR)    \
+                                  | (BME_OPCODE_BITFIELD <<26)  \
+                                  | ((bit)<<23) | ((width-1))<<19))                        
+
+#else
+    /*!
+     * @brief This is slow way for BME as it has sanity check.
+     */
+    /******************************************************************************
+    * macro used to generate hardcoded load 1 bit clear address (LAC1).
+    *
+    *******************************************************************************/
+    #define BME_BIT_CLEAR_16b(ADDR,bit)        (*(volatile uint16_t *)(((uint32_t)ADDR)   \
+                                  | (BME_OPCODE_BIT_CLEAR <<26)  \
+                                  | ((bit & 0x1F)<<21)))                                                /*!< Bit clear operation on 16-bit*/
+
+    /******************************************************************************
+    * macro used to generate hardcoded load 1 bit set address (LAS1).
+    *
+    *******************************************************************************/
+    #define BME_BIT_SET_16b(ADDR,bit)        (*(volatile uint16_t *)(((uint32_t)ADDR)   \
+                                  | (BME_OPCODE_BIT_SET <<26)  \
+                                  | ((bit & 0x1F)<<21)))                                                /*!< Bit set operation on 16-bit */
+
+    /******************************************************************************
+    * macro used to generate hardcoded bit field insert address (BFI).
+    *
+    *******************************************************************************/
+    #define BME_BITFIELD_INSERT_16b(ADDR,bit,width)        (*(volatile uint16_t *)(((uint32_t)ADDR)   \
+                                  | (BME_OPCODE_BITFIELD <<26)  \
+                                  | ((bit & 0x1F)<<23) | ((width-1) & 0xF)<<19))                        /*!< Bitfield insert operation on 16-bit */
+
+
+    /******************************************************************************
+    * macro used to generate hardcoded bit field extract address (UBFX).
+    *
+    *******************************************************************************/
+    #define BME_BITFIELD_EXTRACT_16b(ADDR,bit,width)        (*(volatile uint16_t *)(((uint32_t)ADDR)    \
+                                  | (BME_OPCODE_BITFIELD <<26)  \
+                                  | ((bit & 0x1F)<<23) | ((width-1) & 0xF)<<19))                        /*!< Bitfield extract operation on 16-bit*/
+#endif
+
+/*! @} End of BME_Utilities                                                   */
+#ifdef __cplusplus
+}
+#endif
+#endif /* __BME_H */
+
+
diff --git a/bsp/frdm-ke02/device/lib/inc/MKE02Z2.h b/bsp/frdm-ke02/device/lib/inc/MKE02Z2.h
new file mode 100755
index 0000000..896eb8a
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/MKE02Z2.h
@@ -0,0 +1,2930 @@
+/*
+** ###################################################################
+**     Compilers:           ARM Compiler
+**                          Freescale C/C++ for Embedded ARM
+**                          GNU C Compiler
+**                          IAR ANSI C/C++ Compiler for ARM
+**
+**     Reference manual:    MKE02Z64M20SF0RM, Rev.2.1, Apr-23 2013
+**     Version:             rev. 1.4, 2013-07-10
+**
+**     Abstract:
+**         CMSIS Peripheral Access Layer for MKE02Z2
+**
+**     Copyright: 1997 - 2013 Freescale, Inc. All Rights Reserved.
+**
+**     http:                 www.freescale.com
+**     mail:                 support@freescale.com
+**
+**     Revisions:
+**     - rev. 1.0 (2013-02-06)
+**         Initial version.
+**     - rev. 1.1 (2013-04-05)
+**         Changed start of doxygen comment.
+**     - rev. 1.2 (2013-05-07)
+**         Update according to reference manual rev. 2.1.
+**     - rev. 1.3 (2013-06-13)
+**         Device types PTA,PTB,FPTA,FPTB changed to GPIOA,GPIOB,FGPIOA,FGPIOB.
+**     - rev. 1.4 (2013-07-10)
+**         NV - DFPROT register renamed to EEPROT.
+**         WDOG - Peripheral register layout structure has been extended with 16-bit access registers CNT, TOVAL, WIN.
+**
+** ###################################################################
+*/
+
+/*!
+ * @file MKE02Z2.h
+ * @version 1.4
+ * @date 2013-07-10
+ * @brief CMSIS Peripheral Access Layer for MKE02Z2
+ *
+ * CMSIS Peripheral Access Layer for MKE02Z2
+ */
+
+#if !defined(MKE02Z2_H_)
+#define MKE02Z2_H_                               /**< Symbol preventing repeated inclusion */
+
+/** Memory map major version (memory maps with equal major version number are
+ * compatible) */
+#define MCU_MEM_MAP_VERSION 0x0100u
+/** Memory map minor version */
+#define MCU_MEM_MAP_VERSION_MINOR 0x0004u
+
+
+/* ----------------------------------------------------------------------------
+   -- Interrupt vector numbers
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup Interrupt_vector_numbers Interrupt vector numbers
+ * @{
+ */
+
+/** Interrupt Number Definitions */
+typedef enum IRQn {
+  /* Core interrupts */
+  NonMaskableInt_IRQn          = -14,              /**< Non Maskable Interrupt */
+  HardFault_IRQn               = -13,              /**< Cortex-M0 SV Hard Fault Interrupt */
+  SVCall_IRQn                  = -5,               /**< Cortex-M0 SV Call Interrupt */
+  PendSV_IRQn                  = -2,               /**< Cortex-M0 Pend SV Interrupt */
+  SysTick_IRQn                 = -1,               /**< Cortex-M0 System Tick Interrupt */
+
+  /* Device specific interrupts */
+  Reserved16_IRQn              = 0,                /**< Reserved interrupt 16 */
+  Reserved17_IRQn              = 1,                /**< Reserved interrupt 17 */
+  Reserved18_IRQn              = 2,                /**< Reserved interrupt 18 */
+  Reserved19_IRQn              = 3,                /**< Reserved interrupt 19 */
+  Reserved20_IRQn              = 4,                /**< Reserved interrupt 20 */
+  FTMRH_IRQn                   = 5,                /**< FTMRH command complete/read collision interrupt */
+  LVD_LVW_IRQn                 = 6,                /**< Low Voltage Detect, Low Voltage Warning */
+  IRQ_IRQn                     = 7,                /**< External interrupt */
+  I2C0_IRQn                    = 8,                /**< I2C0 interrupt */
+  Reserved25_IRQn              = 9,                /**< Reserved interrupt 25 */
+  SPI0_IRQn                    = 10,               /**< SPI0 interrupt */
+  SPI1_IRQn                    = 11,               /**< SPI1 interrupt */
+  UART0_IRQn                   = 12,               /**< UART0 status/error interrupt */
+  UART1_IRQn                   = 13,               /**< UART1 status/error interrupt */
+  UART2_IRQn                   = 14,               /**< UART2 status/error interrupt */
+  ADC0_IRQn                    = 15,               /**< ADC0 interrupt */
+  ACMP0_IRQn                   = 16,               /**< ACMP0 interrupt */
+  FTM0_IRQn                    = 17,               /**< FTM0 Single interrupt vector for all sources */
+  FTM1_IRQn                    = 18,               /**< FTM1 Single interrupt vector for all sources */
+  FTM2_IRQn                    = 19,               /**< FTM2 Single interrupt vector for all sources */
+  RTC_IRQn                     = 20,               /**< RTC overflow */
+  ACMP1_IRQn                   = 21,               /**< ACMP1 interrupt */
+  PIT_CH0_IRQn                 = 22,               /**< PIT CH0 overflow */
+  PIT_CH1_IRQn                 = 23,               /**< PIT CH1 overflow */
+  KBI0_IRQn                    = 24,               /**< Keyboard interrupt 0 */
+  KBI1_IRQn                    = 25,               /**< Keyboard interrupt 1 */
+  Reserved42_IRQn              = 26,               /**< Reserved interrupt 42 */
+  ICS_IRQn                     = 27,               /**< ICS interrupt */
+  Watchdog_IRQn                = 28,               /**< WDOG Interrupt */
+  Reserved45_IRQn              = 29,               /**< Reserved interrupt 45 */
+  Reserved46_IRQn              = 30,               /**< Reserved interrupt 46 */
+  Reserved47_IRQn              = 31                /**< Reserved interrupt 47 */
+} IRQn_Type;
+
+/*!
+ * @}
+ */ /* end of group Interrupt_vector_numbers */
+
+
+/* ----------------------------------------------------------------------------
+   -- Cortex M0 Core Configuration
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup Cortex_Core_Configuration Cortex M0 Core Configuration
+ * @{
+ */
+
+#define __CM0PLUS_REV                  0x0000    /**< Core revision r0p0 */
+#define __MPU_PRESENT                  0         /**< Defines if an MPU is present or not */
+#define __VTOR_PRESENT                 1         /**< Defines if an MPU is present or not */
+#define __NVIC_PRIO_BITS               2         /**< Number of priority bits implemented in the NVIC */
+#define __Vendor_SysTickConfig         0         /**< Vendor specific implementation of SysTickConfig is defined */
+
+#include "core_cm0plus.h"              /* Core Peripheral Access Layer */
+#include "system_MKE02Z2.h"            /* Device specific configuration file */
+
+/*!
+ * @}
+ */ /* end of group Cortex_Core_Configuration */
+
+
+/* ----------------------------------------------------------------------------
+   -- Device Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup Peripheral_access_layer Device Peripheral Access Layer
+ * @{
+ */
+
+
+/*
+** Start of section using anonymous unions
+*/
+
+#if defined(__ARMCC_VERSION)
+  #pragma push
+  #pragma anon_unions
+#elif defined(__CWCC__)
+  #pragma push
+  #pragma cpp_extensions on
+#elif defined(__GNUC__)
+  /* anonymous unions are enabled by default */
+#elif defined(__IAR_SYSTEMS_ICC__)
+  #pragma language=extended
+#else
+  #error Not supported compiler type
+#endif
+
+/* ----------------------------------------------------------------------------
+   -- ACMP Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup ACMP_Peripheral_Access_Layer ACMP Peripheral Access Layer
+ * @{
+ */
+
+/** ACMP - Register Layout Typedef */
+typedef struct {
+  __IO uint8_t CS;                                 /**< ACMP Control and Status Register, offset: 0x0 */
+  __IO uint8_t C0;                                 /**< ACMP Control Register 0, offset: 0x1 */
+  __IO uint8_t C1;                                 /**< ACMP Control Register 1, offset: 0x2 */
+  __IO uint8_t C2;                                 /**< ACMP Control Register 2, offset: 0x3 */
+} ACMP_Type;
+
+/* ----------------------------------------------------------------------------
+   -- ACMP Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup ACMP_Register_Masks ACMP Register Masks
+ * @{
+ */
+
+/* CS Bit Fields */
+#define ACMP_CS_ACMOD_MASK                       0x3u
+#define ACMP_CS_ACMOD_SHIFT                      0
+#define ACMP_CS_ACMOD(x)                         (((uint8_t)(((uint8_t)(x))<<ACMP_CS_ACMOD_SHIFT))&ACMP_CS_ACMOD_MASK)
+#define ACMP_CS_ACOPE_MASK                       0x4u
+#define ACMP_CS_ACOPE_SHIFT                      2
+#define ACMP_CS_ACO_MASK                         0x8u
+#define ACMP_CS_ACO_SHIFT                        3
+#define ACMP_CS_ACIE_MASK                        0x10u
+#define ACMP_CS_ACIE_SHIFT                       4
+#define ACMP_CS_ACF_MASK                         0x20u
+#define ACMP_CS_ACF_SHIFT                        5
+#define ACMP_CS_HYST_MASK                        0x40u
+#define ACMP_CS_HYST_SHIFT                       6
+#define ACMP_CS_ACE_MASK                         0x80u
+#define ACMP_CS_ACE_SHIFT                        7
+/* C0 Bit Fields */
+#define ACMP_C0_ACNSEL_MASK                      0x3u
+#define ACMP_C0_ACNSEL_SHIFT                     0
+#define ACMP_C0_ACNSEL(x)                        (((uint8_t)(((uint8_t)(x))<<ACMP_C0_ACNSEL_SHIFT))&ACMP_C0_ACNSEL_MASK)
+#define ACMP_C0_ACPSEL_MASK                      0x30u
+#define ACMP_C0_ACPSEL_SHIFT                     4
+#define ACMP_C0_ACPSEL(x)                        (((uint8_t)(((uint8_t)(x))<<ACMP_C0_ACPSEL_SHIFT))&ACMP_C0_ACPSEL_MASK)
+/* C1 Bit Fields */
+#define ACMP_C1_DACVAL_MASK                      0x3Fu
+#define ACMP_C1_DACVAL_SHIFT                     0
+#define ACMP_C1_DACVAL(x)                        (((uint8_t)(((uint8_t)(x))<<ACMP_C1_DACVAL_SHIFT))&ACMP_C1_DACVAL_MASK)
+#define ACMP_C1_DACREF_MASK                      0x40u
+#define ACMP_C1_DACREF_SHIFT                     6
+#define ACMP_C1_DACEN_MASK                       0x80u
+#define ACMP_C1_DACEN_SHIFT                      7
+/* C2 Bit Fields */
+#define ACMP_C2_ACIPE_MASK                       0x7u
+#define ACMP_C2_ACIPE_SHIFT                      0
+#define ACMP_C2_ACIPE(x)                         (((uint8_t)(((uint8_t)(x))<<ACMP_C2_ACIPE_SHIFT))&ACMP_C2_ACIPE_MASK)
+
+/*!
+ * @}
+ */ /* end of group ACMP_Register_Masks */
+
+
+/* ACMP - Peripheral instance base addresses */
+/** Peripheral ACMP0 base address */
+#define ACMP0_BASE                               (0x40073000u)
+/** Peripheral ACMP0 base pointer */
+#define ACMP0                                    ((ACMP_Type *)ACMP0_BASE)
+/** Peripheral ACMP1 base address */
+#define ACMP1_BASE                               (0x40074000u)
+/** Peripheral ACMP1 base pointer */
+#define ACMP1                                    ((ACMP_Type *)ACMP1_BASE)
+/** Array initializer of ACMP peripheral base pointers */
+#define ACMP_BASES                               { ACMP0, ACMP1 }
+
+/*!
+ * @}
+ */ /* end of group ACMP_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- ADC Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup ADC_Peripheral_Access_Layer ADC Peripheral Access Layer
+ * @{
+ */
+
+/** ADC - Register Layout Typedef */
+typedef struct {
+  __IO uint32_t SC1;                               /**< Status and Control Register 1, offset: 0x0 */
+  __IO uint32_t SC2;                               /**< Status and Control Register 2, offset: 0x4 */
+  __IO uint32_t SC3;                               /**< Status and Control Register 3, offset: 0x8 */
+  __IO uint32_t SC4;                               /**< Status and Control Register 4, offset: 0xC */
+  __I  uint32_t R;                                 /**< Conversion Result Register, offset: 0x10 */
+  __IO uint32_t CV;                                /**< Compare Value Register, offset: 0x14 */
+  __IO uint32_t APCTL1;                            /**< Pin Control 1 Register, offset: 0x18 */
+} ADC_Type;
+
+/* ----------------------------------------------------------------------------
+   -- ADC Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup ADC_Register_Masks ADC Register Masks
+ * @{
+ */
+
+/* SC1 Bit Fields */
+#define ADC_SC1_ADCH_MASK                        0x1Fu
+#define ADC_SC1_ADCH_SHIFT                       0
+#define ADC_SC1_ADCH(x)                          (((uint32_t)(((uint32_t)(x))<<ADC_SC1_ADCH_SHIFT))&ADC_SC1_ADCH_MASK)
+#define ADC_SC1_ADCO_MASK                        0x20u
+#define ADC_SC1_ADCO_SHIFT                       5
+#define ADC_SC1_AIEN_MASK                        0x40u
+#define ADC_SC1_AIEN_SHIFT                       6
+#define ADC_SC1_COCO_MASK                        0x80u
+#define ADC_SC1_COCO_SHIFT                       7
+/* SC2 Bit Fields */
+#define ADC_SC2_REFSEL_MASK                      0x3u
+#define ADC_SC2_REFSEL_SHIFT                     0
+#define ADC_SC2_REFSEL(x)                        (((uint32_t)(((uint32_t)(x))<<ADC_SC2_REFSEL_SHIFT))&ADC_SC2_REFSEL_MASK)
+#define ADC_SC2_FFULL_MASK                       0x4u
+#define ADC_SC2_FFULL_SHIFT                      2
+#define ADC_SC2_FEMPTY_MASK                      0x8u
+#define ADC_SC2_FEMPTY_SHIFT                     3
+#define ADC_SC2_ACFGT_MASK                       0x10u
+#define ADC_SC2_ACFGT_SHIFT                      4
+#define ADC_SC2_ACFE_MASK                        0x20u
+#define ADC_SC2_ACFE_SHIFT                       5
+#define ADC_SC2_ADTRG_MASK                       0x40u
+#define ADC_SC2_ADTRG_SHIFT                      6
+#define ADC_SC2_ADACT_MASK                       0x80u
+#define ADC_SC2_ADACT_SHIFT                      7
+/* SC3 Bit Fields */
+#define ADC_SC3_ADICLK_MASK                      0x3u
+#define ADC_SC3_ADICLK_SHIFT                     0
+#define ADC_SC3_ADICLK(x)                        (((uint32_t)(((uint32_t)(x))<<ADC_SC3_ADICLK_SHIFT))&ADC_SC3_ADICLK_MASK)
+#define ADC_SC3_MODE_MASK                        0xCu
+#define ADC_SC3_MODE_SHIFT                       2
+#define ADC_SC3_MODE(x)                          (((uint32_t)(((uint32_t)(x))<<ADC_SC3_MODE_SHIFT))&ADC_SC3_MODE_MASK)
+#define ADC_SC3_ADLSMP_MASK                      0x10u
+#define ADC_SC3_ADLSMP_SHIFT                     4
+#define ADC_SC3_ADIV_MASK                        0x60u
+#define ADC_SC3_ADIV_SHIFT                       5
+#define ADC_SC3_ADIV(x)                          (((uint32_t)(((uint32_t)(x))<<ADC_SC3_ADIV_SHIFT))&ADC_SC3_ADIV_MASK)
+#define ADC_SC3_ADLPC_MASK                       0x80u
+#define ADC_SC3_ADLPC_SHIFT                      7
+/* SC4 Bit Fields */
+#define ADC_SC4_AFDEP_MASK                       0x7u
+#define ADC_SC4_AFDEP_SHIFT                      0
+#define ADC_SC4_AFDEP(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_SC4_AFDEP_SHIFT))&ADC_SC4_AFDEP_MASK)
+#define ADC_SC4_ACFSEL_MASK                      0x20u
+#define ADC_SC4_ACFSEL_SHIFT                     5
+#define ADC_SC4_ASCANE_MASK                      0x40u
+#define ADC_SC4_ASCANE_SHIFT                     6
+/* R Bit Fields */
+#define ADC_R_ADR_MASK                           0xFFFu
+#define ADC_R_ADR_SHIFT                          0
+#define ADC_R_ADR(x)                             (((uint32_t)(((uint32_t)(x))<<ADC_R_ADR_SHIFT))&ADC_R_ADR_MASK)
+/* CV Bit Fields */
+#define ADC_CV_CV_MASK                           0xFFFu
+#define ADC_CV_CV_SHIFT                          0
+#define ADC_CV_CV(x)                             (((uint32_t)(((uint32_t)(x))<<ADC_CV_CV_SHIFT))&ADC_CV_CV_MASK)
+/* APCTL1 Bit Fields */
+#define ADC_APCTL1_ADPC_MASK                     0xFFFFFFFFu
+#define ADC_APCTL1_ADPC_SHIFT                    0
+#define ADC_APCTL1_ADPC(x)                       (((uint32_t)(((uint32_t)(x))<<ADC_APCTL1_ADPC_SHIFT))&ADC_APCTL1_ADPC_MASK)
+
+/*!
+ * @}
+ */ /* end of group ADC_Register_Masks */
+
+
+/* ADC - Peripheral instance base addresses */
+/** Peripheral ADC base address */
+#define ADC_BASE                                 (0x4003B000u)
+/** Peripheral ADC base pointer */
+#define ADC                                      ((ADC_Type *)ADC_BASE)
+/** Array initializer of ADC peripheral base pointers */
+#define ADC_BASES                                { ADC }
+
+/*!
+ * @}
+ */ /* end of group ADC_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- CRC Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup CRC_Peripheral_Access_Layer CRC Peripheral Access Layer
+ * @{
+ */
+
+/** CRC - Register Layout Typedef */
+typedef struct {
+  union {                                          /* offset: 0x0 */
+    struct {                                         /* offset: 0x0 */
+      __IO uint16_t DATAL;                             /**< CRC_DATAL register., offset: 0x0 */
+      __IO uint16_t DATAH;                             /**< CRC_DATAH register., offset: 0x2 */
+    } ACCESS16BIT;
+    __IO uint32_t DATA;                              /**< CRC Data register, offset: 0x0 */
+    struct {                                         /* offset: 0x0 */
+      __IO uint8_t DATALL;                             /**< CRC_DATALL register., offset: 0x0 */
+      __IO uint8_t DATALU;                             /**< CRC_DATALU register., offset: 0x1 */
+      __IO uint8_t DATAHL;                             /**< CRC_DATAHL register., offset: 0x2 */
+      __IO uint8_t DATAHU;                             /**< CRC_DATAHU register., offset: 0x3 */
+    } ACCESS8BIT;
+  };
+  union {                                          /* offset: 0x4 */
+    struct {                                         /* offset: 0x4 */
+      __IO uint16_t GPOLYL;                            /**< CRC_GPOLYL register., offset: 0x4 */
+      __IO uint16_t GPOLYH;                            /**< CRC_GPOLYH register., offset: 0x6 */
+    } GPOLY_ACCESS16BIT;
+    __IO uint32_t GPOLY;                             /**< CRC Polynomial register, offset: 0x4 */
+    struct {                                         /* offset: 0x4 */
+      __IO uint8_t GPOLYLL;                            /**< CRC_GPOLYLL register., offset: 0x4 */
+      __IO uint8_t GPOLYLU;                            /**< CRC_GPOLYLU register., offset: 0x5 */
+      __IO uint8_t GPOLYHL;                            /**< CRC_GPOLYHL register., offset: 0x6 */
+      __IO uint8_t GPOLYHU;                            /**< CRC_GPOLYHU register., offset: 0x7 */
+    } GPOLY_ACCESS8BIT;
+  };
+  union {                                          /* offset: 0x8 */
+    __IO uint32_t CTRL;                              /**< CRC Control register, offset: 0x8 */
+    struct {                                         /* offset: 0x8 */
+           uint8_t RESERVED_0[3];
+      __IO uint8_t CTRLHU;                             /**< CRC_CTRLHU register., offset: 0xB */
+    } CTRL_ACCESS8BIT;
+  };
+} CRC_Type;
+
+/* ----------------------------------------------------------------------------
+   -- CRC Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup CRC_Register_Masks CRC Register Masks
+ * @{
+ */
+
+/* DATAL Bit Fields */
+#define CRC_DATAL_DATAL_MASK                     0xFFFFu
+#define CRC_DATAL_DATAL_SHIFT                    0
+#define CRC_DATAL_DATAL(x)                       (((uint16_t)(((uint16_t)(x))<<CRC_DATAL_DATAL_SHIFT))&CRC_DATAL_DATAL_MASK)
+/* DATAH Bit Fields */
+#define CRC_DATAH_DATAH_MASK                     0xFFFFu
+#define CRC_DATAH_DATAH_SHIFT                    0
+#define CRC_DATAH_DATAH(x)                       (((uint16_t)(((uint16_t)(x))<<CRC_DATAH_DATAH_SHIFT))&CRC_DATAH_DATAH_MASK)
+/* DATA Bit Fields */
+#define CRC_DATA_LL_MASK                         0xFFu
+#define CRC_DATA_LL_SHIFT                        0
+#define CRC_DATA_LL(x)                           (((uint32_t)(((uint32_t)(x))<<CRC_DATA_LL_SHIFT))&CRC_DATA_LL_MASK)
+#define CRC_DATA_LU_MASK                         0xFF00u
+#define CRC_DATA_LU_SHIFT                        8
+#define CRC_DATA_LU(x)                           (((uint32_t)(((uint32_t)(x))<<CRC_DATA_LU_SHIFT))&CRC_DATA_LU_MASK)
+#define CRC_DATA_HL_MASK                         0xFF0000u
+#define CRC_DATA_HL_SHIFT                        16
+#define CRC_DATA_HL(x)                           (((uint32_t)(((uint32_t)(x))<<CRC_DATA_HL_SHIFT))&CRC_DATA_HL_MASK)
+#define CRC_DATA_HU_MASK                         0xFF000000u
+#define CRC_DATA_HU_SHIFT                        24
+#define CRC_DATA_HU(x)                           (((uint32_t)(((uint32_t)(x))<<CRC_DATA_HU_SHIFT))&CRC_DATA_HU_MASK)
+/* DATALL Bit Fields */
+#define CRC_DATALL_DATALL_MASK                   0xFFu
+#define CRC_DATALL_DATALL_SHIFT                  0
+#define CRC_DATALL_DATALL(x)                     (((uint8_t)(((uint8_t)(x))<<CRC_DATALL_DATALL_SHIFT))&CRC_DATALL_DATALL_MASK)
+/* DATALU Bit Fields */
+#define CRC_DATALU_DATALU_MASK                   0xFFu
+#define CRC_DATALU_DATALU_SHIFT                  0
+#define CRC_DATALU_DATALU(x)                     (((uint8_t)(((uint8_t)(x))<<CRC_DATALU_DATALU_SHIFT))&CRC_DATALU_DATALU_MASK)
+/* DATAHL Bit Fields */
+#define CRC_DATAHL_DATAHL_MASK                   0xFFu
+#define CRC_DATAHL_DATAHL_SHIFT                  0
+#define CRC_DATAHL_DATAHL(x)                     (((uint8_t)(((uint8_t)(x))<<CRC_DATAHL_DATAHL_SHIFT))&CRC_DATAHL_DATAHL_MASK)
+/* DATAHU Bit Fields */
+#define CRC_DATAHU_DATAHU_MASK                   0xFFu
+#define CRC_DATAHU_DATAHU_SHIFT                  0
+#define CRC_DATAHU_DATAHU(x)                     (((uint8_t)(((uint8_t)(x))<<CRC_DATAHU_DATAHU_SHIFT))&CRC_DATAHU_DATAHU_MASK)
+/* GPOLYL Bit Fields */
+#define CRC_GPOLYL_GPOLYL_MASK                   0xFFFFu
+#define CRC_GPOLYL_GPOLYL_SHIFT                  0
+#define CRC_GPOLYL_GPOLYL(x)                     (((uint16_t)(((uint16_t)(x))<<CRC_GPOLYL_GPOLYL_SHIFT))&CRC_GPOLYL_GPOLYL_MASK)
+/* GPOLYH Bit Fields */
+#define CRC_GPOLYH_GPOLYH_MASK                   0xFFFFu
+#define CRC_GPOLYH_GPOLYH_SHIFT                  0
+#define CRC_GPOLYH_GPOLYH(x)                     (((uint16_t)(((uint16_t)(x))<<CRC_GPOLYH_GPOLYH_SHIFT))&CRC_GPOLYH_GPOLYH_MASK)
+/* GPOLY Bit Fields */
+#define CRC_GPOLY_LOW_MASK                       0xFFFFu
+#define CRC_GPOLY_LOW_SHIFT                      0
+#define CRC_GPOLY_LOW(x)                         (((uint32_t)(((uint32_t)(x))<<CRC_GPOLY_LOW_SHIFT))&CRC_GPOLY_LOW_MASK)
+#define CRC_GPOLY_HIGH_MASK                      0xFFFF0000u
+#define CRC_GPOLY_HIGH_SHIFT                     16
+#define CRC_GPOLY_HIGH(x)                        (((uint32_t)(((uint32_t)(x))<<CRC_GPOLY_HIGH_SHIFT))&CRC_GPOLY_HIGH_MASK)
+/* GPOLYLL Bit Fields */
+#define CRC_GPOLYLL_GPOLYLL_MASK                 0xFFu
+#define CRC_GPOLYLL_GPOLYLL_SHIFT                0
+#define CRC_GPOLYLL_GPOLYLL(x)                   (((uint8_t)(((uint8_t)(x))<<CRC_GPOLYLL_GPOLYLL_SHIFT))&CRC_GPOLYLL_GPOLYLL_MASK)
+/* GPOLYLU Bit Fields */
+#define CRC_GPOLYLU_GPOLYLU_MASK                 0xFFu
+#define CRC_GPOLYLU_GPOLYLU_SHIFT                0
+#define CRC_GPOLYLU_GPOLYLU(x)                   (((uint8_t)(((uint8_t)(x))<<CRC_GPOLYLU_GPOLYLU_SHIFT))&CRC_GPOLYLU_GPOLYLU_MASK)
+/* GPOLYHL Bit Fields */
+#define CRC_GPOLYHL_GPOLYHL_MASK                 0xFFu
+#define CRC_GPOLYHL_GPOLYHL_SHIFT                0
+#define CRC_GPOLYHL_GPOLYHL(x)                   (((uint8_t)(((uint8_t)(x))<<CRC_GPOLYHL_GPOLYHL_SHIFT))&CRC_GPOLYHL_GPOLYHL_MASK)
+/* GPOLYHU Bit Fields */
+#define CRC_GPOLYHU_GPOLYHU_MASK                 0xFFu
+#define CRC_GPOLYHU_GPOLYHU_SHIFT                0
+#define CRC_GPOLYHU_GPOLYHU(x)                   (((uint8_t)(((uint8_t)(x))<<CRC_GPOLYHU_GPOLYHU_SHIFT))&CRC_GPOLYHU_GPOLYHU_MASK)
+/* CTRL Bit Fields */
+#define CRC_CTRL_TCRC_MASK                       0x1000000u
+#define CRC_CTRL_TCRC_SHIFT                      24
+#define CRC_CTRL_WAS_MASK                        0x2000000u
+#define CRC_CTRL_WAS_SHIFT                       25
+#define CRC_CTRL_FXOR_MASK                       0x4000000u
+#define CRC_CTRL_FXOR_SHIFT                      26
+#define CRC_CTRL_TOTR_MASK                       0x30000000u
+#define CRC_CTRL_TOTR_SHIFT                      28
+#define CRC_CTRL_TOTR(x)                         (((uint32_t)(((uint32_t)(x))<<CRC_CTRL_TOTR_SHIFT))&CRC_CTRL_TOTR_MASK)
+#define CRC_CTRL_TOT_MASK                        0xC0000000u
+#define CRC_CTRL_TOT_SHIFT                       30
+#define CRC_CTRL_TOT(x)                          (((uint32_t)(((uint32_t)(x))<<CRC_CTRL_TOT_SHIFT))&CRC_CTRL_TOT_MASK)
+/* CTRLHU Bit Fields */
+#define CRC_CTRLHU_TCRC_MASK                     0x1u
+#define CRC_CTRLHU_TCRC_SHIFT                    0
+#define CRC_CTRLHU_WAS_MASK                      0x2u
+#define CRC_CTRLHU_WAS_SHIFT                     1
+#define CRC_CTRLHU_FXOR_MASK                     0x4u
+#define CRC_CTRLHU_FXOR_SHIFT                    2
+#define CRC_CTRLHU_TOTR_MASK                     0x30u
+#define CRC_CTRLHU_TOTR_SHIFT                    4
+#define CRC_CTRLHU_TOTR(x)                       (((uint8_t)(((uint8_t)(x))<<CRC_CTRLHU_TOTR_SHIFT))&CRC_CTRLHU_TOTR_MASK)
+#define CRC_CTRLHU_TOT_MASK                      0xC0u
+#define CRC_CTRLHU_TOT_SHIFT                     6
+#define CRC_CTRLHU_TOT(x)                        (((uint8_t)(((uint8_t)(x))<<CRC_CTRLHU_TOT_SHIFT))&CRC_CTRLHU_TOT_MASK)
+
+/*!
+ * @}
+ */ /* end of group CRC_Register_Masks */
+
+
+/* CRC - Peripheral instance base addresses */
+/** Peripheral CRC base address */
+#define CRC_BASE                                 (0x40032000u)
+/** Peripheral CRC base pointer */
+#define CRC0                                     ((CRC_Type *)CRC_BASE)
+/** Array initializer of CRC peripheral base pointers */
+#define CRC_BASES                                { CRC0 }
+
+/*!
+ * @}
+ */ /* end of group CRC_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- FGPIO Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup FGPIO_Peripheral_Access_Layer FGPIO Peripheral Access Layer
+ * @{
+ */
+
+/** FGPIO - Register Layout Typedef */
+typedef struct {
+  __IO uint32_t PDOR;                              /**< Port Data Output Register, offset: 0x0 */
+  __O  uint32_t PSOR;                              /**< Port Set Output Register, offset: 0x4 */
+  __O  uint32_t PCOR;                              /**< Port Clear Output Register, offset: 0x8 */
+  __O  uint32_t PTOR;                              /**< Port Toggle Output Register, offset: 0xC */
+  __I  uint32_t PDIR;                              /**< Port Data Input Register, offset: 0x10 */
+  __IO uint32_t PDDR;                              /**< Port Data Direction Register, offset: 0x14 */
+  __IO uint32_t PIDR;                              /**< Port Input Disable Register, offset: 0x18 */
+} FGPIO_Type;
+
+/* ----------------------------------------------------------------------------
+   -- FGPIO Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup FGPIO_Register_Masks FGPIO Register Masks
+ * @{
+ */
+
+/* PDOR Bit Fields */
+#define FGPIO_PDOR_PDO_MASK                      0xFFFFFFFFu
+#define FGPIO_PDOR_PDO_SHIFT                     0
+#define FGPIO_PDOR_PDO(x)                        (((uint32_t)(((uint32_t)(x))<<FGPIO_PDOR_PDO_SHIFT))&FGPIO_PDOR_PDO_MASK)
+/* PSOR Bit Fields */
+#define FGPIO_PSOR_PTSO_MASK                     0xFFFFFFFFu
+#define FGPIO_PSOR_PTSO_SHIFT                    0
+#define FGPIO_PSOR_PTSO(x)                       (((uint32_t)(((uint32_t)(x))<<FGPIO_PSOR_PTSO_SHIFT))&FGPIO_PSOR_PTSO_MASK)
+/* PCOR Bit Fields */
+#define FGPIO_PCOR_PTCO_MASK                     0xFFFFFFFFu
+#define FGPIO_PCOR_PTCO_SHIFT                    0
+#define FGPIO_PCOR_PTCO(x)                       (((uint32_t)(((uint32_t)(x))<<FGPIO_PCOR_PTCO_SHIFT))&FGPIO_PCOR_PTCO_MASK)
+/* PTOR Bit Fields */
+#define FGPIO_PTOR_PTTO_MASK                     0xFFFFFFFFu
+#define FGPIO_PTOR_PTTO_SHIFT                    0
+#define FGPIO_PTOR_PTTO(x)                       (((uint32_t)(((uint32_t)(x))<<FGPIO_PTOR_PTTO_SHIFT))&FGPIO_PTOR_PTTO_MASK)
+/* PDIR Bit Fields */
+#define FGPIO_PDIR_PDI_MASK                      0xFFFFFFFFu
+#define FGPIO_PDIR_PDI_SHIFT                     0
+#define FGPIO_PDIR_PDI(x)                        (((uint32_t)(((uint32_t)(x))<<FGPIO_PDIR_PDI_SHIFT))&FGPIO_PDIR_PDI_MASK)
+/* PDDR Bit Fields */
+#define FGPIO_PDDR_PDD_MASK                      0xFFFFFFFFu
+#define FGPIO_PDDR_PDD_SHIFT                     0
+#define FGPIO_PDDR_PDD(x)                        (((uint32_t)(((uint32_t)(x))<<FGPIO_PDDR_PDD_SHIFT))&FGPIO_PDDR_PDD_MASK)
+/* PIDR Bit Fields */
+#define FGPIO_PIDR_PID_MASK                      0xFFFFFFFFu
+#define FGPIO_PIDR_PID_SHIFT                     0
+#define FGPIO_PIDR_PID(x)                        (((uint32_t)(((uint32_t)(x))<<FGPIO_PIDR_PID_SHIFT))&FGPIO_PIDR_PID_MASK)
+
+/*!
+ * @}
+ */ /* end of group FGPIO_Register_Masks */
+
+
+/* FGPIO - Peripheral instance base addresses */
+/** Peripheral FGPIOA base address */
+#define FGPIOA_BASE                              (0xF8000000u)
+/** Peripheral FGPIOA base pointer */
+#define FGPIOA                                   ((FGPIO_Type *)FGPIOA_BASE)
+/** Peripheral FGPIOB base address */
+#define FGPIOB_BASE                              (0xF8000040u)
+/** Peripheral FGPIOB base pointer */
+#define FGPIOB                                   ((FGPIO_Type *)FGPIOB_BASE)
+/** Array initializer of FGPIO peripheral base pointers */
+#define FGPIO_BASES                              { FGPIOA, FGPIOB }
+
+/*!
+ * @}
+ */ /* end of group FGPIO_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- FTM Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup FTM_Peripheral_Access_Layer FTM Peripheral Access Layer
+ * @{
+ */
+
+/** FTM - Register Layout Typedef */
+typedef struct {
+  __IO uint32_t SC;                                /**< Status And Control, offset: 0x0 */
+  __IO uint32_t CNT;                               /**< Counter, offset: 0x4 */
+  __IO uint32_t MOD;                               /**< Modulo, offset: 0x8 */
+  struct {                                         /* offset: 0xC, array step: 0x8 */
+    __IO uint32_t CnSC;                              /**< Channel (n) Status And Control, array offset: 0xC, array step: 0x8 */
+    __IO uint32_t CnV;                               /**< Channel (n) Value, array offset: 0x10, array step: 0x8 */
+  } CONTROLS[6];
+       uint8_t RESERVED_0[16];
+  __IO uint32_t CNTIN;                             /**< Counter Initial Value, offset: 0x4C */
+  __I  uint32_t STATUS;                            /**< Capture And Compare Status, offset: 0x50 */
+  __IO uint32_t MODE;                              /**< Features Mode Selection, offset: 0x54 */
+  __IO uint32_t SYNC;                              /**< Synchronization, offset: 0x58 */
+  __IO uint32_t OUTINIT;                           /**< Initial State For Channels Output, offset: 0x5C */
+  __IO uint32_t OUTMASK;                           /**< Output Mask, offset: 0x60 */
+  __IO uint32_t COMBINE;                           /**< Function For Linked Channels, offset: 0x64 */
+  __IO uint32_t DEADTIME;                          /**< Deadtime Insertion Control, offset: 0x68 */
+  __IO uint32_t EXTTRIG;                           /**< FTM External Trigger, offset: 0x6C */
+  __IO uint32_t POL;                               /**< Channels Polarity, offset: 0x70 */
+  __IO uint32_t FMS;                               /**< Fault Mode Status, offset: 0x74 */
+  __IO uint32_t FILTER;                            /**< Input Capture Filter Control, offset: 0x78 */
+  __IO uint32_t FLTCTRL;                           /**< Fault Control, offset: 0x7C */
+       uint8_t RESERVED_1[4];
+  __IO uint32_t CONF;                              /**< Configuration, offset: 0x84 */
+  __IO uint32_t FLTPOL;                            /**< FTM Fault Input Polarity, offset: 0x88 */
+  __IO uint32_t SYNCONF;                           /**< Synchronization Configuration, offset: 0x8C */
+  __IO uint32_t INVCTRL;                           /**< FTM Inverting Control, offset: 0x90 */
+  __IO uint32_t SWOCTRL;                           /**< FTM Software Output Control, offset: 0x94 */
+  __IO uint32_t PWMLOAD;                           /**< FTM PWM Load, offset: 0x98 */
+} FTM_Type;
+
+/* ----------------------------------------------------------------------------
+   -- FTM Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup FTM_Register_Masks FTM Register Masks
+ * @{
+ */
+
+/* SC Bit Fields */
+#define FTM_SC_PS_MASK                           0x7u
+#define FTM_SC_PS_SHIFT                          0
+#define FTM_SC_PS(x)                             (((uint32_t)(((uint32_t)(x))<<FTM_SC_PS_SHIFT))&FTM_SC_PS_MASK)
+#define FTM_SC_CLKS_MASK                         0x18u
+#define FTM_SC_CLKS_SHIFT                        3
+#define FTM_SC_CLKS(x)                           (((uint32_t)(((uint32_t)(x))<<FTM_SC_CLKS_SHIFT))&FTM_SC_CLKS_MASK)
+#define FTM_SC_CPWMS_MASK                        0x20u
+#define FTM_SC_CPWMS_SHIFT                       5
+#define FTM_SC_TOIE_MASK                         0x40u
+#define FTM_SC_TOIE_SHIFT                        6
+#define FTM_SC_TOF_MASK                          0x80u
+#define FTM_SC_TOF_SHIFT                         7
+/* CNT Bit Fields */
+#define FTM_CNT_COUNT_MASK                       0xFFFFu
+#define FTM_CNT_COUNT_SHIFT                      0
+#define FTM_CNT_COUNT(x)                         (((uint32_t)(((uint32_t)(x))<<FTM_CNT_COUNT_SHIFT))&FTM_CNT_COUNT_MASK)
+/* MOD Bit Fields */
+#define FTM_MOD_MOD_MASK                         0xFFFFu
+#define FTM_MOD_MOD_SHIFT                        0
+#define FTM_MOD_MOD(x)                           (((uint32_t)(((uint32_t)(x))<<FTM_MOD_MOD_SHIFT))&FTM_MOD_MOD_MASK)
+/* CnSC Bit Fields */
+#define FTM_CnSC_ELSA_MASK                       0x4u
+#define FTM_CnSC_ELSA_SHIFT                      2
+#define FTM_CnSC_ELSB_MASK                       0x8u
+#define FTM_CnSC_ELSB_SHIFT                      3
+#define FTM_CnSC_MSA_MASK                        0x10u
+#define FTM_CnSC_MSA_SHIFT                       4
+#define FTM_CnSC_MSB_MASK                        0x20u
+#define FTM_CnSC_MSB_SHIFT                       5
+#define FTM_CnSC_CHIE_MASK                       0x40u
+#define FTM_CnSC_CHIE_SHIFT                      6
+#define FTM_CnSC_CHF_MASK                        0x80u
+#define FTM_CnSC_CHF_SHIFT                       7
+/* CnV Bit Fields */
+#define FTM_CnV_VAL_MASK                         0xFFFFu
+#define FTM_CnV_VAL_SHIFT                        0
+#define FTM_CnV_VAL(x)                           (((uint32_t)(((uint32_t)(x))<<FTM_CnV_VAL_SHIFT))&FTM_CnV_VAL_MASK)
+/* CNTIN Bit Fields */
+#define FTM_CNTIN_INIT_MASK                      0xFFFFu
+#define FTM_CNTIN_INIT_SHIFT                     0
+#define FTM_CNTIN_INIT(x)                        (((uint32_t)(((uint32_t)(x))<<FTM_CNTIN_INIT_SHIFT))&FTM_CNTIN_INIT_MASK)
+/* STATUS Bit Fields */
+#define FTM_STATUS_CH0F_MASK                     0x1u
+#define FTM_STATUS_CH0F_SHIFT                    0
+#define FTM_STATUS_CH1F_MASK                     0x2u
+#define FTM_STATUS_CH1F_SHIFT                    1
+#define FTM_STATUS_CH2F_MASK                     0x4u
+#define FTM_STATUS_CH2F_SHIFT                    2
+#define FTM_STATUS_CH3F_MASK                     0x8u
+#define FTM_STATUS_CH3F_SHIFT                    3
+#define FTM_STATUS_CH4F_MASK                     0x10u
+#define FTM_STATUS_CH4F_SHIFT                    4
+#define FTM_STATUS_CH5F_MASK                     0x20u
+#define FTM_STATUS_CH5F_SHIFT                    5
+#define FTM_STATUS_CH6F_MASK                     0x40u
+#define FTM_STATUS_CH6F_SHIFT                    6
+#define FTM_STATUS_CH7F_MASK                     0x80u
+#define FTM_STATUS_CH7F_SHIFT                    7
+/* MODE Bit Fields */
+#define FTM_MODE_FTMEN_MASK                      0x1u
+#define FTM_MODE_FTMEN_SHIFT                     0
+#define FTM_MODE_INIT_MASK                       0x2u
+#define FTM_MODE_INIT_SHIFT                      1
+#define FTM_MODE_WPDIS_MASK                      0x4u
+#define FTM_MODE_WPDIS_SHIFT                     2
+#define FTM_MODE_PWMSYNC_MASK                    0x8u
+#define FTM_MODE_PWMSYNC_SHIFT                   3
+#define FTM_MODE_CAPTEST_MASK                    0x10u
+#define FTM_MODE_CAPTEST_SHIFT                   4
+#define FTM_MODE_FAULTM_MASK                     0x60u
+#define FTM_MODE_FAULTM_SHIFT                    5
+#define FTM_MODE_FAULTM(x)                       (((uint32_t)(((uint32_t)(x))<<FTM_MODE_FAULTM_SHIFT))&FTM_MODE_FAULTM_MASK)
+#define FTM_MODE_FAULTIE_MASK                    0x80u
+#define FTM_MODE_FAULTIE_SHIFT                   7
+/* SYNC Bit Fields */
+#define FTM_SYNC_CNTMIN_MASK                     0x1u
+#define FTM_SYNC_CNTMIN_SHIFT                    0
+#define FTM_SYNC_CNTMAX_MASK                     0x2u
+#define FTM_SYNC_CNTMAX_SHIFT                    1
+#define FTM_SYNC_REINIT_MASK                     0x4u
+#define FTM_SYNC_REINIT_SHIFT                    2
+#define FTM_SYNC_SYNCHOM_MASK                    0x8u
+#define FTM_SYNC_SYNCHOM_SHIFT                   3
+#define FTM_SYNC_TRIG0_MASK                      0x10u
+#define FTM_SYNC_TRIG0_SHIFT                     4
+#define FTM_SYNC_TRIG1_MASK                      0x20u
+#define FTM_SYNC_TRIG1_SHIFT                     5
+#define FTM_SYNC_TRIG2_MASK                      0x40u
+#define FTM_SYNC_TRIG2_SHIFT                     6
+#define FTM_SYNC_SWSYNC_MASK                     0x80u
+#define FTM_SYNC_SWSYNC_SHIFT                    7
+/* OUTINIT Bit Fields */
+#define FTM_OUTINIT_CH0OI_MASK                   0x1u
+#define FTM_OUTINIT_CH0OI_SHIFT                  0
+#define FTM_OUTINIT_CH1OI_MASK                   0x2u
+#define FTM_OUTINIT_CH1OI_SHIFT                  1
+#define FTM_OUTINIT_CH2OI_MASK                   0x4u
+#define FTM_OUTINIT_CH2OI_SHIFT                  2
+#define FTM_OUTINIT_CH3OI_MASK                   0x8u
+#define FTM_OUTINIT_CH3OI_SHIFT                  3
+#define FTM_OUTINIT_CH4OI_MASK                   0x10u
+#define FTM_OUTINIT_CH4OI_SHIFT                  4
+#define FTM_OUTINIT_CH5OI_MASK                   0x20u
+#define FTM_OUTINIT_CH5OI_SHIFT                  5
+#define FTM_OUTINIT_CH6OI_MASK                   0x40u
+#define FTM_OUTINIT_CH6OI_SHIFT                  6
+#define FTM_OUTINIT_CH7OI_MASK                   0x80u
+#define FTM_OUTINIT_CH7OI_SHIFT                  7
+/* OUTMASK Bit Fields */
+#define FTM_OUTMASK_CH0OM_MASK                   0x1u
+#define FTM_OUTMASK_CH0OM_SHIFT                  0
+#define FTM_OUTMASK_CH1OM_MASK                   0x2u
+#define FTM_OUTMASK_CH1OM_SHIFT                  1
+#define FTM_OUTMASK_CH2OM_MASK                   0x4u
+#define FTM_OUTMASK_CH2OM_SHIFT                  2
+#define FTM_OUTMASK_CH3OM_MASK                   0x8u
+#define FTM_OUTMASK_CH3OM_SHIFT                  3
+#define FTM_OUTMASK_CH4OM_MASK                   0x10u
+#define FTM_OUTMASK_CH4OM_SHIFT                  4
+#define FTM_OUTMASK_CH5OM_MASK                   0x20u
+#define FTM_OUTMASK_CH5OM_SHIFT                  5
+#define FTM_OUTMASK_CH6OM_MASK                   0x40u
+#define FTM_OUTMASK_CH6OM_SHIFT                  6
+#define FTM_OUTMASK_CH7OM_MASK                   0x80u
+#define FTM_OUTMASK_CH7OM_SHIFT                  7
+/* COMBINE Bit Fields */
+#define FTM_COMBINE_COMBINE0_MASK                0x1u
+#define FTM_COMBINE_COMBINE0_SHIFT               0
+#define FTM_COMBINE_COMP0_MASK                   0x2u
+#define FTM_COMBINE_COMP0_SHIFT                  1
+#define FTM_COMBINE_DECAPEN0_MASK                0x4u
+#define FTM_COMBINE_DECAPEN0_SHIFT               2
+#define FTM_COMBINE_DECAP0_MASK                  0x8u
+#define FTM_COMBINE_DECAP0_SHIFT                 3
+#define FTM_COMBINE_DTEN0_MASK                   0x10u
+#define FTM_COMBINE_DTEN0_SHIFT                  4
+#define FTM_COMBINE_SYNCEN0_MASK                 0x20u
+#define FTM_COMBINE_SYNCEN0_SHIFT                5
+#define FTM_COMBINE_FAULTEN0_MASK                0x40u
+#define FTM_COMBINE_FAULTEN0_SHIFT               6
+#define FTM_COMBINE_COMBINE1_MASK                0x100u
+#define FTM_COMBINE_COMBINE1_SHIFT               8
+#define FTM_COMBINE_COMP1_MASK                   0x200u
+#define FTM_COMBINE_COMP1_SHIFT                  9
+#define FTM_COMBINE_DECAPEN1_MASK                0x400u
+#define FTM_COMBINE_DECAPEN1_SHIFT               10
+#define FTM_COMBINE_DECAP1_MASK                  0x800u
+#define FTM_COMBINE_DECAP1_SHIFT                 11
+#define FTM_COMBINE_DTEN1_MASK                   0x1000u
+#define FTM_COMBINE_DTEN1_SHIFT                  12
+#define FTM_COMBINE_SYNCEN1_MASK                 0x2000u
+#define FTM_COMBINE_SYNCEN1_SHIFT                13
+#define FTM_COMBINE_FAULTEN1_MASK                0x4000u
+#define FTM_COMBINE_FAULTEN1_SHIFT               14
+#define FTM_COMBINE_COMBINE2_MASK                0x10000u
+#define FTM_COMBINE_COMBINE2_SHIFT               16
+#define FTM_COMBINE_COMP2_MASK                   0x20000u
+#define FTM_COMBINE_COMP2_SHIFT                  17
+#define FTM_COMBINE_DECAPEN2_MASK                0x40000u
+#define FTM_COMBINE_DECAPEN2_SHIFT               18
+#define FTM_COMBINE_DECAP2_MASK                  0x80000u
+#define FTM_COMBINE_DECAP2_SHIFT                 19
+#define FTM_COMBINE_DTEN2_MASK                   0x100000u
+#define FTM_COMBINE_DTEN2_SHIFT                  20
+#define FTM_COMBINE_SYNCEN2_MASK                 0x200000u
+#define FTM_COMBINE_SYNCEN2_SHIFT                21
+#define FTM_COMBINE_FAULTEN2_MASK                0x400000u
+#define FTM_COMBINE_FAULTEN2_SHIFT               22
+#define FTM_COMBINE_COMBINE3_MASK                0x1000000u
+#define FTM_COMBINE_COMBINE3_SHIFT               24
+#define FTM_COMBINE_COMP3_MASK                   0x2000000u
+#define FTM_COMBINE_COMP3_SHIFT                  25
+#define FTM_COMBINE_DECAPEN3_MASK                0x4000000u
+#define FTM_COMBINE_DECAPEN3_SHIFT               26
+#define FTM_COMBINE_DECAP3_MASK                  0x8000000u
+#define FTM_COMBINE_DECAP3_SHIFT                 27
+#define FTM_COMBINE_DTEN3_MASK                   0x10000000u
+#define FTM_COMBINE_DTEN3_SHIFT                  28
+#define FTM_COMBINE_SYNCEN3_MASK                 0x20000000u
+#define FTM_COMBINE_SYNCEN3_SHIFT                29
+#define FTM_COMBINE_FAULTEN3_MASK                0x40000000u
+#define FTM_COMBINE_FAULTEN3_SHIFT               30
+/* DEADTIME Bit Fields */
+#define FTM_DEADTIME_DTVAL_MASK                  0x3Fu
+#define FTM_DEADTIME_DTVAL_SHIFT                 0
+#define FTM_DEADTIME_DTVAL(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_DEADTIME_DTVAL_SHIFT))&FTM_DEADTIME_DTVAL_MASK)
+#define FTM_DEADTIME_DTPS_MASK                   0xC0u
+#define FTM_DEADTIME_DTPS_SHIFT                  6
+#define FTM_DEADTIME_DTPS(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_DEADTIME_DTPS_SHIFT))&FTM_DEADTIME_DTPS_MASK)
+/* EXTTRIG Bit Fields */
+#define FTM_EXTTRIG_CH2TRIG_MASK                 0x1u
+#define FTM_EXTTRIG_CH2TRIG_SHIFT                0
+#define FTM_EXTTRIG_CH3TRIG_MASK                 0x2u
+#define FTM_EXTTRIG_CH3TRIG_SHIFT                1
+#define FTM_EXTTRIG_CH4TRIG_MASK                 0x4u
+#define FTM_EXTTRIG_CH4TRIG_SHIFT                2
+#define FTM_EXTTRIG_CH5TRIG_MASK                 0x8u
+#define FTM_EXTTRIG_CH5TRIG_SHIFT                3
+#define FTM_EXTTRIG_CH0TRIG_MASK                 0x10u
+#define FTM_EXTTRIG_CH0TRIG_SHIFT                4
+#define FTM_EXTTRIG_CH1TRIG_MASK                 0x20u
+#define FTM_EXTTRIG_CH1TRIG_SHIFT                5
+#define FTM_EXTTRIG_INITTRIGEN_MASK              0x40u
+#define FTM_EXTTRIG_INITTRIGEN_SHIFT             6
+#define FTM_EXTTRIG_TRIGF_MASK                   0x80u
+#define FTM_EXTTRIG_TRIGF_SHIFT                  7
+/* POL Bit Fields */
+#define FTM_POL_POL0_MASK                        0x1u
+#define FTM_POL_POL0_SHIFT                       0
+#define FTM_POL_POL1_MASK                        0x2u
+#define FTM_POL_POL1_SHIFT                       1
+#define FTM_POL_POL2_MASK                        0x4u
+#define FTM_POL_POL2_SHIFT                       2
+#define FTM_POL_POL3_MASK                        0x8u
+#define FTM_POL_POL3_SHIFT                       3
+#define FTM_POL_POL4_MASK                        0x10u
+#define FTM_POL_POL4_SHIFT                       4
+#define FTM_POL_POL5_MASK                        0x20u
+#define FTM_POL_POL5_SHIFT                       5
+#define FTM_POL_POL6_MASK                        0x40u
+#define FTM_POL_POL6_SHIFT                       6
+#define FTM_POL_POL7_MASK                        0x80u
+#define FTM_POL_POL7_SHIFT                       7
+/* FMS Bit Fields */
+#define FTM_FMS_FAULTF0_MASK                     0x1u
+#define FTM_FMS_FAULTF0_SHIFT                    0
+#define FTM_FMS_FAULTF1_MASK                     0x2u
+#define FTM_FMS_FAULTF1_SHIFT                    1
+#define FTM_FMS_FAULTF2_MASK                     0x4u
+#define FTM_FMS_FAULTF2_SHIFT                    2
+#define FTM_FMS_FAULTF3_MASK                     0x8u
+#define FTM_FMS_FAULTF3_SHIFT                    3
+#define FTM_FMS_FAULTIN_MASK                     0x20u
+#define FTM_FMS_FAULTIN_SHIFT                    5
+#define FTM_FMS_WPEN_MASK                        0x40u
+#define FTM_FMS_WPEN_SHIFT                       6
+#define FTM_FMS_FAULTF_MASK                      0x80u
+#define FTM_FMS_FAULTF_SHIFT                     7
+/* FILTER Bit Fields */
+#define FTM_FILTER_CH0FVAL_MASK                  0xFu
+#define FTM_FILTER_CH0FVAL_SHIFT                 0
+#define FTM_FILTER_CH0FVAL(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_FILTER_CH0FVAL_SHIFT))&FTM_FILTER_CH0FVAL_MASK)
+#define FTM_FILTER_CH1FVAL_MASK                  0xF0u
+#define FTM_FILTER_CH1FVAL_SHIFT                 4
+#define FTM_FILTER_CH1FVAL(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_FILTER_CH1FVAL_SHIFT))&FTM_FILTER_CH1FVAL_MASK)
+#define FTM_FILTER_CH2FVAL_MASK                  0xF00u
+#define FTM_FILTER_CH2FVAL_SHIFT                 8
+#define FTM_FILTER_CH2FVAL(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_FILTER_CH2FVAL_SHIFT))&FTM_FILTER_CH2FVAL_MASK)
+#define FTM_FILTER_CH3FVAL_MASK                  0xF000u
+#define FTM_FILTER_CH3FVAL_SHIFT                 12
+#define FTM_FILTER_CH3FVAL(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_FILTER_CH3FVAL_SHIFT))&FTM_FILTER_CH3FVAL_MASK)
+/* FLTCTRL Bit Fields */
+#define FTM_FLTCTRL_FAULT0EN_MASK                0x1u
+#define FTM_FLTCTRL_FAULT0EN_SHIFT               0
+#define FTM_FLTCTRL_FAULT1EN_MASK                0x2u
+#define FTM_FLTCTRL_FAULT1EN_SHIFT               1
+#define FTM_FLTCTRL_FAULT2EN_MASK                0x4u
+#define FTM_FLTCTRL_FAULT2EN_SHIFT               2
+#define FTM_FLTCTRL_FAULT3EN_MASK                0x8u
+#define FTM_FLTCTRL_FAULT3EN_SHIFT               3
+#define FTM_FLTCTRL_FFLTR0EN_MASK                0x10u
+#define FTM_FLTCTRL_FFLTR0EN_SHIFT               4
+#define FTM_FLTCTRL_FFLTR1EN_MASK                0x20u
+#define FTM_FLTCTRL_FFLTR1EN_SHIFT               5
+#define FTM_FLTCTRL_FFLTR2EN_MASK                0x40u
+#define FTM_FLTCTRL_FFLTR2EN_SHIFT               6
+#define FTM_FLTCTRL_FFLTR3EN_MASK                0x80u
+#define FTM_FLTCTRL_FFLTR3EN_SHIFT               7
+#define FTM_FLTCTRL_FFVAL_MASK                   0xF00u
+#define FTM_FLTCTRL_FFVAL_SHIFT                  8
+#define FTM_FLTCTRL_FFVAL(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_FLTCTRL_FFVAL_SHIFT))&FTM_FLTCTRL_FFVAL_MASK)
+/* CONF Bit Fields */
+#define FTM_CONF_NUMTOF_MASK                     0x1Fu
+#define FTM_CONF_NUMTOF_SHIFT                    0
+#define FTM_CONF_NUMTOF(x)                       (((uint32_t)(((uint32_t)(x))<<FTM_CONF_NUMTOF_SHIFT))&FTM_CONF_NUMTOF_MASK)
+#define FTM_CONF_BDMMODE_MASK                    0xC0u
+#define FTM_CONF_BDMMODE_SHIFT                   6
+#define FTM_CONF_BDMMODE(x)                      (((uint32_t)(((uint32_t)(x))<<FTM_CONF_BDMMODE_SHIFT))&FTM_CONF_BDMMODE_MASK)
+#define FTM_CONF_GTBEEN_MASK                     0x200u
+#define FTM_CONF_GTBEEN_SHIFT                    9
+#define FTM_CONF_GTBEOUT_MASK                    0x400u
+#define FTM_CONF_GTBEOUT_SHIFT                   10
+/* FLTPOL Bit Fields */
+#define FTM_FLTPOL_FLT0POL_MASK                  0x1u
+#define FTM_FLTPOL_FLT0POL_SHIFT                 0
+#define FTM_FLTPOL_FLT1POL_MASK                  0x2u
+#define FTM_FLTPOL_FLT1POL_SHIFT                 1
+#define FTM_FLTPOL_FLT2POL_MASK                  0x4u
+#define FTM_FLTPOL_FLT2POL_SHIFT                 2
+#define FTM_FLTPOL_FLT3POL_MASK                  0x8u
+#define FTM_FLTPOL_FLT3POL_SHIFT                 3
+/* SYNCONF Bit Fields */
+#define FTM_SYNCONF_HWTRIGMODE_MASK              0x1u
+#define FTM_SYNCONF_HWTRIGMODE_SHIFT             0
+#define FTM_SYNCONF_CNTINC_MASK                  0x4u
+#define FTM_SYNCONF_CNTINC_SHIFT                 2
+#define FTM_SYNCONF_INVC_MASK                    0x10u
+#define FTM_SYNCONF_INVC_SHIFT                   4
+#define FTM_SYNCONF_SWOC_MASK                    0x20u
+#define FTM_SYNCONF_SWOC_SHIFT                   5
+#define FTM_SYNCONF_SYNCMODE_MASK                0x80u
+#define FTM_SYNCONF_SYNCMODE_SHIFT               7
+#define FTM_SYNCONF_SWRSTCNT_MASK                0x100u
+#define FTM_SYNCONF_SWRSTCNT_SHIFT               8
+#define FTM_SYNCONF_SWWRBUF_MASK                 0x200u
+#define FTM_SYNCONF_SWWRBUF_SHIFT                9
+#define FTM_SYNCONF_SWOM_MASK                    0x400u
+#define FTM_SYNCONF_SWOM_SHIFT                   10
+#define FTM_SYNCONF_SWINVC_MASK                  0x800u
+#define FTM_SYNCONF_SWINVC_SHIFT                 11
+#define FTM_SYNCONF_SWSOC_MASK                   0x1000u
+#define FTM_SYNCONF_SWSOC_SHIFT                  12
+#define FTM_SYNCONF_HWRSTCNT_MASK                0x10000u
+#define FTM_SYNCONF_HWRSTCNT_SHIFT               16
+#define FTM_SYNCONF_HWWRBUF_MASK                 0x20000u
+#define FTM_SYNCONF_HWWRBUF_SHIFT                17
+#define FTM_SYNCONF_HWOM_MASK                    0x40000u
+#define FTM_SYNCONF_HWOM_SHIFT                   18
+#define FTM_SYNCONF_HWINVC_MASK                  0x80000u
+#define FTM_SYNCONF_HWINVC_SHIFT                 19
+#define FTM_SYNCONF_HWSOC_MASK                   0x100000u
+#define FTM_SYNCONF_HWSOC_SHIFT                  20
+/* INVCTRL Bit Fields */
+#define FTM_INVCTRL_INV0EN_MASK                  0x1u
+#define FTM_INVCTRL_INV0EN_SHIFT                 0
+#define FTM_INVCTRL_INV1EN_MASK                  0x2u
+#define FTM_INVCTRL_INV1EN_SHIFT                 1
+#define FTM_INVCTRL_INV2EN_MASK                  0x4u
+#define FTM_INVCTRL_INV2EN_SHIFT                 2
+#define FTM_INVCTRL_INV3EN_MASK                  0x8u
+#define FTM_INVCTRL_INV3EN_SHIFT                 3
+/* SWOCTRL Bit Fields */
+#define FTM_SWOCTRL_CH0OC_MASK                   0x1u
+#define FTM_SWOCTRL_CH0OC_SHIFT                  0
+#define FTM_SWOCTRL_CH1OC_MASK                   0x2u
+#define FTM_SWOCTRL_CH1OC_SHIFT                  1
+#define FTM_SWOCTRL_CH2OC_MASK                   0x4u
+#define FTM_SWOCTRL_CH2OC_SHIFT                  2
+#define FTM_SWOCTRL_CH3OC_MASK                   0x8u
+#define FTM_SWOCTRL_CH3OC_SHIFT                  3
+#define FTM_SWOCTRL_CH4OC_MASK                   0x10u
+#define FTM_SWOCTRL_CH4OC_SHIFT                  4
+#define FTM_SWOCTRL_CH5OC_MASK                   0x20u
+#define FTM_SWOCTRL_CH5OC_SHIFT                  5
+#define FTM_SWOCTRL_CH6OC_MASK                   0x40u
+#define FTM_SWOCTRL_CH6OC_SHIFT                  6
+#define FTM_SWOCTRL_CH7OC_MASK                   0x80u
+#define FTM_SWOCTRL_CH7OC_SHIFT                  7
+#define FTM_SWOCTRL_CH0OCV_MASK                  0x100u
+#define FTM_SWOCTRL_CH0OCV_SHIFT                 8
+#define FTM_SWOCTRL_CH1OCV_MASK                  0x200u
+#define FTM_SWOCTRL_CH1OCV_SHIFT                 9
+#define FTM_SWOCTRL_CH2OCV_MASK                  0x400u
+#define FTM_SWOCTRL_CH2OCV_SHIFT                 10
+#define FTM_SWOCTRL_CH3OCV_MASK                  0x800u
+#define FTM_SWOCTRL_CH3OCV_SHIFT                 11
+#define FTM_SWOCTRL_CH4OCV_MASK                  0x1000u
+#define FTM_SWOCTRL_CH4OCV_SHIFT                 12
+#define FTM_SWOCTRL_CH5OCV_MASK                  0x2000u
+#define FTM_SWOCTRL_CH5OCV_SHIFT                 13
+#define FTM_SWOCTRL_CH6OCV_MASK                  0x4000u
+#define FTM_SWOCTRL_CH6OCV_SHIFT                 14
+#define FTM_SWOCTRL_CH7OCV_MASK                  0x8000u
+#define FTM_SWOCTRL_CH7OCV_SHIFT                 15
+/* PWMLOAD Bit Fields */
+#define FTM_PWMLOAD_CH0SEL_MASK                  0x1u
+#define FTM_PWMLOAD_CH0SEL_SHIFT                 0
+#define FTM_PWMLOAD_CH1SEL_MASK                  0x2u
+#define FTM_PWMLOAD_CH1SEL_SHIFT                 1
+#define FTM_PWMLOAD_CH2SEL_MASK                  0x4u
+#define FTM_PWMLOAD_CH2SEL_SHIFT                 2
+#define FTM_PWMLOAD_CH3SEL_MASK                  0x8u
+#define FTM_PWMLOAD_CH3SEL_SHIFT                 3
+#define FTM_PWMLOAD_CH4SEL_MASK                  0x10u
+#define FTM_PWMLOAD_CH4SEL_SHIFT                 4
+#define FTM_PWMLOAD_CH5SEL_MASK                  0x20u
+#define FTM_PWMLOAD_CH5SEL_SHIFT                 5
+#define FTM_PWMLOAD_CH6SEL_MASK                  0x40u
+#define FTM_PWMLOAD_CH6SEL_SHIFT                 6
+#define FTM_PWMLOAD_CH7SEL_MASK                  0x80u
+#define FTM_PWMLOAD_CH7SEL_SHIFT                 7
+#define FTM_PWMLOAD_LDOK_MASK                    0x200u
+#define FTM_PWMLOAD_LDOK_SHIFT                   9
+
+/*!
+ * @}
+ */ /* end of group FTM_Register_Masks */
+
+
+/* FTM - Peripheral instance base addresses */
+/** Peripheral FTM0 base address */
+#define FTM0_BASE                                (0x40038000u)
+/** Peripheral FTM0 base pointer */
+#define FTM0                                     ((FTM_Type *)FTM0_BASE)
+/** Peripheral FTM1 base address */
+#define FTM1_BASE                                (0x40039000u)
+/** Peripheral FTM1 base pointer */
+#define FTM1                                     ((FTM_Type *)FTM1_BASE)
+/** Peripheral FTM2 base address */
+#define FTM2_BASE                                (0x4003A000u)
+/** Peripheral FTM2 base pointer */
+#define FTM2                                     ((FTM_Type *)FTM2_BASE)
+/** Array initializer of FTM peripheral base pointers */
+#define FTM_BASES                                { FTM0, FTM1, FTM2 }
+
+/*!
+ * @}
+ */ /* end of group FTM_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- FTMRH Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup FTMRH_Peripheral_Access_Layer FTMRH Peripheral Access Layer
+ * @{
+ */
+
+/** FTMRH - Register Layout Typedef */
+typedef struct {
+  __IO uint8_t FCLKDIV;                            /**< Flash Clock Divider Register, offset: 0x0 */
+  __I  uint8_t FSEC;                               /**< Flash Security Register, offset: 0x1 */
+  __IO uint8_t FCCOBIX;                            /**< Flash CCOB Index Register, offset: 0x2 */
+       uint8_t RESERVED_0[1];
+  __IO uint8_t FCNFG;                              /**< Flash Configuration Register, offset: 0x4 */
+  __IO uint8_t FERCNFG;                            /**< Flash Error Configuration Register, offset: 0x5 */
+  __IO uint8_t FSTAT;                              /**< Flash Status Register, offset: 0x6 */
+  __IO uint8_t FERSTAT;                            /**< Flash Error Status Register, offset: 0x7 */
+  __IO uint8_t FPROT;                              /**< Flash Protection Register, offset: 0x8 */
+  __IO uint8_t EEPROT;                             /**< EEPROM Protection Register, offset: 0x9 */
+  __IO uint8_t FCCOBHI;                            /**< Flash Common Command Object Register:High, offset: 0xA */
+  __IO uint8_t FCCOBLO;                            /**< Flash Common Command Object Register: Low, offset: 0xB */
+  __I  uint8_t FOPT;                               /**< Flash Option Register, offset: 0xC */
+} FTMRH_Type;
+
+/* ----------------------------------------------------------------------------
+   -- FTMRH Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup FTMRH_Register_Masks FTMRH Register Masks
+ * @{
+ */
+
+/* FCLKDIV Bit Fields */
+#define FTMRH_FCLKDIV_FDIV_MASK                  0x3Fu
+#define FTMRH_FCLKDIV_FDIV_SHIFT                 0
+#define FTMRH_FCLKDIV_FDIV(x)                    (((uint8_t)(((uint8_t)(x))<<FTMRH_FCLKDIV_FDIV_SHIFT))&FTMRH_FCLKDIV_FDIV_MASK)
+#define FTMRH_FCLKDIV_FDIVLCK_MASK               0x40u
+#define FTMRH_FCLKDIV_FDIVLCK_SHIFT              6
+#define FTMRH_FCLKDIV_FDIVLD_MASK                0x80u
+#define FTMRH_FCLKDIV_FDIVLD_SHIFT               7
+/* FSEC Bit Fields */
+#define FTMRH_FSEC_SEC_MASK                      0x3u
+#define FTMRH_FSEC_SEC_SHIFT                     0
+#define FTMRH_FSEC_SEC(x)                        (((uint8_t)(((uint8_t)(x))<<FTMRH_FSEC_SEC_SHIFT))&FTMRH_FSEC_SEC_MASK)
+#define FTMRH_FSEC_KEYEN_MASK                    0xC0u
+#define FTMRH_FSEC_KEYEN_SHIFT                   6
+#define FTMRH_FSEC_KEYEN(x)                      (((uint8_t)(((uint8_t)(x))<<FTMRH_FSEC_KEYEN_SHIFT))&FTMRH_FSEC_KEYEN_MASK)
+/* FCCOBIX Bit Fields */
+#define FTMRH_FCCOBIX_CCOBIX_MASK                0x7u
+#define FTMRH_FCCOBIX_CCOBIX_SHIFT               0
+#define FTMRH_FCCOBIX_CCOBIX(x)                  (((uint8_t)(((uint8_t)(x))<<FTMRH_FCCOBIX_CCOBIX_SHIFT))&FTMRH_FCCOBIX_CCOBIX_MASK)
+/* FCNFG Bit Fields */
+#define FTMRH_FCNFG_FSFD_MASK                    0x1u
+#define FTMRH_FCNFG_FSFD_SHIFT                   0
+#define FTMRH_FCNFG_FDFD_MASK                    0x2u
+#define FTMRH_FCNFG_FDFD_SHIFT                   1
+#define FTMRH_FCNFG_IGNSF_MASK                   0x10u
+#define FTMRH_FCNFG_IGNSF_SHIFT                  4
+#define FTMRH_FCNFG_CCIE_MASK                    0x80u
+#define FTMRH_FCNFG_CCIE_SHIFT                   7
+/* FERCNFG Bit Fields */
+#define FTMRH_FERCNFG_SFDIE_MASK                 0x1u
+#define FTMRH_FERCNFG_SFDIE_SHIFT                0
+#define FTMRH_FERCNFG_DFDIE_MASK                 0x2u
+#define FTMRH_FERCNFG_DFDIE_SHIFT                1
+/* FSTAT Bit Fields */
+#define FTMRH_FSTAT_MGSTAT_MASK                  0x3u
+#define FTMRH_FSTAT_MGSTAT_SHIFT                 0
+#define FTMRH_FSTAT_MGSTAT(x)                    (((uint8_t)(((uint8_t)(x))<<FTMRH_FSTAT_MGSTAT_SHIFT))&FTMRH_FSTAT_MGSTAT_MASK)
+#define FTMRH_FSTAT_MGBUSY_MASK                  0x8u
+#define FTMRH_FSTAT_MGBUSY_SHIFT                 3
+#define FTMRH_FSTAT_FPVIOL_MASK                  0x10u
+#define FTMRH_FSTAT_FPVIOL_SHIFT                 4
+#define FTMRH_FSTAT_ACCERR_MASK                  0x20u
+#define FTMRH_FSTAT_ACCERR_SHIFT                 5
+#define FTMRH_FSTAT_CCIF_MASK                    0x80u
+#define FTMRH_FSTAT_CCIF_SHIFT                   7
+/* FERSTAT Bit Fields */
+#define FTMRH_FERSTAT_SFDIF_MASK                 0x1u
+#define FTMRH_FERSTAT_SFDIF_SHIFT                0
+#define FTMRH_FERSTAT_DFDIF_MASK                 0x2u
+#define FTMRH_FERSTAT_DFDIF_SHIFT                1
+/* FPROT Bit Fields */
+#define FTMRH_FPROT_FPLS_MASK                    0x3u
+#define FTMRH_FPROT_FPLS_SHIFT                   0
+#define FTMRH_FPROT_FPLS(x)                      (((uint8_t)(((uint8_t)(x))<<FTMRH_FPROT_FPLS_SHIFT))&FTMRH_FPROT_FPLS_MASK)
+#define FTMRH_FPROT_FPLDIS_MASK                  0x4u
+#define FTMRH_FPROT_FPLDIS_SHIFT                 2
+#define FTMRH_FPROT_FPHS_MASK                    0x18u
+#define FTMRH_FPROT_FPHS_SHIFT                   3
+#define FTMRH_FPROT_FPHS(x)                      (((uint8_t)(((uint8_t)(x))<<FTMRH_FPROT_FPHS_SHIFT))&FTMRH_FPROT_FPHS_MASK)
+#define FTMRH_FPROT_FPHDIS_MASK                  0x20u
+#define FTMRH_FPROT_FPHDIS_SHIFT                 5
+#define FTMRH_FPROT_FPOPEN_MASK                  0x80u
+#define FTMRH_FPROT_FPOPEN_SHIFT                 7
+/* EEPROT Bit Fields */
+#define FTMRH_EEPROT_DPS_MASK                    0x7u
+#define FTMRH_EEPROT_DPS_SHIFT                   0
+#define FTMRH_EEPROT_DPS(x)                      (((uint8_t)(((uint8_t)(x))<<FTMRH_EEPROT_DPS_SHIFT))&FTMRH_EEPROT_DPS_MASK)
+#define FTMRH_EEPROT_DPOPEN_MASK                 0x80u
+#define FTMRH_EEPROT_DPOPEN_SHIFT                7
+/* FCCOBHI Bit Fields */
+#define FTMRH_FCCOBHI_CCOB_MASK                  0xFFu
+#define FTMRH_FCCOBHI_CCOB_SHIFT                 0
+#define FTMRH_FCCOBHI_CCOB(x)                    (((uint8_t)(((uint8_t)(x))<<FTMRH_FCCOBHI_CCOB_SHIFT))&FTMRH_FCCOBHI_CCOB_MASK)
+/* FCCOBLO Bit Fields */
+#define FTMRH_FCCOBLO_CCOB_MASK                  0xFFu
+#define FTMRH_FCCOBLO_CCOB_SHIFT                 0
+#define FTMRH_FCCOBLO_CCOB(x)                    (((uint8_t)(((uint8_t)(x))<<FTMRH_FCCOBLO_CCOB_SHIFT))&FTMRH_FCCOBLO_CCOB_MASK)
+/* FOPT Bit Fields */
+#define FTMRH_FOPT_NV_MASK                       0xFFu
+#define FTMRH_FOPT_NV_SHIFT                      0
+#define FTMRH_FOPT_NV(x)                         (((uint8_t)(((uint8_t)(x))<<FTMRH_FOPT_NV_SHIFT))&FTMRH_FOPT_NV_MASK)
+
+/*!
+ * @}
+ */ /* end of group FTMRH_Register_Masks */
+
+
+/* FTMRH - Peripheral instance base addresses */
+/** Peripheral FTMRH base address */
+#define FTMRH_BASE                               (0x40020000u)
+/** Peripheral FTMRH base pointer */
+#define FTMRH                                    ((FTMRH_Type *)FTMRH_BASE)
+/** Array initializer of FTMRH peripheral base pointers */
+#define FTMRH_BASES                              { FTMRH }
+
+/*!
+ * @}
+ */ /* end of group FTMRH_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- GPIO Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup GPIO_Peripheral_Access_Layer GPIO Peripheral Access Layer
+ * @{
+ */
+
+/** GPIO - Register Layout Typedef */
+typedef struct {
+  __IO uint32_t PDOR;                              /**< Port Data Output Register, offset: 0x0 */
+  __O  uint32_t PSOR;                              /**< Port Set Output Register, offset: 0x4 */
+  __O  uint32_t PCOR;                              /**< Port Clear Output Register, offset: 0x8 */
+  __O  uint32_t PTOR;                              /**< Port Toggle Output Register, offset: 0xC */
+  __I  uint32_t PDIR;                              /**< Port Data Input Register, offset: 0x10 */
+  __IO uint32_t PDDR;                              /**< Port Data Direction Register, offset: 0x14 */
+  __IO uint32_t PIDR;                              /**< Port Input Disable Register, offset: 0x18 */
+} GPIO_Type;
+
+/* ----------------------------------------------------------------------------
+   -- GPIO Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup GPIO_Register_Masks GPIO Register Masks
+ * @{
+ */
+
+/* PDOR Bit Fields */
+#define GPIO_PDOR_PDO_MASK                       0xFFFFFFFFu
+#define GPIO_PDOR_PDO_SHIFT                      0
+#define GPIO_PDOR_PDO(x)                         (((uint32_t)(((uint32_t)(x))<<GPIO_PDOR_PDO_SHIFT))&GPIO_PDOR_PDO_MASK)
+/* PSOR Bit Fields */
+#define GPIO_PSOR_PTSO_MASK                      0xFFFFFFFFu
+#define GPIO_PSOR_PTSO_SHIFT                     0
+#define GPIO_PSOR_PTSO(x)                        (((uint32_t)(((uint32_t)(x))<<GPIO_PSOR_PTSO_SHIFT))&GPIO_PSOR_PTSO_MASK)
+/* PCOR Bit Fields */
+#define GPIO_PCOR_PTCO_MASK                      0xFFFFFFFFu
+#define GPIO_PCOR_PTCO_SHIFT                     0
+#define GPIO_PCOR_PTCO(x)                        (((uint32_t)(((uint32_t)(x))<<GPIO_PCOR_PTCO_SHIFT))&GPIO_PCOR_PTCO_MASK)
+/* PTOR Bit Fields */
+#define GPIO_PTOR_PTTO_MASK                      0xFFFFFFFFu
+#define GPIO_PTOR_PTTO_SHIFT                     0
+#define GPIO_PTOR_PTTO(x)                        (((uint32_t)(((uint32_t)(x))<<GPIO_PTOR_PTTO_SHIFT))&GPIO_PTOR_PTTO_MASK)
+/* PDIR Bit Fields */
+#define GPIO_PDIR_PDI_MASK                       0xFFFFFFFFu
+#define GPIO_PDIR_PDI_SHIFT                      0
+#define GPIO_PDIR_PDI(x)                         (((uint32_t)(((uint32_t)(x))<<GPIO_PDIR_PDI_SHIFT))&GPIO_PDIR_PDI_MASK)
+/* PDDR Bit Fields */
+#define GPIO_PDDR_PDD_MASK                       0xFFFFFFFFu
+#define GPIO_PDDR_PDD_SHIFT                      0
+#define GPIO_PDDR_PDD(x)                         (((uint32_t)(((uint32_t)(x))<<GPIO_PDDR_PDD_SHIFT))&GPIO_PDDR_PDD_MASK)
+/* PIDR Bit Fields */
+#define GPIO_PIDR_PID_MASK                       0xFFFFFFFFu
+#define GPIO_PIDR_PID_SHIFT                      0
+#define GPIO_PIDR_PID(x)                         (((uint32_t)(((uint32_t)(x))<<GPIO_PIDR_PID_SHIFT))&GPIO_PIDR_PID_MASK)
+
+/*!
+ * @}
+ */ /* end of group GPIO_Register_Masks */
+
+
+/* GPIO - Peripheral instance base addresses */
+/** Peripheral GPIOA base address */
+#define GPIOA_BASE                               (0x400FF000u)
+/** Peripheral GPIOA base pointer */
+#define GPIOA                                    ((GPIO_Type *)GPIOA_BASE)
+/** Peripheral GPIOB base address */
+#define GPIOB_BASE                               (0x400FF040u)
+/** Peripheral GPIOB base pointer */
+#define GPIOB                                    ((GPIO_Type *)GPIOB_BASE)
+/** Array initializer of GPIO peripheral base pointers */
+#define GPIO_BASES                               { GPIOA, GPIOB }
+
+/*!
+ * @}
+ */ /* end of group GPIO_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- I2C Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup I2C_Peripheral_Access_Layer I2C Peripheral Access Layer
+ * @{
+ */
+
+/** I2C - Register Layout Typedef */
+typedef struct {
+  __IO uint8_t A1;                                 /**< I2C Address Register 1, offset: 0x0 */
+  __IO uint8_t F;                                  /**< I2C Frequency Divider register, offset: 0x1 */
+  __IO uint8_t C1;                                 /**< I2C Control Register 1, offset: 0x2 */
+  __IO uint8_t S;                                  /**< I2C Status register, offset: 0x3 */
+  __IO uint8_t D;                                  /**< I2C Data I/O register, offset: 0x4 */
+  __IO uint8_t C2;                                 /**< I2C Control Register 2, offset: 0x5 */
+  __IO uint8_t FLT;                                /**< I2C Programmable Input Glitch Filter register, offset: 0x6 */
+  __IO uint8_t RA;                                 /**< I2C Range Address register, offset: 0x7 */
+  __IO uint8_t SMB;                                /**< I2C SMBus Control and Status register, offset: 0x8 */
+  __IO uint8_t A2;                                 /**< I2C Address Register 2, offset: 0x9 */
+  __IO uint8_t SLTH;                               /**< I2C SCL Low Timeout Register High, offset: 0xA */
+  __IO uint8_t SLTL;                               /**< I2C SCL Low Timeout Register Low, offset: 0xB */
+} I2C_Type;
+
+/* ----------------------------------------------------------------------------
+   -- I2C Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup I2C_Register_Masks I2C Register Masks
+ * @{
+ */
+
+/* A1 Bit Fields */
+#define I2C_A1_AD_MASK                           0xFEu
+#define I2C_A1_AD_SHIFT                          1
+#define I2C_A1_AD(x)                             (((uint8_t)(((uint8_t)(x))<<I2C_A1_AD_SHIFT))&I2C_A1_AD_MASK)
+/* F Bit Fields */
+#define I2C_F_ICR_MASK                           0x3Fu
+#define I2C_F_ICR_SHIFT                          0
+#define I2C_F_ICR(x)                             (((uint8_t)(((uint8_t)(x))<<I2C_F_ICR_SHIFT))&I2C_F_ICR_MASK)
+#define I2C_F_MULT_MASK                          0xC0u
+#define I2C_F_MULT_SHIFT                         6
+#define I2C_F_MULT(x)                            (((uint8_t)(((uint8_t)(x))<<I2C_F_MULT_SHIFT))&I2C_F_MULT_MASK)
+/* C1 Bit Fields */
+#define I2C_C1_WUEN_MASK                         0x2u
+#define I2C_C1_WUEN_SHIFT                        1
+#define I2C_C1_RSTA_MASK                         0x4u
+#define I2C_C1_RSTA_SHIFT                        2
+#define I2C_C1_TXAK_MASK                         0x8u
+#define I2C_C1_TXAK_SHIFT                        3
+#define I2C_C1_TX_MASK                           0x10u
+#define I2C_C1_TX_SHIFT                          4
+#define I2C_C1_MST_MASK                          0x20u
+#define I2C_C1_MST_SHIFT                         5
+#define I2C_C1_IICIE_MASK                        0x40u
+#define I2C_C1_IICIE_SHIFT                       6
+#define I2C_C1_IICEN_MASK                        0x80u
+#define I2C_C1_IICEN_SHIFT                       7
+/* S Bit Fields */
+#define I2C_S_RXAK_MASK                          0x1u
+#define I2C_S_RXAK_SHIFT                         0
+#define I2C_S_IICIF_MASK                         0x2u
+#define I2C_S_IICIF_SHIFT                        1
+#define I2C_S_SRW_MASK                           0x4u
+#define I2C_S_SRW_SHIFT                          2
+#define I2C_S_RAM_MASK                           0x8u
+#define I2C_S_RAM_SHIFT                          3
+#define I2C_S_ARBL_MASK                          0x10u
+#define I2C_S_ARBL_SHIFT                         4
+#define I2C_S_BUSY_MASK                          0x20u
+#define I2C_S_BUSY_SHIFT                         5
+#define I2C_S_IAAS_MASK                          0x40u
+#define I2C_S_IAAS_SHIFT                         6
+#define I2C_S_TCF_MASK                           0x80u
+#define I2C_S_TCF_SHIFT                          7
+/* D Bit Fields */
+#define I2C_D_DATA_MASK                          0xFFu
+#define I2C_D_DATA_SHIFT                         0
+#define I2C_D_DATA(x)                            (((uint8_t)(((uint8_t)(x))<<I2C_D_DATA_SHIFT))&I2C_D_DATA_MASK)
+/* C2 Bit Fields */
+#define I2C_C2_AD_MASK                           0x7u
+#define I2C_C2_AD_SHIFT                          0
+#define I2C_C2_AD(x)                             (((uint8_t)(((uint8_t)(x))<<I2C_C2_AD_SHIFT))&I2C_C2_AD_MASK)
+#define I2C_C2_RMEN_MASK                         0x8u
+#define I2C_C2_RMEN_SHIFT                        3
+#define I2C_C2_ADEXT_MASK                        0x40u
+#define I2C_C2_ADEXT_SHIFT                       6
+#define I2C_C2_GCAEN_MASK                        0x80u
+#define I2C_C2_GCAEN_SHIFT                       7
+/* FLT Bit Fields */
+#define I2C_FLT_FLT_MASK                         0x1Fu
+#define I2C_FLT_FLT_SHIFT                        0
+#define I2C_FLT_FLT(x)                           (((uint8_t)(((uint8_t)(x))<<I2C_FLT_FLT_SHIFT))&I2C_FLT_FLT_MASK)
+/* RA Bit Fields */
+#define I2C_RA_RAD_MASK                          0xFEu
+#define I2C_RA_RAD_SHIFT                         1
+#define I2C_RA_RAD(x)                            (((uint8_t)(((uint8_t)(x))<<I2C_RA_RAD_SHIFT))&I2C_RA_RAD_MASK)
+/* SMB Bit Fields */
+#define I2C_SMB_SHTF2IE_MASK                     0x1u
+#define I2C_SMB_SHTF2IE_SHIFT                    0
+#define I2C_SMB_SHTF2_MASK                       0x2u
+#define I2C_SMB_SHTF2_SHIFT                      1
+#define I2C_SMB_SHTF1_MASK                       0x4u
+#define I2C_SMB_SHTF1_SHIFT                      2
+#define I2C_SMB_SLTF_MASK                        0x8u
+#define I2C_SMB_SLTF_SHIFT                       3
+#define I2C_SMB_TCKSEL_MASK                      0x10u
+#define I2C_SMB_TCKSEL_SHIFT                     4
+#define I2C_SMB_SIICAEN_MASK                     0x20u
+#define I2C_SMB_SIICAEN_SHIFT                    5
+#define I2C_SMB_ALERTEN_MASK                     0x40u
+#define I2C_SMB_ALERTEN_SHIFT                    6
+#define I2C_SMB_FACK_MASK                        0x80u
+#define I2C_SMB_FACK_SHIFT                       7
+/* A2 Bit Fields */
+#define I2C_A2_SAD_MASK                          0xFEu
+#define I2C_A2_SAD_SHIFT                         1
+#define I2C_A2_SAD(x)                            (((uint8_t)(((uint8_t)(x))<<I2C_A2_SAD_SHIFT))&I2C_A2_SAD_MASK)
+/* SLTH Bit Fields */
+#define I2C_SLTH_SSLT_MASK                       0xFFu
+#define I2C_SLTH_SSLT_SHIFT                      0
+#define I2C_SLTH_SSLT(x)                         (((uint8_t)(((uint8_t)(x))<<I2C_SLTH_SSLT_SHIFT))&I2C_SLTH_SSLT_MASK)
+/* SLTL Bit Fields */
+#define I2C_SLTL_SSLT_MASK                       0xFFu
+#define I2C_SLTL_SSLT_SHIFT                      0
+#define I2C_SLTL_SSLT(x)                         (((uint8_t)(((uint8_t)(x))<<I2C_SLTL_SSLT_SHIFT))&I2C_SLTL_SSLT_MASK)
+
+/*!
+ * @}
+ */ /* end of group I2C_Register_Masks */
+
+
+/* I2C - Peripheral instance base addresses */
+/** Peripheral I2C0 base address */
+#define I2C0_BASE                                (0x40066000u)
+/** Peripheral I2C0 base pointer */
+#define I2C0                                     ((I2C_Type *)I2C0_BASE)
+/** Array initializer of I2C peripheral base pointers */
+#define I2C_BASES                                { I2C0 }
+
+/*!
+ * @}
+ */ /* end of group I2C_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- ICS Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup ICS_Peripheral_Access_Layer ICS Peripheral Access Layer
+ * @{
+ */
+
+/** ICS - Register Layout Typedef */
+typedef struct {
+  __IO uint8_t C1;                                 /**< ICS Control Register 1, offset: 0x0 */
+  __IO uint8_t C2;                                 /**< ICS Control Register 2, offset: 0x1 */
+  __IO uint8_t C3;                                 /**< ICS Control Register 3, offset: 0x2 */
+  __IO uint8_t C4;                                 /**< ICS Control Register 4, offset: 0x3 */
+  __IO uint8_t S;                                  /**< ICS Status Register, offset: 0x4 */
+} ICS_Type;
+
+/* ----------------------------------------------------------------------------
+   -- ICS Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup ICS_Register_Masks ICS Register Masks
+ * @{
+ */
+
+/* C1 Bit Fields */
+#define ICS_C1_IREFSTEN_MASK                     0x1u
+#define ICS_C1_IREFSTEN_SHIFT                    0
+#define ICS_C1_IRCLKEN_MASK                      0x2u
+#define ICS_C1_IRCLKEN_SHIFT                     1
+#define ICS_C1_IREFS_MASK                        0x4u
+#define ICS_C1_IREFS_SHIFT                       2
+#define ICS_C1_RDIV_MASK                         0x38u
+#define ICS_C1_RDIV_SHIFT                        3
+#define ICS_C1_RDIV(x)                           (((uint8_t)(((uint8_t)(x))<<ICS_C1_RDIV_SHIFT))&ICS_C1_RDIV_MASK)
+#define ICS_C1_CLKS_MASK                         0xC0u
+#define ICS_C1_CLKS_SHIFT                        6
+#define ICS_C1_CLKS(x)                           (((uint8_t)(((uint8_t)(x))<<ICS_C1_CLKS_SHIFT))&ICS_C1_CLKS_MASK)
+/* C2 Bit Fields */
+#define ICS_C2_LP_MASK                           0x10u
+#define ICS_C2_LP_SHIFT                          4
+#define ICS_C2_BDIV_MASK                         0xE0u
+#define ICS_C2_BDIV_SHIFT                        5
+#define ICS_C2_BDIV(x)                           (((uint8_t)(((uint8_t)(x))<<ICS_C2_BDIV_SHIFT))&ICS_C2_BDIV_MASK)
+/* C3 Bit Fields */
+#define ICS_C3_SCTRIM_MASK                       0xFFu
+#define ICS_C3_SCTRIM_SHIFT                      0
+#define ICS_C3_SCTRIM(x)                         (((uint8_t)(((uint8_t)(x))<<ICS_C3_SCTRIM_SHIFT))&ICS_C3_SCTRIM_MASK)
+/* C4 Bit Fields */
+#define ICS_C4_SCFTRIM_MASK                      0x1u
+#define ICS_C4_SCFTRIM_SHIFT                     0
+#define ICS_C4_CME_MASK                          0x20u
+#define ICS_C4_CME_SHIFT                         5
+#define ICS_C4_LOLIE_MASK                        0x80u
+#define ICS_C4_LOLIE_SHIFT                       7
+/* S Bit Fields */
+#define ICS_S_CLKST_MASK                         0xCu
+#define ICS_S_CLKST_SHIFT                        2
+#define ICS_S_CLKST(x)                           (((uint8_t)(((uint8_t)(x))<<ICS_S_CLKST_SHIFT))&ICS_S_CLKST_MASK)
+#define ICS_S_IREFST_MASK                        0x10u
+#define ICS_S_IREFST_SHIFT                       4
+#define ICS_S_LOCK_MASK                          0x40u
+#define ICS_S_LOCK_SHIFT                         6
+#define ICS_S_LOLS_MASK                          0x80u
+#define ICS_S_LOLS_SHIFT                         7
+
+/*!
+ * @}
+ */ /* end of group ICS_Register_Masks */
+
+
+/* ICS - Peripheral instance base addresses */
+/** Peripheral ICS base address */
+#define ICS_BASE                                 (0x40064000u)
+/** Peripheral ICS base pointer */
+#define ICS                                      ((ICS_Type *)ICS_BASE)
+/** Array initializer of ICS peripheral base pointers */
+#define ICS_BASES                                { ICS }
+
+/*!
+ * @}
+ */ /* end of group ICS_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- IRQ Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup IRQ_Peripheral_Access_Layer IRQ Peripheral Access Layer
+ * @{
+ */
+
+/** IRQ - Register Layout Typedef */
+typedef struct {
+  __IO uint8_t SC;                                 /**< Interrupt Pin Request Status and Control Register, offset: 0x0 */
+} IRQ_Type;
+
+/* ----------------------------------------------------------------------------
+   -- IRQ Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup IRQ_Register_Masks IRQ Register Masks
+ * @{
+ */
+
+/* SC Bit Fields */
+#define IRQ_SC_IRQMOD_MASK                       0x1u
+#define IRQ_SC_IRQMOD_SHIFT                      0
+#define IRQ_SC_IRQIE_MASK                        0x2u
+#define IRQ_SC_IRQIE_SHIFT                       1
+#define IRQ_SC_IRQACK_MASK                       0x4u
+#define IRQ_SC_IRQACK_SHIFT                      2
+#define IRQ_SC_IRQF_MASK                         0x8u
+#define IRQ_SC_IRQF_SHIFT                        3
+#define IRQ_SC_IRQPE_MASK                        0x10u
+#define IRQ_SC_IRQPE_SHIFT                       4
+#define IRQ_SC_IRQEDG_MASK                       0x20u
+#define IRQ_SC_IRQEDG_SHIFT                      5
+#define IRQ_SC_IRQPDD_MASK                       0x40u
+#define IRQ_SC_IRQPDD_SHIFT                      6
+
+/*!
+ * @}
+ */ /* end of group IRQ_Register_Masks */
+
+
+/* IRQ - Peripheral instance base addresses */
+/** Peripheral IRQ base address */
+#define IRQ_BASE                                 (0x40031000u)
+/** Peripheral IRQ base pointer */
+#define IRQ                                      ((IRQ_Type *)IRQ_BASE)
+/** Array initializer of IRQ peripheral base pointers */
+#define IRQ_BASES                                { IRQ }
+
+/*!
+ * @}
+ */ /* end of group IRQ_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- KBI Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup KBI_Peripheral_Access_Layer KBI Peripheral Access Layer
+ * @{
+ */
+
+/** KBI - Register Layout Typedef */
+typedef struct {
+  __IO uint8_t SC;                                 /**< KBI Status and Control Register, offset: 0x0 */
+  __IO uint8_t PE;                                 /**< KBIx Pin Enable Register, offset: 0x1 */
+  __IO uint8_t ES;                                 /**< KBIx Edge Select Register, offset: 0x2 */
+} KBI_Type;
+
+/* ----------------------------------------------------------------------------
+   -- KBI Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup KBI_Register_Masks KBI Register Masks
+ * @{
+ */
+
+/* SC Bit Fields */
+#define KBI_SC_KBMOD_MASK                        0x1u
+#define KBI_SC_KBMOD_SHIFT                       0
+#define KBI_SC_KBIE_MASK                         0x2u
+#define KBI_SC_KBIE_SHIFT                        1
+#define KBI_SC_KBACK_MASK                        0x4u
+#define KBI_SC_KBACK_SHIFT                       2
+#define KBI_SC_KBF_MASK                          0x8u
+#define KBI_SC_KBF_SHIFT                         3
+/* PE Bit Fields */
+#define KBI_PE_KBIPE_MASK                        0xFFu
+#define KBI_PE_KBIPE_SHIFT                       0
+#define KBI_PE_KBIPE(x)                          (((uint8_t)(((uint8_t)(x))<<KBI_PE_KBIPE_SHIFT))&KBI_PE_KBIPE_MASK)
+/* ES Bit Fields */
+#define KBI_ES_KBEDG_MASK                        0xFFu
+#define KBI_ES_KBEDG_SHIFT                       0
+#define KBI_ES_KBEDG(x)                          (((uint8_t)(((uint8_t)(x))<<KBI_ES_KBEDG_SHIFT))&KBI_ES_KBEDG_MASK)
+
+/*!
+ * @}
+ */ /* end of group KBI_Register_Masks */
+
+
+/* KBI - Peripheral instance base addresses */
+/** Peripheral KBI0 base address */
+#define KBI0_BASE                                (0x40079000u)
+/** Peripheral KBI0 base pointer */
+#define KBI0                                     ((KBI_Type *)KBI0_BASE)
+/** Peripheral KBI1 base address */
+#define KBI1_BASE                                (0x4007A000u)
+/** Peripheral KBI1 base pointer */
+#define KBI1                                     ((KBI_Type *)KBI1_BASE)
+/** Array initializer of KBI peripheral base pointers */
+#define KBI_BASES                                { KBI0, KBI1 }
+
+/*!
+ * @}
+ */ /* end of group KBI_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- MCM Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup MCM_Peripheral_Access_Layer MCM Peripheral Access Layer
+ * @{
+ */
+
+/** MCM - Register Layout Typedef */
+typedef struct {
+       uint8_t RESERVED_0[8];
+  __I  uint16_t PLASC;                             /**< Crossbar Switch (AXBS) Slave Configuration, offset: 0x8 */
+  __I  uint16_t PLAMC;                             /**< Crossbar Switch (AXBS) Master Configuration, offset: 0xA */
+  __IO uint32_t PLACR;                             /**< Platform Control Register, offset: 0xC */
+} MCM_Type;
+
+/* ----------------------------------------------------------------------------
+   -- MCM Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup MCM_Register_Masks MCM Register Masks
+ * @{
+ */
+
+/* PLASC Bit Fields */
+#define MCM_PLASC_ASC_MASK                       0xFFu
+#define MCM_PLASC_ASC_SHIFT                      0
+#define MCM_PLASC_ASC(x)                         (((uint16_t)(((uint16_t)(x))<<MCM_PLASC_ASC_SHIFT))&MCM_PLASC_ASC_MASK)
+/* PLAMC Bit Fields */
+#define MCM_PLAMC_AMC_MASK                       0xFFu
+#define MCM_PLAMC_AMC_SHIFT                      0
+#define MCM_PLAMC_AMC(x)                         (((uint16_t)(((uint16_t)(x))<<MCM_PLAMC_AMC_SHIFT))&MCM_PLAMC_AMC_MASK)
+/* PLACR Bit Fields */
+#define MCM_PLACR_CFCC_MASK                      0x400u
+#define MCM_PLACR_CFCC_SHIFT                     10
+#define MCM_PLACR_DFCDA_MASK                     0x800u
+#define MCM_PLACR_DFCDA_SHIFT                    11
+#define MCM_PLACR_DFCIC_MASK                     0x1000u
+#define MCM_PLACR_DFCIC_SHIFT                    12
+#define MCM_PLACR_DFCC_MASK                      0x2000u
+#define MCM_PLACR_DFCC_SHIFT                     13
+#define MCM_PLACR_EFDS_MASK                      0x4000u
+#define MCM_PLACR_EFDS_SHIFT                     14
+#define MCM_PLACR_DFCS_MASK                      0x8000u
+#define MCM_PLACR_DFCS_SHIFT                     15
+#define MCM_PLACR_ESFC_MASK                      0x10000u
+#define MCM_PLACR_ESFC_SHIFT                     16
+
+/*!
+ * @}
+ */ /* end of group MCM_Register_Masks */
+
+
+/* MCM - Peripheral instance base addresses */
+/** Peripheral MCM base address */
+#define MCM_BASE                                 (0xF0003000u)
+/** Peripheral MCM base pointer */
+#define MCM                                      ((MCM_Type *)MCM_BASE)
+/** Array initializer of MCM peripheral base pointers */
+#define MCM_BASES                                { MCM }
+
+/*!
+ * @}
+ */ /* end of group MCM_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- NV Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup NV_Peripheral_Access_Layer NV Peripheral Access Layer
+ * @{
+ */
+
+/** NV - Register Layout Typedef */
+typedef struct {
+  __I  uint8_t BACKKEY0;                           /**< Backdoor Comparison Key 0, offset: 0x0 */
+  __I  uint8_t BACKKEY1;                           /**< Backdoor Comparison Key 1, offset: 0x1 */
+  __I  uint8_t BACKKEY2;                           /**< Backdoor Comparison Key 2, offset: 0x2 */
+  __I  uint8_t BACKKEY3;                           /**< Backdoor Comparison Key 3, offset: 0x3 */
+  __I  uint8_t BACKKEY4;                           /**< Backdoor Comparison Key 4, offset: 0x4 */
+  __I  uint8_t BACKKEY5;                           /**< Backdoor Comparison Key 5, offset: 0x5 */
+  __I  uint8_t BACKKEY6;                           /**< Backdoor Comparison Key 6, offset: 0x6 */
+  __I  uint8_t BACKKEY7;                           /**< Backdoor Comparison Key 7, offset: 0x7 */
+       uint8_t RESERVED_0[4];
+  __I  uint8_t EEPROT;                             /**< Non-volatile E-Flash Protection Register, offset: 0xC */
+  __I  uint8_t FPROT;                              /**< Non-volatile P-Flash Protection Register, offset: 0xD */
+  __I  uint8_t FSEC;                               /**< Non-volatile Flash Security Register, offset: 0xE */
+  __I  uint8_t FOPT;                               /**< Non-volatile Flash Option Register, offset: 0xF */
+} NV_Type;
+
+/* ----------------------------------------------------------------------------
+   -- NV Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup NV_Register_Masks NV Register Masks
+ * @{
+ */
+
+/* BACKKEY0 Bit Fields */
+#define NV_BACKKEY0_KEY_MASK                     0xFFu
+#define NV_BACKKEY0_KEY_SHIFT                    0
+#define NV_BACKKEY0_KEY(x)                       (((uint8_t)(((uint8_t)(x))<<NV_BACKKEY0_KEY_SHIFT))&NV_BACKKEY0_KEY_MASK)
+/* BACKKEY1 Bit Fields */
+#define NV_BACKKEY1_KEY_MASK                     0xFFu
+#define NV_BACKKEY1_KEY_SHIFT                    0
+#define NV_BACKKEY1_KEY(x)                       (((uint8_t)(((uint8_t)(x))<<NV_BACKKEY1_KEY_SHIFT))&NV_BACKKEY1_KEY_MASK)
+/* BACKKEY2 Bit Fields */
+#define NV_BACKKEY2_KEY_MASK                     0xFFu
+#define NV_BACKKEY2_KEY_SHIFT                    0
+#define NV_BACKKEY2_KEY(x)                       (((uint8_t)(((uint8_t)(x))<<NV_BACKKEY2_KEY_SHIFT))&NV_BACKKEY2_KEY_MASK)
+/* BACKKEY3 Bit Fields */
+#define NV_BACKKEY3_KEY_MASK                     0xFFu
+#define NV_BACKKEY3_KEY_SHIFT                    0
+#define NV_BACKKEY3_KEY(x)                       (((uint8_t)(((uint8_t)(x))<<NV_BACKKEY3_KEY_SHIFT))&NV_BACKKEY3_KEY_MASK)
+/* BACKKEY4 Bit Fields */
+#define NV_BACKKEY4_KEY_MASK                     0xFFu
+#define NV_BACKKEY4_KEY_SHIFT                    0
+#define NV_BACKKEY4_KEY(x)                       (((uint8_t)(((uint8_t)(x))<<NV_BACKKEY4_KEY_SHIFT))&NV_BACKKEY4_KEY_MASK)
+/* BACKKEY5 Bit Fields */
+#define NV_BACKKEY5_KEY_MASK                     0xFFu
+#define NV_BACKKEY5_KEY_SHIFT                    0
+#define NV_BACKKEY5_KEY(x)                       (((uint8_t)(((uint8_t)(x))<<NV_BACKKEY5_KEY_SHIFT))&NV_BACKKEY5_KEY_MASK)
+/* BACKKEY6 Bit Fields */
+#define NV_BACKKEY6_KEY_MASK                     0xFFu
+#define NV_BACKKEY6_KEY_SHIFT                    0
+#define NV_BACKKEY6_KEY(x)                       (((uint8_t)(((uint8_t)(x))<<NV_BACKKEY6_KEY_SHIFT))&NV_BACKKEY6_KEY_MASK)
+/* BACKKEY7 Bit Fields */
+#define NV_BACKKEY7_KEY_MASK                     0xFFu
+#define NV_BACKKEY7_KEY_SHIFT                    0
+#define NV_BACKKEY7_KEY(x)                       (((uint8_t)(((uint8_t)(x))<<NV_BACKKEY7_KEY_SHIFT))&NV_BACKKEY7_KEY_MASK)
+/* EEPROT Bit Fields */
+#define NV_EEPROT_DPS_MASK                       0x7u
+#define NV_EEPROT_DPS_SHIFT                      0
+#define NV_EEPROT_DPS(x)                         (((uint8_t)(((uint8_t)(x))<<NV_EEPROT_DPS_SHIFT))&NV_EEPROT_DPS_MASK)
+#define NV_EEPROT_DPOPEN_MASK                    0x80u
+#define NV_EEPROT_DPOPEN_SHIFT                   7
+/* FPROT Bit Fields */
+#define NV_FPROT_FPLS_MASK                       0x3u
+#define NV_FPROT_FPLS_SHIFT                      0
+#define NV_FPROT_FPLS(x)                         (((uint8_t)(((uint8_t)(x))<<NV_FPROT_FPLS_SHIFT))&NV_FPROT_FPLS_MASK)
+#define NV_FPROT_FPLDIS_MASK                     0x4u
+#define NV_FPROT_FPLDIS_SHIFT                    2
+#define NV_FPROT_FPHS_MASK                       0x18u
+#define NV_FPROT_FPHS_SHIFT                      3
+#define NV_FPROT_FPHS(x)                         (((uint8_t)(((uint8_t)(x))<<NV_FPROT_FPHS_SHIFT))&NV_FPROT_FPHS_MASK)
+#define NV_FPROT_FPHDIS_MASK                     0x20u
+#define NV_FPROT_FPHDIS_SHIFT                    5
+#define NV_FPROT_FPOPEN_MASK                     0x80u
+#define NV_FPROT_FPOPEN_SHIFT                    7
+/* FSEC Bit Fields */
+#define NV_FSEC_SEC_MASK                         0x3u
+#define NV_FSEC_SEC_SHIFT                        0
+#define NV_FSEC_SEC(x)                           (((uint8_t)(((uint8_t)(x))<<NV_FSEC_SEC_SHIFT))&NV_FSEC_SEC_MASK)
+#define NV_FSEC_KEYEN_MASK                       0xC0u
+#define NV_FSEC_KEYEN_SHIFT                      6
+#define NV_FSEC_KEYEN(x)                         (((uint8_t)(((uint8_t)(x))<<NV_FSEC_KEYEN_SHIFT))&NV_FSEC_KEYEN_MASK)
+
+/*!
+ * @}
+ */ /* end of group NV_Register_Masks */
+
+
+/* NV - Peripheral instance base addresses */
+/** Peripheral FTMRH_FlashConfig base address */
+#define FTMRH_FlashConfig_BASE                   (0x400u)
+/** Peripheral FTMRH_FlashConfig base pointer */
+#define FTMRH_FlashConfig                        ((NV_Type *)FTMRH_FlashConfig_BASE)
+/** Array initializer of NV peripheral base pointers */
+#define NV_BASES                                 { FTMRH_FlashConfig }
+
+/*!
+ * @}
+ */ /* end of group NV_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- OSC Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup OSC_Peripheral_Access_Layer OSC Peripheral Access Layer
+ * @{
+ */
+
+/** OSC - Register Layout Typedef */
+typedef struct {
+  __IO uint8_t CR;                                 /**< OSC Control Register, offset: 0x0 */
+} OSC_Type;
+
+/* ----------------------------------------------------------------------------
+   -- OSC Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup OSC_Register_Masks OSC Register Masks
+ * @{
+ */
+
+/* CR Bit Fields */
+#define OSC_CR_OSCINIT_MASK                      0x1u
+#define OSC_CR_OSCINIT_SHIFT                     0
+#define OSC_CR_HGO_MASK                          0x2u
+#define OSC_CR_HGO_SHIFT                         1
+#define OSC_CR_RANGE_MASK                        0x4u
+#define OSC_CR_RANGE_SHIFT                       2
+#define OSC_CR_OSCOS_MASK                        0x10u
+#define OSC_CR_OSCOS_SHIFT                       4
+#define OSC_CR_OSCSTEN_MASK                      0x20u
+#define OSC_CR_OSCSTEN_SHIFT                     5
+#define OSC_CR_OSCEN_MASK                        0x80u
+#define OSC_CR_OSCEN_SHIFT                       7
+
+/*!
+ * @}
+ */ /* end of group OSC_Register_Masks */
+
+
+/* OSC - Peripheral instance base addresses */
+/** Peripheral OSC base address */
+#define OSC_BASE                                 (0x40065000u)
+/** Peripheral OSC base pointer */
+#define OSC                                      ((OSC_Type *)OSC_BASE)
+/** Array initializer of OSC peripheral base pointers */
+#define OSC_BASES                                { OSC }
+
+/*!
+ * @}
+ */ /* end of group OSC_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- PIT Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup PIT_Peripheral_Access_Layer PIT Peripheral Access Layer
+ * @{
+ */
+
+/** PIT - Register Layout Typedef */
+typedef struct {
+  __IO uint32_t MCR;                               /**< PIT Module Control Register, offset: 0x0 */
+       uint8_t RESERVED_0[252];
+  struct {                                         /* offset: 0x100, array step: 0x10 */
+    __IO uint32_t LDVAL;                             /**< Timer Load Value Register, array offset: 0x100, array step: 0x10 */
+    __I  uint32_t CVAL;                              /**< Current Timer Value Register, array offset: 0x104, array step: 0x10 */
+    __IO uint32_t TCTRL;                             /**< Timer Control Register, array offset: 0x108, array step: 0x10 */
+    __IO uint32_t TFLG;                              /**< Timer Flag Register, array offset: 0x10C, array step: 0x10 */
+  } CHANNEL[2];
+} PIT_Type;
+
+/* ----------------------------------------------------------------------------
+   -- PIT Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup PIT_Register_Masks PIT Register Masks
+ * @{
+ */
+
+/* MCR Bit Fields */
+#define PIT_MCR_FRZ_MASK                         0x1u
+#define PIT_MCR_FRZ_SHIFT                        0
+#define PIT_MCR_MDIS_MASK                        0x2u
+#define PIT_MCR_MDIS_SHIFT                       1
+/* LDVAL Bit Fields */
+#define PIT_LDVAL_TSV_MASK                       0xFFFFFFFFu
+#define PIT_LDVAL_TSV_SHIFT                      0
+#define PIT_LDVAL_TSV(x)                         (((uint32_t)(((uint32_t)(x))<<PIT_LDVAL_TSV_SHIFT))&PIT_LDVAL_TSV_MASK)
+/* CVAL Bit Fields */
+#define PIT_CVAL_TVL_MASK                        0xFFFFFFFFu
+#define PIT_CVAL_TVL_SHIFT                       0
+#define PIT_CVAL_TVL(x)                          (((uint32_t)(((uint32_t)(x))<<PIT_CVAL_TVL_SHIFT))&PIT_CVAL_TVL_MASK)
+/* TCTRL Bit Fields */
+#define PIT_TCTRL_TEN_MASK                       0x1u
+#define PIT_TCTRL_TEN_SHIFT                      0
+#define PIT_TCTRL_TIE_MASK                       0x2u
+#define PIT_TCTRL_TIE_SHIFT                      1
+#define PIT_TCTRL_CHN_MASK                       0x4u
+#define PIT_TCTRL_CHN_SHIFT                      2
+/* TFLG Bit Fields */
+#define PIT_TFLG_TIF_MASK                        0x1u
+#define PIT_TFLG_TIF_SHIFT                       0
+
+/*!
+ * @}
+ */ /* end of group PIT_Register_Masks */
+
+
+/* PIT - Peripheral instance base addresses */
+/** Peripheral PIT base address */
+#define PIT_BASE                                 (0x40037000u)
+/** Peripheral PIT base pointer */
+#define PIT                                      ((PIT_Type *)PIT_BASE)
+/** Array initializer of PIT peripheral base pointers */
+#define PIT_BASES                                { PIT }
+
+/*!
+ * @}
+ */ /* end of group PIT_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- PMC Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup PMC_Peripheral_Access_Layer PMC Peripheral Access Layer
+ * @{
+ */
+
+/** PMC - Register Layout Typedef */
+typedef struct {
+  __IO uint8_t SPMSC1;                             /**< System Power Management Status and Control 1 Register, offset: 0x0 */
+  __IO uint8_t SPMSC2;                             /**< System Power Management Status and Control 2 Register, offset: 0x1 */
+} PMC_Type;
+
+/* ----------------------------------------------------------------------------
+   -- PMC Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup PMC_Register_Masks PMC Register Masks
+ * @{
+ */
+
+/* SPMSC1 Bit Fields */
+#define PMC_SPMSC1_BGBE_MASK                     0x1u
+#define PMC_SPMSC1_BGBE_SHIFT                    0
+#define PMC_SPMSC1_BGBDS_MASK                    0x2u
+#define PMC_SPMSC1_BGBDS_SHIFT                   1
+#define PMC_SPMSC1_LVDE_MASK                     0x4u
+#define PMC_SPMSC1_LVDE_SHIFT                    2
+#define PMC_SPMSC1_LVDSE_MASK                    0x8u
+#define PMC_SPMSC1_LVDSE_SHIFT                   3
+#define PMC_SPMSC1_LVDRE_MASK                    0x10u
+#define PMC_SPMSC1_LVDRE_SHIFT                   4
+#define PMC_SPMSC1_LVWIE_MASK                    0x20u
+#define PMC_SPMSC1_LVWIE_SHIFT                   5
+#define PMC_SPMSC1_LVWACK_MASK                   0x40u
+#define PMC_SPMSC1_LVWACK_SHIFT                  6
+#define PMC_SPMSC1_LVWF_MASK                     0x80u
+#define PMC_SPMSC1_LVWF_SHIFT                    7
+/* SPMSC2 Bit Fields */
+#define PMC_SPMSC2_LVWV_MASK                     0x30u
+#define PMC_SPMSC2_LVWV_SHIFT                    4
+#define PMC_SPMSC2_LVWV(x)                       (((uint8_t)(((uint8_t)(x))<<PMC_SPMSC2_LVWV_SHIFT))&PMC_SPMSC2_LVWV_MASK)
+#define PMC_SPMSC2_LVDV_MASK                     0x40u
+#define PMC_SPMSC2_LVDV_SHIFT                    6
+
+/*!
+ * @}
+ */ /* end of group PMC_Register_Masks */
+
+
+/* PMC - Peripheral instance base addresses */
+/** Peripheral PMC base address */
+#define PMC_BASE                                 (0x4007D000u)
+/** Peripheral PMC base pointer */
+#define PMC                                      ((PMC_Type *)PMC_BASE)
+/** Array initializer of PMC peripheral base pointers */
+#define PMC_BASES                                { PMC }
+
+/*!
+ * @}
+ */ /* end of group PMC_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- PORT Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup PORT_Peripheral_Access_Layer PORT Peripheral Access Layer
+ * @{
+ */
+
+/** PORT - Register Layout Typedef */
+typedef struct {
+  __IO uint32_t IOFLT;                             /**< Port Filter Register, offset: 0x0 */
+  __IO uint32_t PUEL;                              /**< Port Pullup Enable Low Register, offset: 0x4 */
+  __IO uint32_t PUEH;                              /**< Port Pullup Enable High Register, offset: 0x8 */
+  __IO uint32_t HDRVE;                             /**< Port High Drive Enable Register, offset: 0xC */
+} PORT_Type;
+
+/* ----------------------------------------------------------------------------
+   -- PORT Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup PORT_Register_Masks PORT Register Masks
+ * @{
+ */
+
+/* IOFLT Bit Fields */
+#define PORT_IOFLT_FLTA_MASK                     0x3u
+#define PORT_IOFLT_FLTA_SHIFT                    0
+#define PORT_IOFLT_FLTA(x)                       (((uint32_t)(((uint32_t)(x))<<PORT_IOFLT_FLTA_SHIFT))&PORT_IOFLT_FLTA_MASK)
+#define PORT_IOFLT_FLTB_MASK                     0xCu
+#define PORT_IOFLT_FLTB_SHIFT                    2
+#define PORT_IOFLT_FLTB(x)                       (((uint32_t)(((uint32_t)(x))<<PORT_IOFLT_FLTB_SHIFT))&PORT_IOFLT_FLTB_MASK)
+#define PORT_IOFLT_FLTC_MASK                     0x30u
+#define PORT_IOFLT_FLTC_SHIFT                    4
+#define PORT_IOFLT_FLTC(x)                       (((uint32_t)(((uint32_t)(x))<<PORT_IOFLT_FLTC_SHIFT))&PORT_IOFLT_FLTC_MASK)
+#define PORT_IOFLT_FLTD_MASK                     0xC0u
+#define PORT_IOFLT_FLTD_SHIFT                    6
+#define PORT_IOFLT_FLTD(x)                       (((uint32_t)(((uint32_t)(x))<<PORT_IOFLT_FLTD_SHIFT))&PORT_IOFLT_FLTD_MASK)
+#define PORT_IOFLT_FLTE_MASK                     0x300u
+#define PORT_IOFLT_FLTE_SHIFT                    8
+#define PORT_IOFLT_FLTE(x)                       (((uint32_t)(((uint32_t)(x))<<PORT_IOFLT_FLTE_SHIFT))&PORT_IOFLT_FLTE_MASK)
+#define PORT_IOFLT_FLTF_MASK                     0xC00u
+#define PORT_IOFLT_FLTF_SHIFT                    10
+#define PORT_IOFLT_FLTF(x)                       (((uint32_t)(((uint32_t)(x))<<PORT_IOFLT_FLTF_SHIFT))&PORT_IOFLT_FLTF_MASK)
+#define PORT_IOFLT_FLTG_MASK                     0x3000u
+#define PORT_IOFLT_FLTG_SHIFT                    12
+#define PORT_IOFLT_FLTG(x)                       (((uint32_t)(((uint32_t)(x))<<PORT_IOFLT_FLTG_SHIFT))&PORT_IOFLT_FLTG_MASK)
+#define PORT_IOFLT_FLTH_MASK                     0xC000u
+#define PORT_IOFLT_FLTH_SHIFT                    14
+#define PORT_IOFLT_FLTH(x)                       (((uint32_t)(((uint32_t)(x))<<PORT_IOFLT_FLTH_SHIFT))&PORT_IOFLT_FLTH_MASK)
+#define PORT_IOFLT_FLTRST_MASK                   0x30000u
+#define PORT_IOFLT_FLTRST_SHIFT                  16
+#define PORT_IOFLT_FLTRST(x)                     (((uint32_t)(((uint32_t)(x))<<PORT_IOFLT_FLTRST_SHIFT))&PORT_IOFLT_FLTRST_MASK)
+#define PORT_IOFLT_FLTKBI0_MASK                  0xC0000u
+#define PORT_IOFLT_FLTKBI0_SHIFT                 18
+#define PORT_IOFLT_FLTKBI0(x)                    (((uint32_t)(((uint32_t)(x))<<PORT_IOFLT_FLTKBI0_SHIFT))&PORT_IOFLT_FLTKBI0_MASK)
+#define PORT_IOFLT_FLTKBI1_MASK                  0x300000u
+#define PORT_IOFLT_FLTKBI1_SHIFT                 20
+#define PORT_IOFLT_FLTKBI1(x)                    (((uint32_t)(((uint32_t)(x))<<PORT_IOFLT_FLTKBI1_SHIFT))&PORT_IOFLT_FLTKBI1_MASK)
+#define PORT_IOFLT_FLTNMI_MASK                   0xC00000u
+#define PORT_IOFLT_FLTNMI_SHIFT                  22
+#define PORT_IOFLT_FLTNMI(x)                     (((uint32_t)(((uint32_t)(x))<<PORT_IOFLT_FLTNMI_SHIFT))&PORT_IOFLT_FLTNMI_MASK)
+#define PORT_IOFLT_FLTDIV1_MASK                  0x3000000u
+#define PORT_IOFLT_FLTDIV1_SHIFT                 24
+#define PORT_IOFLT_FLTDIV1(x)                    (((uint32_t)(((uint32_t)(x))<<PORT_IOFLT_FLTDIV1_SHIFT))&PORT_IOFLT_FLTDIV1_MASK)
+#define PORT_IOFLT_FLTDIV2_MASK                  0x1C000000u
+#define PORT_IOFLT_FLTDIV2_SHIFT                 26
+#define PORT_IOFLT_FLTDIV2(x)                    (((uint32_t)(((uint32_t)(x))<<PORT_IOFLT_FLTDIV2_SHIFT))&PORT_IOFLT_FLTDIV2_MASK)
+#define PORT_IOFLT_FLTDIV3_MASK                  0xE0000000u
+#define PORT_IOFLT_FLTDIV3_SHIFT                 29
+#define PORT_IOFLT_FLTDIV3(x)                    (((uint32_t)(((uint32_t)(x))<<PORT_IOFLT_FLTDIV3_SHIFT))&PORT_IOFLT_FLTDIV3_MASK)
+/* PUEL Bit Fields */
+#define PORT_PUEL_PTAPE0_MASK                    0x1u
+#define PORT_PUEL_PTAPE0_SHIFT                   0
+#define PORT_PUEL_PTAPE1_MASK                    0x2u
+#define PORT_PUEL_PTAPE1_SHIFT                   1
+#define PORT_PUEL_PTAPE2_MASK                    0x4u
+#define PORT_PUEL_PTAPE2_SHIFT                   2
+#define PORT_PUEL_PTAPE3_MASK                    0x8u
+#define PORT_PUEL_PTAPE3_SHIFT                   3
+#define PORT_PUEL_PTAPE4_MASK                    0x10u
+#define PORT_PUEL_PTAPE4_SHIFT                   4
+#define PORT_PUEL_PTAPE5_MASK                    0x20u
+#define PORT_PUEL_PTAPE5_SHIFT                   5
+#define PORT_PUEL_PTAPE6_MASK                    0x40u
+#define PORT_PUEL_PTAPE6_SHIFT                   6
+#define PORT_PUEL_PTAPE7_MASK                    0x80u
+#define PORT_PUEL_PTAPE7_SHIFT                   7
+#define PORT_PUEL_PTBPE0_MASK                    0x100u
+#define PORT_PUEL_PTBPE0_SHIFT                   8
+#define PORT_PUEL_PTBPE1_MASK                    0x200u
+#define PORT_PUEL_PTBPE1_SHIFT                   9
+#define PORT_PUEL_PTBPE2_MASK                    0x400u
+#define PORT_PUEL_PTBPE2_SHIFT                   10
+#define PORT_PUEL_PTBPE3_MASK                    0x800u
+#define PORT_PUEL_PTBPE3_SHIFT                   11
+#define PORT_PUEL_PTBPE4_MASK                    0x1000u
+#define PORT_PUEL_PTBPE4_SHIFT                   12
+#define PORT_PUEL_PTBPE5_MASK                    0x2000u
+#define PORT_PUEL_PTBPE5_SHIFT                   13
+#define PORT_PUEL_PTBPE6_MASK                    0x4000u
+#define PORT_PUEL_PTBPE6_SHIFT                   14
+#define PORT_PUEL_PTBPE7_MASK                    0x8000u
+#define PORT_PUEL_PTBPE7_SHIFT                   15
+#define PORT_PUEL_PTCPE0_MASK                    0x10000u
+#define PORT_PUEL_PTCPE0_SHIFT                   16
+#define PORT_PUEL_PTCPE1_MASK                    0x20000u
+#define PORT_PUEL_PTCPE1_SHIFT                   17
+#define PORT_PUEL_PTCPE2_MASK                    0x40000u
+#define PORT_PUEL_PTCPE2_SHIFT                   18
+#define PORT_PUEL_PTCPE3_MASK                    0x80000u
+#define PORT_PUEL_PTCPE3_SHIFT                   19
+#define PORT_PUEL_PTCPE4_MASK                    0x100000u
+#define PORT_PUEL_PTCPE4_SHIFT                   20
+#define PORT_PUEL_PTCPE5_MASK                    0x200000u
+#define PORT_PUEL_PTCPE5_SHIFT                   21
+#define PORT_PUEL_PTCPE6_MASK                    0x400000u
+#define PORT_PUEL_PTCPE6_SHIFT                   22
+#define PORT_PUEL_PTCPE7_MASK                    0x800000u
+#define PORT_PUEL_PTCPE7_SHIFT                   23
+#define PORT_PUEL_PTDPE0_MASK                    0x1000000u
+#define PORT_PUEL_PTDPE0_SHIFT                   24
+#define PORT_PUEL_PTDPE1_MASK                    0x2000000u
+#define PORT_PUEL_PTDPE1_SHIFT                   25
+#define PORT_PUEL_PTDPE2_MASK                    0x4000000u
+#define PORT_PUEL_PTDPE2_SHIFT                   26
+#define PORT_PUEL_PTDPE3_MASK                    0x8000000u
+#define PORT_PUEL_PTDPE3_SHIFT                   27
+#define PORT_PUEL_PTDPE4_MASK                    0x10000000u
+#define PORT_PUEL_PTDPE4_SHIFT                   28
+#define PORT_PUEL_PTDPE5_MASK                    0x20000000u
+#define PORT_PUEL_PTDPE5_SHIFT                   29
+#define PORT_PUEL_PTDPE6_MASK                    0x40000000u
+#define PORT_PUEL_PTDPE6_SHIFT                   30
+#define PORT_PUEL_PTDPE7_MASK                    0x80000000u
+#define PORT_PUEL_PTDPE7_SHIFT                   31
+/* PUEH Bit Fields */
+#define PORT_PUEH_PTEPE0_MASK                    0x1u
+#define PORT_PUEH_PTEPE0_SHIFT                   0
+#define PORT_PUEH_PTEPE1_MASK                    0x2u
+#define PORT_PUEH_PTEPE1_SHIFT                   1
+#define PORT_PUEH_PTEPE2_MASK                    0x4u
+#define PORT_PUEH_PTEPE2_SHIFT                   2
+#define PORT_PUEH_PTEPE3_MASK                    0x8u
+#define PORT_PUEH_PTEPE3_SHIFT                   3
+#define PORT_PUEH_PTEPE4_MASK                    0x10u
+#define PORT_PUEH_PTEPE4_SHIFT                   4
+#define PORT_PUEH_PTEPE5_MASK                    0x20u
+#define PORT_PUEH_PTEPE5_SHIFT                   5
+#define PORT_PUEH_PTEPE6_MASK                    0x40u
+#define PORT_PUEH_PTEPE6_SHIFT                   6
+#define PORT_PUEH_PTEPE7_MASK                    0x80u
+#define PORT_PUEH_PTEPE7_SHIFT                   7
+#define PORT_PUEH_PTFPE0_MASK                    0x100u
+#define PORT_PUEH_PTFPE0_SHIFT                   8
+#define PORT_PUEH_PTFPE1_MASK                    0x200u
+#define PORT_PUEH_PTFPE1_SHIFT                   9
+#define PORT_PUEH_PTFPE2_MASK                    0x400u
+#define PORT_PUEH_PTFPE2_SHIFT                   10
+#define PORT_PUEH_PTFPE3_MASK                    0x800u
+#define PORT_PUEH_PTFPE3_SHIFT                   11
+#define PORT_PUEH_PTFPE4_MASK                    0x1000u
+#define PORT_PUEH_PTFPE4_SHIFT                   12
+#define PORT_PUEH_PTFPE5_MASK                    0x2000u
+#define PORT_PUEH_PTFPE5_SHIFT                   13
+#define PORT_PUEH_PTFPE6_MASK                    0x4000u
+#define PORT_PUEH_PTFPE6_SHIFT                   14
+#define PORT_PUEH_PTFPE7_MASK                    0x8000u
+#define PORT_PUEH_PTFPE7_SHIFT                   15
+#define PORT_PUEH_PTGPE0_MASK                    0x10000u
+#define PORT_PUEH_PTGPE0_SHIFT                   16
+#define PORT_PUEH_PTGPE1_MASK                    0x20000u
+#define PORT_PUEH_PTGPE1_SHIFT                   17
+#define PORT_PUEH_PTGPE2_MASK                    0x40000u
+#define PORT_PUEH_PTGPE2_SHIFT                   18
+#define PORT_PUEH_PTGPE3_MASK                    0x80000u
+#define PORT_PUEH_PTGPE3_SHIFT                   19
+#define PORT_PUEH_PTHPE0_MASK                    0x1000000u
+#define PORT_PUEH_PTHPE0_SHIFT                   24
+#define PORT_PUEH_PTHPE1_MASK                    0x2000000u
+#define PORT_PUEH_PTHPE1_SHIFT                   25
+#define PORT_PUEH_PTHPE2_MASK                    0x4000000u
+#define PORT_PUEH_PTHPE2_SHIFT                   26
+#define PORT_PUEH_PTHPE6_MASK                    0x40000000u
+#define PORT_PUEH_PTHPE6_SHIFT                   30
+#define PORT_PUEH_PTHPE7_MASK                    0x80000000u
+#define PORT_PUEH_PTHPE7_SHIFT                   31
+/* HDRVE Bit Fields */
+#define PORT_HDRVE_PTB4_MASK                     0x1u
+#define PORT_HDRVE_PTB4_SHIFT                    0
+#define PORT_HDRVE_PTB5_MASK                     0x2u
+#define PORT_HDRVE_PTB5_SHIFT                    1
+#define PORT_HDRVE_PTD0_MASK                     0x4u
+#define PORT_HDRVE_PTD0_SHIFT                    2
+#define PORT_HDRVE_PTD1_MASK                     0x8u
+#define PORT_HDRVE_PTD1_SHIFT                    3
+#define PORT_HDRVE_PTE0_MASK                     0x10u
+#define PORT_HDRVE_PTE0_SHIFT                    4
+#define PORT_HDRVE_PTE1_MASK                     0x20u
+#define PORT_HDRVE_PTE1_SHIFT                    5
+#define PORT_HDRVE_PTH0_MASK                     0x40u
+#define PORT_HDRVE_PTH0_SHIFT                    6
+#define PORT_HDRVE_PTH1_MASK                     0x80u
+#define PORT_HDRVE_PTH1_SHIFT                    7
+
+/*!
+ * @}
+ */ /* end of group PORT_Register_Masks */
+
+
+/* PORT - Peripheral instance base addresses */
+/** Peripheral PORT base address */
+#define PORT_BASE                                (0x40049000u)
+/** Peripheral PORT base pointer */
+#define PORT                                     ((PORT_Type *)PORT_BASE)
+/** Array initializer of PORT peripheral base pointers */
+#define PORT_BASES                               { PORT }
+
+/*!
+ * @}
+ */ /* end of group PORT_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- RTC Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup RTC_Peripheral_Access_Layer RTC Peripheral Access Layer
+ * @{
+ */
+
+/** RTC - Register Layout Typedef */
+typedef struct {
+  __IO uint32_t SC;                                /**< RTC Status and Control Register, offset: 0x0 */
+  __IO uint32_t MOD;                               /**< RTC Modulo Register, offset: 0x4 */
+  __I  uint32_t CNT;                               /**< RTC Counter Register, offset: 0x8 */
+} RTC_Type;
+
+/* ----------------------------------------------------------------------------
+   -- RTC Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup RTC_Register_Masks RTC Register Masks
+ * @{
+ */
+
+/* SC Bit Fields */
+#define RTC_SC_RTCO_MASK                         0x10u
+#define RTC_SC_RTCO_SHIFT                        4
+#define RTC_SC_RTIE_MASK                         0x40u
+#define RTC_SC_RTIE_SHIFT                        6
+#define RTC_SC_RTIF_MASK                         0x80u
+#define RTC_SC_RTIF_SHIFT                        7
+#define RTC_SC_RTCPS_MASK                        0x700u
+#define RTC_SC_RTCPS_SHIFT                       8
+#define RTC_SC_RTCPS(x)                          (((uint32_t)(((uint32_t)(x))<<RTC_SC_RTCPS_SHIFT))&RTC_SC_RTCPS_MASK)
+#define RTC_SC_RTCLKS_MASK                       0xC000u
+#define RTC_SC_RTCLKS_SHIFT                      14
+#define RTC_SC_RTCLKS(x)                         (((uint32_t)(((uint32_t)(x))<<RTC_SC_RTCLKS_SHIFT))&RTC_SC_RTCLKS_MASK)
+/* MOD Bit Fields */
+#define RTC_MOD_MOD_MASK                         0xFFFFu
+#define RTC_MOD_MOD_SHIFT                        0
+#define RTC_MOD_MOD(x)                           (((uint32_t)(((uint32_t)(x))<<RTC_MOD_MOD_SHIFT))&RTC_MOD_MOD_MASK)
+/* CNT Bit Fields */
+#define RTC_CNT_CNT_MASK                         0xFFFFu
+#define RTC_CNT_CNT_SHIFT                        0
+#define RTC_CNT_CNT(x)                           (((uint32_t)(((uint32_t)(x))<<RTC_CNT_CNT_SHIFT))&RTC_CNT_CNT_MASK)
+
+/*!
+ * @}
+ */ /* end of group RTC_Register_Masks */
+
+
+/* RTC - Peripheral instance base addresses */
+/** Peripheral RTC base address */
+#define RTC_BASE                                 (0x4003D000u)
+/** Peripheral RTC base pointer */
+#define RTC                                      ((RTC_Type *)RTC_BASE)
+/** Array initializer of RTC peripheral base pointers */
+#define RTC_BASES                                { RTC }
+
+/*!
+ * @}
+ */ /* end of group RTC_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- SIM Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup SIM_Peripheral_Access_Layer SIM Peripheral Access Layer
+ * @{
+ */
+
+/** SIM - Register Layout Typedef */
+typedef struct {
+  __I  uint32_t SRSID;                             /**< System Reset Status and ID Register, offset: 0x0 */
+  __IO uint32_t SOPT;                              /**< System Options Register, offset: 0x4 */
+  __IO uint32_t PINSEL;                            /**< Pin Selection Register, offset: 0x8 */
+  __IO uint32_t SCGC;                              /**< System Clock Gating Control Register, offset: 0xC */
+  __I  uint32_t UUIDL;                             /**< Universally Unique Identifier Low Register, offset: 0x10 */
+  __I  uint32_t UUIDH;                             /**< Universally Unique Identifier High Register, offset: 0x14 */
+  __IO uint32_t BUSDIV;                            /**< BUS Clock Divider Register, offset: 0x18 */
+} SIM_Type;
+
+/* ----------------------------------------------------------------------------
+   -- SIM Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup SIM_Register_Masks SIM Register Masks
+ * @{
+ */
+
+/* SRSID Bit Fields */
+#define SIM_SRSID_LVD_MASK                       0x2u
+#define SIM_SRSID_LVD_SHIFT                      1
+#define SIM_SRSID_LOC_MASK                       0x4u
+#define SIM_SRSID_LOC_SHIFT                      2
+#define SIM_SRSID_WDOG_MASK                      0x20u
+#define SIM_SRSID_WDOG_SHIFT                     5
+#define SIM_SRSID_PIN_MASK                       0x40u
+#define SIM_SRSID_PIN_SHIFT                      6
+#define SIM_SRSID_POR_MASK                       0x80u
+#define SIM_SRSID_POR_SHIFT                      7
+#define SIM_SRSID_LOCKUP_MASK                    0x200u
+#define SIM_SRSID_LOCKUP_SHIFT                   9
+#define SIM_SRSID_SW_MASK                        0x400u
+#define SIM_SRSID_SW_SHIFT                       10
+#define SIM_SRSID_MDMAP_MASK                     0x800u
+#define SIM_SRSID_MDMAP_SHIFT                    11
+#define SIM_SRSID_SACKERR_MASK                   0x2000u
+#define SIM_SRSID_SACKERR_SHIFT                  13
+#define SIM_SRSID_PINID_MASK                     0xF0000u
+#define SIM_SRSID_PINID_SHIFT                    16
+#define SIM_SRSID_PINID(x)                       (((uint32_t)(((uint32_t)(x))<<SIM_SRSID_PINID_SHIFT))&SIM_SRSID_PINID_MASK)
+#define SIM_SRSID_RevID_MASK                     0xF00000u
+#define SIM_SRSID_RevID_SHIFT                    20
+#define SIM_SRSID_RevID(x)                       (((uint32_t)(((uint32_t)(x))<<SIM_SRSID_RevID_SHIFT))&SIM_SRSID_RevID_MASK)
+#define SIM_SRSID_SUBFAMID_MASK                  0xF000000u
+#define SIM_SRSID_SUBFAMID_SHIFT                 24
+#define SIM_SRSID_SUBFAMID(x)                    (((uint32_t)(((uint32_t)(x))<<SIM_SRSID_SUBFAMID_SHIFT))&SIM_SRSID_SUBFAMID_MASK)
+#define SIM_SRSID_FAMID_MASK                     0xF0000000u
+#define SIM_SRSID_FAMID_SHIFT                    28
+#define SIM_SRSID_FAMID(x)                       (((uint32_t)(((uint32_t)(x))<<SIM_SRSID_FAMID_SHIFT))&SIM_SRSID_FAMID_MASK)
+/* SOPT Bit Fields */
+#define SIM_SOPT_NMIE_MASK                       0x2u
+#define SIM_SOPT_NMIE_SHIFT                      1
+#define SIM_SOPT_RSTPE_MASK                      0x4u
+#define SIM_SOPT_RSTPE_SHIFT                     2
+#define SIM_SOPT_SWDE_MASK                       0x8u
+#define SIM_SOPT_SWDE_SHIFT                      3
+#define SIM_SOPT_ADHWT_MASK                      0x300u
+#define SIM_SOPT_ADHWT_SHIFT                     8
+#define SIM_SOPT_ADHWT(x)                        (((uint32_t)(((uint32_t)(x))<<SIM_SOPT_ADHWT_SHIFT))&SIM_SOPT_ADHWT_MASK)
+#define SIM_SOPT_RTCC_MASK                       0x400u
+#define SIM_SOPT_RTCC_SHIFT                      10
+#define SIM_SOPT_ACIC_MASK                       0x800u
+#define SIM_SOPT_ACIC_SHIFT                      11
+#define SIM_SOPT_RXDCE_MASK                      0x1000u
+#define SIM_SOPT_RXDCE_SHIFT                     12
+#define SIM_SOPT_RXDFE_MASK                      0x2000u
+#define SIM_SOPT_RXDFE_SHIFT                     13
+#define SIM_SOPT_FTMSYNC_MASK                    0x4000u
+#define SIM_SOPT_FTMSYNC_SHIFT                   14
+#define SIM_SOPT_TXDME_MASK                      0x8000u
+#define SIM_SOPT_TXDME_SHIFT                     15
+#define SIM_SOPT_BUSREF_MASK                     0x70000u
+#define SIM_SOPT_BUSREF_SHIFT                    16
+#define SIM_SOPT_BUSREF(x)                       (((uint32_t)(((uint32_t)(x))<<SIM_SOPT_BUSREF_SHIFT))&SIM_SOPT_BUSREF_MASK)
+#define SIM_SOPT_CLKOE_MASK                      0x80000u
+#define SIM_SOPT_CLKOE_SHIFT                     19
+#define SIM_SOPT_DLYACT_MASK                     0x800000u
+#define SIM_SOPT_DLYACT_SHIFT                    23
+#define SIM_SOPT_DELAY_MASK                      0xFF000000u
+#define SIM_SOPT_DELAY_SHIFT                     24
+#define SIM_SOPT_DELAY(x)                        (((uint32_t)(((uint32_t)(x))<<SIM_SOPT_DELAY_SHIFT))&SIM_SOPT_DELAY_MASK)
+/* PINSEL Bit Fields */
+#define SIM_PINSEL_RTCPS_MASK                    0x10u
+#define SIM_PINSEL_RTCPS_SHIFT                   4
+#define SIM_PINSEL_IICPS_MASK                    0x20u
+#define SIM_PINSEL_IICPS_SHIFT                   5
+#define SIM_PINSEL_SPI0PS_MASK                   0x40u
+#define SIM_PINSEL_SPI0PS_SHIFT                  6
+#define SIM_PINSEL_UART0PS_MASK                  0x80u
+#define SIM_PINSEL_UART0PS_SHIFT                 7
+#define SIM_PINSEL_FTM0PS0_MASK                  0x100u
+#define SIM_PINSEL_FTM0PS0_SHIFT                 8
+#define SIM_PINSEL_FTM0PS1_MASK                  0x200u
+#define SIM_PINSEL_FTM0PS1_SHIFT                 9
+#define SIM_PINSEL_FTM1PS0_MASK                  0x400u
+#define SIM_PINSEL_FTM1PS0_SHIFT                 10
+#define SIM_PINSEL_FTM1PS1_MASK                  0x800u
+#define SIM_PINSEL_FTM1PS1_SHIFT                 11
+#define SIM_PINSEL_FTM2PS0_MASK                  0x1000u
+#define SIM_PINSEL_FTM2PS0_SHIFT                 12
+#define SIM_PINSEL_FTM2PS1_MASK                  0x2000u
+#define SIM_PINSEL_FTM2PS1_SHIFT                 13
+#define SIM_PINSEL_FTM2PS2_MASK                  0x4000u
+#define SIM_PINSEL_FTM2PS2_SHIFT                 14
+#define SIM_PINSEL_FTM2PS3_MASK                  0x8000u
+#define SIM_PINSEL_FTM2PS3_SHIFT                 15
+/* SCGC Bit Fields */
+#define SIM_SCGC_RTC_MASK                        0x1u
+#define SIM_SCGC_RTC_SHIFT                       0
+#define SIM_SCGC_PIT_MASK                        0x2u
+#define SIM_SCGC_PIT_SHIFT                       1
+#define SIM_SCGC_FTM0_MASK                       0x20u
+#define SIM_SCGC_FTM0_SHIFT                      5
+#define SIM_SCGC_FTM1_MASK                       0x40u
+#define SIM_SCGC_FTM1_SHIFT                      6
+#define SIM_SCGC_FTM2_MASK                       0x80u
+#define SIM_SCGC_FTM2_SHIFT                      7
+#define SIM_SCGC_CRC_MASK                        0x400u
+#define SIM_SCGC_CRC_SHIFT                       10
+#define SIM_SCGC_FLASH_MASK                      0x1000u
+#define SIM_SCGC_FLASH_SHIFT                     12
+#define SIM_SCGC_SWD_MASK                        0x2000u
+#define SIM_SCGC_SWD_SHIFT                       13
+#define SIM_SCGC_IIC_MASK                        0x20000u
+#define SIM_SCGC_IIC_SHIFT                       17
+#define SIM_SCGC_SPI0_MASK                       0x40000u
+#define SIM_SCGC_SPI0_SHIFT                      18
+#define SIM_SCGC_SPI1_MASK                       0x80000u
+#define SIM_SCGC_SPI1_SHIFT                      19
+#define SIM_SCGC_UART0_MASK                      0x100000u
+#define SIM_SCGC_UART0_SHIFT                     20
+#define SIM_SCGC_UART1_MASK                      0x200000u
+#define SIM_SCGC_UART1_SHIFT                     21
+#define SIM_SCGC_UART2_MASK                      0x400000u
+#define SIM_SCGC_UART2_SHIFT                     22
+#define SIM_SCGC_KBI0_MASK                       0x1000000u
+#define SIM_SCGC_KBI0_SHIFT                      24
+#define SIM_SCGC_KBI1_MASK                       0x2000000u
+#define SIM_SCGC_KBI1_SHIFT                      25
+#define SIM_SCGC_IRQ_MASK                        0x8000000u
+#define SIM_SCGC_IRQ_SHIFT                       27
+#define SIM_SCGC_ADC_MASK                        0x20000000u
+#define SIM_SCGC_ADC_SHIFT                       29
+#define SIM_SCGC_ACMP0_MASK                      0x40000000u
+#define SIM_SCGC_ACMP0_SHIFT                     30
+#define SIM_SCGC_ACMP1_MASK                      0x80000000u
+#define SIM_SCGC_ACMP1_SHIFT                     31
+/* UUIDL Bit Fields */
+#define SIM_UUIDL_ID_MASK                        0xFFFFFFFFu
+#define SIM_UUIDL_ID_SHIFT                       0
+#define SIM_UUIDL_ID(x)                          (((uint32_t)(((uint32_t)(x))<<SIM_UUIDL_ID_SHIFT))&SIM_UUIDL_ID_MASK)
+/* UUIDH Bit Fields */
+#define SIM_UUIDH_ID_MASK                        0xFFFFFFFFu
+#define SIM_UUIDH_ID_SHIFT                       0
+#define SIM_UUIDH_ID(x)                          (((uint32_t)(((uint32_t)(x))<<SIM_UUIDH_ID_SHIFT))&SIM_UUIDH_ID_MASK)
+/* BUSDIV Bit Fields */
+#define SIM_BUSDIV_BUSDIV_MASK                   0x1u
+#define SIM_BUSDIV_BUSDIV_SHIFT                  0
+
+/*!
+ * @}
+ */ /* end of group SIM_Register_Masks */
+
+
+/* SIM - Peripheral instance base addresses */
+/** Peripheral SIM base address */
+#define SIM_BASE                                 (0x40048000u)
+/** Peripheral SIM base pointer */
+#define SIM                                      ((SIM_Type *)SIM_BASE)
+/** Array initializer of SIM peripheral base pointers */
+#define SIM_BASES                                { SIM }
+
+/*!
+ * @}
+ */ /* end of group SIM_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- SPI Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup SPI_Peripheral_Access_Layer SPI Peripheral Access Layer
+ * @{
+ */
+
+/** SPI - Register Layout Typedef */
+typedef struct {
+  __IO uint8_t C1;                                 /**< SPI control register 1, offset: 0x0 */
+  __IO uint8_t C2;                                 /**< SPI control register 2, offset: 0x1 */
+  __IO uint8_t BR;                                 /**< SPI baud rate register, offset: 0x2 */
+  __I  uint8_t S;                                  /**< SPI status register, offset: 0x3 */
+       uint8_t RESERVED_0[1];
+  __IO uint8_t D;                                  /**< SPI data register, offset: 0x5 */
+       uint8_t RESERVED_1[1];
+  __IO uint8_t M;                                  /**< SPI match register, offset: 0x7 */
+} SPI_Type;
+
+/* ----------------------------------------------------------------------------
+   -- SPI Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup SPI_Register_Masks SPI Register Masks
+ * @{
+ */
+
+/* C1 Bit Fields */
+#define SPI_C1_LSBFE_MASK                        0x1u
+#define SPI_C1_LSBFE_SHIFT                       0
+#define SPI_C1_SSOE_MASK                         0x2u
+#define SPI_C1_SSOE_SHIFT                        1
+#define SPI_C1_CPHA_MASK                         0x4u
+#define SPI_C1_CPHA_SHIFT                        2
+#define SPI_C1_CPOL_MASK                         0x8u
+#define SPI_C1_CPOL_SHIFT                        3
+#define SPI_C1_MSTR_MASK                         0x10u
+#define SPI_C1_MSTR_SHIFT                        4
+#define SPI_C1_SPTIE_MASK                        0x20u
+#define SPI_C1_SPTIE_SHIFT                       5
+#define SPI_C1_SPE_MASK                          0x40u
+#define SPI_C1_SPE_SHIFT                         6
+#define SPI_C1_SPIE_MASK                         0x80u
+#define SPI_C1_SPIE_SHIFT                        7
+/* C2 Bit Fields */
+#define SPI_C2_SPC0_MASK                         0x1u
+#define SPI_C2_SPC0_SHIFT                        0
+#define SPI_C2_SPISWAI_MASK                      0x2u
+#define SPI_C2_SPISWAI_SHIFT                     1
+#define SPI_C2_BIDIROE_MASK                      0x8u
+#define SPI_C2_BIDIROE_SHIFT                     3
+#define SPI_C2_MODFEN_MASK                       0x10u
+#define SPI_C2_MODFEN_SHIFT                      4
+#define SPI_C2_SPMIE_MASK                        0x80u
+#define SPI_C2_SPMIE_SHIFT                       7
+/* BR Bit Fields */
+#define SPI_BR_SPR_MASK                          0xFu
+#define SPI_BR_SPR_SHIFT                         0
+#define SPI_BR_SPR(x)                            (((uint8_t)(((uint8_t)(x))<<SPI_BR_SPR_SHIFT))&SPI_BR_SPR_MASK)
+#define SPI_BR_SPPR_MASK                         0x70u
+#define SPI_BR_SPPR_SHIFT                        4
+#define SPI_BR_SPPR(x)                           (((uint8_t)(((uint8_t)(x))<<SPI_BR_SPPR_SHIFT))&SPI_BR_SPPR_MASK)
+/* S Bit Fields */
+#define SPI_S_MODF_MASK                          0x10u
+#define SPI_S_MODF_SHIFT                         4
+#define SPI_S_SPTEF_MASK                         0x20u
+#define SPI_S_SPTEF_SHIFT                        5
+#define SPI_S_SPMF_MASK                          0x40u
+#define SPI_S_SPMF_SHIFT                         6
+#define SPI_S_SPRF_MASK                          0x80u
+#define SPI_S_SPRF_SHIFT                         7
+/* D Bit Fields */
+#define SPI_D_Bits_MASK                          0xFFu
+#define SPI_D_Bits_SHIFT                         0
+#define SPI_D_Bits(x)                            (((uint8_t)(((uint8_t)(x))<<SPI_D_Bits_SHIFT))&SPI_D_Bits_MASK)
+/* M Bit Fields */
+#define SPI_M_Bits_MASK                          0xFFu
+#define SPI_M_Bits_SHIFT                         0
+#define SPI_M_Bits(x)                            (((uint8_t)(((uint8_t)(x))<<SPI_M_Bits_SHIFT))&SPI_M_Bits_MASK)
+
+/*!
+ * @}
+ */ /* end of group SPI_Register_Masks */
+
+
+/* SPI - Peripheral instance base addresses */
+/** Peripheral SPI0 base address */
+#define SPI0_BASE                                (0x40076000u)
+/** Peripheral SPI0 base pointer */
+#define SPI0                                     ((SPI_Type *)SPI0_BASE)
+/** Peripheral SPI1 base address */
+#define SPI1_BASE                                (0x40077000u)
+/** Peripheral SPI1 base pointer */
+#define SPI1                                     ((SPI_Type *)SPI1_BASE)
+/** Array initializer of SPI peripheral base pointers */
+#define SPI_BASES                                { SPI0, SPI1 }
+
+/*!
+ * @}
+ */ /* end of group SPI_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- UART Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup UART_Peripheral_Access_Layer UART Peripheral Access Layer
+ * @{
+ */
+
+/** UART - Register Layout Typedef */
+typedef struct {
+  __IO uint8_t BDH;                                /**< UART Baud Rate Register: High, offset: 0x0 */
+  __IO uint8_t BDL;                                /**< UART Baud Rate Register: Low, offset: 0x1 */
+  __IO uint8_t C1;                                 /**< UART Control Register 1, offset: 0x2 */
+  __IO uint8_t C2;                                 /**< UART Control Register 2, offset: 0x3 */
+  __I  uint8_t S1;                                 /**< UART Status Register 1, offset: 0x4 */
+  __IO uint8_t S2;                                 /**< UART Status Register 2, offset: 0x5 */
+  __IO uint8_t C3;                                 /**< UART Control Register 3, offset: 0x6 */
+  __IO uint8_t D;                                  /**< UART Data Register, offset: 0x7 */
+} UART_Type;
+
+/* ----------------------------------------------------------------------------
+   -- UART Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup UART_Register_Masks UART Register Masks
+ * @{
+ */
+
+/* BDH Bit Fields */
+#define UART_BDH_SBR_MASK                        0x1Fu
+#define UART_BDH_SBR_SHIFT                       0
+#define UART_BDH_SBR(x)                          (((uint8_t)(((uint8_t)(x))<<UART_BDH_SBR_SHIFT))&UART_BDH_SBR_MASK)
+#define UART_BDH_SBNS_MASK                       0x20u
+#define UART_BDH_SBNS_SHIFT                      5
+#define UART_BDH_RXEDGIE_MASK                    0x40u
+#define UART_BDH_RXEDGIE_SHIFT                   6
+#define UART_BDH_LBKDIE_MASK                     0x80u
+#define UART_BDH_LBKDIE_SHIFT                    7
+/* BDL Bit Fields */
+#define UART_BDL_SBR_MASK                        0xFFu
+#define UART_BDL_SBR_SHIFT                       0
+#define UART_BDL_SBR(x)                          (((uint8_t)(((uint8_t)(x))<<UART_BDL_SBR_SHIFT))&UART_BDL_SBR_MASK)
+/* C1 Bit Fields */
+#define UART_C1_PT_MASK                          0x1u
+#define UART_C1_PT_SHIFT                         0
+#define UART_C1_PE_MASK                          0x2u
+#define UART_C1_PE_SHIFT                         1
+#define UART_C1_ILT_MASK                         0x4u
+#define UART_C1_ILT_SHIFT                        2
+#define UART_C1_WAKE_MASK                        0x8u
+#define UART_C1_WAKE_SHIFT                       3
+#define UART_C1_M_MASK                           0x10u
+#define UART_C1_M_SHIFT                          4
+#define UART_C1_RSRC_MASK                        0x20u
+#define UART_C1_RSRC_SHIFT                       5
+#define UART_C1_UARTSWAI_MASK                    0x40u
+#define UART_C1_UARTSWAI_SHIFT                   6
+#define UART_C1_LOOPS_MASK                       0x80u
+#define UART_C1_LOOPS_SHIFT                      7
+/* C2 Bit Fields */
+#define UART_C2_SBK_MASK                         0x1u
+#define UART_C2_SBK_SHIFT                        0
+#define UART_C2_RWU_MASK                         0x2u
+#define UART_C2_RWU_SHIFT                        1
+#define UART_C2_RE_MASK                          0x4u
+#define UART_C2_RE_SHIFT                         2
+#define UART_C2_TE_MASK                          0x8u
+#define UART_C2_TE_SHIFT                         3
+#define UART_C2_ILIE_MASK                        0x10u
+#define UART_C2_ILIE_SHIFT                       4
+#define UART_C2_RIE_MASK                         0x20u
+#define UART_C2_RIE_SHIFT                        5
+#define UART_C2_TCIE_MASK                        0x40u
+#define UART_C2_TCIE_SHIFT                       6
+#define UART_C2_TIE_MASK                         0x80u
+#define UART_C2_TIE_SHIFT                        7
+/* S1 Bit Fields */
+#define UART_S1_PF_MASK                          0x1u
+#define UART_S1_PF_SHIFT                         0
+#define UART_S1_FE_MASK                          0x2u
+#define UART_S1_FE_SHIFT                         1
+#define UART_S1_NF_MASK                          0x4u
+#define UART_S1_NF_SHIFT                         2
+#define UART_S1_OR_MASK                          0x8u
+#define UART_S1_OR_SHIFT                         3
+#define UART_S1_IDLE_MASK                        0x10u
+#define UART_S1_IDLE_SHIFT                       4
+#define UART_S1_RDRF_MASK                        0x20u
+#define UART_S1_RDRF_SHIFT                       5
+#define UART_S1_TC_MASK                          0x40u
+#define UART_S1_TC_SHIFT                         6
+#define UART_S1_TDRE_MASK                        0x80u
+#define UART_S1_TDRE_SHIFT                       7
+/* S2 Bit Fields */
+#define UART_S2_RAF_MASK                         0x1u
+#define UART_S2_RAF_SHIFT                        0
+#define UART_S2_LBKDE_MASK                       0x2u
+#define UART_S2_LBKDE_SHIFT                      1
+#define UART_S2_BRK13_MASK                       0x4u
+#define UART_S2_BRK13_SHIFT                      2
+#define UART_S2_RWUID_MASK                       0x8u
+#define UART_S2_RWUID_SHIFT                      3
+#define UART_S2_RXINV_MASK                       0x10u
+#define UART_S2_RXINV_SHIFT                      4
+#define UART_S2_RXEDGIF_MASK                     0x40u
+#define UART_S2_RXEDGIF_SHIFT                    6
+#define UART_S2_LBKDIF_MASK                      0x80u
+#define UART_S2_LBKDIF_SHIFT                     7
+/* C3 Bit Fields */
+#define UART_C3_PEIE_MASK                        0x1u
+#define UART_C3_PEIE_SHIFT                       0
+#define UART_C3_FEIE_MASK                        0x2u
+#define UART_C3_FEIE_SHIFT                       1
+#define UART_C3_NEIE_MASK                        0x4u
+#define UART_C3_NEIE_SHIFT                       2
+#define UART_C3_ORIE_MASK                        0x8u
+#define UART_C3_ORIE_SHIFT                       3
+#define UART_C3_TXINV_MASK                       0x10u
+#define UART_C3_TXINV_SHIFT                      4
+#define UART_C3_TXDIR_MASK                       0x20u
+#define UART_C3_TXDIR_SHIFT                      5
+#define UART_C3_T8_MASK                          0x40u
+#define UART_C3_T8_SHIFT                         6
+#define UART_C3_R8_MASK                          0x80u
+#define UART_C3_R8_SHIFT                         7
+/* D Bit Fields */
+#define UART_D_R0T0_MASK                         0x1u
+#define UART_D_R0T0_SHIFT                        0
+#define UART_D_R1T1_MASK                         0x2u
+#define UART_D_R1T1_SHIFT                        1
+#define UART_D_R2T2_MASK                         0x4u
+#define UART_D_R2T2_SHIFT                        2
+#define UART_D_R3T3_MASK                         0x8u
+#define UART_D_R3T3_SHIFT                        3
+#define UART_D_R4T4_MASK                         0x10u
+#define UART_D_R4T4_SHIFT                        4
+#define UART_D_R5T5_MASK                         0x20u
+#define UART_D_R5T5_SHIFT                        5
+#define UART_D_R6T6_MASK                         0x40u
+#define UART_D_R6T6_SHIFT                        6
+#define UART_D_R7T7_MASK                         0x80u
+#define UART_D_R7T7_SHIFT                        7
+
+/*!
+ * @}
+ */ /* end of group UART_Register_Masks */
+
+
+/* UART - Peripheral instance base addresses */
+/** Peripheral UART0 base address */
+#define UART0_BASE                               (0x4006A000u)
+/** Peripheral UART0 base pointer */
+#define UART0                                    ((UART_Type *)UART0_BASE)
+/** Peripheral UART1 base address */
+#define UART1_BASE                               (0x4006B000u)
+/** Peripheral UART1 base pointer */
+#define UART1                                    ((UART_Type *)UART1_BASE)
+/** Peripheral UART2 base address */
+#define UART2_BASE                               (0x4006C000u)
+/** Peripheral UART2 base pointer */
+#define UART2                                    ((UART_Type *)UART2_BASE)
+/** Array initializer of UART peripheral base pointers */
+#define UART_BASES                               { UART0, UART1, UART2 }
+
+/*!
+ * @}
+ */ /* end of group UART_Peripheral_Access_Layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- WDOG Peripheral Access Layer
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup WDOG_Peripheral_Access_Layer WDOG Peripheral Access Layer
+ * @{
+ */
+
+/** WDOG - Register Layout Typedef */
+typedef struct {
+  __IO uint8_t CS1;                                /**< Watchdog Control and Status Register 1, offset: 0x0 */
+  __IO uint8_t CS2;                                /**< Watchdog Control and Status Register 2, offset: 0x1 */
+  union {                                          /* offset: 0x2 */
+    __IO uint16_t CNT;                               /**< WDOG_CNT register., offset: 0x2 */
+    struct {                                         /* offset: 0x2 */
+      __I  uint8_t CNTH;                               /**< Watchdog Counter Register: High, offset: 0x2 */
+      __I  uint8_t CNTL;                               /**< Watchdog Counter Register: Low, offset: 0x3 */
+    } CNT8B;
+  };
+  union {                                          /* offset: 0x4 */
+    __IO uint16_t TOVAL;                             /**< WDOG_TOVAL register., offset: 0x4 */
+    struct {                                         /* offset: 0x4 */
+      __IO uint8_t TOVALH;                             /**< Watchdog Timeout Value Register: High, offset: 0x4 */
+      __IO uint8_t TOVALL;                             /**< Watchdog Timeout Value Register: Low, offset: 0x5 */
+    } TOVAL8B;
+  };
+  union {                                          /* offset: 0x6 */
+    __IO uint16_t WIN;                               /**< WDOG_WIN register., offset: 0x6 */
+    struct {                                         /* offset: 0x6 */
+      __IO uint8_t WINH;                               /**< Watchdog Window Register: High, offset: 0x6 */
+      __IO uint8_t WINL;                               /**< Watchdog Window Register: Low, offset: 0x7 */
+    } WIN8B;
+  };
+} WDOG_Type;
+
+/* ----------------------------------------------------------------------------
+   -- WDOG Register Masks
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup WDOG_Register_Masks WDOG Register Masks
+ * @{
+ */
+
+/* CS1 Bit Fields */
+#define WDOG_CS1_STOP_MASK                       0x1u
+#define WDOG_CS1_STOP_SHIFT                      0
+#define WDOG_CS1_WAIT_MASK                       0x2u
+#define WDOG_CS1_WAIT_SHIFT                      1
+#define WDOG_CS1_DBG_MASK                        0x4u
+#define WDOG_CS1_DBG_SHIFT                       2
+#define WDOG_CS1_TST_MASK                        0x18u
+#define WDOG_CS1_TST_SHIFT                       3
+#define WDOG_CS1_TST(x)                          (((uint8_t)(((uint8_t)(x))<<WDOG_CS1_TST_SHIFT))&WDOG_CS1_TST_MASK)
+#define WDOG_CS1_UPDATE_MASK                     0x20u
+#define WDOG_CS1_UPDATE_SHIFT                    5
+#define WDOG_CS1_INT_MASK                        0x40u
+#define WDOG_CS1_INT_SHIFT                       6
+#define WDOG_CS1_EN_MASK                         0x80u
+#define WDOG_CS1_EN_SHIFT                        7
+/* CS2 Bit Fields */
+#define WDOG_CS2_CLK_MASK                        0x3u
+#define WDOG_CS2_CLK_SHIFT                       0
+#define WDOG_CS2_CLK(x)                          (((uint8_t)(((uint8_t)(x))<<WDOG_CS2_CLK_SHIFT))&WDOG_CS2_CLK_MASK)
+#define WDOG_CS2_PRES_MASK                       0x10u
+#define WDOG_CS2_PRES_SHIFT                      4
+#define WDOG_CS2_FLG_MASK                        0x40u
+#define WDOG_CS2_FLG_SHIFT                       6
+#define WDOG_CS2_WIN_MASK                        0x80u
+#define WDOG_CS2_WIN_SHIFT                       7
+/* CNT Bit Fields */
+#define WDOG_CNT_CNT_MASK                        0xFFFFu
+#define WDOG_CNT_CNT_SHIFT                       0
+#define WDOG_CNT_CNT(x)                          (((uint16_t)(((uint16_t)(x))<<WDOG_CNT_CNT_SHIFT))&WDOG_CNT_CNT_MASK)
+/* CNTH Bit Fields */
+#define WDOG_CNTH_CNTHIGH_MASK                   0xFFu
+#define WDOG_CNTH_CNTHIGH_SHIFT                  0
+#define WDOG_CNTH_CNTHIGH(x)                     (((uint8_t)(((uint8_t)(x))<<WDOG_CNTH_CNTHIGH_SHIFT))&WDOG_CNTH_CNTHIGH_MASK)
+/* CNTL Bit Fields */
+#define WDOG_CNTL_CNTLOW_MASK                    0xFFu
+#define WDOG_CNTL_CNTLOW_SHIFT                   0
+#define WDOG_CNTL_CNTLOW(x)                      (((uint8_t)(((uint8_t)(x))<<WDOG_CNTL_CNTLOW_SHIFT))&WDOG_CNTL_CNTLOW_MASK)
+/* TOVAL Bit Fields */
+#define WDOG_TOVAL_TOVAL_MASK                    0xFFFFu
+#define WDOG_TOVAL_TOVAL_SHIFT                   0
+#define WDOG_TOVAL_TOVAL(x)                      (((uint16_t)(((uint16_t)(x))<<WDOG_TOVAL_TOVAL_SHIFT))&WDOG_TOVAL_TOVAL_MASK)
+/* TOVALH Bit Fields */
+#define WDOG_TOVALH_TOVALHIGH_MASK               0xFFu
+#define WDOG_TOVALH_TOVALHIGH_SHIFT              0
+#define WDOG_TOVALH_TOVALHIGH(x)                 (((uint8_t)(((uint8_t)(x))<<WDOG_TOVALH_TOVALHIGH_SHIFT))&WDOG_TOVALH_TOVALHIGH_MASK)
+/* TOVALL Bit Fields */
+#define WDOG_TOVALL_TOVALLOW_MASK                0xFFu
+#define WDOG_TOVALL_TOVALLOW_SHIFT               0
+#define WDOG_TOVALL_TOVALLOW(x)                  (((uint8_t)(((uint8_t)(x))<<WDOG_TOVALL_TOVALLOW_SHIFT))&WDOG_TOVALL_TOVALLOW_MASK)
+/* WIN Bit Fields */
+#define WDOG_WIN_WIN_MASK                        0xFFFFu
+#define WDOG_WIN_WIN_SHIFT                       0
+#define WDOG_WIN_WIN(x)                          (((uint16_t)(((uint16_t)(x))<<WDOG_WIN_WIN_SHIFT))&WDOG_WIN_WIN_MASK)
+/* WINH Bit Fields */
+#define WDOG_WINH_WINHIGH_MASK                   0xFFu
+#define WDOG_WINH_WINHIGH_SHIFT                  0
+#define WDOG_WINH_WINHIGH(x)                     (((uint8_t)(((uint8_t)(x))<<WDOG_WINH_WINHIGH_SHIFT))&WDOG_WINH_WINHIGH_MASK)
+/* WINL Bit Fields */
+#define WDOG_WINL_WINLOW_MASK                    0xFFu
+#define WDOG_WINL_WINLOW_SHIFT                   0
+#define WDOG_WINL_WINLOW(x)                      (((uint8_t)(((uint8_t)(x))<<WDOG_WINL_WINLOW_SHIFT))&WDOG_WINL_WINLOW_MASK)
+
+/*!
+ * @}
+ */ /* end of group WDOG_Register_Masks */
+
+
+/* WDOG - Peripheral instance base addresses */
+/** Peripheral WDOG base address */
+#define WDOG_BASE                                (0x40052000u)
+/** Peripheral WDOG base pointer */
+#define WDOG                                     ((WDOG_Type *)WDOG_BASE)
+/** Array initializer of WDOG peripheral base pointers */
+#define WDOG_BASES                               { WDOG }
+
+/*!
+ * @}
+ */ /* end of group WDOG_Peripheral_Access_Layer */
+
+
+/*
+** End of section using anonymous unions
+*/
+
+#if defined(__ARMCC_VERSION)
+  #pragma pop
+#elif defined(__CWCC__)
+  #pragma pop
+#elif defined(__GNUC__)
+  /* leave anonymous unions enabled */
+#elif defined(__IAR_SYSTEMS_ICC__)
+  #pragma language=default
+#else
+  #error Not supported compiler type
+#endif
+
+/*!
+ * @}
+ */ /* end of group Peripheral_access_layer */
+
+
+/* ----------------------------------------------------------------------------
+   -- Backward Compatibility
+   ---------------------------------------------------------------------------- */
+
+/*!
+ * @addtogroup Backward_Compatibility_Symbols Backward Compatibility
+ * @{
+ */
+
+#define NV_DFPROT_DPS_MASK                NV_EEPROT_DPS_MASK
+#define NV_DFPROT_DPS_SHIFT               NV_EEPROT_DPS_SHIFT
+#define NV_DFPROT_DPS(x)                  NV_EEPROT_DPS(x)
+#define NV_DFPROT_DPOPEN_MASK             NV_EEPROT_DPOPEN_MASK
+#define NV_DFPROT_DPOPEN_SHIFT            NV_EEPROT_DPOPEN_SHIFT
+#define NV_DFPROT_DPOPEN_SHIFT            NV_EEPROT_DPOPEN_SHIFT
+
+/*!
+ * @}
+ */ /* end of group Backward_Compatibility_Symbols */
+
+
+#endif  /* #if !defined(MKE02Z2_H_) */
+
+/* MKE02Z2.h, eof. */
diff --git a/bsp/frdm-ke02/device/lib/inc/acmp.h b/bsp/frdm-ke02/device/lib/inc/acmp.h
new file mode 100755
index 0000000..dd6d037
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/acmp.h
@@ -0,0 +1,597 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file acmp.h
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief header file for ACMP utilities. 
+*
+*******************************************************************************
+*
+* provide APIs for accessing ACMP
+******************************************************************************/
+#ifndef _MY_ACMP_H_
+#define _MY_ACMP_H_
+#ifdef __cplusplus
+extern "C" {
+#endif
+/******************************************************************************
+* Includes
+******************************************************************************/
+
+/******************************************************************************
+* Constants
+******************************************************************************/
+
+/* DAC reference select */
+enum
+{
+    DAC_REF_BANDGAP = 0,
+    DAC_REF_VDDA
+};
+
+/******************************************************************************
+* Macros
+******************************************************************************/
+
+/******************************************************************************
+ * ACMP module number definition                                               *
+ ******************************************************************************/
+#define     MAX_ACMP_NO             2
+
+/******************************************************************************
+* ACMP positive and negative pin select definition
+*
+*//*! @addtogroup acmp_pinsel_list
+* @{
+*******************************************************************************/
+#define     ACMP_INPUT_P_EXT0       (0<<4)  /*!< positive pin select external pin 0 */
+#define     ACMP_INPUT_P_EXT1       (1<<4)  /*!< positive pin select external pin 1 */
+#define     ACMP_INPUT_P_EXT2       (2<<4)  /*!< positive pin select external pin 2 */
+#define     ACMP_INPUT_P_DAC        (3<<4)  /*!< positive pin select internal DAC */
+
+#define     ACMP_INPUT_N_EXT0       0       /*!< positive pin select external pin 0 */
+#define     ACMP_INPUT_N_EXT1       1       /*!< positive pin select external pin 1 */
+#define     ACMP_INPUT_N_EXT2       2       /*!< positive pin select external pin 2 */
+#define     ACMP_INPUT_N_DAC        3       /*!< positive pin select internal DAC */
+/*! @} End of acmp_pinsel_list                                                */
+
+/******************************************************************************
+* ACMP interrupt sensitivity edge definition
+*
+*//*! @addtogroup acmp_intedgesel
+* @{
+*******************************************************************************/
+#define     ACMP_SENSITIVITYMODE_FALLING   0    /*!< interrupt on falling edge  */
+#define     ACMP_SENSITIVITYMODE_RISING    1    /*!< interrupt on rising edge  */
+#define     ACMP_SENSITIVITYMODE_ANY       3    /*!< interrupt on falling or rising edge */ 
+/*! @} End of acmp_intedgesel                                                 */
+
+
+/******************************************************************************
+* ACMP hysterisis selection definition
+*
+*//*! @addtogroup acmp_hyst
+* @{
+*******************************************************************************/
+#define     ACMP_HYST_20MV                 (0<<6)  /*!< 20mv hyst */
+#define     ACMP_HYST_30MV                 (1<<6)  /*!< 30mv hyst */
+/*! @} End of acmp_hyst                                                       */
+
+
+/******************************************************************************
+* ACMP internal DAC reference selection definition
+*
+*//*! @addtogroup acmp_dacref
+* @{
+*******************************************************************************/
+#define     ACMP_DAC_REFERENCE_BANDGAP     (0<<6)  /*!< select bandgap as refference */
+#define     ACMP_DAC_REFERENCE_VDDA        (1<<6)  /*!< select VDDA as refference */
+/*! @} End of acmp_dacref                                                     */
+
+
+/******************************************************************************
+* Types
+******************************************************************************/
+
+/*! @brief ACMP_CALLBACK function declaration                                  */
+typedef void (*ACMP_CallbackPtr)(void);
+/*! @} End of acmp_callback                                                    */
+
+/******************************************************************************
+* ACMP control status struct
+*
+*//*! @addtogroup acmp_ctrlstatusstruct
+* @{
+*******************************************************************************/
+/*!
+ * @brief ACMP control and status fields type.
+ *
+ */
+
+typedef union 
+{
+    uint8_t byte;    				 /*!< byte field of union type */
+    struct 
+    {
+        uint8_t bMod        : 2;     /*!< Sensitivity modes of the interrupt trigger */
+        uint8_t bOutEn      : 1;     /*!< Output can be placed onto an external pin */
+        uint8_t bOutState   : 1;     /*!< The current value of the analog comparator output */
+        uint8_t bIntEn      : 1;     /*!< ACMP interrupt enable */
+        uint8_t bIntFlag    : 1;     /*!< ACMP Interrupt Flag Bit */
+        uint8_t bHyst       : 1;     /*!< Selects ACMP hystersis */
+        uint8_t bEn         : 1;     /*!< Enables the ACMP module */
+    }bits;      				     /*!< bitfield of union type */
+}ACMP_CtrlStatusType, *ACMP_CtrlStatusPtr;  /*!< ACMP Control/Status reg structure */
+/*! @} End of acmp_ctrlstatusstruct                                           */
+
+/******************************************************************************
+* ACMP pin select struct
+*
+*//*! @addtogroup acmp_pinselectstruct
+* @{
+*******************************************************************************/
+/*!
+* @brief ACMP external pins control struct.
+*
+*/
+
+typedef union 
+{
+    uint8_t byte;    				 /*!< byte field of union type */
+    struct 
+    {
+        uint8_t bNegPin  : 2;        /*!< Negative pin select */
+        uint8_t          : 2;
+        uint8_t bPosPin  : 2;        /*!< Positive pin select */
+        uint8_t          : 2;
+    }bits;      				     /*!< bitfield of union type */  
+}ACMP_PinSelType, *ACMP_PinSelPtr; 	     /*!< ACMP Pin select structure */ 
+/*! @} End of acmp_pinselectstruct                                            */
+
+/******************************************************************************
+* ACMP DAC control struct
+*
+*//*! @addtogroup acmp_dacctrlstruct
+* @{
+*******************************************************************************/
+/*!
+* @brief ACMP internal ADC control struct.
+*
+*/
+typedef union 
+{
+    uint8_t byte;    				 /*!< byte field of union type */
+    struct 
+    {
+        uint8_t bVal  : 6;           /*!< 6 bit DAC value */
+        uint8_t bRef  : 1;           /*!< 6 bit DAC reference select */
+        uint8_t bEn   : 1;           /*!< 6 bit DAC enable bit */
+    }bits;      				     /*!< bitfield of union type */  
+}ACMP_DACType, *ACMP_DACPtr;	     /*!< ACMP DAC control structure */ 
+/*! @} End of acmp_dacctrlstruct                                              */
+
+/******************************************************************************
+* ACMP pin enable union
+*
+*//*! @addtogroup acmp_pinenunion
+* @{
+*******************************************************************************/
+/*!
+* @brief ACMP external input pin enable control struct.
+*
+*/
+typedef union 
+{
+    uint8_t byte;    				 /*!< byte field of union type */
+    struct 
+    {
+        uint8_t bEn   : 3;           /*!< ACMP external input pin enable */
+        uint8_t bRsvd : 5;
+    }bits;      				     /*!< bitfield of union type */  
+}ACMP_PinEnType, *ACMP_PinEnPtr;	 /*!< ACMP Pin enable structure */ 
+/*! @} End of acmp_pinenunion                                                 */
+
+/******************************************************************************
+* ACMP config struct
+*
+*//*! @addtogroup acmp_configstruct
+* @{
+*******************************************************************************/
+/*!
+* @brief ACMP module configuration struct.
+*
+*/
+
+typedef struct 
+{
+    ACMP_CtrlStatusType  sCtrlStatus;     /*!< ACMP control and status */
+    ACMP_PinSelType      sPinSelect;      /*!< ACMP pin select */
+    ACMP_DACType         sDacSet;         /*!< ACMP internal dac set */
+    ACMP_PinEnType       sPinEnable;      /*!< ACMP external pin control */
+}ACMP_ConfigType, *ACMP_ConfigPtr;
+/*! @} End of acmp_configstruct                                               */
+
+/******************************************************************************
+* Global variables
+******************************************************************************/
+
+/*!
+ * inline functions
+ */
+/******************************************************************************
+* ACMP api list.
+*
+*//*! @addtogroup acmp_api_list
+* @{
+*******************************************************************************/
+/*****************************************************************************//*!
+*
+* @brief  enable the acmp module.
+*        
+* @param[in]  pACMPx      pointer to an ACMP module.
+*              
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see    ACMP_Disable.
+*
+*****************************************************************************/
+__STATIC_INLINE void ACMP_Enable(ACMP_Type *pACMPx)
+{
+    pACMPx->CS |= ACMP_CS_ACE_MASK;
+}
+
+/*****************************************************************************//*!
+*
+* @brief  disable the acmp module.
+*        
+* @param[in]  pACMPx      pointer to an ACMP module.
+*              
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see    ACMP_Enable.
+*
+*****************************************************************************/
+__STATIC_INLINE void ACMP_Disable(ACMP_Type *pACMPx)
+{
+    pACMPx->CS &= ~ACMP_CS_ACE_MASK;
+}
+
+/*****************************************************************************//*!
+*
+* @brief  select sensitivity modes of the interrupt trigger.
+*        
+* @param[in]  pACMPx         pointer to an ACMP module.
+* @param[in]  u8EdgeSelect   falling or rising selction, 0~3. 
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*****************************************************************************/
+__STATIC_INLINE void ACMP_SelectIntMode(ACMP_Type *pACMPx, uint8_t u8EdgeSelect)
+{
+    pACMPx->CS &= ~ACMP_CS_ACMOD_MASK;
+    pACMPx->CS |= ACMP_CS_ACMOD(u8EdgeSelect & 0x3);
+}
+
+/*****************************************************************************//*!
+*
+* @brief  enable the ACMP module analog comparator output.
+*        
+* @param[in]  pACMPx      pointer to an ACMP module.
+*              
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see    ACMP_DisablePinOut.
+*
+*****************************************************************************/
+__STATIC_INLINE void ACMP_EnablePinOut(ACMP_Type *pACMPx)
+{
+    pACMPx->CS |= ACMP_CS_ACOPE_MASK;
+}
+
+/*****************************************************************************//*!
+*
+* @brief  disable the ACMP module analog comparator output.
+*        
+* @param[in]  pACMPx      pointer to an ACMP module.
+*              
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see    ACMP_EnablePinOut.
+*
+*****************************************************************************/
+__STATIC_INLINE void ACMP_DisablePinOut(ACMP_Type *pACMPx)
+{
+    pACMPx->CS &= ~ACMP_CS_ACOPE_MASK;
+}
+
+/*****************************************************************************//*!
+*
+* @brief  select ACMP hystersis. 
+*        
+* @param[in]  pACMPx           pointer to an ACMP module.
+* @param[in]  u8HystSelect     ACMP_HYST_20MV or ACMP_HYST_30MV.   
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*****************************************************************************/
+__STATIC_INLINE void ACMP_SelectHyst(ACMP_Type *pACMPx, uint8_t u8HystSelect)
+{
+    pACMPx->CS &= ~ACMP_CS_HYST_MASK;
+    pACMPx->CS |= u8HystSelect;
+}
+
+/*****************************************************************************//*!
+*
+* @brief  enable the acmp module interrupt.
+*        
+* @param[in]  pACMPx      pointer to an ACMP module.
+*              
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see    ACMP_DisableInterrupt.
+*
+*****************************************************************************/
+__STATIC_INLINE void ACMP_EnableInterrupt(ACMP_Type *pACMPx)
+{
+    pACMPx->CS |= ACMP_CS_ACIE_MASK;
+}
+
+/*****************************************************************************//*!
+*
+* @brief  disable the acmp module interrupt.
+*        
+* @param[in]  pACMPx      pointer to an ACMP module.
+*              
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see    ACMP_EnableInterrupt.
+*
+*****************************************************************************/
+__STATIC_INLINE void ACMP_DisableInterrupt(ACMP_Type *pACMPx)
+{
+    pACMPx->CS &= ~ACMP_CS_ACIE_MASK;
+}
+
+/*****************************************************************************//*!
+*
+* @brief  get the interrupt flag bit.
+*        
+* @param[in]  pACMPx      pointer to an ACMP module.
+*              
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see    ACMP_ClrFlag.
+*
+*****************************************************************************/
+__STATIC_INLINE uint8_t ACMP_GetFlag(ACMP_Type *pACMPx)
+{
+    return (pACMPx->CS & ACMP_CS_ACF_MASK);
+}
+
+/*****************************************************************************//*!
+*
+* @brief  clear the interrupt flag bit.
+*        
+* @param[in]  pACMPx      pointer to an ACMP module.
+*              
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see    ACMP_GetFlag.
+*
+*****************************************************************************/
+__STATIC_INLINE void ACMP_ClrFlag(ACMP_Type *pACMPx)
+{
+    pACMPx->CS &= ~ACMP_CS_ACF_MASK;
+}
+
+/*****************************************************************************//*!
+*
+* @brief  ACMP Positive Input Select.
+*        
+* @param[in]  pACMPx        pointer to an ACMP module.
+* @param[in]  u8PosPinSel   positive input select, ACMP_INPUT_P_EXT0~2 or ACMP_INPUT_P_DAC.     
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see    ACMP_NegativeInputSelect.
+*
+*****************************************************************************/
+__STATIC_INLINE void ACMP_PositiveInputSelect(ACMP_Type *pACMPx, uint8_t u8PosPinSel)
+{
+    pACMPx->C0 &= ~ACMP_C0_ACPSEL_MASK;
+    pACMPx->C0 |= u8PosPinSel;
+}
+
+/*****************************************************************************//*!
+*
+* @brief  ACMP Negative Input Select.
+*        
+* @param[in]  pACMPx        pointer to an ACMP module.
+* @param[in]  u8NegPinSel   negative input select, ACMP_INPUT_N_EXT0~2 or ACMP_INPUT_N_DAC.  
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see    ACMP_PositiveInputSelect.
+*
+*****************************************************************************/
+__STATIC_INLINE void ACMP_NegativeInputSelect(ACMP_Type *pACMPx, uint8_t u8NegPinSel)
+{
+    pACMPx->C0 &= ~ACMP_C0_ACNSEL_MASK;
+    pACMPx->C0 |= u8NegPinSel;
+}
+
+/*****************************************************************************//*!
+*
+* @brief  Enable 6 bit DAC in ACMP module.
+*        
+* @param[in]  pACMPx      pointer to an ACMP module.
+*              
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see    ACMP_DacDisable.
+*
+*****************************************************************************/
+__STATIC_INLINE void ACMP_DacEnable(ACMP_Type *pACMPx)
+{
+    pACMPx->C1 |= ACMP_C1_DACEN_MASK;
+}
+
+/*****************************************************************************//*!
+*
+* @brief  Disable 6 bit DAC in ACMP module.
+*        
+* @param[in]  pACMPx      pointer to an ACMP module.
+*              
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see    ACMP_DacEnable.
+*
+*****************************************************************************/
+__STATIC_INLINE void ACMP_DacDisable(ACMP_Type *pACMPx)
+{
+    pACMPx->C1 &= ~ACMP_C1_DACEN_MASK;
+}
+
+/*****************************************************************************//*!
+*
+* @brief  ACMP 6 bit DAC Reference Select.
+*        
+* @param[in]  pACMPx        pointer to an ACMP module.
+* @param[in]  u8RefSelect   dac reference select:ACMP_DAC_REFERENCE_BANDGAP or ACMP_DAC_REFERENCE_VDDA.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*****************************************************************************/
+__STATIC_INLINE void ACMP_DacReferenceSelect(ACMP_Type *pACMPx, uint8_t u8RefSelect)
+{
+    pACMPx->C1 &= ~ACMP_C1_DACREF_MASK;
+    pACMPx->C1 |= u8RefSelect;
+}
+
+/*****************************************************************************//*!
+*
+* @brief  ACMP 6 bit DAC Output Value Set.
+*        
+* @param[in]  pACMPx        pointer to an ACMP module.
+* @param[in]  u8DacValue    dac output set, Voutput= (Vin/64)x(DACVAL[5:0]+1).
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*****************************************************************************/
+__STATIC_INLINE void ACMP_DacOutputSet(ACMP_Type *pACMPx, uint8_t u8DacValue)
+{
+    ASSERT(!(u8DacValue & (~ACMP_C1_DACVAL_MASK)));
+    pACMPx->C1 &= ~ACMP_C1_DACVAL_MASK;
+    pACMPx->C1 |= ACMP_C1_DACVAL(u8DacValue);
+}
+
+/*****************************************************************************//*!
+*
+* @brief  Enable ACMP input pin.
+*        
+* @param[in]  pACMPx        pointer to an ACMP module.
+* @param[in]  u8InputPin    ACMP external pin, 0~2.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*****************************************************************************/
+__STATIC_INLINE void ACMP_InputPinEnable(ACMP_Type *pACMPx, uint8_t u8InputPin)
+{
+    ASSERT(!(u8InputPin & (~ACMP_C2_ACIPE_MASK)));
+    pACMPx->C2 |= ACMP_C2_ACIPE(u8InputPin);
+}
+
+/*****************************************************************************//*!
+*
+* @brief  Disable ACMP input pin.
+*        
+* @param[in]  pACMPx        pointer to an ACMP module.
+* @param[in]  u8InputPin    ACMP external pin, 0~2.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*****************************************************************************/
+__STATIC_INLINE void ACMP_InputPinDisable(ACMP_Type *pACMPx, uint8_t u8InputPin)
+{
+    ASSERT(!(u8InputPin & (~ACMP_C2_ACIPE_MASK)));
+    pACMPx->C2 &= ~ACMP_C2_ACIPE(u8InputPin);
+}
+
+/*! @} End of acmp_api_list                                                  */
+
+/******************************************************************************
+* Global functions
+******************************************************************************/
+void ACMP_Init(ACMP_Type *pACMPx, ACMP_ConfigType *pConfig);
+void ACMP_DeInit(ACMP_Type *pACMPx); 
+void ACMP_ConfigDAC(ACMP_Type *pACMPx, ACMP_DACType *pDACConfig);
+void ACMP_SetCallback(ACMP_Type *pACMPx, ACMP_CallbackPtr pfnCallback);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _MY_ACMP_H_ */
+
+
+
diff --git a/bsp/frdm-ke02/device/lib/inc/adc.h b/bsp/frdm-ke02/device/lib/inc/adc.h
new file mode 100755
index 0000000..d346aee
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/adc.h
@@ -0,0 +1,739 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file adc.h
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief header file for ADC module utilities (ADC). 
+*
+*******************************************************************************
+*
+* provide APIs for accessing ADC module (ADC)
+******************************************************************************/
+
+#ifndef ADC_H_
+#define ADC_H_
+#ifdef __cplusplus
+extern "C" {
+#endif
+/******************************************************************************
+* Macros
+******************************************************************************/
+/******************************************************************************
+*define ADC refernce voltage 
+*
+*//*! @addtogroup adc_ref_list
+* @{
+*******************************************************************************/
+
+#define ADC_VREF_VREFH                 0x00			/*!< ADC reference voltage is VREFH*/
+#define ADC_VREF_VDDA                  0x01			/*!< ADC reference voltage is VDDA*/
+
+/*! @} End of adc_ref_list                                                    						*/
+
+/******************************************************************************
+* define ADC clock source 
+*
+*//*! @addtogroup adc_clock_source_list
+* @{
+*******************************************************************************/
+
+#define CLOCK_SOURCE_BUS_CLOCK							0x00	/*!< ADC clock source is bus clock*/
+#define CLOCK_SOURCE_BUS_CLOCK_DIVIDE_2			        0x01	/*!< ADC clock source is bus clock devided by 2*/
+#define CLOCK_SOURCE_ALTCLK								0x02	/*!< ADC clock source is alternative clcok*/
+#define CLOCK_SOURCE_ADACK								0x03	/*!< ADC clock source is asynchronous clock*/
+/*! @} End of adc_clock_source_list                                          						*/
+
+
+/******************************************************************************
+* define ADC divider 
+*
+*//*! @addtogroup adc_clock_divider_list
+* @{
+*******************************************************************************/
+
+#define ADC_ADIV_DIVIDE_1								0x00		/*!< ADC clock divide by 1*/
+#define ADC_ADIV_DIVIDE_2								0x01		/*!< ADC clock divide by 2*/
+#define ADC_ADIV_DIVIDE_4								0x02		/*!< ADC clock divide by 4*/
+#define ADC_ADIV_DIVIDE_8								0x03		/*!< ADC clock divide by 8*/
+/*! @} End of adc_clock_divider_list                                          						*/
+
+/******************************************************************************
+* define ADC mode 
+*
+*//*! @addtogroup adc_mode_list
+* @{
+*******************************************************************************/
+
+#define ADC_MODE_8BIT									0x00		/*!< ADC 8bit mode*/
+#define ADC_MODE_10BIT									0x01		/*!< ADC 10bit mode*/
+#define ADC_MODE_12BIT									0x02		/*!< ADC 12bit mode */
+/*! @} End of adc_mode_list                                               						*/
+
+/******************************************************************************
+* define ADC channel
+*
+*//*! @addtogroup adc_channel_list
+* @{
+*******************************************************************************/
+
+#define ADC_CHANNEL_AD0                                 0x0 /*!< ADC input channel 0 */
+#define ADC_CHANNEL_AD1                                 0x1 /*!< ADC input channel 1 */
+#define ADC_CHANNEL_AD2                                 0x2 /*!< ADC input channel 2 */
+#define ADC_CHANNEL_AD3                                 0x3 /*!< ADC input channel 3 */
+#define ADC_CHANNEL_AD4                                 0x4 /*!< ADC input channel 4 */
+#define ADC_CHANNEL_AD5                                 0x5 /*!< ADC input channel 5 */
+#define ADC_CHANNEL_AD6                                 0x6 /*!< ADC input channel 6 */
+#define ADC_CHANNEL_AD7                                 0x7 /*!< ADC input channel 7 */
+#define ADC_CHANNEL_AD8                                 0x8 /*!< ADC input channel 8 */
+#define ADC_CHANNEL_AD9                                 0x9 /*!< ADC input channel 9 */
+#define ADC_CHANNEL_AD10                                 0xa /*!< ADC input channel 10 */
+#define ADC_CHANNEL_AD11                                 0xb /*!< ADC input channel 11 */
+#define ADC_CHANNEL_AD12                                 0xc /*!< ADC input channel 12 */
+#define ADC_CHANNEL_AD13                                 0xd /*!< ADC input channel 13 */
+#define ADC_CHANNEL_AD14                                 0xe /*!< ADC input channel 14 */
+#define ADC_CHANNEL_AD15                                 0xf /*!< ADC input channel 15 */
+#define ADC_CHANNEL_AD18_VSS                            0x12 /*!< ADC input channel VSS */ 
+#define ADC_CHANNEL_AD22_TEMPSENSOR                     0x16 /*!< ADC input channel internal temperature sensor */
+#define ADC_CHANNEL_AD23_BANDGAP                        0x17 /*!< ADC input channel bandgap */ 
+#define ADC_CHANNEL_AD29_VREFH                          0x1D /*!< ADC input channel Vrefh */ 
+#define ADC_CHANNEL_AD30_VREFL                          0x1E /*!< ADC input channel Vrefl */ 
+#define ADC_CHANNEL_DISABLE                             0x1F /*!< ADC disable */
+/*! @} End of adc_channel_list                                               						*/
+
+
+/******************************************************************************
+* define ADC FIFO_LEVEL
+*
+*//*! @addtogroup adc_fifo_level_list
+* @{
+*******************************************************************************/
+#define ADC_FIFO_DISABLE                                0 /*!< FIFO Level 0 */
+#define ADC_FIFO_LEVEL2                                 1 /*!< FIFO Level 1 */
+#define ADC_FIFO_LEVEL3                                 2 /*!< FIFO Level 2 */
+#define ADC_FIFO_LEVEL4                                 3 /*!< FIFO Level 3 */
+#define ADC_FIFO_LEVEL5                                 4 /*!< FIFO Level 4 */
+#define ADC_FIFO_LEVEL6                                 5 /*!< FIFO Level 5 */
+#define ADC_FIFO_LEVEL7                                 6 /*!< FIFO Level 6 */
+#define ADC_FIFO_LEVEL8                                 7	/*!< FIFO Level 7 */
+/*! @} End of adc_fifo_level_list                                               						*/
+
+
+/******************************************************************************
+* define ADC trigger source
+*
+*//*! @addtogroup adc_trigger_list
+* @{
+*******************************************************************************/
+#define ADC_HARDWARE_TRIGGER                            0x01  /*!< hardware trigger */
+#define ADC_SOFTWARE_TRIGGER                            0x00	/*!< software trigger */
+#define ADC_TRIGGER_RTC                                 0x00  /*!< RTC act as trigger source */          
+#define ADC_TRIGGER_PIT                                 0x01  /*!< PIT act as trigger source */ 
+#define ADC_TRIGGER_FTM2INIT                            0x10  /*!< FTM2 initialization act as trigger source */ 
+#define ADC_TRIGGER_FTM2MATCH                           0x11  /*!< FTM2 match interrupt act as trigger source */
+/*! @} End of adc_trigger_list                                               						*/
+
+
+#define ADC_COMPARE_LESS                                0x00
+#define ADC_COMPARE_GREATER                             0x01
+
+
+/******************************************************************************
+* define ADC call back
+*
+*//*! @addtogroup adc_callback
+* @{
+*******************************************************************************/
+typedef void (*ADC_CallbackType)(void);							/*!< ADC call back function */
+/*! @} End of adc_callback                                               						*/
+
+/******************************************************************************
+* 
+*
+*//*! @addtogroup adc_setting_type
+* @{
+*******************************************************************************/
+/*!
+ * @brief ADC setting type.
+ *
+ */
+typedef struct
+{
+    uint16_t bIntEn                 :1;     /*!< 1: Interrupt Enable, 0: Interrupt disable */
+    uint16_t bContinuousEn          :1;     /*!< 1: Continuous Conversion Enable, 0: Continuous Conversion disable */
+    uint16_t bHardwareTriggerEn     :1;     /*!< 1: hardware trigger, 0: software trigger */
+    uint16_t bCompareEn             :1;     /*!< 1: compare mode Enable, 0: compare mode disable */
+    uint16_t bCompareGreaterEn      :1;     /*!< 1: Compare greater mode, 0: compare less than mode */
+    uint16_t bLowPowerEn            :1;     /*!< 1: Low power mode, 0: high speed mode */
+    uint16_t bLongSampleEn          :1;     /*!< 1: long sample mode, 0: short sample mode */
+    uint16_t bFiFoScanModeEn        :1;     /*!< 1: FIFO scan mode enable, 0: FIFO scan mode disable */
+    uint16_t bCompareAndEn          :1;     /*!< 1: Compare and logic, 0: Compare and logic */
+#ifdef CPU_KE02 
+    uint16_t bReverse               :7;    
+#else
+    uint16_t bHTRGMEn               :1;     /*!< one hardware trigger pulse trigger multiple conversions in fifo mode */      
+    uint16_t bHTRGMASKEn            :1;		/*!< Hardware trigger mask enable. */
+    uint16_t bHTRGMASKSEL           :1;		/*!< This field selects hardware trigger mask mode. */
+    uint16_t Reserve                :4;
+#endif
+}ADC_SettingType;
+/*! @} End of adc_setting_type                                               						*/
+
+/******************************************************************************
+* 
+*
+*//*! @addtogroup adc_config_type
+* @{
+*******************************************************************************/
+/*!
+ * @brief ADC configure type.
+ *
+ */
+typedef struct
+{
+    ADC_SettingType sSetting;               /*!< ADC setting structure*/
+    uint16_t u16PinControl;                 /*!< pin control */
+    uint8_t u8ClockSource;                  /*!< clock source selection */
+    uint8_t u8ClockDiv;                     /*!< set clock divider */
+    uint8_t u8Mode;                         /*!< set clcok mode(8/10/12 bit mode) */
+    uint8_t u8FiFoLevel;                    /*!< set FIFO level */
+}ADC_ConfigType,*ADC_ConfigTypePtr;
+/*! @} End of adc_config_type                                               */
+
+/******************************************************************************
+* define ADC APIs
+*
+*//*! @addtogroup adc_api_list
+* @{
+*******************************************************************************/
+/*****************************************************************************//*!
+   *
+   * @brief enable ADC interrupt.
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+__STATIC_INLINE void ADC_IntEnable( ADC_Type *pADC )
+{
+    pADC->SC1 |= ADC_SC1_AIEN_MASK;   
+}
+/*****************************************************************************//*!
+   *
+   * @brief disable ADC interrupt.
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+__STATIC_INLINE void ADC_IntDisable( ADC_Type *pADC )
+{
+    pADC->SC1 &= ~ADC_SC1_AIEN_MASK;   
+}
+/*****************************************************************************//*!
+   *
+   * @brief enable ADC continuous conversion.
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+__STATIC_INLINE void ADC_ContinuousConversion( ADC_Type *pADC )
+{
+    pADC->SC1 |= ADC_SC1_ADCO_MASK;   
+}
+/*****************************************************************************//*!
+   *
+   * @brief enable ADC single conversion
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+__STATIC_INLINE void ADC_SingleConversion( ADC_Type *pADC )
+{
+    pADC->SC1 &= ~ADC_SC1_ADCO_MASK;   
+}
+/*****************************************************************************//*!
+   *
+   * @brief set the ADC to hardware trigger.
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   *
+   * @return none.
+   *
+   * @ Pass/ Fail criteria: none.
+   *****************************************************************************/
+__STATIC_INLINE void ADC_SetHardwareTrigger( ADC_Type *pADC )
+{
+    pADC->SC2 |= ADC_SC2_ADTRG_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief set the ADC to software trigger.
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+__STATIC_INLINE void ADC_SetSoftwareTrigger( ADC_Type *pADC )
+{
+    pADC->SC2 &= ~ADC_SC2_ADTRG_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief enable ADC compare function.
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+__STATIC_INLINE void ADC_CompareEnable( ADC_Type *pADC )
+{
+    pADC->SC2 |= ADC_SC2_ACFE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief disable ADC compare function.
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+__STATIC_INLINE void ADC_CompareDisable( ADC_Type *pADC )
+{
+    pADC->SC2 &= ~ADC_SC2_ACFE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief enable ADC compare greater function.
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+__STATIC_INLINE void ADC_CompareGreaterFunction( ADC_Type *pADC )
+{
+    pADC->SC2 |= ADC_SC2_ACFGT_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief enable ADC compare less function.
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+__STATIC_INLINE void ADC_CompareLessFunction( ADC_Type *pADC )
+{
+    pADC->SC2 &= ~ADC_SC2_ACFGT_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief set ADC to low power configuration.
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+__STATIC_INLINE void ADC_SetLowPower( ADC_Type *pADC )
+{
+    pADC->SC3 |= ADC_SC3_ADLPC_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief set ADC to high speed configuration.
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+__STATIC_INLINE void ADC_SetHighSpeed( ADC_Type *pADC )
+{
+    pADC->SC3 &= ~ADC_SC3_ADLPC_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Long Sample Time Configuration.
+   *        
+   * @param[in]  pADC point to ADC module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+__STATIC_INLINE void ADC_SetLongSample( ADC_Type *pADC )
+{
+    pADC->SC3 |= ADC_SC3_ADLSMP_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Short Sample Time Configuration.
+   *        
+   * @param[in]  pADC point to ADC module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+__STATIC_INLINE void ADC_SetShortSample( ADC_Type *pADC )
+{
+    pADC->SC3 &= ~ADC_SC3_ADLSMP_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief FIFO scan mode enable.
+   *        
+   * @param[in]  pADC point to ADC module type.
+   *
+   * @return none.
+   *
+   * @ Pass/ Fail criteria: none.
+   *****************************************************************************/
+__STATIC_INLINE void ADC_FifoScanModeEnable( ADC_Type *pADC )
+{
+    pADC->SC4 |= ADC_SC4_ASCANE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief FIFO scan mode disable.
+   *        
+   * @param[in]  pADC point to ADC module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+__STATIC_INLINE void ADC_FifoScanModeDisable( ADC_Type *pADC )
+{
+    pADC->SC4 &= ~ADC_SC4_ASCANE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief OR all of compare trigger.
+   *        
+   * @param[in]  pADC point to ADC module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+__STATIC_INLINE void ADC_CompareFifoOr( ADC_Type *pADC )
+{
+    pADC->SC4 &= ~ADC_SC4_ACFSEL_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief And all of compare trigger.
+   *        
+   * @param[in]  pADC point to ADC module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+__STATIC_INLINE void ADC_CompareFifoAnd( ADC_Type *pADC )
+{
+    pADC->SC4 |= ADC_SC4_ACFSEL_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief read ADC result register.
+   *        
+   * @param[in]  pADC point to ADC module type.
+   *
+   * @return ADC result value.
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+__STATIC_INLINE uint16_t ADC_ReadResultReg( ADC_Type *pADC )
+{
+    return (uint16_t)pADC->R;
+}
+/*****************************************************************************//*!
+   *
+   * @brief set ADC compare value.
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   * @param[in]  u16Compare compare value. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+__STATIC_INLINE void ADC_SetCompareValue( ADC_Type *pADC, uint16_t u16Compare )
+{
+    pADC->CV = u16Compare;
+}
+/*****************************************************************************//*!
+   *
+   * @brief ADC pin control enable.
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   * @param[in]  u16PinNumber enable ADC function to specified pin number. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+__STATIC_INLINE void ADC_PinControlEnable( ADC_Type *pADC, uint16_t u16PinNumber)
+{
+    ASSERT((u16PinNumber<16));
+    pADC->APCTL1 &= ~(0x01<<u16PinNumber);
+}
+/*****************************************************************************//*!
+   *
+   * @brief ADC pin control disable.
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   * @param[in]  u16PinNumber  disable ADC function to specified pin number. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+__STATIC_INLINE void ADC_PinControlDisable( ADC_Type *pADC, uint16_t u16PinNumber)
+{
+    ASSERT((u16PinNumber<16));
+    pADC->APCTL1 |= (0x01<<u16PinNumber);
+}
+/*****************************************************************************//*!
+   *
+   * @brief check conversion active status
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   *
+   * @return TRUE or FALSE
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+__STATIC_INLINE uint8_t ADC_IsConversionActiveFlag( ADC_Type *pADC )
+{
+    return(pADC->SC2 & ADC_SC2_ADACT_MASK);
+}
+/*****************************************************************************//*!
+   *
+   * @brief check COCO flag
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   *
+   * @return TRUE or FALSE
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+__STATIC_INLINE uint8_t ADC_IsCOCOFlag( ADC_Type *pADC )
+{
+    return(pADC->SC1 & ADC_SC1_COCO_MASK);
+}
+/*****************************************************************************//*!
+   *
+   * @brief check Result FIFO empty
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   *
+   * @return TRUE or FALSE
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+__STATIC_INLINE uint8_t ADC_IsFIFOEmptyFlag( ADC_Type *pADC )
+{
+    return(pADC->SC2 & ADC_SC2_FEMPTY_MASK);
+}
+/*****************************************************************************//*!
+   *
+   * @brief check Result FIFO full
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   *
+   * @return TRUE or FALSE
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+__STATIC_INLINE uint8_t ADC_IsFIFOFullFlag( ADC_Type *pADC )
+{
+    return(pADC->SC2 & ADC_SC2_FFULL_MASK);
+}
+#ifndef CPU_KE02
+/*****************************************************************************//*!
+   *
+   * @brief Hardware Trigger Multiple Conversion Enable
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+__STATIC_INLINE void ADC_HardwareTriggerMultiple( ADC_Type *pADC )
+{
+    pADC->SC4 |= ADC_SC4_HTRGME_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Hardware Trigger Single Conversion
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+__STATIC_INLINE void ADC_HardwareTriggerSingle( ADC_Type *pADC )
+{
+    pADC->SC4 &= ~ADC_SC4_HTRGME_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Hardware Trigger Mask Enable
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+__STATIC_INLINE void ADC_HardwareTriggerMaskEnable( ADC_Type *pADC )
+{
+    pADC->SC5 |= ADC_SC5_HTRGMASKE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Hardware Trigger Mask Disable
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+__STATIC_INLINE void ADC_HardwareTriggerMaskDisable( ADC_Type *pADC )
+{
+    pADC->SC5 &= ~ADC_SC5_HTRGMASKE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Hardware Trigger Mask Mode Select Automatic Mode
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+__STATIC_INLINE void ADC_HardwareTriggerMaskAuto( ADC_Type *pADC )
+{
+    pADC->SC5 |= ADC_SC5_HTRGMASKSEL_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Hardware Trigger Mask Mode Select to be with HTRGMASKE
+   *        
+   * @param[in]  pADC point to ADC module type. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+__STATIC_INLINE void ADC_HardwareTriggerMaskNonAuto( ADC_Type *pADC )
+{
+    pADC->SC5 &= ~ADC_SC5_HTRGMASKSEL_MASK;
+}
+#endif
+/******************************************************************************
+* Global function
+******************************************************************************/
+
+void ADC_SetChannel( ADC_Type *pADC, uint8_t u8Channel );
+void ADC_IntEnable( ADC_Type *pADC );
+void ADC_IntDisable( ADC_Type *pADC );
+void ADC_ContinuousConversion( ADC_Type *pADC );
+void ADC_SingleConversion( ADC_Type *pADC );
+void ADC_SetSoftwareTrigger( ADC_Type *pADC );
+void ADC_SetHardwareTrigger( ADC_Type *pADC );
+void ADC_VrefSelect( ADC_Type *pADC, uint8_t u8Vref );
+void ADC_CompareEnable( ADC_Type *pADC );
+void ADC_CompareDisable( ADC_Type *pADC );
+void ADC_CompareGreaterFunction( ADC_Type *pADC );
+void ADC_CompareLessFunction( ADC_Type *pADC );
+void ADC_SetLowPower( ADC_Type *pADC );
+void ADC_SetHighSpeed( ADC_Type *pADC );
+void ADC_SelectClockDivide( ADC_Type *pADC, uint8_t u8Div);
+void ADC_SetLongSample(ADC_Type *pADC);
+void ADC_SetShortSample(ADC_Type *pADC);
+void ADC_SetMode(ADC_Type *pADC, uint8_t u8Mode);
+void ADC_SelectClock(ADC_Type *pADC, uint8_t u8Clock);
+void ADC_FifoScanModeEnable(ADC_Type *pADC);
+void ADC_FifoScanModeDisable(ADC_Type *pADC);
+void ADC_CompareFifoOr(ADC_Type *pADC);
+void ADC_CompareFifoAnd(ADC_Type *pADC);
+void ADC_SetFifoLevel(ADC_Type *pADC, uint8_t u8FifoLevel);
+uint16_t ADC_ReadResultReg(ADC_Type *pADC );
+void ADC_SetCompareValue(ADC_Type *pADC, uint16_t u16Compare );
+void ADC_PinControlEnable(ADC_Type *pADC, uint16_t u16PinNumber);
+void ADC_PinControlDisable(ADC_Type *pADC, uint16_t u16PinNumber);
+uint8_t ADC_IsConversionActiveFlag(ADC_Type *pADC);
+uint8_t ADC_IsCOCOFlag(ADC_Type *pADC);
+uint8_t ADC_IsFIFOEmptyFlag(ADC_Type *pADC);
+uint8_t ADC_IsFIFOFullFlag(ADC_Type *pADC);
+void ADC_HardwareTriggerMaskNonAuto(ADC_Type *pADC);
+void ADC_HardwareTriggerMaskAuto(ADC_Type *pADC);
+void ADC_HardwareTriggerMaskDisable( ADC_Type *pADC );
+void ADC_HardwareTriggerMaskEnable( ADC_Type *pADC );
+void ADC_HardwareTriggerSingle( ADC_Type *pADC );
+void ADC_HardwareTriggerMultiple( ADC_Type *pADC );
+unsigned int ADC_PollRead( ADC_Type *pADC, uint8_t u8Channel);
+void ADC_SetCallBack(ADC_CallbackType pADC_CallBack);
+void ADC_DeInit(ADC_Type *pADC);
+void ADC_Init(ADC_Type *pADC, ADC_ConfigTypePtr pADC_Config);
+/*! @} End of adc_api_list                                               						*/
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* ADC_H_ */
diff --git a/bsp/frdm-ke02/device/lib/inc/arm_cm0.h b/bsp/frdm-ke02/device/lib/inc/arm_cm0.h
new file mode 100755
index 0000000..b96f143
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/arm_cm0.h
@@ -0,0 +1,128 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file arm_cm0.h
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief provide generic high-level routines for ARM Cortex M0/M0+ processors. 
+*
+*******************************************************************************/
+
+#ifndef _CPU_ARM_CM0_H
+#define _CPU_ARM_CM0_H
+
+/*ARM Cortex M0 implementation for interrupt priority shift*/
+#define ARM_INTERRUPT_LEVEL_BITS          2
+
+
+/***********************************************************************/
+  /*!< Macro to enable all interrupts. */
+#ifndef KEIL
+#define EnableInterrupts asm(" CPSIE i");
+#else
+#define EnableInterrupts  __enable_irq()
+#endif
+
+  /*!< Macro to disable all interrupts. */
+#ifndef KEIL
+#define DisableInterrupts asm(" CPSID i");
+#else
+#define DisableInterrupts __disable_irq()
+#endif
+
+#define disable_irq(irq)             NVIC_DisableIRQ(irq)
+#define enable_irq(irq)              NVIC_EnableIRQ(irq)
+#define set_irq_priority(irq, prio)  NVIC_SetPriority(irq, prio)
+/***********************************************************************/
+
+
+/*
+ * Misc. Defines
+ */
+#ifdef	FALSE
+#undef	FALSE
+#endif
+#define FALSE	(0)
+
+#ifdef	TRUE
+#undef	TRUE
+#endif
+#define	TRUE	(1)
+
+#ifdef	NULL
+#undef	NULL
+#endif
+#define NULL	(0)
+
+#ifdef  ON
+#undef  ON
+#endif
+#define ON      (1)
+
+#ifdef  OFF
+#undef  OFF
+#endif
+#define OFF     (0)
+
+#undef  ENABLE
+#define ENABLE  (1)
+
+#undef  DISABLE
+#define DISABLE  (0)
+
+
+/***********************************************************************/
+/*
+ * The basic data types
+ */
+typedef unsigned char		uint8;  /*  8 bits */
+typedef unsigned short int	uint16; /* 16 bits */
+typedef unsigned long int	uint32; /* 32 bits */
+
+typedef char			int8;   /*  8 bits */
+typedef short int	        int16;  /* 16 bits */
+typedef int		        int32;  /* 32 bits */
+
+typedef volatile int8		vint8;  /*  8 bits */
+typedef volatile int16		vint16; /* 16 bits */
+typedef volatile int32		vint32; /* 32 bits */
+
+typedef volatile uint8		vuint8;  /*  8 bits */
+typedef volatile uint16		vuint16; /* 16 bits */
+typedef volatile uint32		vuint32; /* 32 bits */
+
+// function prototype for main function
+int main(void);
+/***********************************************************************/
+// function prototypes for arm_cm0.c
+void stop (void);
+void wait (void);
+void write_vtor (int);
+
+/***********************************************************************/
+#endif	/* _CPU_ARM_CM4_H */
+
diff --git a/bsp/frdm-ke02/device/lib/inc/assert.h b/bsp/frdm-ke02/device/lib/inc/assert.h
new file mode 100755
index 0000000..1d40d70
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/assert.h
@@ -0,0 +1,53 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file assert.h
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief provide macro for software assertions. 
+*
+*       assert_failed() defined in assert.c.
+*******************************************************************************/
+
+#ifndef _ASSERT_H_
+#define _ASSERT_H_
+
+/********************************************************************/
+
+void assert_failed(char *, int);
+
+#ifdef DEBUG_PRINT
+#define ASSERT(expr) \
+    if (!(expr)) \
+        assert_failed(__FILE__, __LINE__)
+#else
+#define ASSERT(expr)
+#endif
+
+/********************************************************************/
+#endif /* _ASSERT_H_ */
+
diff --git a/bsp/frdm-ke02/device/lib/inc/bitband.h b/bsp/frdm-ke02/device/lib/inc/bitband.h
new file mode 100755
index 0000000..1536e55
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/bitband.h
@@ -0,0 +1,125 @@
+
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file bitband.h
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief Provide Bit-band utilities. 
+*
+* @history:
+* 	Jun. 25, 2013	created macros
+******************************************************************************/
+
+#ifndef __BIT_BAND_H
+#define __BIT_BAND_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+                                      
+/******************************************************************************
+* 
+*
+*//*! @addtogroup BIT_BandType
+* @{
+*******************************************************************************/
+/*!
+ * @brief bit band type.
+ *
+ */
+typedef struct
+{
+		uint32_t bBit0;				/*!< aliase to 0th bit */
+		uint32_t bBit1;				/*!< aliase to 1th bit */
+		uint32_t bBit2;				/*!< aliase to 2th bit */
+		uint32_t bBit3;				/*!< aliase to 3th bit */
+		uint32_t bBit4;				/*!< aliase to 4th bit */
+		uint32_t bBit5;				/*!< aliase to 5th bit */
+		uint32_t bBit6;				/*!< aliase to 6th bit */
+		uint32_t bBit7;				/*!< aliase to 7th bit */
+		uint32_t bBit8;				/*!< aliase to 8th bit */
+		uint32_t bBit9;				/*!< aliase to 9th bit */
+		uint32_t bBit10;				/*!< aliase to 10th bit */
+		uint32_t bBit11;				/*!< aliase to 11th bit */
+		uint32_t bBit12;				/*!< aliase to 12th bit */
+		uint32_t bBit13;				/*!< aliase to 13th bit */
+		uint32_t bBit14;				/*!< aliase to 14th bit */
+		uint32_t bBit15;				/*!< aliase to 15th bit */
+		uint32_t bBit16;				/*!< aliase to 16th bit */
+		uint32_t bBit17;				/*!< aliase to 17th bit */
+		uint32_t bBit18;				/*!< aliase to 18th bit */
+		uint32_t bBit19;				/*!< aliase to 19th bit */
+		uint32_t bBit20;				/*!< aliase to 20th bit */
+		uint32_t bBit21;				/*!< aliase to 21th bit */
+		uint32_t bBit22;				/*!< aliase to 22th bit */
+		uint32_t bBit23;				/*!< aliase to 23th bit */
+		uint32_t bBit24;				/*!< aliase to 24th bit */
+		uint32_t bBit25;				/*!< aliase to 25th bit */
+		uint32_t bBit26;				/*!< aliase to 26th bit */
+		uint32_t bBit27;				/*!< aliase to 27th bit */
+		uint32_t bBit28;				/*!< aliase to 28th bit */
+		uint32_t bBit29;				/*!< aliase to 29th bit */
+		uint32_t bBit30;				/*!< aliase to 30th bit */
+		uint32_t bBit31;				/*!< aliase to 31th bit */
+}BIT_BandType,*BIT_BandPtr;
+/*! @} End of BIT_BandType                                               */
+
+/******************************************************************************
+* define  API list
+*
+*//*! @addtogroup bit_band_api_list
+* @{
+*******************************************************************************/
+/*****************************************************************************//*!
+   *
+   * @brief bit-band initialize pointer, so that invoke the pointer to access alisaed bitband.
+   *        
+   * @param[in]  pVariableAddress - point to variable.
+   * @param[in]  pBitbandPtr - point to alisaed bitband address. 
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+__STATIC_INLINE void BIT_BandVariableInit( uint32_t *pVariableAddress,BIT_BandPtr *pBitbandPtr )
+{
+#if defined(CPU_KE04)
+	ASSERT( ((uint32)pVariableAddress >= 0x20000000)&&((uint32_t)pVariableAddress <= 0x200002FF) );
+#elif defined(CPU_KE06)
+	ASSERT( ((uint32)pVariableAddress >= 0x20000000)&&((uint32_t)pVariableAddress <= (0x20000000+12*1024)));
+#else
+	#error "don't support this function on this device"
+#endif
+    *pBitbandPtr = (BIT_BandPtr)(((uint32_t)pVariableAddress-0x20000000)*32+0x22000000);   
+}
+/*! @} End of bit_band_api_list                                                    					*/
+#ifdef __cplusplus
+}
+#endif
+#endif /* __BIT_BAND_H */
+
+
diff --git a/bsp/frdm-ke02/device/lib/inc/common.h b/bsp/frdm-ke02/device/lib/inc/common.h
new file mode 100755
index 0000000..37e14c6
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/common.h
@@ -0,0 +1,118 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file common.h
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief provide header files to be included by all project files. 
+*
+*******************************************************************************/
+
+
+#ifndef _COMMON_H_
+#define _COMMON_H_
+
+#define swap_bytes(ptrWord)   *ptrWord = (*ptrWord >>8) | (*ptrWord<<8)
+typedef unsigned long   dword;
+typedef unsigned short  word;
+
+/********************************************************************/
+
+/*
+ * Debug prints ON (#define) or OFF (#undef)
+ */
+
+#define DEBUG
+//#define DEBUG_PRINT
+
+/* 
+ * Include the generic CPU header file 
+ */
+#include "arm_cm0.h"
+
+/* 
+ * Include the platform specific header file 
+ */
+#if (defined(FRDM_KE02))
+ #include  "ke02_config.h"
+#elif (defined(FRDM_KE04))
+ #include  "ke04_config.h"
+#elif (defined(FRDM_KE06))
+ #include  "ke06_config.h"
+#else
+  #error "No valid board defined"
+#endif
+
+/* 
+ * Include the cpu specific header file 
+*/
+#if (defined(CPU_KE02))
+ #include "MKE02Z2.h"
+#elif (defined(CPU_KE04))
+ #include "MKE04Z4.h"
+#elif (defined(CPU_KE06))
+ #include "MKE06Z4.h"
+#else
+  #error "No valid CPU defined"
+#endif
+
+
+/* 
+ * Include any toolchain specfic header files 
+ */
+#if (defined(__MWERKS__))
+  #include "mwerks.h"
+#elif (defined(__DCC__))
+  #include "build/wrs/diab.h"
+#elif (defined(__ghs__))
+  #include "build/ghs/ghs.h"
+#elif (defined(__GNUC__))
+  #if (defined(IAR))
+    #include "build/gnu/gnu.h"
+  #endif
+#elif (defined(IAR))
+  #include "iar.h"
+#elif (defined(KEIL))
+  
+#else
+#warning "No toolchain specific header included"
+#endif
+
+/* 
+ * Include common utilities
+ */
+#include "assert.h"
+#include "io.h"
+#include "startup.h"
+#include "stdlib.h"
+
+#if (defined(IAR))
+#include "intrinsics.h"
+#endif
+/********************************************************************/
+
+#endif /* _COMMON_H_ */
diff --git a/bsp/frdm-ke02/device/lib/inc/core_cm0plus.h b/bsp/frdm-ke02/device/lib/inc/core_cm0plus.h
new file mode 100755
index 0000000..5cea74e
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/core_cm0plus.h
@@ -0,0 +1,793 @@
+/**************************************************************************//**
+ * @file     core_cm0plus.h
+ * @brief    CMSIS Cortex-M0+ Core Peripheral Access Layer Header File
+ * @version  V3.20
+ * @date     25. February 2013
+ *
+ * @note
+ *
+ ******************************************************************************/
+/* Copyright (c) 2009 - 2013 ARM LIMITED
+
+   All rights reserved.
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+   - Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+   - Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+   - Neither the name of ARM nor the names of its contributors may be used
+     to endorse or promote products derived from this software without
+     specific prior written permission.
+   *
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
+   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+   POSSIBILITY OF SUCH DAMAGE.
+   ---------------------------------------------------------------------------*/
+
+
+#if defined ( __ICCARM__ )
+ #pragma system_include  /* treat file as system include file for MISRA check */
+#endif
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+#ifndef __CORE_CM0PLUS_H_GENERIC
+#define __CORE_CM0PLUS_H_GENERIC
+
+/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
+  CMSIS violates the following MISRA-C:2004 rules:
+
+   \li Required Rule 8.5, object/function definition in header file.<br>
+     Function definitions in header files are used to allow 'inlining'.
+
+   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
+     Unions are used for effective representation of core registers.
+
+   \li Advisory Rule 19.7, Function-like macro defined.<br>
+     Function-like macros are used to allow more efficient code.
+ */
+
+
+/*******************************************************************************
+ *                 CMSIS definitions
+ ******************************************************************************/
+/** \ingroup Cortex-M0+
+  @{
+ */
+
+/*  CMSIS CM0P definitions */
+#define __CM0PLUS_CMSIS_VERSION_MAIN (0x03)                                /*!< [31:16] CMSIS HAL main version   */
+#define __CM0PLUS_CMSIS_VERSION_SUB  (0x20)                                /*!< [15:0]  CMSIS HAL sub version    */
+#define __CM0PLUS_CMSIS_VERSION      ((__CM0PLUS_CMSIS_VERSION_MAIN << 16) | \
+                                       __CM0PLUS_CMSIS_VERSION_SUB)        /*!< CMSIS HAL version number         */
+
+#define __CORTEX_M                (0x00)                                   /*!< Cortex-M Core                    */
+
+
+#if   defined ( __CC_ARM )
+  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
+  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
+  #define __STATIC_INLINE  static __inline
+
+#elif defined ( __ICCARM__ )
+  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
+  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
+  #define __STATIC_INLINE  static inline
+
+#elif defined ( __GNUC__ )
+  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
+  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
+  #define __STATIC_INLINE  static inline
+
+#elif defined ( __TASKING__ )
+  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
+  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
+  #define __STATIC_INLINE  static inline
+
+#endif
+
+/** __FPU_USED indicates whether an FPU is used or not. This core does not support an FPU at all
+*/
+#define __FPU_USED       0
+
+#if defined ( __CC_ARM )
+  #if defined __TARGET_FPU_VFP
+    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+  #endif
+
+#elif defined ( __ICCARM__ )
+  #if defined __ARMVFP__
+    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+  #endif
+
+#elif defined ( __GNUC__ )
+  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
+    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+  #endif
+
+#elif defined ( __TASKING__ )
+  #if defined __FPU_VFP__
+    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+  #endif
+#endif
+
+#include <stdint.h>                      /* standard types definitions                      */
+#include <core_cmInstr.h>                /* Core Instruction Access                         */
+#include <core_cmFunc.h>                 /* Core Function Access                            */
+
+#endif /* __CORE_CM0PLUS_H_GENERIC */
+
+#ifndef __CMSIS_GENERIC
+
+#ifndef __CORE_CM0PLUS_H_DEPENDANT
+#define __CORE_CM0PLUS_H_DEPENDANT
+
+/* check device defines and use defaults */
+#if defined __CHECK_DEVICE_DEFINES
+  #ifndef __CM0PLUS_REV
+    #define __CM0PLUS_REV             0x0000
+    #warning "__CM0PLUS_REV not defined in device header file; using default!"
+  #endif
+
+  #ifndef __MPU_PRESENT
+    #define __MPU_PRESENT             0
+    #warning "__MPU_PRESENT not defined in device header file; using default!"
+  #endif
+
+  #ifndef __VTOR_PRESENT
+    #define __VTOR_PRESENT            0
+    #warning "__VTOR_PRESENT not defined in device header file; using default!"
+  #endif
+
+  #ifndef __NVIC_PRIO_BITS
+    #define __NVIC_PRIO_BITS          2
+    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
+  #endif
+
+  #ifndef __Vendor_SysTickConfig
+    #define __Vendor_SysTickConfig    0
+    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
+  #endif
+#endif
+
+/* IO definitions (access restrictions to peripheral registers) */
+/**
+    \defgroup CMSIS_glob_defs CMSIS Global Defines
+
+    <strong>IO Type Qualifiers</strong> are used
+    \li to specify the access to peripheral variables.
+    \li for automatic generation of peripheral register debug information.
+*/
+#ifdef __cplusplus
+  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
+#else
+  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
+#endif
+#define     __O     volatile             /*!< Defines 'write only' permissions                */
+#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
+
+/*@} end of group Cortex-M0+ */
+
+
+
+/*******************************************************************************
+ *                 Register Abstraction
+  Core Register contain:
+  - Core Register
+  - Core NVIC Register
+  - Core SCB Register
+  - Core SysTick Register
+  - Core MPU Register
+ ******************************************************************************/
+/** \defgroup CMSIS_core_register Defines and Type Definitions
+    \brief Type definitions and defines for Cortex-M processor based devices.
+*/
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_CORE  Status and Control Registers
+    \brief  Core Register type definitions.
+  @{
+ */
+
+/** \brief  Union type to access the Application Program Status Register (APSR).
+ */
+typedef union
+{
+  struct
+  {
+#if (__CORTEX_M != 0x04)
+    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
+#else
+    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
+    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
+    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
+#endif
+    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
+    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
+    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
+    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
+    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} APSR_Type;
+
+
+/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
+    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} IPSR_Type;
+
+
+/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
+#if (__CORTEX_M != 0x04)
+    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
+#else
+    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
+    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
+    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
+#endif
+    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
+    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
+    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
+    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
+    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
+    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
+    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} xPSR_Type;
+
+
+/** \brief  Union type to access the Control Registers (CONTROL).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
+    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
+    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
+    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} CONTROL_Type;
+
+/*@} end of group CMSIS_CORE */
+
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
+    \brief      Type definitions for the NVIC Registers
+  @{
+ */
+
+/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
+ */
+typedef struct
+{
+  __IO uint32_t ISER[1];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
+       uint32_t RESERVED0[31];
+  __IO uint32_t ICER[1];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register          */
+       uint32_t RSERVED1[31];
+  __IO uint32_t ISPR[1];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register           */
+       uint32_t RESERVED2[31];
+  __IO uint32_t ICPR[1];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register         */
+       uint32_t RESERVED3[31];
+       uint32_t RESERVED4[64];
+  __IO uint32_t IP[8];                   /*!< Offset: 0x300 (R/W)  Interrupt Priority Register              */
+}  NVIC_Type;
+
+/*@} end of group CMSIS_NVIC */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_SCB     System Control Block (SCB)
+    \brief      Type definitions for the System Control Block Registers
+  @{
+ */
+
+/** \brief  Structure type to access the System Control Block (SCB).
+ */
+typedef struct
+{
+  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
+  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
+#if (__VTOR_PRESENT == 1)
+  __IO uint32_t VTOR;                    /*!< Offset: 0x008 (R/W)  Vector Table Offset Register                          */
+#else
+       uint32_t RESERVED0;
+#endif
+  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
+  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
+  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
+       uint32_t RESERVED1;
+  __IO uint32_t SHP[2];                  /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED   */
+  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
+} SCB_Type;
+
+/* SCB CPUID Register Definitions */
+#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
+#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
+
+#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
+#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
+
+#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
+#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
+
+#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
+#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
+
+#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
+#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
+
+/* SCB Interrupt Control State Register Definitions */
+#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
+#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
+
+#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
+#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
+
+#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
+#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
+
+#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
+#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
+
+#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
+#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
+
+#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
+#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
+
+#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
+#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
+
+#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
+#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
+
+#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
+#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
+
+#if (__VTOR_PRESENT == 1)
+/* SCB Interrupt Control State Register Definitions */
+#define SCB_VTOR_TBLOFF_Pos                 8                                             /*!< SCB VTOR: TBLOFF Position */
+#define SCB_VTOR_TBLOFF_Msk                (0xFFFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
+#endif
+
+/* SCB Application Interrupt and Reset Control Register Definitions */
+#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
+#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
+
+#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
+#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
+
+#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
+#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
+
+#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
+#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
+
+#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
+#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
+
+/* SCB System Control Register Definitions */
+#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
+#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
+
+#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
+#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
+
+#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
+#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
+
+/* SCB Configuration Control Register Definitions */
+#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
+#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
+
+#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
+#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
+
+/* SCB System Handler Control and State Register Definitions */
+#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
+#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
+
+/*@} end of group CMSIS_SCB */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
+    \brief      Type definitions for the System Timer Registers.
+  @{
+ */
+
+/** \brief  Structure type to access the System Timer (SysTick).
+ */
+typedef struct
+{
+  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
+  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
+  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
+  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
+} SysTick_Type;
+
+/* SysTick Control / Status Register Definitions */
+#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
+#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
+
+#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
+#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
+
+#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
+#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
+
+#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
+#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
+
+/* SysTick Reload Register Definitions */
+#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
+#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
+
+/* SysTick Current Register Definitions */
+#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
+#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
+
+/* SysTick Calibration Register Definitions */
+#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
+#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
+
+#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
+#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
+
+#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
+#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
+
+/*@} end of group CMSIS_SysTick */
+
+#if (__MPU_PRESENT == 1)
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
+    \brief      Type definitions for the Memory Protection Unit (MPU)
+  @{
+ */
+
+/** \brief  Structure type to access the Memory Protection Unit (MPU).
+ */
+typedef struct
+{
+  __I  uint32_t TYPE;                    /*!< Offset: 0x000 (R/ )  MPU Type Register                              */
+  __IO uint32_t CTRL;                    /*!< Offset: 0x004 (R/W)  MPU Control Register                           */
+  __IO uint32_t RNR;                     /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register                     */
+  __IO uint32_t RBAR;                    /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register               */
+  __IO uint32_t RASR;                    /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register         */
+} MPU_Type;
+
+/* MPU Type Register */
+#define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU TYPE: IREGION Position */
+#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
+
+#define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU TYPE: DREGION Position */
+#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
+
+#define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU TYPE: SEPARATE Position */
+#define MPU_TYPE_SEPARATE_Msk              (1UL << MPU_TYPE_SEPARATE_Pos)                 /*!< MPU TYPE: SEPARATE Mask */
+
+/* MPU Control Register */
+#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU CTRL: PRIVDEFENA Position */
+#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
+
+#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */
+#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
+
+#define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU CTRL: ENABLE Position */
+#define MPU_CTRL_ENABLE_Msk                (1UL << MPU_CTRL_ENABLE_Pos)                   /*!< MPU CTRL: ENABLE Mask */
+
+/* MPU Region Number Register */
+#define MPU_RNR_REGION_Pos                  0                                             /*!< MPU RNR: REGION Position */
+#define MPU_RNR_REGION_Msk                 (0xFFUL << MPU_RNR_REGION_Pos)                 /*!< MPU RNR: REGION Mask */
+
+/* MPU Region Base Address Register */
+#define MPU_RBAR_ADDR_Pos                   8                                             /*!< MPU RBAR: ADDR Position */
+#define MPU_RBAR_ADDR_Msk                  (0xFFFFFFUL << MPU_RBAR_ADDR_Pos)              /*!< MPU RBAR: ADDR Mask */
+
+#define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU RBAR: VALID Position */
+#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
+
+#define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU RBAR: REGION Position */
+#define MPU_RBAR_REGION_Msk                (0xFUL << MPU_RBAR_REGION_Pos)                 /*!< MPU RBAR: REGION Mask */
+
+/* MPU Region Attribute and Size Register */
+#define MPU_RASR_ATTRS_Pos                 16                                             /*!< MPU RASR: MPU Region Attribute field Position */
+#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
+
+#define MPU_RASR_XN_Pos                    28                                             /*!< MPU RASR: ATTRS.XN Position */
+#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
+
+#define MPU_RASR_AP_Pos                    24                                             /*!< MPU RASR: ATTRS.AP Position */
+#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
+
+#define MPU_RASR_TEX_Pos                   19                                             /*!< MPU RASR: ATTRS.TEX Position */
+#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
+
+#define MPU_RASR_S_Pos                     18                                             /*!< MPU RASR: ATTRS.S Position */
+#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
+
+#define MPU_RASR_C_Pos                     17                                             /*!< MPU RASR: ATTRS.C Position */
+#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
+
+#define MPU_RASR_B_Pos                     16                                             /*!< MPU RASR: ATTRS.B Position */
+#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
+
+#define MPU_RASR_SRD_Pos                    8                                             /*!< MPU RASR: Sub-Region Disable Position */
+#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
+
+#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */
+#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
+
+#define MPU_RASR_ENABLE_Pos                 0                                             /*!< MPU RASR: Region enable bit Position */
+#define MPU_RASR_ENABLE_Msk                (1UL << MPU_RASR_ENABLE_Pos)                   /*!< MPU RASR: Region enable bit Disable Mask */
+
+/*@} end of group CMSIS_MPU */
+#endif
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
+    \brief      Cortex-M0+ Core Debug Registers (DCB registers, SHCSR, and DFSR)
+                are only accessible over DAP and not via processor. Therefore
+                they are not covered by the Cortex-M0 header file.
+  @{
+ */
+/*@} end of group CMSIS_CoreDebug */
+
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_core_base     Core Definitions
+    \brief      Definitions for base addresses, unions, and structures.
+  @{
+ */
+
+/* Memory mapping of Cortex-M0+ Hardware */
+#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
+#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address              */
+#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                 */
+#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
+
+#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
+#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
+#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
+
+#if (__MPU_PRESENT == 1)
+  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit             */
+  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit             */
+#endif
+
+/*@} */
+
+
+
+/*******************************************************************************
+ *                Hardware Abstraction Layer
+  Core Function Interface contains:
+  - Core NVIC Functions
+  - Core SysTick Functions
+  - Core Register Access Functions
+ ******************************************************************************/
+/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
+*/
+
+
+
+/* ##########################   NVIC functions  #################################### */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
+    \brief      Functions that manage interrupts and exceptions via the NVIC.
+    @{
+ */
+
+/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
+/* The following MACROS handle generation of the register offset and byte masks */
+#define _BIT_SHIFT(IRQn)         (  (((uint32_t)(IRQn)       )    &  0x03) * 8 )
+#define _SHP_IDX(IRQn)           ( ((((uint32_t)(IRQn) & 0x0F)-8) >>    2)     )
+#define _IP_IDX(IRQn)            (   ((uint32_t)(IRQn)            >>    2)     )
+
+
+/** \brief  Enable External Interrupt
+
+    The function enables a device-specific interrupt in the NVIC interrupt controller.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
+{
+  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
+}
+
+
+/** \brief  Disable External Interrupt
+
+    The function disables a device-specific interrupt in the NVIC interrupt controller.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
+{
+  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
+}
+
+
+/** \brief  Get Pending Interrupt
+
+    The function reads the pending register in the NVIC and returns the pending bit
+    for the specified interrupt.
+
+    \param [in]      IRQn  Interrupt number.
+
+    \return             0  Interrupt status is not pending.
+    \return             1  Interrupt status is pending.
+ */
+__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
+{
+  return((uint32_t) ((NVIC->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
+}
+
+
+/** \brief  Set Pending Interrupt
+
+    The function sets the pending bit of an external interrupt.
+
+    \param [in]      IRQn  Interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
+{
+  NVIC->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
+}
+
+
+/** \brief  Clear Pending Interrupt
+
+    The function clears the pending bit of an external interrupt.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
+{
+  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
+}
+
+
+/** \brief  Set Interrupt Priority
+
+    The function sets the priority of an interrupt.
+
+    \note The priority cannot be set for every core interrupt.
+
+    \param [in]      IRQn  Interrupt number.
+    \param [in]  priority  Priority to set.
+ */
+__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
+{
+  if(IRQn < 0) {
+    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
+        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
+  else {
+    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
+        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
+}
+
+
+/** \brief  Get Interrupt Priority
+
+    The function reads the priority of an interrupt. The interrupt
+    number can be positive to specify an external (device specific)
+    interrupt, or negative to specify an internal (core) interrupt.
+
+
+    \param [in]   IRQn  Interrupt number.
+    \return             Interrupt Priority. Value is aligned automatically to the implemented
+                        priority bits of the microcontroller.
+ */
+__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
+{
+
+  if(IRQn < 0) {
+    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & 0xFF) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M0 system interrupts */
+  else {
+    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & 0xFF) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
+}
+
+
+/** \brief  System Reset
+
+    The function initiates a system reset request to reset the MCU.
+ */
+__STATIC_INLINE void NVIC_SystemReset(void)
+{
+  __DSB();                                                     /* Ensure all outstanding memory accesses included
+                                                                  buffered write are completed before reset */
+  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
+                 SCB_AIRCR_SYSRESETREQ_Msk);
+  __DSB();                                                     /* Ensure completion of memory access */
+  while(1);                                                    /* wait until reset */
+}
+
+/*@} end of CMSIS_Core_NVICFunctions */
+
+
+
+/* ##################################    SysTick function  ############################################ */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
+    \brief      Functions that configure the System.
+  @{
+ */
+
+#if (__Vendor_SysTickConfig == 0)
+
+/** \brief  System Tick Configuration
+
+    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
+    Counter is in free running mode to generate periodic interrupts.
+
+    \param [in]  ticks  Number of ticks between two interrupts.
+
+    \return          0  Function succeeded.
+    \return          1  Function failed.
+
+    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
+    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
+    must contain a vendor-specific implementation of this function.
+
+ */
+__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
+{
+  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
+
+  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
+  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
+  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
+  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
+                   SysTick_CTRL_TICKINT_Msk   |
+                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
+  return (0);                                                  /* Function successful */
+}
+
+#endif
+
+/*@} end of CMSIS_Core_SysTickFunctions */
+
+
+
+
+#endif /* __CORE_CM0PLUS_H_DEPENDANT */
+
+#endif /* __CMSIS_GENERIC */
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/bsp/frdm-ke02/device/lib/inc/core_cmFunc.h b/bsp/frdm-ke02/device/lib/inc/core_cmFunc.h
new file mode 100755
index 0000000..0a18faf
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/core_cmFunc.h
@@ -0,0 +1,636 @@
+/**************************************************************************//**
+ * @file     core_cmFunc.h
+ * @brief    CMSIS Cortex-M Core Function Access Header File
+ * @version  V3.20
+ * @date     25. February 2013
+ *
+ * @note
+ *
+ ******************************************************************************/
+/* Copyright (c) 2009 - 2013 ARM LIMITED
+
+   All rights reserved.
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+   - Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+   - Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+   - Neither the name of ARM nor the names of its contributors may be used
+     to endorse or promote products derived from this software without
+     specific prior written permission.
+   *
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
+   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+   POSSIBILITY OF SUCH DAMAGE.
+   ---------------------------------------------------------------------------*/
+
+
+#ifndef __CORE_CMFUNC_H
+#define __CORE_CMFUNC_H
+
+
+/* ###########################  Core Function Access  ########################### */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
+  @{
+ */
+
+#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
+/* ARM armcc specific functions */
+
+#if (__ARMCC_VERSION < 400677)
+  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
+#endif
+
+/* intrinsic void __enable_irq();     */
+/* intrinsic void __disable_irq();    */
+
+/** \brief  Get Control Register
+
+    This function returns the content of the Control Register.
+
+    \return               Control Register value
+ */
+__STATIC_INLINE uint32_t __get_CONTROL(void)
+{
+  register uint32_t __regControl         __ASM("control");
+  return(__regControl);
+}
+
+
+/** \brief  Set Control Register
+
+    This function writes the given value to the Control Register.
+
+    \param [in]    control  Control Register value to set
+ */
+__STATIC_INLINE void __set_CONTROL(uint32_t control)
+{
+  register uint32_t __regControl         __ASM("control");
+  __regControl = control;
+}
+
+
+/** \brief  Get IPSR Register
+
+    This function returns the content of the IPSR Register.
+
+    \return               IPSR Register value
+ */
+__STATIC_INLINE uint32_t __get_IPSR(void)
+{
+  register uint32_t __regIPSR          __ASM("ipsr");
+  return(__regIPSR);
+}
+
+
+/** \brief  Get APSR Register
+
+    This function returns the content of the APSR Register.
+
+    \return               APSR Register value
+ */
+__STATIC_INLINE uint32_t __get_APSR(void)
+{
+  register uint32_t __regAPSR          __ASM("apsr");
+  return(__regAPSR);
+}
+
+
+/** \brief  Get xPSR Register
+
+    This function returns the content of the xPSR Register.
+
+    \return               xPSR Register value
+ */
+__STATIC_INLINE uint32_t __get_xPSR(void)
+{
+  register uint32_t __regXPSR          __ASM("xpsr");
+  return(__regXPSR);
+}
+
+
+/** \brief  Get Process Stack Pointer
+
+    This function returns the current value of the Process Stack Pointer (PSP).
+
+    \return               PSP Register value
+ */
+__STATIC_INLINE uint32_t __get_PSP(void)
+{
+  register uint32_t __regProcessStackPointer  __ASM("psp");
+  return(__regProcessStackPointer);
+}
+
+
+/** \brief  Set Process Stack Pointer
+
+    This function assigns the given value to the Process Stack Pointer (PSP).
+
+    \param [in]    topOfProcStack  Process Stack Pointer value to set
+ */
+__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
+{
+  register uint32_t __regProcessStackPointer  __ASM("psp");
+  __regProcessStackPointer = topOfProcStack;
+}
+
+
+/** \brief  Get Main Stack Pointer
+
+    This function returns the current value of the Main Stack Pointer (MSP).
+
+    \return               MSP Register value
+ */
+__STATIC_INLINE uint32_t __get_MSP(void)
+{
+  register uint32_t __regMainStackPointer     __ASM("msp");
+  return(__regMainStackPointer);
+}
+
+
+/** \brief  Set Main Stack Pointer
+
+    This function assigns the given value to the Main Stack Pointer (MSP).
+
+    \param [in]    topOfMainStack  Main Stack Pointer value to set
+ */
+__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
+{
+  register uint32_t __regMainStackPointer     __ASM("msp");
+  __regMainStackPointer = topOfMainStack;
+}
+
+
+/** \brief  Get Priority Mask
+
+    This function returns the current state of the priority mask bit from the Priority Mask Register.
+
+    \return               Priority Mask value
+ */
+__STATIC_INLINE uint32_t __get_PRIMASK(void)
+{
+  register uint32_t __regPriMask         __ASM("primask");
+  return(__regPriMask);
+}
+
+
+/** \brief  Set Priority Mask
+
+    This function assigns the given value to the Priority Mask Register.
+
+    \param [in]    priMask  Priority Mask
+ */
+__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
+{
+  register uint32_t __regPriMask         __ASM("primask");
+  __regPriMask = (priMask);
+}
+
+
+#if       (__CORTEX_M >= 0x03)
+
+/** \brief  Enable FIQ
+
+    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
+    Can only be executed in Privileged modes.
+ */
+#define __enable_fault_irq                __enable_fiq
+
+
+/** \brief  Disable FIQ
+
+    This function disables FIQ interrupts by setting the F-bit in the CPSR.
+    Can only be executed in Privileged modes.
+ */
+#define __disable_fault_irq               __disable_fiq
+
+
+/** \brief  Get Base Priority
+
+    This function returns the current value of the Base Priority register.
+
+    \return               Base Priority register value
+ */
+__STATIC_INLINE uint32_t  __get_BASEPRI(void)
+{
+  register uint32_t __regBasePri         __ASM("basepri");
+  return(__regBasePri);
+}
+
+
+/** \brief  Set Base Priority
+
+    This function assigns the given value to the Base Priority register.
+
+    \param [in]    basePri  Base Priority value to set
+ */
+__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
+{
+  register uint32_t __regBasePri         __ASM("basepri");
+  __regBasePri = (basePri & 0xff);
+}
+
+
+/** \brief  Get Fault Mask
+
+    This function returns the current value of the Fault Mask register.
+
+    \return               Fault Mask register value
+ */
+__STATIC_INLINE uint32_t __get_FAULTMASK(void)
+{
+  register uint32_t __regFaultMask       __ASM("faultmask");
+  return(__regFaultMask);
+}
+
+
+/** \brief  Set Fault Mask
+
+    This function assigns the given value to the Fault Mask register.
+
+    \param [in]    faultMask  Fault Mask value to set
+ */
+__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
+{
+  register uint32_t __regFaultMask       __ASM("faultmask");
+  __regFaultMask = (faultMask & (uint32_t)1);
+}
+
+#endif /* (__CORTEX_M >= 0x03) */
+
+
+#if       (__CORTEX_M == 0x04)
+
+/** \brief  Get FPSCR
+
+    This function returns the current value of the Floating Point Status/Control register.
+
+    \return               Floating Point Status/Control register value
+ */
+__STATIC_INLINE uint32_t __get_FPSCR(void)
+{
+#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
+  register uint32_t __regfpscr         __ASM("fpscr");
+  return(__regfpscr);
+#else
+   return(0);
+#endif
+}
+
+
+/** \brief  Set FPSCR
+
+    This function assigns the given value to the Floating Point Status/Control register.
+
+    \param [in]    fpscr  Floating Point Status/Control value to set
+ */
+__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
+{
+#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
+  register uint32_t __regfpscr         __ASM("fpscr");
+  __regfpscr = (fpscr);
+#endif
+}
+
+#endif /* (__CORTEX_M == 0x04) */
+
+
+#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
+/* IAR iccarm specific functions */
+
+#include <cmsis_iar.h>
+
+
+#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
+/* TI CCS specific functions */
+
+#include <cmsis_ccs.h>
+
+
+#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
+/* GNU gcc specific functions */
+
+/** \brief  Enable IRQ Interrupts
+
+  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
+  Can only be executed in Privileged modes.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
+{
+  __ASM volatile ("cpsie i" : : : "memory");
+}
+
+
+/** \brief  Disable IRQ Interrupts
+
+  This function disables IRQ interrupts by setting the I-bit in the CPSR.
+  Can only be executed in Privileged modes.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
+{
+  __ASM volatile ("cpsid i" : : : "memory");
+}
+
+
+/** \brief  Get Control Register
+
+    This function returns the content of the Control Register.
+
+    \return               Control Register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, control" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Set Control Register
+
+    This function writes the given value to the Control Register.
+
+    \param [in]    control  Control Register value to set
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
+{
+  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
+}
+
+
+/** \brief  Get IPSR Register
+
+    This function returns the content of the IPSR Register.
+
+    \return               IPSR Register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Get APSR Register
+
+    This function returns the content of the APSR Register.
+
+    \return               APSR Register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Get xPSR Register
+
+    This function returns the content of the xPSR Register.
+
+    \return               xPSR Register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Get Process Stack Pointer
+
+    This function returns the current value of the Process Stack Pointer (PSP).
+
+    \return               PSP Register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
+{
+  register uint32_t result;
+
+  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Set Process Stack Pointer
+
+    This function assigns the given value to the Process Stack Pointer (PSP).
+
+    \param [in]    topOfProcStack  Process Stack Pointer value to set
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
+{
+  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
+}
+
+
+/** \brief  Get Main Stack Pointer
+
+    This function returns the current value of the Main Stack Pointer (MSP).
+
+    \return               MSP Register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
+{
+  register uint32_t result;
+
+  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Set Main Stack Pointer
+
+    This function assigns the given value to the Main Stack Pointer (MSP).
+
+    \param [in]    topOfMainStack  Main Stack Pointer value to set
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
+{
+  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
+}
+
+
+/** \brief  Get Priority Mask
+
+    This function returns the current state of the priority mask bit from the Priority Mask Register.
+
+    \return               Priority Mask value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, primask" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Set Priority Mask
+
+    This function assigns the given value to the Priority Mask Register.
+
+    \param [in]    priMask  Priority Mask
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
+{
+  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
+}
+
+
+#if       (__CORTEX_M >= 0x03)
+
+/** \brief  Enable FIQ
+
+    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
+    Can only be executed in Privileged modes.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
+{
+  __ASM volatile ("cpsie f" : : : "memory");
+}
+
+
+/** \brief  Disable FIQ
+
+    This function disables FIQ interrupts by setting the F-bit in the CPSR.
+    Can only be executed in Privileged modes.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
+{
+  __ASM volatile ("cpsid f" : : : "memory");
+}
+
+
+/** \brief  Get Base Priority
+
+    This function returns the current value of the Base Priority register.
+
+    \return               Base Priority register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Set Base Priority
+
+    This function assigns the given value to the Base Priority register.
+
+    \param [in]    basePri  Base Priority value to set
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
+{
+  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
+}
+
+
+/** \brief  Get Fault Mask
+
+    This function returns the current value of the Fault Mask register.
+
+    \return               Fault Mask register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Set Fault Mask
+
+    This function assigns the given value to the Fault Mask register.
+
+    \param [in]    faultMask  Fault Mask value to set
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
+{
+  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
+}
+
+#endif /* (__CORTEX_M >= 0x03) */
+
+
+#if       (__CORTEX_M == 0x04)
+
+/** \brief  Get FPSCR
+
+    This function returns the current value of the Floating Point Status/Control register.
+
+    \return               Floating Point Status/Control register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
+{
+#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
+  uint32_t result;
+
+  /* Empty asm statement works as a scheduling barrier */
+  __ASM volatile ("");
+  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
+  __ASM volatile ("");
+  return(result);
+#else
+   return(0);
+#endif
+}
+
+
+/** \brief  Set FPSCR
+
+    This function assigns the given value to the Floating Point Status/Control register.
+
+    \param [in]    fpscr  Floating Point Status/Control value to set
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
+{
+#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
+  /* Empty asm statement works as a scheduling barrier */
+  __ASM volatile ("");
+  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc");
+  __ASM volatile ("");
+#endif
+}
+
+#endif /* (__CORTEX_M == 0x04) */
+
+
+#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
+/* TASKING carm specific functions */
+
+/*
+ * The CMSIS functions have been implemented as intrinsics in the compiler.
+ * Please use "carm -?i" to get an up to date list of all instrinsics,
+ * Including the CMSIS ones.
+ */
+
+#endif
+
+/*@} end of CMSIS_Core_RegAccFunctions */
+
+
+#endif /* __CORE_CMFUNC_H */
diff --git a/bsp/frdm-ke02/device/lib/inc/core_cmInstr.h b/bsp/frdm-ke02/device/lib/inc/core_cmInstr.h
new file mode 100755
index 0000000..d213f0e
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/core_cmInstr.h
@@ -0,0 +1,688 @@
+/**************************************************************************//**
+ * @file     core_cmInstr.h
+ * @brief    CMSIS Cortex-M Core Instruction Access Header File
+ * @version  V3.20
+ * @date     05. March 2013
+ *
+ * @note
+ *
+ ******************************************************************************/
+/* Copyright (c) 2009 - 2013 ARM LIMITED
+
+   All rights reserved.
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+   - Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+   - Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+   - Neither the name of ARM nor the names of its contributors may be used
+     to endorse or promote products derived from this software without
+     specific prior written permission.
+   *
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
+   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+   POSSIBILITY OF SUCH DAMAGE.
+   ---------------------------------------------------------------------------*/
+
+
+#ifndef __CORE_CMINSTR_H
+#define __CORE_CMINSTR_H
+
+
+/* ##########################  Core Instruction Access  ######################### */
+/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
+  Access to dedicated instructions
+  @{
+*/
+
+#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
+/* ARM armcc specific functions */
+
+#if (__ARMCC_VERSION < 400677)
+  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
+#endif
+
+
+/** \brief  No Operation
+
+    No Operation does nothing. This instruction can be used for code alignment purposes.
+ */
+#define __NOP                             __nop
+
+
+/** \brief  Wait For Interrupt
+
+    Wait For Interrupt is a hint instruction that suspends execution
+    until one of a number of events occurs.
+ */
+#define __WFI                             __wfi
+
+
+/** \brief  Wait For Event
+
+    Wait For Event is a hint instruction that permits the processor to enter
+    a low-power state until one of a number of events occurs.
+ */
+#define __WFE                             __wfe
+
+
+/** \brief  Send Event
+
+    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
+ */
+#define __SEV                             __sev
+
+
+/** \brief  Instruction Synchronization Barrier
+
+    Instruction Synchronization Barrier flushes the pipeline in the processor,
+    so that all instructions following the ISB are fetched from cache or
+    memory, after the instruction has been completed.
+ */
+#define __ISB()                           __isb(0xF)
+
+
+/** \brief  Data Synchronization Barrier
+
+    This function acts as a special kind of Data Memory Barrier.
+    It completes when all explicit memory accesses before this instruction complete.
+ */
+#define __DSB()                           __dsb(0xF)
+
+
+/** \brief  Data Memory Barrier
+
+    This function ensures the apparent order of the explicit memory operations before
+    and after the instruction, without ensuring their completion.
+ */
+#define __DMB()                           __dmb(0xF)
+
+
+/** \brief  Reverse byte order (32 bit)
+
+    This function reverses the byte order in integer value.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+#define __REV                             __rev
+
+
+/** \brief  Reverse byte order (16 bit)
+
+    This function reverses the byte order in two unsigned short values.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+#ifndef __NO_EMBEDDED_ASM
+__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
+{
+  rev16 r0, r0
+  bx lr
+}
+#endif
+
+/** \brief  Reverse byte order in signed short value
+
+    This function reverses the byte order in a signed short value with sign extension to integer.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+#ifndef __NO_EMBEDDED_ASM
+__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
+{
+  revsh r0, r0
+  bx lr
+}
+#endif
+
+
+/** \brief  Rotate Right in unsigned value (32 bit)
+
+    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
+
+    \param [in]    value  Value to rotate
+    \param [in]    value  Number of Bits to rotate
+    \return               Rotated value
+ */
+#define __ROR                             __ror
+
+
+/** \brief  Breakpoint
+
+    This function causes the processor to enter Debug state.
+    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
+
+    \param [in]    value  is ignored by the processor.
+                   If required, a debugger can use it to store additional information about the breakpoint.
+ */
+#define __BKPT(value)                       __breakpoint(value)
+
+
+#if       (__CORTEX_M >= 0x03)
+
+/** \brief  Reverse bit order of value
+
+    This function reverses the bit order of the given value.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+#define __RBIT                            __rbit
+
+
+/** \brief  LDR Exclusive (8 bit)
+
+    This function performs a exclusive LDR command for 8 bit value.
+
+    \param [in]    ptr  Pointer to data
+    \return             value of type uint8_t at (*ptr)
+ */
+#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
+
+
+/** \brief  LDR Exclusive (16 bit)
+
+    This function performs a exclusive LDR command for 16 bit values.
+
+    \param [in]    ptr  Pointer to data
+    \return        value of type uint16_t at (*ptr)
+ */
+#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
+
+
+/** \brief  LDR Exclusive (32 bit)
+
+    This function performs a exclusive LDR command for 32 bit values.
+
+    \param [in]    ptr  Pointer to data
+    \return        value of type uint32_t at (*ptr)
+ */
+#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
+
+
+/** \brief  STR Exclusive (8 bit)
+
+    This function performs a exclusive STR command for 8 bit values.
+
+    \param [in]  value  Value to store
+    \param [in]    ptr  Pointer to location
+    \return          0  Function succeeded
+    \return          1  Function failed
+ */
+#define __STREXB(value, ptr)              __strex(value, ptr)
+
+
+/** \brief  STR Exclusive (16 bit)
+
+    This function performs a exclusive STR command for 16 bit values.
+
+    \param [in]  value  Value to store
+    \param [in]    ptr  Pointer to location
+    \return          0  Function succeeded
+    \return          1  Function failed
+ */
+#define __STREXH(value, ptr)              __strex(value, ptr)
+
+
+/** \brief  STR Exclusive (32 bit)
+
+    This function performs a exclusive STR command for 32 bit values.
+
+    \param [in]  value  Value to store
+    \param [in]    ptr  Pointer to location
+    \return          0  Function succeeded
+    \return          1  Function failed
+ */
+#define __STREXW(value, ptr)              __strex(value, ptr)
+
+
+/** \brief  Remove the exclusive lock
+
+    This function removes the exclusive lock which is created by LDREX.
+
+ */
+#define __CLREX                           __clrex
+
+
+/** \brief  Signed Saturate
+
+    This function saturates a signed value.
+
+    \param [in]  value  Value to be saturated
+    \param [in]    sat  Bit position to saturate to (1..32)
+    \return             Saturated value
+ */
+#define __SSAT                            __ssat
+
+
+/** \brief  Unsigned Saturate
+
+    This function saturates an unsigned value.
+
+    \param [in]  value  Value to be saturated
+    \param [in]    sat  Bit position to saturate to (0..31)
+    \return             Saturated value
+ */
+#define __USAT                            __usat
+
+
+/** \brief  Count leading zeros
+
+    This function counts the number of leading zeros of a data value.
+
+    \param [in]  value  Value to count the leading zeros
+    \return             number of leading zeros in value
+ */
+#define __CLZ                             __clz
+
+#endif /* (__CORTEX_M >= 0x03) */
+
+
+
+#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
+/* IAR iccarm specific functions */
+
+#include <cmsis_iar.h>
+
+
+#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
+/* TI CCS specific functions */
+
+#include <cmsis_ccs.h>
+
+
+#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
+/* GNU gcc specific functions */
+
+/* Define macros for porting to both thumb1 and thumb2.
+ * For thumb1, use low register (r0-r7), specified by constrant "l"
+ * Otherwise, use general registers, specified by constrant "r" */
+#if defined (__thumb__) && !defined (__thumb2__)
+#define __CMSIS_GCC_OUT_REG(r) "=l" (r)
+#define __CMSIS_GCC_USE_REG(r) "l" (r)
+#else
+#define __CMSIS_GCC_OUT_REG(r) "=r" (r)
+#define __CMSIS_GCC_USE_REG(r) "r" (r)
+#endif
+
+/** \brief  No Operation
+
+    No Operation does nothing. This instruction can be used for code alignment purposes.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
+{
+  __ASM volatile ("nop");
+}
+
+
+/** \brief  Wait For Interrupt
+
+    Wait For Interrupt is a hint instruction that suspends execution
+    until one of a number of events occurs.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
+{
+  __ASM volatile ("wfi");
+}
+
+
+/** \brief  Wait For Event
+
+    Wait For Event is a hint instruction that permits the processor to enter
+    a low-power state until one of a number of events occurs.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
+{
+  __ASM volatile ("wfe");
+}
+
+
+/** \brief  Send Event
+
+    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __SEV(void)
+{
+  __ASM volatile ("sev");
+}
+
+
+/** \brief  Instruction Synchronization Barrier
+
+    Instruction Synchronization Barrier flushes the pipeline in the processor,
+    so that all instructions following the ISB are fetched from cache or
+    memory, after the instruction has been completed.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
+{
+  __ASM volatile ("isb");
+}
+
+
+/** \brief  Data Synchronization Barrier
+
+    This function acts as a special kind of Data Memory Barrier.
+    It completes when all explicit memory accesses before this instruction complete.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
+{
+  __ASM volatile ("dsb");
+}
+
+
+/** \brief  Data Memory Barrier
+
+    This function ensures the apparent order of the explicit memory operations before
+    and after the instruction, without ensuring their completion.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
+{
+  __ASM volatile ("dmb");
+}
+
+
+/** \brief  Reverse byte order (32 bit)
+
+    This function reverses the byte order in integer value.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV(uint32_t value)
+{
+#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
+  return __builtin_bswap32(value);
+#else
+  uint32_t result;
+
+  __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
+  return(result);
+#endif
+}
+
+
+/** \brief  Reverse byte order (16 bit)
+
+    This function reverses the byte order in two unsigned short values.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV16(uint32_t value)
+{
+  uint32_t result;
+
+  __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
+  return(result);
+}
+
+
+/** \brief  Reverse byte order in signed short value
+
+    This function reverses the byte order in a signed short value with sign extension to integer.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE int32_t __REVSH(int32_t value)
+{
+#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
+  return (short)__builtin_bswap16(value);
+#else
+  uint32_t result;
+
+  __ASM volatile ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
+  return(result);
+#endif
+}
+
+
+/** \brief  Rotate Right in unsigned value (32 bit)
+
+    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
+
+    \param [in]    value  Value to rotate
+    \param [in]    value  Number of Bits to rotate
+    \return               Rotated value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
+{
+  return (op1 >> op2) | (op1 << (32 - op2)); 
+}
+
+
+/** \brief  Breakpoint
+
+    This function causes the processor to enter Debug state.
+    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
+
+    \param [in]    value  is ignored by the processor.
+                   If required, a debugger can use it to store additional information about the breakpoint.
+ */
+#define __BKPT(value)                       __ASM volatile ("bkpt "#value)
+
+
+#if       (__CORTEX_M >= 0x03)
+
+/** \brief  Reverse bit order of value
+
+    This function reverses the bit order of the given value.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
+{
+  uint32_t result;
+
+   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
+   return(result);
+}
+
+
+/** \brief  LDR Exclusive (8 bit)
+
+    This function performs a exclusive LDR command for 8 bit value.
+
+    \param [in]    ptr  Pointer to data
+    \return             value of type uint8_t at (*ptr)
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __LDREXB(volatile uint8_t *addr)
+{
+    uint32_t result;
+
+#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
+   __ASM volatile ("ldrexb %0, %1" : "=r" (result) : "Q" (*addr) );
+#else
+    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
+       accepted by assembler. So has to use following less efficient pattern.
+    */
+   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
+#endif
+   return(result);
+}
+
+
+/** \brief  LDR Exclusive (16 bit)
+
+    This function performs a exclusive LDR command for 16 bit values.
+
+    \param [in]    ptr  Pointer to data
+    \return        value of type uint16_t at (*ptr)
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint16_t __LDREXH(volatile uint16_t *addr)
+{
+    uint32_t result;
+
+#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
+   __ASM volatile ("ldrexh %0, %1" : "=r" (result) : "Q" (*addr) );
+#else
+    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
+       accepted by assembler. So has to use following less efficient pattern.
+    */
+   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
+#endif
+   return(result);
+}
+
+
+/** \brief  LDR Exclusive (32 bit)
+
+    This function performs a exclusive LDR command for 32 bit values.
+
+    \param [in]    ptr  Pointer to data
+    \return        value of type uint32_t at (*ptr)
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
+{
+    uint32_t result;
+
+   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
+   return(result);
+}
+
+
+/** \brief  STR Exclusive (8 bit)
+
+    This function performs a exclusive STR command for 8 bit values.
+
+    \param [in]  value  Value to store
+    \param [in]    ptr  Pointer to location
+    \return          0  Function succeeded
+    \return          1  Function failed
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
+{
+   uint32_t result;
+
+   __ASM volatile ("strexb %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
+   return(result);
+}
+
+
+/** \brief  STR Exclusive (16 bit)
+
+    This function performs a exclusive STR command for 16 bit values.
+
+    \param [in]  value  Value to store
+    \param [in]    ptr  Pointer to location
+    \return          0  Function succeeded
+    \return          1  Function failed
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
+{
+   uint32_t result;
+
+   __ASM volatile ("strexh %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
+   return(result);
+}
+
+
+/** \brief  STR Exclusive (32 bit)
+
+    This function performs a exclusive STR command for 32 bit values.
+
+    \param [in]  value  Value to store
+    \param [in]    ptr  Pointer to location
+    \return          0  Function succeeded
+    \return          1  Function failed
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
+{
+   uint32_t result;
+
+   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
+   return(result);
+}
+
+
+/** \brief  Remove the exclusive lock
+
+    This function removes the exclusive lock which is created by LDREX.
+
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __CLREX(void)
+{
+  __ASM volatile ("clrex" ::: "memory");
+}
+
+
+/** \brief  Signed Saturate
+
+    This function saturates a signed value.
+
+    \param [in]  value  Value to be saturated
+    \param [in]    sat  Bit position to saturate to (1..32)
+    \return             Saturated value
+ */
+#define __SSAT(ARG1,ARG2) \
+({                          \
+  uint32_t __RES, __ARG1 = (ARG1); \
+  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
+  __RES; \
+ })
+
+
+/** \brief  Unsigned Saturate
+
+    This function saturates an unsigned value.
+
+    \param [in]  value  Value to be saturated
+    \param [in]    sat  Bit position to saturate to (0..31)
+    \return             Saturated value
+ */
+#define __USAT(ARG1,ARG2) \
+({                          \
+  uint32_t __RES, __ARG1 = (ARG1); \
+  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
+  __RES; \
+ })
+
+
+/** \brief  Count leading zeros
+
+    This function counts the number of leading zeros of a data value.
+
+    \param [in]  value  Value to count the leading zeros
+    \return             number of leading zeros in value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
+{
+   uint32_t result;
+
+  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
+  return(result);
+}
+
+#endif /* (__CORTEX_M >= 0x03) */
+
+
+
+
+#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
+/* TASKING carm specific functions */
+
+/*
+ * The CMSIS functions have been implemented as intrinsics in the compiler.
+ * Please use "carm -?i" to get an up to date list of all intrinsics,
+ * Including the CMSIS ones.
+ */
+
+#endif
+
+/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
+
+#endif /* __CORE_CMINSTR_H */
diff --git a/bsp/frdm-ke02/device/lib/inc/crc.h b/bsp/frdm-ke02/device/lib/inc/crc.h
new file mode 100755
index 0000000..e78e6dd
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/crc.h
@@ -0,0 +1,137 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file     crc.h
+*
+* @author   Freescale
+*
+* @version  0.0.1
+*
+* @date     Jun 25, 2013
+*
+* @brief    Cyclic redundancy check (CRC) header file. 
+*
+******************************************************************************/
+#ifndef CRC_H_
+#define CRC_H_
+#ifdef __cplusplus
+extern "C" {
+#endif
+/******************************************************************************
+* Includes
+******************************************************************************/
+
+/******************************************************************************
+* Constants
+******************************************************************************/
+
+/******************************************************************************
+* Macros
+******************************************************************************/
+
+
+/******************************************************************************
+* CRC control bit definition
+*
+*//*! @addtogroup crc_controlbit
+* @{
+*******************************************************************************/
+
+/*!
+ * @brief CRC control register bit definition.
+ *
+ */
+
+#define CRC_WIDTH_16BIT                 0	/*!< select CRC16 protocol */   
+#define CRC_WIDTH_32BIT                 1	/*!< select CRC32 protocol */ 
+#define CRC_DATA_SEED                   1	/*!< Write CRC Data Register are seed */  
+#define CRC_DATA_DATA                   0	/*!< Write CRC Data Register are data */ 
+#define CRC_READ_COMPLETE               1	/*!< Invert or complement read CRC Data register */ 
+#define CRC_READ_NONE                   0	/*!< No XOR on reading */ 
+#define CRC_READ_TRANSPOSE_NONE         0	/*!< No transposition in read */ 
+#define CRC_READ_TRANSPOSE_BIT          1	/*!< only bits in bytes are transposed in read */
+#define CRC_READ_TRANSPOSE_ALL          2	/*!< both bits in bytes and bytes are transposed in read */
+#define CRC_READ_TRANSPOSE_BYTE         3	/*!< only bytes are transposed in read */
+#define CRC_WRITE_TRANSPOSE_NONE        0	/*!< No transposition write */
+#define CRC_WRITE_TRANSPOSE_BIT         1	/*!< only bits in bytes are transposed in write */ 
+#define CRC_WRITE_TRANSPOSE_ALL         2	/*!< both bits in bytes and bytes are transposed in write */
+#define CRC_WRITE_TRANSPOSE_BYTE        3	/*!< only bytes are transposed in write */
+
+/*! @} End of crc_controlbit                                                */
+
+     
+/******************************************************************************
+* Types
+******************************************************************************/
+/* CRC configuration structure 
+ */  
+/******************************************************************************
+* CRC Configuration Structure type.
+*
+*//*! @addtogroup crc_config_type
+* @{
+*******************************************************************************/ 
+/*!
+ * @brief CRC Configuration Structure.
+ *
+ */
+
+typedef struct
+{          
+    uint8_t bWidth                  : 1;    /*!< 1: 32-bit CRC protocol , 0: 16-bit CRC protocol */
+    uint8_t bDataType               : 1;    /*!< 1: write seed , 0: write data */
+    uint8_t bFinalXOR               : 1;    /*!< 1: Invert or complement read , 0: No XOR on reading */
+    uint8_t bRESERVED               : 1;    /*!< reserved bit */  
+    uint8_t bTransposeReadType      : 2;    /*!< type of transpose For read, see reference manual */
+    uint8_t bTransposeWriteType     : 2;    /*!< type of transpose For write, see reference manual */      
+    uint32_t u32PolyData               ;    /*!< 32bit or 16-biy poly data */           
+} CRC_ConfigType, *CRC_ConfigPtr  ; 
+/*! @} End of crc_config_type                                                */
+
+           
+/******************************************************************************
+* Global variables
+******************************************************************************/
+
+/******************************************************************************
+* CRC API list
+*
+*//*! @addtogroup crc_api_list
+* @{
+*******************************************************************************/
+
+/******************************************************************************
+* Global functions
+******************************************************************************/
+void        CRC_Init(CRC_ConfigType *pConfig);
+uint32_t    CRC_Cal16(uint32_t u32Seed, uint8_t *msg, uint32_t u32SizeBytes);
+uint32_t    CRC_Cal32(uint32_t u32Seed, uint8_t *msg, uint32_t u32SizeBytes);
+void        CRC_DeInit(void);
+/*! @} End of crc_api_list                                                   */
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* CRC_H_ */
+
+
+
diff --git a/bsp/frdm-ke02/device/lib/inc/derivative.h b/bsp/frdm-ke02/device/lib/inc/derivative.h
new file mode 100755
index 0000000..fc8e7e6
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/derivative.h
@@ -0,0 +1,8 @@
+/*
+ * Note: This file is recreated by the project wizard whenever the MCU is
+ *       changed and should not be edited by hand
+ */
+
+/* Include the derivative-specific header file */
+#include <MKE02Z2.h>
+#include "arm_cm0.h"
diff --git a/bsp/frdm-ke02/device/lib/inc/flash.h b/bsp/frdm-ke02/device/lib/inc/flash.h
new file mode 100755
index 0000000..e076f7f
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/flash.h
@@ -0,0 +1,353 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file flash.h
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief header file for FLASH module utilities (FLASH). 
+*
+*******************************************************************************
+*
+* provide APIs for accessing FLASH module (FLASH)
+******************************************************************************/
+
+#ifndef FLASH_H_
+#define FLASH_H_
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/******************************************************************************
+* Includes
+******************************************************************************/
+#include "common.h"
+/******************************************************************************
+* Constants
+******************************************************************************/
+
+/******************************************************************************
+* Macros
+******************************************************************************/
+
+/******************************************************************************
+* Uncomment the following line to support programming flash while running code from flash 
+*
+*//*! @addtogroup flash_stalling_control_enable
+* @{
+*******************************************************************************/
+
+#define FLASH_ENABLE_STALLING_FLASH_CONTROLLER	/*!< enable flash stalling control */
+
+/*! @} End of flash_stalling_control_enable                                  */
+
+/******************************************************************************
+* Memory Controller Command Completion Status Flag
+*
+*//*! @addtogroup flash_MGSTAT_list
+* @{
+*******************************************************************************/
+
+#define FTMRH_FSTAT_MGSTAT0_MASK  (1)						/*!< FTMRH FSTAT MGSTAT0 MASK */
+#define FTMRH_FSTAT_MGSTAT1_MASK  (1<<1)				/*!< FTMRH FSTAT MGSTAT1 MASK */
+/*! @} End of flash_MGSTAT_list                                                */
+
+#define FLASH_SECTOR_SIZE			512							  /*!< FTMRH sector size*/
+#define FLASH_START_ADDRESS			0								/*!< FTMRH start address */
+#define EEPROM_START_ADDRESS		0x10000000			/*!< EEPRON start address*/
+
+/******************************************************************************
+* flash and eeprom driver error status
+*
+*//*! @addtogroup flash_error_list
+* @{
+*******************************************************************************/
+#define FLASH_ERR_BASE				0x3000										/*!< FTMRH error base */
+#define FLASH_ERR_SUCCESS			0													/*!< FTMRH sucess */
+#define FLASH_ERR_INVALID_PARAM		(FLASH_ERR_BASE+1)		/*!<  invalid parameter error code*/
+#define EEPROM_ERR_SINGLE_BIT_FAULT	(FLASH_ERR_BASE+2)	/*!<  EEPROM single bit fault error code*/
+#define EEPROM_ERR_DOUBLE_BIT_FAULT	(FLASH_ERR_BASE+4)	/*!<  EEPROM double bits fault error code*/
+#define FLASH_ERR_ACCESS			(FLASH_ERR_BASE+8)				/*!< flash access error code*/
+#define FLASH_ERR_PROTECTION		(FLASH_ERR_BASE+0x10)		/*!<  flash protection error code*/
+#define FLASH_ERR_MGSTAT0			(FLASH_ERR_BASE+0x11)			/*!<  flash verification error code*/
+#define FLASH_ERR_MGSTAT1			(FLASH_ERR_BASE+0x12)			/*!<  flash non-correctable error code*/
+#define FLASH_ERR_INIT_CCIF			(FLASH_ERR_BASE+0x14)		/*!<  flash driver init error with CCIF = 1*/
+#define FLASH_ERR_INIT_FDIV			(FLASH_ERR_BASE+0x18)		/*!<  flash driver init error with wrong FDIV*/ 
+/*! @} End of flash_error_list                                                */
+
+/******************************************************************************
+* Flash and EEPROM commands
+*
+*//*! @addtogroup flash_command_list
+* @{
+*******************************************************************************/
+#define FTMRH_CMD_ERASE_VERIFY_ALL				0x01			/*!< FTMRH erase verify all command */
+#define FTMRH_CMD_ERASE_VERIFY_BLOCK			0x02			/*!< FTMRH erase verify block command */
+#define FTMRH_CMD_ERASE_ALL								0x08			/*!< FTMRH erase all command */
+#define FTMRH_CMD_ERASE_BLOCK							0x09			/*!< FTMRH erase blockcommand */
+#define FTMRH_CMD_UNSECURE								0x0B			/*!< FTMRH unsecure command */
+#define FTMRH_CMD_SET_USER_MARGIN					0x0D			/*!< FTMRH set usermargin command */
+
+#define FLASH_CMD_ERASE_VERIFY_SECTION		0x03			/*!< FTMRH erase verify section command */
+#define FLASH_CMD_READONCE								0x04			/*!< FTMRH read once command */
+#define FLASH_CMD_PROGRAM									0x06			/*!< FTMRH program command */
+#define FLASH_CMD_PROGRAMONCE							0x07			/*!< FTMRH program once command */
+#define FLASH_CMD_ERASE_SECTOR						0x0A			/*!< FTMRH erase sector command */
+#define FLASH_CMD_BACKDOOR_ACCESS					0x0C			/*!< FTMRH backdoor key access command */
+#define FLASH_CMD_SET_USER_MARGIN_LEVEL		0x0D			/*!< FTMRH set user margin level command */
+
+#define EEPROM_CMD_ERASE_VERIFY_SECTION		0x10			/*!< EEPROM erase berify section command */
+#define EEPROM_CMD_PROGRAM								0x11			/*!< EEPROM program command */
+#define EEPROM_CMD_ERASE_SECTOR 					0x12			/*!< EEPROM erase sector command */
+/*! @} End of flash_command_list                                              */
+
+
+/******************************************************************************
+*
+*//*! @addtogroup nvm_api_list
+* @{
+*******************************************************************************/
+/******************************************************************************
+* inline function
+******************************************************************************/
+
+/*****************************************************************************//*!
+  *
+  * @brief Command Complete Interrupt Enable.
+  *        
+  * @param none.
+  *
+  * @return none.
+  *
+  * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+__STATIC_INLINE void FLASH_IntEnable( void )
+{
+	FTMRH->FCNFG |= FTMRH_FCNFG_CCIE_MASK;	
+}
+/*****************************************************************************//*!
+  *
+  * @brief Command Complete Interrupt Disable.
+  *        
+  * @param none.
+  *
+  * @return none.
+  *
+  * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+__STATIC_INLINE void FLASH_IntDisable( void )
+{
+	FTMRH->FCNFG &= ~FTMRH_FCNFG_CCIE_MASK;	
+}
+
+#if defined(CPU_KE02) 
+/*****************************************************************************//*!
+  *
+  * @brief Double Bit Fault Detect Interrupt Enable.
+  *        
+  * @param none.
+  *
+  * @return none.
+  *
+  * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+__STATIC_INLINE void FLASH_DoubleBitFaultEnable( void )
+{
+	FTMRH->FERCNFG |= FTMRH_FERCNFG_DFDIE_MASK;	
+}
+/*****************************************************************************//*!
+  *
+  * @brief Double Bit Fault Detect Interrupt Disable.
+  *        
+  * @param none.
+  *
+  * @return none.
+  *
+  * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+__STATIC_INLINE void FLASH_DoubleBitFaultDisable( void )
+{
+	FTMRH->FERCNFG &= ~FTMRH_FERCNFG_DFDIE_MASK;	
+}
+/*****************************************************************************//*!
+  *
+  * @brief Single Bit Fault Detect Interrupt Enable.
+  *        
+  * @param none.
+  *
+  * @return none.
+  *
+  * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+__STATIC_INLINE void FLASH_SingleBitFaultEnable( void )
+{
+	FTMRH->FERCNFG |= FTMRH_FERCNFG_SFDIE_MASK;	
+}
+/*****************************************************************************//*!
+  *
+  * @brief Single Bit Fault Detect Interrupt Disable.
+  *        
+  * @param none.
+  *
+  * @return none.
+  *
+  * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+__STATIC_INLINE void FLASH_SingleBitFaultDisable( void )
+{
+	FTMRH->FERCNFG &= ~FTMRH_FERCNFG_SFDIE_MASK;	
+}
+/*****************************************************************************//*!
+  *
+  * @brief Clear Double Bit Fault Detect Interrupt Flag.
+  *        
+  * @param none.
+  *
+  * @return none.
+  *
+  * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+__STATIC_INLINE void FLASH_ClearDoubleBitFaultFlag( void )
+{
+	FTMRH->FERSTAT |= FTMRH_FERSTAT_DFDIF_MASK;	
+}
+/*****************************************************************************//*!
+  *
+  * @brief Clear Single Bit Fault Detect Interrupt Flag.
+  *        
+  * @param none.
+  *
+  * @return none.
+  *
+  * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+__STATIC_INLINE void FLASH_ClearSingleBitFaultFlag( void )
+{
+	FTMRH->FERSTAT |= FTMRH_FERSTAT_SFDIF_MASK;	
+}
+/*****************************************************************************//*!
+  *
+  * @brief Force Double Bit Fault Detect,The FDFD bit allows the user to simulate a double bit 
+  *             fault during flash array read operations and check the associated interrupt routine.
+  *        
+  * @param u8EnableStatus  Force double bit fault detect or not.
+  *
+  * @return none.
+  *
+  * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+__STATIC_INLINE void FLASH_ForceDoubleBitFault( uint8_t u8EnableStatus )
+{
+	if( u8EnableStatus )
+	{
+		FTMRH->FCNFG |= FTMRH_FCNFG_FDFD_MASK;	
+	}
+	else
+	{
+		FTMRH->FCNFG &= ~FTMRH_FCNFG_FDFD_MASK;
+	}
+}
+/*****************************************************************************//*!
+  *
+  * @brief Force Single Bit Fault Detect,The FDFD bit allows the user to simulate a single bit 
+  *             fault during flash array read operations and check the associated interrupt routine.
+  *        
+  * @param u8EnableStatus  Force single bit fault detect or not.
+  *
+  * @return none.
+  *
+  * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+__STATIC_INLINE void FLASH_ForceSingleBitFault( uint8_t u8EnableStatus )
+{
+	if( u8EnableStatus )
+	{
+		FTMRH->FCNFG |= FTMRH_FCNFG_FSFD_MASK;	
+	}
+	else
+	{
+		FTMRH->FCNFG &= ~FTMRH_FCNFG_FSFD_MASK;
+	}
+}
+#else
+
+
+
+#endif
+
+/******************************************************************************
+* Types
+******************************************************************************/
+
+
+/******************************************************************************
+* Global variables
+******************************************************************************/
+
+/******************************************************************************
+* Global functions
+******************************************************************************/
+uint16_t FLASH_Program1LongWord(uint32_t wNVMTargetAddress, uint32_t dwData);
+uint16_t FLASH_Program2LongWords(uint32_t wNVMTargetAddress, uint32_t dwData0, uint32_t dwData1);
+uint16_t FLASH_ProgramOnce(uint8_t bPhraseIndex, uint8_t *pData8Bytes);
+uint16_t FLASH_ReadOnce(uint8_t bPhraseIndex, uint8_t *pData8Bytes);
+uint16_t FLASH_EraseSector(uint32_t wNVMTargetAddress);
+uint16_t FLASH_EraseVerifySection(uint32_t wNVMTargetAddress, uint16_t uiLongWordCount);
+uint16_t FLASH_VerifyBackdoorKey(uint8_t *pbKey);
+uint16_t FLASH_SetUserMarginLevel(uint32_t wNVMTargetAddress, uint16_t wMarginLevel, uint8_t bIsEEPROM);
+uint16_t FLASH_Program(uint32_t wNVMTargetAddress, uint8_t *pData, uint16_t sizeBytes);
+
+uint16_t FLASH_EraseBlock(uint32_t wNVMTargetAddress, uint8_t bIsEEPROM);
+uint16_t FLASH_EraseVerifyBlock(uint32_t wNVMTargetAddress,uint8_t bIsEEPROM);
+uint16_t FLASH_EraseAll(void);
+uint16_t FLASH_EraseVerifyAll(void);
+uint16_t FLASH_Unsecure(void);
+uint16_t FLASH_EraseBlock_NoWait(uint32_t wNVMTargetAddress, uint8_t bIsEEPROM);
+uint16_t FLASH_CheckErrStatus(void);
+
+#if (defined(IAR))
+__ramfunc void FLASH_LaunchCMD(uint8_t bWaitComplete);
+#else
+void FLASH_LaunchCMD(uint8_t bWaitComplete);
+#endif
+
+uint16_t EEPROM_Program1Byte(uint32_t wNVMTargetAddress, uint8_t bData);
+uint16_t EEPROM_ProgramUpto4Bytes(uint32_t wNVMTargetAddress, uint8_t *pbData, uint8_t bByteCount);
+uint16_t EEPROM_Program(uint32_t wNVMTargetAddress, uint8_t *pData, uint16_t sizeBytes);
+uint16_t EEPROM_EraseVerifySection(uint32_t wNVMTargetAddress, uint16_t uiByteCount);
+uint16_t EEPROM_Program1Byte_NoWait(uint32_t wNVMTargetAddress, uint8_t bData);
+uint16_t EEPROM_ProgramUpto4Bytes_NoWait(uint32_t wNVMTargetAddress, uint8_t *pbData, uint8_t bByteCount);
+uint16_t EEPROM_EraseSector_NoWait(uint32_t wNVMTargetAddress);
+uint16_t EEPROM_EraseSector(uint32_t wNVMTargetAddress);
+
+uint16_t FLASH_Init(uint32_t BusClock);
+
+/*! @} End of nvm_api_list                                              */
+/********************************************************************/
+#ifdef __cplusplus
+}
+#endif
+#endif /* FLASH_H_ */
diff --git a/bsp/frdm-ke02/device/lib/inc/ftm.h b/bsp/frdm-ke02/device/lib/inc/ftm.h
new file mode 100755
index 0000000..9c2b877
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/ftm.h
@@ -0,0 +1,1195 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file ftm.h
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief header file for FTM. 
+*
+*******************************************************************************
+*
+* provide APIs for accessing FTM
+******************************************************************************/
+#ifndef FTM_H_
+#define FTM_H_
+#ifdef __cplusplus
+extern "C" {
+#endif
+/******************************************************************************
+* Includes
+******************************************************************************/
+
+/******************************************************************************
+* Constants
+******************************************************************************/
+
+/******************************************************************************
+* Macros
+******************************************************************************/
+
+/******************************************************************************
+* FTM return status definition
+*
+*//*! @addtogroup ftm_returnstatus
+* @{
+*******************************************************************************/
+#define FTM_ERR_SUCCESS         0               /*!< return ok */
+#define FTM_ERR_INVALID_PARAM   1               /*!< return invalid parameter */
+/*! @} End of ftm_returnstatus                                                */
+
+
+/******************************************************************************
+* FTM channel number definition
+*
+*//*! @addtogroup ftm_channelnumber
+* @{
+*******************************************************************************/
+#define FTM_CHANNEL_CHANNEL0    0               /*!< channel 0 */
+#define FTM_CHANNEL_CHANNEL1    1               /*!< channel 1 */
+#define FTM_CHANNEL_CHANNEL2    2               /*!< channel 2 */
+#define FTM_CHANNEL_CHANNEL3    3               /*!< channel 3 */
+#define FTM_CHANNEL_CHANNEL4    4               /*!< channel 4 */
+#define FTM_CHANNEL_CHANNEL5    5               /*!< channel 5 */
+
+#define FTM_CHANNELPAIR0        0               /*!< channel pair 0:ch0 & ch1 */
+#define FTM_CHANNELPAIR1        2               /*!< channel pair 1:ch2 & ch3 */
+#define FTM_CHANNELPAIR2        4               /*!< channel pair 2:ch4 & ch5 */
+
+/*! @} End of ftm_channelnumber                                               */
+
+/******************************************************************************
+* FTM pwm mode definition
+*
+*//*! @addtogroup ftm_pwmmode
+* @{
+*******************************************************************************/
+#define FTM_PWMMODE_EDGEALLIGNED      1          /*!< EPWM */
+#define FTM_PWMMODE_CENTERALLIGNED    2          /*!< CPWM */
+#define FTM_PWMMODE_COMBINE           3          /*!< Combine PWM */
+/*! @} End of ftm_pwmmode                                                     */
+
+/******************************************************************************
+* FTM init value definition
+*
+*//*! @addtogroup ftm_initvalue
+* @{
+*******************************************************************************/
+#define FTM_MOD_INIT	(20000-1)                /*!< MOD inite value */
+#define FTM_C0V_INIT	1000                     /*!< C0V inite value */
+#define FTM_C1V_INIT	1000                     /*!< C1V inite value */
+#define FTM_C2V_INIT	1000                     /*!< C2V inite value */    
+#define FTM_C3V_INIT	1000                     /*!< C3V inite value */
+#define FTM_C4V_INIT	1000                     /*!< C4V inite value */
+#define FTM_C5V_INIT	1000                     /*!< C5V inite value */
+/*! @} End of ftm_initvalue                                                   */
+
+/******************************************************************************
+* FTM combine feature definition
+*
+*//*! @addtogroup ftm_combinefeature
+* @{
+*******************************************************************************/
+#define FTM_COMBINE_FAULTEN_MASK  0x40       /*!< fault enable */
+#define FTM_COMBINE_SYNCEN_MASK   0x20       /*!< sync enable */
+#define FTM_COMBINE_DTEN_MASK     0x10       /*!< dead time insertion enable */
+#define FTM_COMBINE_DECAP_MASK    0x08       /*!< dual capture status */
+#define FTM_COMBINE_DECAPEN_MASK  0x04       /*!< dual capture enable */
+#define FTM_COMBINE_COMP_MASK     0x02       /*!< complementary enable */
+#define FTM_COMBINE_COMBINE_MASK  0x01       /*!< combine enable */
+/*! @} End of ftm_combinefeature                                              */
+
+/******************************************************************************
+* FTM clock sources definition
+*
+*//*! @addtogroup ftm_clocksource
+* @{
+*******************************************************************************/
+#define FTM_CLOCK_NOCLOCK             0                 /*!< No Clock */
+#define FTM_CLOCK_SYSTEMCLOCK         1                 /*!< System clock/2 */
+#define FTM_CLOCK_FIXEDFREQCLOCK      2                 /*!< Fixed Freq Clock */
+#define FTM_CLOCK_EXTERNALCLOCK       3                 /*!< External Clock */
+
+/* clock prescale */
+#define FTM_CLOCK_PS_DIV1             0                 /*!< DIV 1 */
+#define FTM_CLOCK_PS_DIV2             1                 /*!< DIV 2 */
+#define FTM_CLOCK_PS_DIV4             2                 /*!< DIV 4 */
+#define FTM_CLOCK_PS_DIV8             3                 /*!< DIV 8 */
+#define FTM_CLOCK_PS_DIV16            4                 /*!< DIV 16 */
+#define FTM_CLOCK_PS_DIV32            5                 /*!< DIV 32 */
+#define FTM_CLOCK_PS_DIV64            6                 /*!< DIV 64 */
+#define FTM_CLOCK_PS_DIV128           7                 /*!< DIV 128 */
+/*! @} End of ftm_clocksource                                                 */
+
+/******************************************************************************
+* FTM dead time clock prescale definition
+*
+*//*! @addtogroup ftm_deadtimeprescale
+* @{
+*******************************************************************************/
+/*  */
+#define FTM_DEADTIME_DTPS_DIV1        0                 /*!< DIV 1 */
+#define FTM_DEADTIME_DTPS_DIV4        2                 /*!< DIV 4 */
+#define FTM_DEADTIME_DTPS_DIV16       3                 /*!< DIV 16 */
+/*! @} End of ftm_deadtimeprescale                                            */
+
+/******************************************************************************
+* FTM output mode definition
+*
+*//*! @addtogroup ftm_outputmode
+* @{
+*******************************************************************************/
+/* output mode */
+#define FTM_OUTPUT_TOGGLE   1                    /*!< toggle output on match */
+#define FTM_OUTPUT_CLEAR    2                    /*!< clear output on match */
+#define FTM_OUTPUT_SET      3                    /*!< set output on match */
+/*! @} End of ftm_outputmode                                                  */
+
+/******************************************************************************
+* FTM input capture edge definition
+*
+*//*! @addtogroup ftm_inputcaptureedge
+* @{
+*******************************************************************************/
+/* mode edge select*/
+#define FTM_INPUTCAPTURE_RISINGEDGE           1     /*!< rising edge */
+#define FTM_INPUTCAPTURE_FALLINGEDGE          2     /*!< falling edge */
+#define FTM_INPUTCAPTURE_BOTHEDGE             3     /*!< both edge */
+
+#define FTM_INPUTCAPTURE_DUALEDGE_NOEDGE      0     /*!< none */
+#define FTM_INPUTCAPTURE_DUALEDGE_RISINGEDGE  1     /*!< rising edge*/
+#define FTM_INPUTCAPTURE_DUALEDGE_FALLInGEDGE 2     /*!< falling edge*/
+#define FTM_INPUTCAPTURE_DUALEDGE_BOTHEDGE    3     /*!< both edge */
+/*! @} End of ftm_inputcaptureedge                                            */
+
+/******************************************************************************
+* FTM dual edge capture mode definition
+*
+*//*! @addtogroup ftm_dualcapturemode
+* @{
+*******************************************************************************/
+#define FTM_INPUTCAPTURE_DUALEDGE_ONESHOT     4  /*!< dual edge one shot mode*/ 
+#define FTM_INPUTCAPTURE_DUALEDGE_CONTINUOUS  5  /*!< dual edge continuouse mode*/
+/*! @} End of ftm_dualcapturemode                                            */
+
+/******************************************************************************
+* FTM PWM edge definition
+*
+*//*! @addtogroup ftm_pwmedge
+* @{
+*******************************************************************************/
+#define FTM_PWM_HIGHTRUEPULSE        1            /*!< high true pulses */
+#define FTM_PWM_LOWTRUEPULSE         2            /*!< low true pulses */
+/*! @} End of ftm_pwmedge                                                     */
+
+/******************************************************************************
+* FTM sync trigger source definition
+*
+*//*! @addtogroup ftm_syncsource
+* @{
+*******************************************************************************/
+#define FTM_SYNC_TRIGGER_SOFTWARE    1        /*!< Software synchronization */
+#define FTM_SYNC_TRIGGER_TRIGGER2    2        /*!< Tigger2 synchronization, SIM_SOPT[FTMSYNC] */
+#define FTM_SYNC_TRIGGER_TRIGGER1    3        /*!< Tigger1 synchronization, FTM0CH0 */
+#define FTM_SYNC_TRIGGER_TRIGGER0    4        /*!< Tigger0 synchronization, ACMP0 */
+/*! @} End of ftm_syncsource                                                  */
+
+/******************************************************************************
+* FTM SW output control definition
+*
+*//*! @addtogroup ftm_swoutputcontrol
+* @{
+*******************************************************************************/ 
+#define FTM_SWOCTRL_HIGH    1                /*!< software output high */
+#define FTM_SWOCTRL_LOW     0                /*!< software output low */
+/*! @} End of ftm_swoutputcontrol                                             */
+
+/******************************************************************************
+* FTM  polarity definition
+*
+*//*! @addtogroup ftm_polarity
+* @{
+*******************************************************************************/
+#define FTM_POLARITY_HIGHACTIVE     0        /*!< active high */
+#define FTM_POLARITY_LOWACTIVE      1        /*!< active low */
+/*! @} End of ftm_polarity                                                    */
+
+
+/******************************************************************************
+* Types
+******************************************************************************/
+/*! @brief FTM_CALLBACK function declaration                                  */
+typedef void (*FTM_CallbackPtr)(void);
+/*! @} End of ftm_callback                                                    */
+
+/******************************************************************************
+* FTM configure struct.
+*
+*//*! @addtogroup ftm_configsturct
+* @{
+*******************************************************************************/
+/*!
+* @brief FTM configure struct.
+*
+*/
+
+typedef struct
+{
+  uint8_t   clk_source;       /*!< clock source */
+  uint8_t   prescaler;        /*!< clock prescaler */
+  uint8_t   sc;               /*!< status and control */
+  uint16_t  modulo;           /*!< counter mod */
+  uint16_t  cnt;              /*!< counter value */
+  uint16_t  cntin;            /*!< counter inite */
+  uint8_t   mode;             /*!< features mode selction */
+  uint8_t   sync;             /*!< synchronization */
+  uint8_t   outinit;          /*!< initial state for channels output  */
+  uint8_t   outmask;          /*!< output mask */
+  uint32_t  combine;          /*!< function for linked channels */
+  uint16_t  deadtime;         /*!< dead time insertion control */
+  uint8_t   exttrig;          /*!< external trigger */
+  uint8_t   pol;              /*!< channels polarity */
+  uint16_t  filter;           /*!< input filter control */
+  uint8_t   fms;              /*!< fault mode status */
+  uint16_t  fltctrl;          /*!< fault control */
+  uint8_t   fltpol;           /*!< fault input polarity */
+  uint16_t  conf;             /*!< FTM configuration */
+  uint32_t  synconf;          /*!< synchronization configuration*/
+  uint8_t   invctrl;          /*!< inverting control */
+  uint16_t  swoctrl;          /*!< software output control */
+  uint16_t  pwmload;          /*!< pwm load control */
+} FTM_ConfigType, *FTM_ConfigPtr;
+/*! @} End of ftm_configsturct                                                */
+
+/******************************************************************************
+* FTM channel configure struct.
+*
+*//*! @addtogroup ftm_chconfigsturct
+* @{
+*******************************************************************************/
+/*!
+* @brief FTM channel configure struct.
+*
+*/
+typedef struct
+{
+  uint8_t         u8CnSC;                  /*!< FTM channel status and control */
+  uint16_t        u16CnV;                  /*!< FTM channel value control */
+  union
+  {
+    uint32_t      u32dw;
+    struct 
+    {
+      uint32_t    bMode         : 3;        /*!< flextimer mode: GPIO, INPUT_CAPTURE, OUTPUT_COMPARE, EDGE_ALIGNED_PWM, CENTER_ALIGNED_PWM,
+                                             * COMBINE_PWM, DUAL_EDGE_CAPTURE 
+                                             */
+      uint32_t    bEdge         : 2;        /*!< edge select */
+      uint32_t    bOutCmp       : 2;        /*!< toggle, clear, set */
+      uint32_t    bPWMPol       : 1;        /*!< high-true pulse, low-true pulses */
+      uint32_t    bDualCapMode  : 1;        /*!< dual edge capture mode: one-shot, continuous mode */
+      uint32_t    bCHIE         : 1;        /*!< enable channel interrupt */
+    }bits;
+  }ctrl;                                    /*!< FTM channel feature control */
+} FTM_ChParamsType;
+
+/*! @} End of ftm_chconfigsturct                                              */
+
+/******************************************************************************
+* Global variables
+******************************************************************************/
+
+/*!
+ * inline functions
+ */
+/******************************************************************************
+* FTM inline functions
+*
+*//*! @addtogroup ftm_api_list
+* @{
+*******************************************************************************/
+/*****************************************************************************//*!
+*
+* @brief  enable the over flow interrupt.
+*        
+* @param[in]    pFTM          pointer to one of three FTM base register address.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see FTM_DisableOverflowInt.
+*
+*****************************************************************************/
+__STATIC_INLINE void FTM_EnableOverflowInt(FTM_Type *pFTM)
+{
+    if(pFTM->SC & FTM_SC_TOF_MASK)
+    {
+        pFTM->SC &= ~FTM_SC_TOF_MASK;
+    }
+    pFTM->SC |= FTM_SC_TOIE_MASK;
+}
+
+/*****************************************************************************//*!
+*
+* @brief  disable the over flow interrupt.
+*        
+* @param[in]    pFTM          pointer to one of three FTM base register address.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none
+*
+* @see FTM_EnableOverflowInt.
+*
+*****************************************************************************/
+__STATIC_INLINE void FTM_DisableOverflowInt(FTM_Type *pFTM)
+{
+    pFTM->SC &= ~FTM_SC_TOIE_MASK;
+}
+
+/*****************************************************************************//*!
+*
+* @brief  enable the channel interrupt.
+*        
+* @param[in]    pFTM           pointer to one of three FTM base register address.
+* @param[in]    u8FTM_Channel  channel number.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see FTM_DisableChannelInt.
+*
+*****************************************************************************/
+__STATIC_INLINE void FTM_EnableChannelInt(FTM_Type *pFTM, uint8_t u8FTM_Channel)
+{
+    pFTM->CONTROLS[u8FTM_Channel].CnSC |= FTM_CnSC_CHIE_MASK;
+}
+
+/*****************************************************************************//*!
+*
+* @brief  disable the channel interrupt.
+*        
+* @param[in]    pFTM           pointer to one of three FTM base register address.
+* @param[in]    u8FTM_Channel  channel number.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see FTM_EnableChannelInt.
+*
+*****************************************************************************/
+__STATIC_INLINE void FTM_DisableChannelInt(FTM_Type *pFTM, uint8_t u8FTM_Channel)
+{
+    pFTM->CONTROLS[u8FTM_Channel].CnSC &= ~FTM_CnSC_CHIE_MASK;
+}
+
+/*****************************************************************************//*!
+*
+* @brief  get the over flow flag.
+*        
+* @param[in]    pFTM           pointer to one of three FTM base register address.
+*    
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see FTM_ClrOverFlowFlag.
+*
+*****************************************************************************/
+__STATIC_INLINE uint8_t FTM_GetOverFlowFlag(FTM_Type *pFTM)
+{
+    return (pFTM->SC & FTM_SC_TOF_MASK);
+}
+
+/*****************************************************************************//*!
+*
+* @brief  clear the over flow flag.
+*        
+* @param[in]    pFTM           pointer to one of three FTM base register address.
+*    
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see FTM_GetOverFlowFlag.
+*
+*****************************************************************************/
+__STATIC_INLINE void FTM_ClrOverFlowFlag(FTM_Type *pFTM)
+{
+    if(pFTM->SC & FTM_SC_TOF_MASK)
+    {
+         pFTM->SC &= ~FTM_SC_TOF_MASK;
+    }
+}
+
+/*****************************************************************************//*!
+*
+* @brief  get the channel flag.
+*        
+* @param[in]    pFTM           pointer to one of three FTM base register address.
+* @param[in]    u8FTM_Channel  channel number.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see FTM_ClrChannelFlag.
+*
+*****************************************************************************/
+__STATIC_INLINE uint8_t FTM_GetChannelFlag(FTM_Type *pFTM, uint8_t u8FTM_Channel)
+{
+    return (pFTM->CONTROLS[u8FTM_Channel].CnSC & FTM_CnSC_CHF_MASK);
+}
+
+/*****************************************************************************//*!
+*
+* @brief  clear the channel flag.
+*        
+* @param[in]    pFTM           pointer to one of three FTM base register address.
+*    
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see FTM_GetChannelFlag.
+*
+*****************************************************************************/
+__STATIC_INLINE void FTM_ClrChannelFlag(FTM_Type *pFTM, uint8_t u8FTM_Channel)
+{
+    pFTM->CONTROLS[u8FTM_Channel].CnSC &= ~FTM_CnSC_CHF_MASK;
+}
+
+/*********************************************************************************//*!
+*
+* @brief enable the write protection function.Write protected bits cannot be written. 
+*        
+* @param[in]    pFTM              pointer to one of three FTM base register address.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see FTM_WriteProtectionDisable.
+*
+*********************************************************************************/
+__STATIC_INLINE void FTM_WriteProtectionEnable(FTM_Type *pFTM)
+{
+    pFTM->FMS |= FTM_FMS_WPEN_MASK;
+}
+
+/*********************************************************************************//*!
+*
+* @brief disable the write protection function.Write protected bits can be written. 
+*        
+* @param[in]    pFTM              pointer to one of three FTM base register address.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see FTM_WriteProtectionDisable.
+*
+*********************************************************************************/
+__STATIC_INLINE void FTM_WriteProtectionDisable(FTM_Type *pFTM)
+{
+    if (pFTM->FMS & FTM_FMS_WPEN_MASK)
+    {
+        pFTM->MODE |= FTM_MODE_WPDIS_MASK;
+    }
+}
+
+/*****************************************************************************//*!
+*
+* @brief  set FTMEN bit to enable FTM-specific register.
+*        
+* @param[in]    pFTM           pointer to one of three FTM base register address.
+*    
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see FTM_SetFTMBasic.
+*
+*****************************************************************************/
+__STATIC_INLINE void FTM_SetFTMEnhanced(FTM_Type *pFTM)
+{
+    if(pFTM->MODE & FTM_MODE_WPDIS_MASK)   /* if not write protected */
+    {
+        pFTM->MODE |= FTM_MODE_FTMEN_MASK;
+    }
+    else
+    {
+        FTM_WriteProtectionDisable(pFTM);
+        pFTM->MODE |= FTM_MODE_FTMEN_MASK;
+        FTM_WriteProtectionEnable(pFTM);
+    }    
+}
+
+/*****************************************************************************//*!
+*
+* @brief  clear FTMEN bit to disable FTM-specific registers, only TPM-compatible
+*         registers can be used.
+*        
+* @param[in]    pFTM           pointer to one of three FTM base register address.
+*    
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see FTM_SetFTMEnhanced.
+*
+*****************************************************************************/
+__STATIC_INLINE void FTM_SetFTMBasic(FTM_Type *pFTM)
+{
+    if(pFTM->MODE & FTM_MODE_WPDIS_MASK)    /* if not write protected */
+    {
+        pFTM->MODE &= ~FTM_MODE_FTMEN_MASK;
+    }
+    else
+    {
+        FTM_WriteProtectionDisable(pFTM);
+        pFTM->MODE &= ~FTM_MODE_FTMEN_MASK;
+        FTM_WriteProtectionEnable(pFTM);
+    }  
+}
+
+/*****************************************************************************//*!
+*
+* @brief  set the ftm mod value.
+*              
+* @param[in]    pFTM           pointer to one of three FTM base register address.
+* @param[in]    u16ModValue    the mod value required to set.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see FTM_SetChannelValue.
+*
+*****************************************************************************/
+__STATIC_INLINE void FTM_SetModValue(FTM_Type *pFTM, uint16_t u16ModValue)
+{
+    pFTM->CNT = 0;
+    pFTM->MOD = u16ModValue;
+    if(FTM2 == pFTM)
+    {
+        if(pFTM->MODE & FTM_MODE_FTMEN_MASK)
+        {
+            pFTM->PWMLOAD |= FTM_PWMLOAD_LDOK_MASK;
+        }
+        else
+        {
+        }
+    }
+    else
+    {
+    }
+}
+
+/*****************************************************************************//*!
+*
+* @brief  set the ftm channel value.
+*                
+* @param[in]    pFTM             pointer to one of three FTM base register address.
+* @param[in]    u16ChannelValue  the CnV value required to set.
+* @param[in]    u8FTM_Channel    ftm channel number.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see FTM_SetModValue.
+*
+*****************************************************************************/
+__STATIC_INLINE void FTM_SetChannelValue(FTM_Type *pFTM, uint8_t u8FTM_Channel, uint16_t u16ChannelValue)
+{
+    pFTM->CONTROLS[u8FTM_Channel].CnV = u16ChannelValue;
+    if(FTM2 == pFTM)
+    {
+        if(pFTM->MODE & FTM_MODE_FTMEN_MASK)
+        {
+            if(u8FTM_Channel < 2)
+            {
+                pFTM->COMBINE |= FTM_COMBINE_SYNCEN0_MASK;  /* enable the sync function */
+            }
+            else if (u8FTM_Channel < 4)
+            {
+                pFTM->COMBINE |= FTM_COMBINE_SYNCEN1_MASK;
+            }
+            else
+            {
+                pFTM->COMBINE |= FTM_COMBINE_SYNCEN2_MASK;
+            }
+            pFTM->PWMLOAD |= FTM_PWMLOAD_LDOK_MASK;  
+        }
+        else
+        {
+        }
+    }
+    else
+    {
+    }
+}
+
+/*****************************************************************************//*!
+*
+* @brief  set the ftm channel value.
+*               
+* @param[in]    pFTM              pointer to one of three FTM base register address.
+* @param[in]    u16CounterValue   the CNTIN value required to set.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none
+*
+* @see FTM_SetModValue.
+*
+*****************************************************************************/
+__STATIC_INLINE void FTM_SetCounterInitValue(FTM_Type *pFTM, uint16_t u16CounterValue)
+{
+    pFTM->CNTIN = u16CounterValue;
+    if(pFTM->MODE & FTM_MODE_FTMEN_MASK)
+    {
+        pFTM->PWMLOAD |= FTM_PWMLOAD_LDOK_MASK;
+    }
+    else
+    {
+    }
+}
+
+/*****************************************************************************//*!
+*
+* @brief  set the channel output mask value, FTM2 used only.
+*               
+* @param[in]    pFTM            pointer to one of three FTM base register address.
+* @param[in]    u16ChMask       the CNTIN value required to set.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none
+*
+* @see FTM_UnMaskChannels.
+*
+*****************************************************************************/
+__STATIC_INLINE void FTM_MaskChannels(FTM_Type *pFTM, uint16_t u16ChMask)
+{
+     pFTM->OUTMASK |= u16ChMask;
+}
+
+/*****************************************************************************//*!
+*
+* @brief  clear the channel output mask value, FTM2 used only.
+*               
+* @param[in]    pFTM            pointer to one of three FTM base register address.
+* @param[in]    u16ChMask       the CNTIN value required to set.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none
+*
+* @see FTM_MaskChannels.
+*
+*****************************************************************************/
+__STATIC_INLINE void FTM_UnMaskChannels(FTM_Type *pFTM, uint16_t u16ChMask)
+{
+     pFTM->OUTMASK &= ~u16ChMask;
+}
+
+/*********************************************************************************//*!
+*
+* @brief set FTM channels polarity.
+*        
+* @param[in]    pFTM                  pointer to one of three FTM base register address.
+* @param[in]    u8ChsPolValue         the channels value need to be set.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see FTM_GetChannelsPolarity.
+*
+*********************************************************************************/
+__STATIC_INLINE void FTM_SetChannelsPolarity(FTM_Type *pFTM, uint8_t u8ChsPolValue)
+{
+    pFTM->POL = u8ChsPolValue;
+}
+
+/*********************************************************************************//*!
+*
+* @brief get FTM channels polarity.
+*        
+* @param[in]    pFTM                  pointer to one of three FTM base register address.
+*
+* @return uint8_t the channels polarity.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see FTM_SetChannelsPolarity.
+*
+*********************************************************************************/
+__STATIC_INLINE uint8_t FTM_GetChannelsPolarity(FTM_Type *pFTM)
+{
+    return (pFTM->POL);
+}
+
+/*********************************************************************************//*!
+*
+* @brief select the enhanced SYNC mode.
+*        
+* @param[in]    pFTM              pointer to one of three FTM base register address.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see FTM_DisableEnhancedSYNCMode.
+*
+*********************************************************************************/
+__STATIC_INLINE void FTM_EnableEnhancedSYNCMode(FTM_Type *pFTM)
+{
+    pFTM->SYNCONF   |= FTM_SYNCONF_SYNCMODE_MASK;   /* recommend enhanced sync mode */
+}
+
+/*********************************************************************************//*!
+*
+* @brief select the legacy SYNC mode.
+*        
+* @param[in]    pFTM              pointer to one of three FTM base register address.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see FTM_EnableEnhancedSYNCMode.
+*
+*********************************************************************************/
+__STATIC_INLINE void FTM_DisableEnhancedSYNCMode(FTM_Type *pFTM)
+{
+    pFTM->SYNCONF   &= ~FTM_SYNCONF_SYNCMODE_MASK;   /* recommend enhanced sync mode */
+}
+
+/*********************************************************************************//*!
+*
+* @brief set the external trigger source.
+*        
+* @param[in]    pFTM              pointer to one of three FTM base register address.
+* @param[in]    u8TirggerSource   initial trigger or CHn(0~5)trigger
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see FTM_GetExternalTriggerFlag.
+*
+*********************************************************************************/
+__STATIC_INLINE void FTM_SetExternalTrigger(FTM_Type *pFTM, uint8_t u8TirggerSource)
+{
+    pFTM->EXTTRIG   = u8TirggerSource;
+}
+
+/*********************************************************************************//*!
+*
+* @brief get the external trigger flag.
+*        
+* @param[in]    pFTM              pointer to one of three FTM base register address.
+*
+* @return ex trigger flag.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see FTM_SetExternalTrigger.
+*
+*********************************************************************************/
+__STATIC_INLINE uint8_t FTM_GetExternalTriggerFlag(FTM_Type *pFTM)
+{
+    return (pFTM->EXTTRIG & FTM_EXTTRIG_TRIGF_MASK);
+}
+
+/*********************************************************************************//*!
+*
+* @brief set LDOK bit.
+*        
+* @param[in]    pFTM              pointer to one of three FTM base register address.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see FTM_SetLoadMatchChannel.
+*
+*********************************************************************************/
+__STATIC_INLINE void FTM_SetLoadEnable(FTM_Type *pFTM)
+{
+    pFTM->PWMLOAD |= FTM_PWMLOAD_LDOK_MASK;
+}
+
+/*********************************************************************************//*!
+*
+* @brief set the channel in the matching process.
+*        
+* @param[in]    pFTM              pointer to one of three FTM base register address.
+* @param[in]    u8Matchchannel    the channel in the matching process.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see FTM_SetLoadEnable.
+*
+*********************************************************************************/
+__STATIC_INLINE void FTM_SetLoadMatchChannel(FTM_Type *pFTM, uint8_t u8Matchchannel)
+{
+    pFTM->PWMLOAD |= u8Matchchannel;
+}
+
+/*********************************************************************************//*!
+*
+* @brief disable the channel input capture filter.
+*        
+* @param[in]    pFTM              pointer to one of three FTM base register address.
+* @param[in]    u8FTM_Channel     the channel number: 0~3.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see FTM_InputCaptureFilterSet.
+*
+*********************************************************************************/
+__STATIC_INLINE void FTM_InputCaptureFilterClr(FTM_Type *pFTM, uint8_t u8FTM_Channel)
+{
+    pFTM->FILTER &= ~(0x000F << (u8FTM_Channel << 2));
+}
+
+/*********************************************************************************//*!
+*
+* @brief set the channel input capture filter value.
+*        
+* @param[in]    pFTM              pointer to one of three FTM base register address.
+* @param[in]    u8FTM_Channel     the channel number: 0~3.
+* @param[in]    u8FilterValue     fliter cycles:1~15, 0: disable channel filter.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see FTM_InputCaptureFilterClr.
+*
+*********************************************************************************/
+__STATIC_INLINE void FTM_InputCaptureFilterSet(FTM_Type *pFTM, uint8_t u8FTM_Channel, uint8_t u8FilterValue)
+{
+    if (u8FilterValue)
+    {
+        pFTM->FILTER |= (u8FilterValue << (u8FTM_Channel << 2));
+    }
+    else
+    {
+        FTM_InputCaptureFilterClr(pFTM, u8FTM_Channel);
+    }
+}
+
+
+/*********************************************************************************//*!
+*
+* @brief enable the fault input pin.
+*        
+* @param[in]    pFTM              pointer to one of three FTM base register address.
+* @param[in]    u8FaultPin        the fault input channel number: 0~3.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see FTM_FaultPinDisable.
+*
+*********************************************************************************/
+__STATIC_INLINE void FTM_FaultPinEnable(FTM_Type *pFTM, uint8_t u8FaultPin)
+{
+    if (pFTM->MODE & FTM_MODE_WPDIS_MASK) /* if not protected */
+    {
+        pFTM->FLTCTRL |= (1 << u8FaultPin);
+    }
+    else                                  /* if protected */ 
+    {
+        FTM_WriteProtectionDisable(pFTM);
+        pFTM->FLTCTRL |= (1 << u8FaultPin);
+        FTM_WriteProtectionEnable(pFTM);
+    }
+}
+
+/*********************************************************************************//*!
+*
+* @brief disable the fault input pin.
+*        
+* @param[in]    pFTM              pointer to one of three FTM base register address.
+* @param[in]    u8FaultPin        the fault input channel number: 0~3.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see FTM_FaultPinEnable.
+*
+*********************************************************************************/
+__STATIC_INLINE void FTM_FaultPinDisable(FTM_Type *pFTM, uint8_t u8FaultPin)
+{
+    if (pFTM->MODE & FTM_MODE_WPDIS_MASK) /* if not protected */
+    {
+        pFTM->FLTCTRL &= ~(1 << u8FaultPin);
+    }
+    else                                  /* if protected */ 
+    {
+        FTM_WriteProtectionDisable(pFTM);
+        pFTM->FLTCTRL &= ~(1 << u8FaultPin);
+        FTM_WriteProtectionEnable(pFTM);
+    }
+}
+
+/*********************************************************************************//*!
+*
+* @brief enable the fault pin filter.
+*        
+* @param[in]    pFTM              pointer to one of three FTM base register address.
+* @param[in]    u8FaultPin        the fault input channel number: 0~3.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see FTM_FaultPinFilterDisable.
+*
+*********************************************************************************/
+__STATIC_INLINE void FTM_FaultPinFilterEnable(FTM_Type *pFTM, uint8_t u8FaultPin)
+{
+    if (pFTM->MODE & FTM_MODE_WPDIS_MASK) /* if not protected */
+    {
+        pFTM->FLTCTRL |= (0x10 << u8FaultPin);
+    }
+    else                                  /* if protected */ 
+    {
+        FTM_WriteProtectionDisable(pFTM);
+        pFTM->FLTCTRL |= (0x10 << u8FaultPin);
+        FTM_WriteProtectionEnable(pFTM);
+    }
+}
+
+/*********************************************************************************//*!
+*
+* @brief disable the fault pin filter.
+*        
+* @param[in]    pFTM              pointer to one of three FTM base register address.
+* @param[in]    u8FaultPin        the fault input channel number: 0~3.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see FTM_FaultPinFilterDisable.
+*
+*********************************************************************************/
+__STATIC_INLINE void FTM_FaultPinFilterDisable(FTM_Type *pFTM, uint8_t u8FaultPin)
+{
+    if (pFTM->MODE & FTM_MODE_WPDIS_MASK) /* if not protected */
+    {
+        pFTM->FLTCTRL &= ~(0x10 << u8FaultPin);
+    }
+    else                                  /* if protected */ 
+    {
+        FTM_WriteProtectionDisable(pFTM);
+        pFTM->FLTCTRL &= ~(0x10 << u8FaultPin);
+        FTM_WriteProtectionEnable(pFTM);
+    }
+}
+
+/*********************************************************************************//*!
+*
+* @brief disable all the fault pins filter together. 
+*        
+* @param[in]    pFTM              pointer to one of three FTM base register address.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see FTM_FaultPinFilterSet.
+*
+*********************************************************************************/
+__STATIC_INLINE void FTM_FaultPinFilterCDisableAll(FTM_Type *pFTM)
+{
+    pFTM->FLTCTRL &= ~FTM_FLTCTRL_FFVAL_MASK;
+}
+
+/*********************************************************************************//*!
+*
+* @brief set the fault filter value. All channels share the same filter value.
+*        
+* @param[in]    pFTM              pointer to one of three FTM base register address.
+* @param[in]    u8FilterValue     the fault input filter value: 1~15, 0 disable the filter.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see FTM_FaultPinFilterCDisableAll.
+*
+*********************************************************************************/
+__STATIC_INLINE void FTM_FaultPinFilterSet(FTM_Type *pFTM, uint8_t u8FilterValue)
+{
+    if (u8FilterValue)
+    {
+        pFTM->FLTCTRL |= FTM_FLTCTRL_FFVAL(u8FilterValue);
+    }
+    else
+    {
+        FTM_FaultPinFilterCDisableAll(pFTM);
+    }
+}
+
+/*********************************************************************************//*!
+*
+* @brief get the logic OR of all the fault detection flags
+*        
+* @param[in]    pFTM              pointer to one of three FTM base register address.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see FTM_GetFaultDetectionFlag.
+*
+*********************************************************************************/
+__STATIC_INLINE uint8_t FTM_GetFaultDetectionLogicORFlag(FTM_Type *pFTM)
+{
+    return (pFTM->FMS & FTM_FMS_FAULTF_MASK);
+}
+
+/*********************************************************************************//*!
+*
+* @brief get the fault detection flag
+*        
+* @param[in]    pFTM              pointer to one of three FTM base register address.
+* @param[in]    u8FaultPin        fault input pin number: 0~3.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see FTM_GetFaultDetectionLogicORFlag.
+*
+*********************************************************************************/
+__STATIC_INLINE uint8_t FTM_GetFaultDetectionFlag(FTM_Type *pFTM, uint8_t u8FaultPin)
+{
+    return (pFTM->FMS & (1 << u8FaultPin));
+}
+
+/*********************************************************************************//*!
+*
+* @brief get the logic OR value of the fault inputs
+*        
+* @param[in]    pFTM              pointer to one of three FTM base register address.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+*********************************************************************************/
+__STATIC_INLINE uint8_t FTM_GetFaultInputsLogicORValue(FTM_Type *pFTM)
+{
+    return (pFTM->FMS & FTM_FMS_FAULTIN_MASK);
+}
+
+/*! @} End of ftm_api_list                                                    */
+
+/******************************************************************************
+* Global functions
+******************************************************************************/
+
+void FTM_ClockSet(FTM_Type *pFTM, uint8_t u8ClockSource, uint8_t u8ClockPrescale);
+void FTM_PWMInit(FTM_Type *pFTM, uint8_t u8PWMModeSelect, uint8_t u8PWMEdgeSelect);
+void FTM_InputCaptureInit(FTM_Type *pFTM, uint8_t u8FTM_Channel, uint8_t u8CaptureMode);
+void FTM_DualEdgeCaptureInit(FTM_Type *pFTM, uint8_t u8ChannelPair, uint8_t u8CaptureMode, 
+                             uint8_t u8Channel_N_Edge, uint8_t u8Channel_Np1_Edge);
+void FTM_OutputCompareInit(FTM_Type *pFTM, uint8_t u8FTM_Channel, uint8_t u8CompareMode);
+void FTM_SoftwareSync(FTM_Type *pFTM);
+void FTM_HardwareSync(FTM_Type *pFTM, uint8_t u8TriggerN);
+void FTM_HardwareSyncCombine(FTM_Type *pFTM, uint8_t u8TriggerMask);
+void FTM_GenerateTrig2(FTM_Type *pFTM);
+void FTM_PWMDeadtimeSet(FTM_Type *pFTM, uint8_t u8PrescalerValue, uint8_t u8DeadtimeValue);
+void FTM_OutputMaskSet(FTM_Type *pFTM, uint8_t u8FTM_Channel);
+void FTM_SWOutputControlSet(FTM_Type *pFTM, uint8_t u8FTM_Channel, uint8_t u8ChannelValue);
+void FTM_SetDebugModeBehavior(FTM_Type *pFTM, uint8_t u8DebugMode);
+void FTM_SetTOFFrequency(FTM_Type *pFTM, uint8_t u8TOFNUM);
+void FTM_PolaritySet(FTM_Type *pFTM, uint8_t u8FTM_Channel, uint8_t u8ActiveValue);
+void FTM_InvertChannel(FTM_Type *pFTM, uint8_t u8ChannelPair);
+void FTM_Init(FTM_Type *pFTM, FTM_ConfigType *pConfig);
+void FTM_DeInit(FTM_Type *pFTM);
+void FTM_ChannelInit(FTM_Type *pFTM, uint8_t u8FTM_Channel, FTM_ChParamsType *pFTM_ChParams);
+void FTM_SetDutyCycleCombine(FTM_Type *pFTM, uint8_t u8FTM_Channel, uint8_t u8DutyCycle);
+void FTM_SetCallback(FTM_Type *pFTM, FTM_CallbackPtr pfnCallback);
+void  FTM_SyncConfigActivate(FTM_Type *pFTM, uint32_t u32ConfigValue);
+void FTM_SyncConfigDeactivate(FTM_Type * pFTM, uint32_t u32ConfigValue);
+uint8_t FTM_GetFaultDetectionLogicORFlag(FTM_Type *pFTM);
+uint8_t FTM_GetFaultDetectionFlag(FTM_Type *pFTM, uint8_t u8FaultPin);
+uint8_t FTM_GetFaultInputsLogicORValue(FTM_Type *pFTM);
+void FTM_WriteProtectionEnable(FTM_Type *pFTM);
+void FTM_WriteProtectionDisable(FTM_Type *pFTM);
+void FTM_FaultPinFilterCDisableAll(FTM_Type *pFTM);
+void FTM_FaultPinFilterSet(FTM_Type *pFTM, uint8_t u8FilterValue);
+void FTM_FaultPinFilterDisable(FTM_Type *pFTM, uint8_t u8FaultPin);
+void FTM_FaultPinFilterEnable(FTM_Type *pFTM, uint8_t u8FaultPin);
+void FTM_FaultPinEnable(FTM_Type *pFTM, uint8_t u8FaultPin);
+void FTM_FaultPinDisable(FTM_Type *pFTM, uint8_t u8FaultPin);
+void FTM_InputCaptureFilterClr(FTM_Type *pFTM, uint8_t u8FTM_Channel);
+void FTM_InputCaptureFilterSet(FTM_Type *pFTM, uint8_t u8FTM_Channel, uint8_t u8FilterValue);
+void FTM_SetLoadMatchChannel(FTM_Type *pFTM, uint8_t u8Matchchannel);
+void FTM_SetLoadEnable(FTM_Type *pFTM);
+uint8_t FTM_GetExternalTriggerFlag(FTM_Type *pFTM);
+void FTM_DisableEnhancedSYNCMode(FTM_Type *pFTM);
+void FTM_EnableEnhancedSYNCMode(FTM_Type *pFTM);
+uint8_t FTM_GetChannelsPolarity(FTM_Type *pFTM);
+void FTM_SetChannelsPolarity(FTM_Type *pFTM, uint8_t u8ChsPolValue);
+void FTM_UnMaskChannels(FTM_Type *pFTM, uint16_t u16ChMask);
+void FTM_MaskChannels(FTM_Type *pFTM, uint16_t u16ChMask);
+void FTM_SetCounterInitValue(FTM_Type *pFTM, uint16_t u16CounterValue);
+void FTM_SetChannelValue(FTM_Type *pFTM, uint8_t u8FTM_Channel, uint16_t u16ChannelValue);
+void FTM_SetModValue(FTM_Type *pFTM, uint16_t u16ModValue);
+void FTM_SetFTMBasic(FTM_Type *pFTM);
+void FTM_SetFTMEnhanced(FTM_Type *pFTM);
+void FTM_ClrChannelFlag(FTM_Type *pFTM, uint8_t u8FTM_Channel);
+uint8_t FTM_GetChannelFlag(FTM_Type *pFTM, uint8_t u8FTM_Channel);
+void FTM_ClrOverFlowFlag(FTM_Type *pFTM);
+uint8_t FTM_GetOverFlowFlag(FTM_Type *pFTM);
+void FTM_DisableChannelInt(FTM_Type *pFTM, uint8_t u8FTM_Channel);
+void FTM_EnableChannelInt(FTM_Type *pFTM, uint8_t u8FTM_Channel);
+void FTM_DisableOverflowInt(FTM_Type *pFTM);
+void FTM_EnableOverflowInt(FTM_Type *pFTM);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* FTM_H_ */
diff --git a/bsp/frdm-ke02/device/lib/inc/gpio.h b/bsp/frdm-ke02/device/lib/inc/gpio.h
new file mode 100755
index 0000000..0df4242
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/gpio.h
@@ -0,0 +1,303 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2011-2012 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file GPIO.h
+*
+* @version 0.0.1
+*
+* @date Jun 12, 2013
+*
+* @brief provide commond GPIO utilities. 
+*
+*******************************************************************************/
+#ifndef _GPIO_H_
+#define _GPIO_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "common.h"
+#include "stdint.h"
+
+/******************************************************************************
+*define gpio pin name
+*
+*//*! @addtogroup gpio_pin_name_list
+* @{
+*******************************************************************************/
+typedef enum
+{
+    /* in GPIOA register */
+    GPIO_PTA0 = 0,              /*!< GPIO Pin PTA0 */
+    GPIO_PTA1,                  /*!< GPIO Pin PTA1 */
+    GPIO_PTA2,                  /*!< GPIO Pin PTA2 */
+    GPIO_PTA3,                  /*!< GPIO Pin PTA3 */
+    GPIO_PTA4,                  /*!< GPIO Pin PTA4 */
+    GPIO_PTA5,                  /*!< GPIO Pin PTA5 */
+    GPIO_PTA6,                  /*!< GPIO Pin PTA6 */
+    GPIO_PTA7,                  /*!< GPIO Pin PTA7 */
+    GPIO_PTB0,                  /*!< GPIO Pin PTB0 */
+    GPIO_PTB1,                  /*!< GPIO Pin PTB1 */
+    GPIO_PTB2,                  /*!< GPIO Pin PTB2 */
+    GPIO_PTB3,                  /*!< GPIO Pin PTB3 */
+    GPIO_PTB4,                  /*!< GPIO Pin PTB4 */
+    GPIO_PTB5,                  /*!< GPIO Pin PTB5 */
+    GPIO_PTB6,                  /*!< GPIO Pin PTB6 */
+    GPIO_PTB7,                  /*!< GPIO Pin PTB7 */
+    GPIO_PTC0,                  /*!< GPIO Pin PTC0 */
+    GPIO_PTC1,                  /*!< GPIO Pin PTC1 */
+    GPIO_PTC2,                  /*!< GPIO Pin PTC2 */
+    GPIO_PTC3,                  /*!< GPIO Pin PTC3 */
+    GPIO_PTC4,                  /*!< GPIO Pin PTC4 */
+    GPIO_PTC5,                  /*!< GPIO Pin PTC5 */
+    GPIO_PTC6,                  /*!< GPIO Pin PTC6 */
+    GPIO_PTC7,                  /*!< GPIO Pin PTC7 */
+    GPIO_PTD0,                  /*!< GPIO Pin PTD0 */
+    GPIO_PTD1,                  /*!< GPIO Pin PTD1 */
+    GPIO_PTD2,                  /*!< GPIO Pin PTD2 */
+    GPIO_PTD3,                  /*!< GPIO Pin PTD3 */
+    GPIO_PTD4,                  /*!< GPIO Pin PTD4 */
+    GPIO_PTD5,                  /*!< GPIO Pin PTD5 */
+    GPIO_PTD6,                  /*!< GPIO Pin PTD6 */
+    GPIO_PTD7,                  /*!< GPIO Pin PTD7 */
+    /* in GPIOB register */
+    GPIO_PTE0,                  /*!< GPIO Pin PTE0 */
+    GPIO_PTE1,                  /*!< GPIO Pin PTE1 */
+    GPIO_PTE2,                  /*!< GPIO Pin PTE2 */
+    GPIO_PTE3,                  /*!< GPIO Pin PTE3 */
+    GPIO_PTE4,                  /*!< GPIO Pin PTE4 */
+    GPIO_PTE5,                  /*!< GPIO Pin PTE5 */
+    GPIO_PTE6,                  /*!< GPIO Pin PTE6 */
+    GPIO_PTE7,                  /*!< GPIO Pin PTE7 */
+    GPIO_PTF0,                  /*!< GPIO Pin PTF0 */
+    GPIO_PTF1,                  /*!< GPIO Pin PTF1 */
+    GPIO_PTF2,                  /*!< GPIO Pin PTF2 */
+    GPIO_PTF3,                  /*!< GPIO Pin PTF3 */
+    GPIO_PTF4,                  /*!< GPIO Pin PTF4 */
+    GPIO_PTF5,                  /*!< GPIO Pin PTF5 */
+    GPIO_PTF6,                  /*!< GPIO Pin PTF6 */
+    GPIO_PTF7,                  /*!< GPIO Pin PTF7 */
+    GPIO_PTG0,                  /*!< GPIO Pin PTG0 */
+    GPIO_PTG1,                  /*!< GPIO Pin PTG1 */
+    GPIO_PTG2,                  /*!< GPIO Pin PTG2 */
+    GPIO_PTG3,                  /*!< GPIO Pin PTG3 */
+    GPIO_PTG4,                  /*!< GPIO Pin PTG4 */
+    GPIO_PTG5,                  /*!< GPIO Pin PTG5 */
+    GPIO_PTG6,                  /*!< GPIO Pin PTG6 */
+    GPIO_PTG7,                  /*!< GPIO Pin PTG7 */
+    GPIO_PTH0,                  /*!< GPIO Pin PTH0 */
+    GPIO_PTH1,                  /*!< GPIO Pin PTH1 */
+    GPIO_PTH2,                  /*!< GPIO Pin PTH2 */
+    GPIO_PTH3,                  /*!< GPIO Pin PTH3 */
+    GPIO_PTH4,                  /*!< GPIO Pin PTH4 */
+    GPIO_PTH5,                  /*!< GPIO Pin PTH5 */
+    GPIO_PTH6,                  /*!< GPIO Pin PTH6 */
+    GPIO_PTH7,                  /*!< GPIO Pin PTH7 */
+    /* the following pins are not in KE02 */
+    GPIO_PTI0,                  /*!< GPIO Pin PTI0 */
+    GPIO_PTI1,                  /*!< GPIO Pin PTI1 */
+    GPIO_PTI2,                  /*!< GPIO Pin PTI2 */
+    GPIO_PTI3,                  /*!< GPIO Pin PTI3 */
+    GPIO_PTI4,                  /*!< GPIO Pin PTI4 */
+    GPIO_PTI5,                  /*!< GPIO Pin PTI5 */
+    GPIO_PTI6,                  /*!< GPIO Pin PTI6 */
+    GPIO_PTI7,                  /*!< GPIO Pin PTI7 */
+    GPIO_PIN_MAX,
+} GPIO_PinType;
+/*! @} End of gpio_pin_name_list    */
+
+/******************************************************************************
+*define gpio pin mask
+*
+*//*! @addtogroup gpio_pin_mask_list
+* @{
+*******************************************************************************/
+typedef enum
+{
+    /* in GPIOA register */
+    GPIO_PTA0_MASK = (1<<0),    /*!< GPIO Pin PTA0 bit mask */        
+    GPIO_PTA1_MASK = (1<<1),    /*!< GPIO Pin PTA1 bit mask */
+    GPIO_PTA2_MASK = (1<<2),    /*!< GPIO Pin PTA2 bit mask */
+    GPIO_PTA3_MASK = (1<<3),    /*!< GPIO Pin PTA3 bit mask */
+    GPIO_PTA4_MASK = (1<<4),    /*!< GPIO Pin PTA4 bit mask */
+    GPIO_PTA5_MASK = (1<<5),    /*!< GPIO Pin PTA5 bit mask */
+    GPIO_PTA6_MASK = (1<<6),    /*!< GPIO Pin PTA6 bit mask */
+    GPIO_PTA7_MASK = (1<<7),    /*!< GPIO Pin PTA7 bit mask */
+    GPIO_PTB0_MASK = (1<<8),    /*!< GPIO Pin PTB0 bit mask */
+    GPIO_PTB1_MASK = (1<<9),    /*!< GPIO Pin PTB1 bit mask */
+    GPIO_PTB2_MASK = (1<<10),   /*!< GPIO Pin PTB2 bit mask */
+    GPIO_PTB3_MASK = (1<<11),   /*!< GPIO Pin PTB3 bit mask */
+    GPIO_PTB4_MASK = (1<<12),   /*!< GPIO Pin PTB4 bit mask */
+    GPIO_PTB5_MASK = (1<<13),   /*!< GPIO Pin PTB5 bit mask */
+    GPIO_PTB6_MASK = (1<<14),   /*!< GPIO Pin PTB6 bit mask */
+    GPIO_PTB7_MASK = (1<<15),   /*!< GPIO Pin PTB7 bit mask */
+    GPIO_PTC0_MASK = (1<<16),   /*!< GPIO Pin PTC0 bit mask */
+    GPIO_PTC1_MASK = (1<<17),   /*!< GPIO Pin PTC1 bit mask */
+    GPIO_PTC2_MASK = (1<<18),   /*!< GPIO Pin PTC2 bit mask */
+    GPIO_PTC3_MASK = (1<<19),   /*!< GPIO Pin PTC3 bit mask */
+    GPIO_PTC4_MASK = (1<<20),   /*!< GPIO Pin PTC4 bit mask */
+    GPIO_PTC5_MASK = (1<<21),   /*!< GPIO Pin PTC5 bit mask */
+    GPIO_PTC6_MASK = (1<<22),   /*!< GPIO Pin PTC6 bit mask */
+    GPIO_PTC7_MASK = (1<<23),   /*!< GPIO Pin PTC7 bit mask */
+    GPIO_PTD0_MASK = (1<<24),   /*!< GPIO Pin PTD0 bit mask */
+    GPIO_PTD1_MASK = (1<<25),   /*!< GPIO Pin PTD1 bit mask */
+    GPIO_PTD2_MASK = (1<<26),   /*!< GPIO Pin PTD2 bit mask */
+    GPIO_PTD3_MASK = (1<<27),   /*!< GPIO Pin PTD3 bit mask */
+    GPIO_PTD4_MASK = (1<<28),   /*!< GPIO Pin PTD4 bit mask */
+    GPIO_PTD5_MASK = (1<<29),   /*!< GPIO Pin PTD5 bit mask */
+    GPIO_PTD6_MASK = (1<<30),   /*!< GPIO Pin PTD6 bit mask */
+    GPIO_PTD7_MASK = (1<<31),   /*!< GPIO Pin PTD7 bit mask */
+    /* in GPIOB register */
+    GPIO_PTE0_MASK = (1<<0),    /*!< GPIO Pin PTE0 bit mask */
+    GPIO_PTE1_MASK = (1<<1),    /*!< GPIO Pin PTE1 bit mask */
+    GPIO_PTE2_MASK = (1<<2),    /*!< GPIO Pin PTE2 bit mask */
+    GPIO_PTE3_MASK = (1<<3),    /*!< GPIO Pin PTE3 bit mask */
+    GPIO_PTE4_MASK = (1<<4),    /*!< GPIO Pin PTE4 bit mask */
+    GPIO_PTE5_MASK = (1<<5),    /*!< GPIO Pin PTE5 bit mask */
+    GPIO_PTE6_MASK = (1<<6),    /*!< GPIO Pin PTE6 bit mask */
+    GPIO_PTE7_MASK = (1<<7),    /*!< GPIO Pin PTE7 bit mask */
+    GPIO_PTF0_MASK = (1<<8),    /*!< GPIO Pin PTF0 bit mask */
+    GPIO_PTF1_MASK = (1<<9),    /*!< GPIO Pin PTF1 bit mask */
+    GPIO_PTF2_MASK = (1<<10),   /*!< GPIO Pin PTF2 bit mask */
+    GPIO_PTF3_MASK = (1<<11),   /*!< GPIO Pin PTF3 bit mask */
+    GPIO_PTF4_MASK = (1<<12),   /*!< GPIO Pin PTF4 bit mask */
+    GPIO_PTF5_MASK = (1<<13),   /*!< GPIO Pin PTF5 bit mask */
+    GPIO_PTF6_MASK = (1<<14),   /*!< GPIO Pin PTF6 bit mask */
+    GPIO_PTF7_MASK = (1<<15),   /*!< GPIO Pin PTF7 bit mask */
+    GPIO_PTG0_MASK = (1<<16),   /*!< GPIO Pin PTG0 bit mask */
+    GPIO_PTG1_MASK = (1<<17),   /*!< GPIO Pin PTG1 bit mask */
+    GPIO_PTG2_MASK = (1<<18),   /*!< GPIO Pin PTG2 bit mask */
+    GPIO_PTG3_MASK = (1<<19),   /*!< GPIO Pin PTG3 bit mask */
+    GPIO_PTG4_MASK = (1<<20),   /*!< GPIO Pin PTG4 bit mask */
+    GPIO_PTG5_MASK = (1<<21),   /*!< GPIO Pin PTG5 bit mask */
+    GPIO_PTG6_MASK = (1<<22),   /*!< GPIO Pin PTG6 bit mask */
+    GPIO_PTG7_MASK = (1<<23),   /*!< GPIO Pin PTG7 bit mask */
+    GPIO_PTH0_MASK = (1<<24),   /*!< GPIO Pin PTH0 bit mask */
+    GPIO_PTH1_MASK = (1<<25),   /*!< GPIO Pin PTH1 bit mask */
+    GPIO_PTH2_MASK = (1<<26),   /*!< GPIO Pin PTH2 bit mask */
+    GPIO_PTH3_MASK = (1<<27),   /*!< GPIO Pin PTH3 bit mask */
+    GPIO_PTH4_MASK = (1<<28),   /*!< GPIO Pin PTH4 bit mask */
+    GPIO_PTH5_MASK = (1<<29),   /*!< GPIO Pin PTH5 bit mask */
+    GPIO_PTH6_MASK = (1<<30),   /*!< GPIO Pin PTH6 bit mask */
+    GPIO_PTH7_MASK = (1<<31),   /*!< GPIO Pin PTH7 bit mask */
+    /* in GPIOC register */
+    GPIO_PTI0_MASK = (1<<0),    /*!< GPIO Pin PTI0 bit mask */
+    GPIO_PTI1_MASK = (1<<1),    /*!< GPIO Pin PTI1 bit mask */
+    GPIO_PTI2_MASK = (1<<2),    /*!< GPIO Pin PTI2 bit mask */
+    GPIO_PTI3_MASK = (1<<3),    /*!< GPIO Pin PTI3 bit mask */
+    GPIO_PTI4_MASK = (1<<4),    /*!< GPIO Pin PTI4 bit mask */
+    GPIO_PTI5_MASK = (1<<5),    /*!< GPIO Pin PTI5 bit mask */
+    GPIO_PTI6_MASK = (1<<6),    /*!< GPIO Pin PTI6 bit mask */
+    GPIO_PTI7_MASK = (1<<7),    /*!< GPIO Pin PTI7 bit mask */
+} GPIO_PinMaskType;
+/*! @} End of gpio_pin_mask_list    */
+
+
+/******************************************************************************
+*define gpio pin config type
+*
+*//*! @addtogroup gpio_pin_config_type_list
+* @{
+*******************************************************************************/
+/*
+*   . Internal pullup is disabled if the pin is configured as an output
+*   . High-current drive function is disabled, if the pin is configured as an input
+*       Only PTH1/0, PTE1/0, PTD1/0, PTB5/4 support Hight-current Drive.
+*/
+typedef enum
+{
+    GPIO_PinOutput = 0,                 /*!< set pin as outout */
+    GPIO_PinInput,                      /*!< set pin as input */
+    GPIO_PinInput_InternalPullup,       /*!< set internal pullup for input pin */
+    GPIO_PinOutput_HighCurrent,         /*!< set high drive for output pin */
+} GPIO_PinConfigType;
+/*! @} End of gpio_pin_config_type_list */
+
+/******************************************************************************
+* define GPIO APIs
+*
+*//*! @addtogroup gpio_api_list
+* @{
+*******************************************************************************/
+
+/*****************************************************************************//*!
+* @brief    Toggle the pins which are specified by u32PinMask in single cycle.
+*        
+* @param[in] pGPIO       Pointer to GPIO module, can be FGPIOA/FGPIOB.
+* @param[in] u32PinMask  Specify GPIO pin need to be toggled
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void FGPIO_Toggle(FGPIO_Type *pFGPIO, uint32_t u32PinMask)
+{
+    pFGPIO->PTOR = u32PinMask;   /* Toggle the pins specified by u32PinMask */
+}
+
+/*****************************************************************************//*!
+* @brief Read input data from GPIO which is specified by pGPIO in single cycle.
+*        
+* @param[in] pGPIO       Pointer to GPIO module, can be FGPIOA/FGPIOB.
+*
+* @return   GPIO input value unsigned int 32-bit
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint32_t FGPIO_Read(FGPIO_Type *pFGPIO)
+{
+    return (pFGPIO->PDIR);      /* Read Port Data Input Register */
+  
+}
+
+/*****************************************************************************//*!
+* @brief    Write output data to GPIO which is specified by pGPIO in single cycle.
+*        
+* @param[in] pGPIO       Pointer to GPIO module, can be FGPIOA/FGPIOB.
+* @param[in] u32Value    value to output
+*
+* @return   none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void FGPIO_Write(FGPIO_Type *pFGPIO, uint32_t u32Value)
+{    
+    pFGPIO->PDOR = u32Value;    /* Write Port Ouput Data Register */
+}
+
+void GPIO_DeInit(GPIO_Type *pGPIO);
+void GPIO_Init(GPIO_Type *pGPIO, uint32_t u32PinMask, GPIO_PinConfigType sGpioType);
+void GPIO_Toggle(GPIO_Type *pGPIO, uint32_t u32PinMask);
+uint32_t GPIO_Read(GPIO_Type *pGPIO);
+void GPIO_Write(GPIO_Type *pGPIO, uint32_t u32Value);
+void GPIO_PinInit(GPIO_PinType GPIO_Pin, GPIO_PinConfigType GPIO_PinConfig);
+void GPIO_PinToggle(GPIO_PinType GPIO_Pin);
+void GPIO_PinSet(GPIO_PinType GPIO_Pin);
+void GPIO_PinClear(GPIO_PinType GPIO_Pin);
+    
+/*! @} End of gpio_api_list */
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* #ifndef _GPIO_H_ */
diff --git a/bsp/frdm-ke02/device/lib/inc/i2c.h b/bsp/frdm-ke02/device/lib/inc/i2c.h
new file mode 100755
index 0000000..9ee96a2
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/i2c.h
@@ -0,0 +1,553 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file i2c.h
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief header file for I2C module utilities (I2C). 
+*
+*******************************************************************************
+*
+* provide APIs for accessing I2C module (I2C)
+******************************************************************************/
+#ifndef _I2C_H__
+#define _I2C_H__
+#ifdef __cplusplus
+extern "C" {
+#endif
+/******************************************************************************
+* Global variables
+******************************************************************************/
+
+/******************************************************************************
+* Constants and macros
+******************************************************************************/
+/******************************************************************************
+* define I2C work read or write 
+*
+*//*! @addtogroup i2c_read_write_list
+* @{
+*******************************************************************************/
+#define I2C_READ                        0x01				/*!< I2C read */
+#define I2C_WRITE                       0x0  				/*!< I2C write */
+/*! @} End of i2c_read_write_list                                             */
+
+#define I2C_SEND_ACK                    0						/*!< I2C send ACK */
+#define I2C_SEND_NACK                   1						/*!< I2C send NACK */
+
+#define I2C_WAIT_STATUS_TIMEOUT         200000
+
+/******************************************************************************
+* define I2C error state
+*
+*//*! @addtogroup i2c_error_state_list
+* @{
+*******************************************************************************/
+#define I2C_ERROR_NULL                  0x00			/*!< I2C sucess*/
+#define I2C_ERROR_NO_WAIT_TCF_FLAG      0x01			/*!< I2C wait TCF overtime*/
+#define I2C_ERROR_NO_WAIT_IICIF_FLAG    0x02			/*!< I2C wait IICIF overtime */
+#define I2C_ERROR_NO_GET_ACK            0x04			/*!< I2C no get ACK */
+#define I2C_ERROR_START_NO_BUSY_FLAG    0x10			/*!< I2C fail to send start signals */
+#define I2C_ERROR_STOP_BUSY_FLAG        0x20			/*!< I2C fail to send stop signal */
+#define I2C_ERROR_BUS_BUSY              0x80			/*!< I2C bus busy error */
+/*! @} End of i2c_error_state_list                                            */
+
+/******************************************************************************
+* define I2C bus state
+*
+*//*! @addtogroup i2c_bus_state_list
+* @{
+*******************************************************************************/
+#define I2C_BUS_NORMAL				0x00								/*!< I2C bus normal */
+#define I2C_BUS_SLTF					0x01								/*!< I2C bus SLTF flag */
+#define I2C_BUS_SHTF2					0x02								/*!< I2C bus SHTF2 flag */
+/*! @} End of i2c_bus_state_list                                             */
+
+
+/******************************************************************************
+* Local types
+******************************************************************************/
+
+/******************************************************************************
+* Local function prototypes
+******************************************************************************/
+
+/******************************************************************************
+* Local variables
+******************************************************************************/
+#define I2C_MODE_MASTER             1
+#define I2C_MODE_SLAVE              0
+#define I2C_ADDRESS_7BIT            0
+#define I2C_ADDRESS_10BIT           1
+#define I2C_TIMEOUT_BUS_CLOCK_DIV64 0
+#define I2C_TIMEOUT_BUS_CLOCK       1
+
+/******************************************************************************
+*
+*//*! @addtogroup i2c_setting_type
+* @{
+*******************************************************************************/
+/*!
+ * @brief I2C setting type.
+ *
+ */
+typedef struct
+{
+	uint16_t bI2CEn         :1;     			/*!< enable I2C module */
+	uint16_t bIntEn         :1;    			 	/*!< enable I2C enable */
+	uint16_t bWakeUpEn      :1;     			/*!< I2C wake up enable */
+	uint16_t bGCAEn         :1;     			/*!< I2C General call address enable */
+	uint16_t bAddressExt    :1;     			/*!< I2C extertion address selection */
+	uint16_t bRangeAddEn    :1;     			/*!< enable range address */
+	uint16_t bFackEn        :1;     			/*!< enable fast ack */
+	uint16_t bSMB_AlertEn   :1;     			/*!< SMB Alert enable */
+	uint16_t bSecondAddressEn:1;    			/*!< enable the second address */
+	uint16_t bTimeoutCountClockSelect:1;  /*!< TimeoutCountClockSelect */
+    uint16_t bSHTF2IntEn    :1;					/*!< SHTF2 interrupt enable */
+    uint16_t Reserve        :5;
+}I2C_SettingType;
+/*! @} End of i2c_setting_type                                       						*/
+
+/******************************************************************************
+*
+*//*! @addtogroup i2c_config_type
+* @{
+*******************************************************************************/
+/*!
+ * @brief I2C configure type.
+ *
+ */
+typedef struct
+{
+    I2C_SettingType sSetting;
+    uint16_t u16F;              /*!< setting the band rate for I2C */
+    uint16_t u16OwnA1;          /*!< slave address */
+    uint16_t u16OwnA2;          /*!< the second slave address */
+    uint16_t u16RangeA;         /*!< range address */
+    uint16_t u16Filt;           /*!< Filter for I2C   */
+    uint16_t u16Slt;            /*!< SCL Low timeout register low */
+    
+}I2C_ConfigType, *I2C_ConfigPtr;
+/*! @} End of i2c_config_type                                             				*/
+
+/******************************************************************************
+*
+*//*! @addtogroup i2c_callback
+* @{
+*******************************************************************************/
+typedef void (*I2C_CallbackType)(void);		/*!< I2C call back function */
+/*! @} End of i2c_callback                                             						*/
+
+/******************************************************************************
+* inline functions
+******************************************************************************/
+/******************************************************************************
+*
+*//*! @addtogroup i2c_api_list
+* @{
+*******************************************************************************/
+/*****************************************************************************//*!
+   *
+   * @brief enable I2C to transmit data.
+   *        
+   * @param[in] pI2Cx      point to I2C module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void I2C_TxEnable(I2C_Type *pI2Cx)
+{
+    pI2Cx->C1 |= I2C_C1_TX_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief enable I2C to receive data.
+   *        
+   * @param[in] pI2Cx      point to I2C module type.
+   *
+   * @return none.
+   *
+   * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+__STATIC_INLINE void I2C_RxEnable(I2C_Type *pI2Cx)
+{
+    pI2Cx->C1 &= ~I2C_C1_TX_MASK;
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief set IIC band rate. 
+   *        
+   * @param[in] pI2Cx      point to I2C module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void I2C_SetBaudRate(I2C_Type *pI2Cx,uint32_t u32Bps)
+{
+    pI2Cx->F = (uint8_t)u32Bps;
+}
+/*****************************************************************************//*!
+   *
+   * @brief enable general call.
+   *        
+   * @param[in] pI2Cx      point to I2C module type.
+   *
+   * @return none.
+   *
+   * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+__STATIC_INLINE void I2C_GeneralCallEnable(I2C_Type *pI2Cx)
+{
+     pI2Cx->C2 |= I2C_C2_GCAEN_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief SMBus Alert Response Address Enable. 
+   *        
+   * @param[in] pI2Cx      point to I2C module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void I2C_SMBusAlertEnable(I2C_Type *pI2Cx)
+{
+     pI2Cx->SMB|= I2C_SMB_ALERTEN_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Range Address Matching Enable.
+   *        
+   * @param[in] pI2Cx      point to I2C module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void I2C_RangeAddressEnable(I2C_Type *pI2Cx)
+{
+     pI2Cx->C2 |= I2C_C2_RMEN_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief SHTF2 Interrupt Enable.
+   *        
+   * @param[in] pI2Cx      point to I2C module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void I2C_SHTF2IntEnable(I2C_Type *pI2Cx)
+{
+     pI2Cx->SMB |= I2C_SMB_SHTF2IE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Timeout Counter Clock Select.
+   *        
+   * @param[in] pI2Cx      point to I2C module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void I2C_TimeoutCounterClockSelect(I2C_Type *pI2Cx, uint8_t u8Clock)
+{
+    if( u8Clock )
+    {
+        pI2Cx->SMB |= I2C_SMB_TCKSEL_MASK;
+    }
+    else
+    {
+        pI2Cx->SMB &= ~I2C_SMB_TCKSEL_MASK;
+    }
+}
+/*****************************************************************************//*!
+   *
+   * @brief get I2C status.
+   *        
+   * @param[in] pI2Cx      point to I2C module type.
+   *
+   * @return I2C status
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t I2C_GetStatus(I2C_Type *pI2Cx)
+{
+    return pI2Cx->S;
+}
+/*****************************************************************************//*!
+   *
+   * @brief clear specified status.
+   *        
+   * @param[in] pI2Cx      point to I2C module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void I2C_ClearStatus(I2C_Type *pI2Cx, uint8_t u8ClearFlag)
+{
+    pI2Cx->S |= u8ClearFlag;
+}
+/*****************************************************************************//*!
+   *
+   * @brief write data to data register.
+   *        
+   * @param[in] pI2Cx      point to I2C module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void I2C_WriteDataReg(I2C_Type *pI2Cx, uint8_t u8DataBuff)
+{
+    pI2Cx->D = u8DataBuff;
+}
+/*****************************************************************************//*!
+   *
+   * @brief read data from data register.
+   *        
+   * @param[in] pI2Cx      point to I2C module type.
+   *
+   * @return I2C data register value
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t I2C_ReadDataReg(I2C_Type *pI2Cx )
+{
+    return pI2Cx->D;
+}
+/*****************************************************************************//*!
+   *
+   * @brief check if is Tx mode.
+   *        
+   * @param[in] pI2Cx      point to I2C module type.
+   *
+   * @return result  TRUE or FALSE
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t I2C_IsTxMode(I2C_Type *pI2Cx )
+{
+    return(pI2Cx->C1 & I2C_C1_TX_MASK);
+}
+/*****************************************************************************//*!
+   *
+   * @brief check I2C if busy.
+   *        
+   * @param[in] pI2Cx      point to I2C module type.
+   *
+   * @return result  TRUE or FALSE
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t I2C_IsBusy(I2C_Type *pI2Cx )
+{
+    return (pI2Cx->S & I2C_S_BUSY_MASK);
+}
+/*****************************************************************************//*!
+   *
+   * @brief check I2C receive ack or nack.
+   *        
+   * @param[in] pI2Cx      point to I2C module type.
+   *
+   * @return result    TRUE or FALSE
+   *
+   * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+__STATIC_INLINE uint8_t I2C_IsReceivedAck(I2C_Type *pI2Cx )
+{
+    return (pI2Cx->S & I2C_S_RXAK_MASK);
+}
+/*****************************************************************************//*!
+   *
+   * @brief check I2C if is master mode.
+   *        
+   * @param[in] pI2Cx    point to I2C module type.
+   *
+   * @return result    TRUE or FALSE.
+   *
+   * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+__STATIC_INLINE uint8_t I2C_IsMasterMode(I2C_Type *pI2Cx )
+{
+    return(pI2Cx->C1 & I2C_C1_MST_MASK);
+}
+/*****************************************************************************//*!
+   *
+   * @brief check SCL Low Timeout Flag.
+   *        
+   * @param[in] pI2Cx    point to I2C module type.
+   *
+   * @return result    TRUE or FALSE.
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t I2C_IsSMB_SLTF(I2C_Type *pI2Cx )
+{
+    return (pI2Cx->SMB & I2C_SMB_SLTF_MASK);
+}
+/*****************************************************************************//*!
+   *
+   * @brief check SCL High Timeout Flag is set or clear.
+   *        
+   * @param[in] pI2Cx    point to I2C module type.
+   *
+   * @return result    TRUE or FALSE.
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t I2C_IsSMB_SHTF2(I2C_Type *pI2Cx )
+{
+    return(pI2Cx->SMB & I2C_SMB_SHTF2_MASK);
+}
+/*****************************************************************************//*!
+   *
+   * @brief clear SLTF flag.
+   *        
+   * @param[in] pI2Cx    point to I2C module type.
+   *
+   * @return none.
+   *
+   * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+__STATIC_INLINE void I2C_ClearSLTF(I2C_Type *pI2Cx )
+{
+    pI2Cx->SMB |= I2C_SMB_SLTF_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief clear SHTF2 flag.
+   *        
+   * @param[in] pI2Cx    point to I2C module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void I2C_ClearSHTF2(I2C_Type *pI2Cx )
+{
+    pI2Cx->SMB |= I2C_SMB_SHTF2_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief send out ACK.
+   *        
+   * @param[in] pI2Cx    point to I2C module type.
+   *
+   * @return none.
+   *
+   * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+__STATIC_INLINE void I2C_SendAck(I2C_Type *pI2Cx )
+{
+    pI2Cx->C1 &= ~I2C_C1_TXAK_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief send out NACK.
+   *        
+   * @param[in] pI2Cx    point to I2C module type.
+   *
+   * @return none.
+   *
+   * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+__STATIC_INLINE void I2C_SendNack(I2C_Type *pI2Cx )
+{
+    pI2Cx->C1 |= I2C_C1_TXAK_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Second I2C Address Enable.
+   *        
+   * @param[in] pI2Cx    point to I2C module type.
+   *
+   * @return none.
+   *
+   * @ Pass/ Fail criteria: none.
+*****************************************************************************/
+__STATIC_INLINE void I2C_SecondAddressEnable(I2C_Type *pI2Cx)
+{
+     pI2Cx->SMB |= I2C_SMB_SIICAEN_MASK;
+}
+/******************************************************************************
+* Global functions
+******************************************************************************/
+void I2C_Init(I2C_Type *pI2Cx,I2C_ConfigPtr pI2CConfig);
+uint8_t I2C_Start(I2C_Type *pI2Cx);
+uint8_t I2C_Stop(I2C_Type *pI2Cx);
+uint8_t I2C_RepeatStart(I2C_Type *pI2Cx);
+uint8_t I2C_IsTxMode(I2C_Type *pI2Cx );
+uint8_t I2C_IsBusy(I2C_Type *pI2Cx );
+uint8_t I2C_IsReceivedAck(I2C_Type *pI2Cx );
+uint8_t I2C_IsMasterMode(I2C_Type *pI2Cx );
+void I2C_ClearSHTF2(I2C_Type *pI2Cx );
+void I2C_ClearSLTF(I2C_Type *pI2Cx );
+uint8_t I2C_IsSMB_SHTF2(I2C_Type *pI2Cx );
+uint8_t I2C_IsSMB_SLTF(I2C_Type *pI2Cx );
+void I2C_TxEnable(I2C_Type *pI2Cx);
+void I2C_RxEnable(I2C_Type *pI2Cx);
+void I2C_IntEnable(I2C_Type *pI2Cx);
+void I2C_IntDisable(I2C_Type *pI2Cx);
+void I2C_SetBaudRate(I2C_Type *pI2Cx,uint32_t u32Bps);
+void I2C_SetSlaveAddress(I2C_Type *pI2Cx,uint16_t u16SlaveAddress);
+void I2C_GeneralCallEnable(I2C_Type *pI2Cx);
+void I2C_SMBusAlertEnable(I2C_Type *pI2Cx);
+void I2C_RangeAddressEnable(I2C_Type *pI2Cx);
+void I2C_SHTF2IntEnable(I2C_Type *pI2Cx);
+void I2C_TimeoutCounterClockSelect(I2C_Type *pI2Cx, uint8_t u8Clock);
+void I2C_SetSCLLowTimeout(I2C_Type *pI2Cx, uint16_t u16Timeout);
+uint8_t I2C_GetStatus(I2C_Type *pI2Cx);
+void I2C_ClearStatus(I2C_Type *pI2Cx, uint8_t u8ClearFlag);
+void I2C_SendAck(I2C_Type *pI2Cx );
+void I2C_SendNack(I2C_Type *pI2Cx );
+void I2C_SecondAddressEnable(I2C_Type *pI2Cx);
+void I2C_ClearStatus(I2C_Type *pI2Cx, uint8_t u8ClearFlag);
+void I2C_WriteDataReg(I2C_Type *pI2Cx, uint8_t u8DataBuff);
+uint8_t I2C_ReadDataReg(I2C_Type *pI2Cx );
+void I2C_Deinit(I2C_Type *pI2Cx);
+uint8_t I2C_WriteOneByte(I2C_Type *pI2Cx, uint8_t u8WrBuff);
+uint8_t I2C_ReadOneByte(I2C_Type *pI2Cx, uint8_t *pRdBuff, uint8_t u8Ack);
+uint8_t I2C_MasterSendWait(I2C_Type *pI2Cx,uint16_t u16SlaveAddress,uint8_t *pWrBuff,uint32_t u32Length);
+uint8_t I2C_MasterReadWait(I2C_Type *pI2Cx,uint16_t u16SlaveAddress,uint8_t *pRdBuff,uint32_t u32Length);
+void I2C0_SetCallBack( I2C_CallbackType pCallBack );
+void I2C1_SetCallBack( I2C_CallbackType pCallBack );
+
+/*! @} End of i2c_bus_state_list                                             						*/
+
+#ifdef __cplusplus
+}
+#endif
+#endif //
+
+
diff --git a/bsp/frdm-ke02/device/lib/inc/ics.h b/bsp/frdm-ke02/device/lib/inc/ics.h
new file mode 100755
index 0000000..459d6f2
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/ics.h
@@ -0,0 +1,479 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file ics.h
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief header file for Internal Clock Source utilities. 
+*
+*******************************************************************************
+*
+* provide APIs for accessing internal clock source (ICS)
+******************************************************************************/
+
+#ifndef ICS_H_
+#define ICS_H_
+#ifdef __cplusplus
+extern "C" {
+#endif
+/******************************************************************************
+* Includes
+******************************************************************************/
+
+/******************************************************************************
+* Constants
+******************************************************************************/
+/* 
+ * ICS clock mode
+ */
+/******************************************************************************
+* define ICS clock modes
+*
+*//*! @addtogroup ics_clock_mode
+* @{
+*******************************************************************************/
+ 
+/*!
+ * @brief clock mode constants definition.
+ *
+ */
+enum
+{
+    ICS_CLK_MODE_FEI = 1,       /*!< FEI mode */
+    ICS_CLK_MODE_FEE,           /*!< FEE mode */
+    ICS_CLK_MODE_FEE_OSC,       /*!< FEE mode with external active oscillator */    
+    ICS_CLK_MODE_FBE,           /*!< FBE mode */
+    ICS_CLK_MODE_FBE_OSC,       /*!< FBE mode with external active oscillator */    
+    ICS_CLK_MODE_FBI,           /*!< FBI mode */
+    ICS_CLK_MODE_FBILP,         /*!< FBILP mode */    
+    ICS_CLK_MODE_FBELP,         /*!< FBELP mode */        
+};
+/*! @} End of ics_clock_mode                                                    					*/
+
+/******************************************************************************
+* Macros
+******************************************************************************/
+
+
+/******************************************************************************
+* define ICS API list
+*
+*//*! @addtogroup ics_api_list
+* @{
+*******************************************************************************/
+      
+/*****************************************************************************//*!
+   *
+   * @brief switch clock mode from current to new mode.
+   *
+   *  The clock mode macros are as follows:
+   *      FEI, FBI, FEE, FBE, FBILP, FBELP, FEE_OSC, FBE_OSC
+   *    where FEE_OSC, FBE_OSC can not be used as current mode. The valid combinationS of 
+   *    <CurMode, NewMode> pair are as follows:      
+   *    <FEI,FEE>, <FEI,FBI>, <FEI,FBE>, <FEI,FBE_OSC>, <FEI,FEE_OSC>, <FEE,FEI>,
+   *    <FEE,FBI>, <FEE,FBE>, <FBI,FBE>, <FBI,FEE>, <FBI,FBILP>, <FBI,FEI>,
+   *    <FBE,FBI>, <FBE,FEE>, <FBE,FEI>, <FBE,FBELP>, <FBELP,FBE>, <FBILP,FBI>.
+   *    
+   * @param[in] CurMode   current clock mode macro
+   * @param[in] NewMode   new clock mode macro
+   * @param[in] clkFreq     reference clock frequency
+   *       
+   * @return none
+   * @warning FEE_OSC, FBE_OSC can not be used as current mode
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+
+#define ICS_SwitchMode(CurMode, NewMode, clkFreq)   CurMode##_to_##NewMode(clkFreq)
+       
+/*! @} End of ics_api_list                                                    					*/
+
+/*!****************************************************************************
+* Types
+******************************************************************************/
+    
+/* OSC configuration structure 
+ */  
+/******************************************************************************
+* define OSC configuration structure
+*
+*//*! @addtogroup osc_config_type
+* @{
+*******************************************************************************/
+ 
+/*!
+ * @brief OSC configuration type.
+ *
+ */
+typedef struct
+{
+	uint8_t bRange      : 1;        /*!< 1: high range, 0: low range */
+	uint8_t bGain       : 1;        /*!< 1: high gain, 0: low gain */
+	uint8_t bEnable     : 1;        /*!< 1: enable XOSC, 0: disable XOSC */
+	uint8_t bStopEnable : 1;        /*!< 1: stop enable, 0: stop disable */
+	uint8_t bIsCryst    : 1;        /*!< 1: crystal input, 0: active clock input */
+	uint8_t bWaitInit   : 1;        /*!< 1: wait till XOSC init done, 0: no wait */
+} OSC_ConfigType, *OSC_ConfigPtr;
+/*! @} End of osc_config_type                                                    					*/
+
+
+/* ICS configuration structure
+ */
+/******************************************************************************
+* define ICS configuration structure
+*
+*//*! @addtogroup ics_config_type
+* @{
+*******************************************************************************/
+ 
+/*!
+ * @brief ICS configuration type.
+ * @see   OSC_ConfigType
+ */
+typedef struct
+{
+   uint8_t    u8ClkMode;        /*!< clock mode to be switched */
+   uint8_t    bLPEnable;        /*!< low power mode enable */
+   uint32_t   u32ClkFreq;       /*!< reference clock frequency in KHz; use value 32 for 31.25KHz to 39.0625KHz */  
+   OSC_ConfigType  oscConfig;   /*!< OSC configuration */
+} ICS_ConfigType ;
+
+/*! @} End of ics_config_type                                                    					*/
+
+
+   
+/******************************************************************************
+* Global variables
+******************************************************************************/
+
+
+/******************************************************************************
+* define ICS API list
+*
+*//*! @addtogroup ics_api_list
+* @{
+*******************************************************************************/
+
+/*!
+ * inline functions
+ */
+/*****************************************************************************//*!
+*
+* @brief enable interrupt.
+*        
+* @param   none
+*
+* @return none
+* @ Pass/ Fail criteria: none
+* @see    ICS_DisableInt
+*****************************************************************************/
+__STATIC_INLINE void ICS_EnableInt(void)
+{
+    ICS->C4 |= (ICS_C4_LOLIE_MASK);    
+}
+
+/*****************************************************************************//*!
+*
+* @brief disable interrupt.
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+* @see    ICS_EnableInt
+*****************************************************************************/
+__STATIC_INLINE void ICS_DisableInt(void)
+{
+    ICS->C4 &= ~(ICS_C4_LOLIE_MASK);    
+}
+
+/*****************************************************************************//*!
+*
+* @brief enable clock monitor.
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+* @see    ICS_DisableClockMonitor
+*****************************************************************************/
+__STATIC_INLINE void ICS_EnableClockMonitor(void)
+{
+    ICS->C4 |= (ICS_C4_CME_MASK);    
+}
+
+/*****************************************************************************//*!
+*
+* @brief disable clock monitor.
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+* @see    ICS_EnableClockMonitor
+*****************************************************************************/
+__STATIC_INLINE void ICS_DisableClockMonitor(void)
+{
+    ICS->C4 &= ~(ICS_C4_CME_MASK);    
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief set bus divider BDIV bit field.
+   *        
+   * @param[in] busDivide   -- BDIV value
+   * @return  depends on commands
+   * @ Pass/ Fail criteria:  
+   *****************************************************************************/
+__STATIC_INLINE void ICS_SetBusDivider(uint8_t u8BusDivide)
+{
+    ICS->C2 = (ICS->C2 & ~(ICS_C2_BDIV_MASK)) | ICS_C2_BDIV(u8BusDivide);
+}
+/*! @} End of ics_api_list                                                    					*/
+
+
+/******************************************************************************
+* define OSC API list
+*
+*//*! @addtogroup osc_api_list
+* @{
+*******************************************************************************/
+
+
+/*****************************************************************************//*!
+*
+* @brief enable OSC.
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void OSC_Enable(void)
+{
+    OSC->CR |= (OSC_CR_OSCEN_MASK);    
+}
+
+/*****************************************************************************//*!
+*
+* @brief disable OSC.
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void OSC_Disable(void)
+{
+    OSC->CR &= ~(OSC_CR_OSCEN_MASK);    
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief set low range of oscillator.
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void OSC_SetLowRange(void)
+{
+    OSC->CR &= ~(OSC_CR_RANGE_MASK);    
+}
+
+/*!***************************************************************************//*!
++FUNCTION----------------------------------------------------------------
+* @function name: OSC_SetHighRange
+*
+* @brief set high range of oscillator
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void OSC_SetHighRange(void)
+{
+    OSC->CR |= (OSC_CR_RANGE_MASK);    
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief set high gain of oscillator.
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void OSC_SetHighGain(void)
+{
+    OSC->CR |= (OSC_CR_HGO_MASK);    
+}
+
+/*****************************************************************************//*!
+*
+* @brief set low gain of oscillator.
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void OSC_SetLowGain(void)
+{
+    OSC->CR &= ~(OSC_CR_HGO_MASK);    
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief select crystal as clock source.
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void OSC_SelectCrystal(void)
+{
+    OSC->CR |= (OSC_CR_OSCOS_MASK);    
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief select active clock as clock source
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void OSC_SelectClock(void)
+{
+    OSC->CR &= ~(OSC_CR_OSCOS_MASK);    
+}
+
+/*****************************************************************************//*!
+*
+* @brief enable OSC in stop mode.
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void OSC_ActiveInStop(void)
+{
+    OSC->CR |= (OSC_CR_OSCSTEN_MASK);    
+}
+
+/*****************************************************************************//*!
+*
+* @brief disable OSC in stop mode.
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void OSC_InactiveInStop(void)
+{
+    OSC->CR &= ~(OSC_CR_OSCSTEN_MASK);    
+}
+
+/*! @} End of osc_api_list                                                    					*/
+
+
+/******************************************************************************
+* Global functions
+******************************************************************************/
+
+void ICS_Init(ICS_ConfigType *pConfig);
+void ICS_DeInit(void);
+void ICS_SetClkDivider(uint32_t u32ClkFreqKHz);
+void ICS_Trim(uint16 u16TrimValue);
+void OSC_Init(OSC_ConfigType *pConfig);
+void OSC_DeInit(void);
+
+/* inline functions */
+void ICS_DisableClockMonitor(void);
+void ICS_DisableInt(void);
+void ICS_EnableClockMonitor(void);
+void ICS_EnableInt(void);
+void ICS_SetBusDivider(uint8_t u8BusDivide);
+void OSC_ActiveInStop(void);
+void OSC_Enable(void);
+void OSC_Disable(void);
+void OSC_InactiveInStop(void);
+void OSC_SelectClock(void);
+void OSC_SelectCrystal(void);
+void OSC_SetHighGain(void);
+void OSC_SetHighRange(void);
+void OSC_SetLowGain(void);
+void OSC_SetLowRange(void);
+
+/* do not touch the following functions */
+void FEI_to_FEE(ICS_ConfigType *pConfig);
+void FEI_to_FBI(ICS_ConfigType *pConfig);
+void FEI_to_FBE(ICS_ConfigType *pConfig);
+void FEE_to_FBI(ICS_ConfigType *pConfig);
+void FEE_to_FEI(ICS_ConfigType *pConfig);
+void FEE_to_FBE(ICS_ConfigType *pConfig);
+void FBE_to_FEE(ICS_ConfigType *pConfig);
+void FBE_to_FEI(ICS_ConfigType *pConfig);
+void FBE_to_FBI(ICS_ConfigType *pConfig);
+void FBE_to_FBELP(ICS_ConfigType *pConfig);
+void FBI_to_FEI(ICS_ConfigType *pConfig);
+void FBI_to_FBE(ICS_ConfigType *pConfig);
+void FBI_to_FEE(ICS_ConfigType *pConfig);
+void FBI_to_FBILP(ICS_ConfigType *pConfig);
+void FBILP_to_FBI(ICS_ConfigType *pConfig);
+void FBELP_to_FBE(ICS_ConfigType *pConfig);
+void FEI_to_FBE_OSC(ICS_ConfigType *pConfig);
+void FEI_to_FEE_OSC(ICS_ConfigType *pConfig);
+#ifdef __cplusplus
+}
+#endif
+#endif /* ICS_H_ */
diff --git a/bsp/frdm-ke02/device/lib/inc/io.h b/bsp/frdm-ke02/device/lib/inc/io.h
new file mode 100755
index 0000000..9886d69
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/io.h
@@ -0,0 +1,58 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file io.h
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief provide serial Input/Output routines. 
+*
+*******************************************************************************/
+
+#ifndef _IO_H
+#define _IO_H
+
+/********************************************************************/
+
+char	
+in_char(void);
+
+void
+out_char(char);
+
+int
+char_present(void);
+
+int		
+printf(const char *, ... );
+
+int
+sprintf(char *, const char *, ... );
+
+
+/********************************************************************/
+
+#endif
diff --git a/bsp/frdm-ke02/device/lib/inc/kbi.h b/bsp/frdm-ke02/device/lib/inc/kbi.h
new file mode 100755
index 0000000..dc84491
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/kbi.h
@@ -0,0 +1,456 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file kbi.h
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief header file for KBI. 
+*
+*******************************************************************************
+*
+* provide APIs for accessing KBI
+******************************************************************************/
+#ifndef _KBI_H_
+#define _KBI_H_
+#ifdef __cplusplus
+extern "C" {
+#endif
+/******************************************************************************
+* Includes
+******************************************************************************/
+
+/******************************************************************************
+* Constants
+******************************************************************************/
+
+/*!
+* @brief KBI MODE select enum.
+*
+*/
+typedef enum
+{
+    KBI_MODE_EDGE_ONLY = 0,             /*!< select  edge only mode  */         
+    KBI_MODE_EDGE_LEVEL                 /*!< select  both edge and level  mode */
+}KBI_ModeType;
+
+
+ /*!
+ * @brief KBI Edge select enum.
+ *
+ */
+typedef enum
+{
+    KBI_FALLING_EDGE_LOW_LEVEL = 0,     /*!< select falling edge and/or low level  */
+    KBI_RISING_EDGE_HIGH_LEVEL          /*!< select rising edge and/or high level  */
+}KBI_EdgeType;
+
+
+/******************************************************************************
+* Macros
+******************************************************************************/
+
+/******************************************************************************
+* KBI module max number and port pins definition
+*
+*//*! @addtogroup kbi_macro
+* @{
+*******************************************************************************/
+#define KBI_MAX_NO              2                  /*!< max number of modules */
+
+#if defined(CPU_KE02)|| defined(CPU_KE04)
+   #define KBI_MAX_PINS_PER_PORT   8                  /*!< max number of pins */
+#elif defined(CPU_KE06)
+   #define KBI_MAX_PINS_PER_PORT   32                  /*!< max number of pins */
+#endif
+/*! @} End of kbi_macro                                                    */
+
+
+/******************************************************************************
+* Types
+******************************************************************************/
+
+/*! @brief KBI_CALLBACK function declaration                                  */
+typedef void (*KBI_CallbackType)(void);                     
+/*! @} End of kbi_callback                                                    */
+
+
+
+/******************************************************************************
+* KBI pin config struct
+*
+*//*! @addtogroup kbi_pinconfigstruct
+* @{
+*******************************************************************************/
+/*!
+* @brief KBI pin enable and edge select struct.
+*
+*/
+
+typedef struct
+{
+    uint8_t     bEdge   : 1;                                /*!< edge/level select bit */
+    uint8_t     bEn     : 1;                                /*!< pin enable bit */
+    uint8_t     bRsvd   : 6;                                /*!< reserved */
+} KBI_PinConfigType;
+/*! @} End of kbi_pinconfigstruct                                             */
+
+
+/******************************************************************************
+* KBI config struct
+*
+*//*! @addtogroup kbi_configstruct
+* @{
+*******************************************************************************/
+/*!
+ * @brief KBI status and control struct.
+ *
+ */
+
+typedef struct
+{
+#if defined(CPU_KE02)|| defined(CPU_KE04)
+    struct
+    {
+        uint8_t     bMode   : 1;                            /*!< KBI detection mode select */
+        uint8_t     bIntEn  : 1;                            /*!< KBI interrupt enable bit */
+        uint8_t     bRsvd   : 6;                            /*!< reserved */
+    } sBits;
+#elif  defined(CPU_KE06)
+    struct
+    {
+        uint32_t     bMode   : 1;                            /*!< KBI detection mode select */
+        uint32_t     bIntEn  : 1;                            /*!< KBI interrupt enable bit */
+        uint32_t     bRsvd2  : 2;                           /*!< reserved */
+        uint32_t     bKbspEn : 1;							  /*!<Real KBI_SP register enable*/
+		uint32_t     bRstKbsp: 1;                            /*!<Reset KBI_SP register*/
+        uint32_t     bRsvd26 : 26;                           /*!< reserved */
+    } sBits;
+#endif
+    KBI_PinConfigType   sPin[KBI_MAX_PINS_PER_PORT];
+} KBI_ConfigType, *KBI_ConfigTypePtr;
+/*! @} End of kbi_configstruct                                                */
+
+/******************************************************************************
+* Global variables
+******************************************************************************/
+/*!
+ * inline functions
+ */
+/******************************************************************************
+* KBI api list
+*
+*//*! @addtogroup kbi_api_list
+* @{
+*******************************************************************************/
+/*****************************************************************************//*!
+*
+* @brief set detect falling edge only.
+*        
+* @param[in]   pKBI          pointer to KBI module.
+* @param[in]   PinMasks      indicate pin numbers.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see KBI_DetectRisingEdge.
+*
+*****************************************************************************/
+#if defined(CPU_KE02)|| defined(CPU_KE04)
+__STATIC_INLINE  void KBI_DetectFallingEdge(KBI_Type *pKBI, uint8_t PinMasks)
+#elif defined(CPU_KE06)
+__STATIC_INLINE  void KBI_DetectFallingEdge(KBI_Type *pKBI, uint32_t PinMasks)
+#endif
+{
+    pKBI->SC &= ~KBI_SC_KBMOD_MASK;
+    pKBI->ES &= ~(PinMasks);
+}
+
+/*****************************************************************************//*!
+*
+* @brief set detect falling edge only.
+*        
+* @param[in]   pKBI         pointer to KBI module.
+* @param[in]   PinMasks     indicate pin numbers.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see KBI_DetectFallingEdge.
+*
+*****************************************************************************/
+#if defined(CPU_KE02)|| defined(CPU_KE04)
+__STATIC_INLINE  void KBI_DetectRisingEdge(KBI_Type *pKBI, uint8_t PinMasks)
+#elif defined(CPU_KE06)
+__STATIC_INLINE  void KBI_DetectRisingEdge(KBI_Type *pKBI, uint32_t PinMasks)
+#endif
+{
+    pKBI->SC &= ~KBI_SC_KBMOD_MASK;
+    pKBI->ES |= (PinMasks);    
+}
+
+/*****************************************************************************//*!
+*
+* @brief set detect falling edge only.
+*        
+* @param[in]   pKBI         pointer to KBI module.
+* @param[in]   PinMasks     indicate pin number/mask.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see KBI_DetectFallingEdgeLowLevel.
+*
+*****************************************************************************/
+#if defined(CPU_KE02)|| defined(CPU_KE04)
+__STATIC_INLINE  void KBI_DetectRisingEdgeHighLevel(KBI_Type *pKBI, uint8_t PinMasks)
+#elif defined(CPU_KE06)
+__STATIC_INLINE  void KBI_DetectRisingEdgeHighLevel(KBI_Type *pKBI, uint32_t PinMasks)
+#endif
+{
+    pKBI->SC |= KBI_SC_KBMOD_MASK;
+    pKBI->ES |= (PinMasks);    
+}
+
+/*****************************************************************************//*!
+*
+* @brief set detect falling edge only.
+*        
+* @param[in]   pKBI         pointer to KBI module.
+* @param[in]   PinMasks     indicate pin number/mask.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see KBI_DetectRisingEdgeHighLevel.
+*
+*****************************************************************************/
+#if defined(CPU_KE02)|| defined(CPU_KE04)
+__STATIC_INLINE  void KBI_DetectFallingEdgeLowLevel(KBI_Type *pKBI, uint8_t PinMasks)
+#elif defined(CPU_KE06)
+__STATIC_INLINE  void KBI_DetectFallingEdgeLowLevel(KBI_Type *pKBI, uint32_t PinMasks)
+#endif
+{
+    pKBI->SC |= KBI_SC_KBMOD_MASK;
+    pKBI->ES &= ~(PinMasks);        
+}
+
+/*****************************************************************************//*!
+*
+* @brief enable the pin specified.
+*        
+* @param[in]   pKBI         pointer to KBI module.
+* @param[in]   PinMasks     indicate pin number/mask.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see KBI_Disable.
+*
+*****************************************************************************/
+#if defined(CPU_KE02)|| defined(CPU_KE04)
+__STATIC_INLINE  void KBI_Enable(KBI_Type *pKBI, uint8_t PinMasks)
+#elif defined(CPU_KE06)
+__STATIC_INLINE  void KBI_Enable(KBI_Type *pKBI, uint32_t PinMasks)
+#endif
+{
+    pKBI->PE |= (PinMasks);        
+}
+
+/*****************************************************************************//*!
+*
+* @brief disable the pin specified.
+*        
+* @param[in]   pKBI         pointer to KBI module.
+* @param[in]   PinMasks     indicate pin number/mask.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see KBI_Enable.
+*
+*****************************************************************************/
+#if defined(CPU_KE02)|| defined(CPU_KE04)
+__STATIC_INLINE  void KBI_Disable(KBI_Type *pKBI, uint8_t PinMasks)
+#elif defined(CPU_KE06)
+__STATIC_INLINE  void KBI_Disable(KBI_Type *pKBI, uint32_t PinMasks)
+#endif
+{
+    pKBI->PE &= ~(PinMasks);        
+}
+
+/*****************************************************************************//*!
+*
+* @brief enable the corresponding interrupt.
+*        
+* @param[in]   pKBI         pointer to KBI module.
+*          
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see KBI_DisableInt.
+*
+*****************************************************************************/
+__STATIC_INLINE  void KBI_EnableInt(KBI_Type *pKBI)
+{
+    pKBI->SC |= KBI_SC_KBIE_MASK;        
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief disable the corresponding interrupt.
+*        
+* @param[in]  pKBI         pointer to KBI module.
+*          
+* @return none.
+*
+* @ Pass/ Fail criteria: none
+*
+* @see KBI_EnableInt.
+*
+*****************************************************************************/
+__STATIC_INLINE  void KBI_DisableInt(KBI_Type *pKBI)
+{
+    pKBI->SC &= ~KBI_SC_KBIE_MASK;        
+}
+
+/*****************************************************************************//*!
+*
+* @brief Get the corresponding status flag bits.
+*        
+* @param[in]   pKBI         pointer to KBI module.
+*          
+* @return uint8_t.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see KBI_ClrFlags.
+*
+*****************************************************************************/
+#if defined(CPU_KE02)|| defined(CPU_KE04)
+__STATIC_INLINE  uint8_t KBI_GetFlags(KBI_Type *pKBI)
+#elif defined(CPU_KE06)
+__STATIC_INLINE  uint32_t KBI_GetFlags(KBI_Type *pKBI)
+#endif
+{
+    return (pKBI->SC & KBI_SC_KBF_MASK);        
+}
+
+/*****************************************************************************//*!
+*
+* @brief clear the corresponding status flag bits.
+*        
+* @param[in]   pKBI         pointer to KBI module
+*          
+* @return none.
+*
+* @ Pass/ Fail criteria: none
+*
+* @see KBI_GetFlags.
+*
+*****************************************************************************/
+__STATIC_INLINE  void KBI_ClrFlags(KBI_Type *pKBI)
+{
+    pKBI->SC |= KBI_SC_KBACK_MASK;        
+}
+
+#if defined(CPU_KE06)
+/*****************************************************************************//*!
+*
+* @brief Real KBI_SP register enable.
+*        
+* @param[in]   pKBI         pointer to KBI module
+*          
+* @return none.
+*
+* @ Pass/ Fail criteria: none
+*
+* @see The real time value of Keyboard source pin to be read.
+*
+*****************************************************************************/
+__STATIC_INLINE  void KBI_SPEnable(KBI_Type *pKBI)
+{
+    pKBI->SC |= KBI_SC_KBSPEN_MASK;        
+}
+
+/*****************************************************************************//*!
+*
+* @brief Get KBI source pin register fields.
+*        
+* @param[in]   pKBI         pointer to KBI module.
+*          
+* @return uint32_t.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see KBI_GetSP.
+*
+*****************************************************************************/
+__STATIC_INLINE  uint32_t KBI_GetSP(KBI_Type *pKBI)
+{
+    return (pKBI->SP & KBI_SP_SP_MASK);        
+}
+
+/*****************************************************************************//*!
+*
+* @brief Reset KBI_SP register.
+*        
+* @param[in]   pKBI         pointer to KBI module
+*          
+* @return none.
+*
+* @ Pass/ Fail criteria: none
+*
+* @see KBI_RstSP.
+*
+*****************************************************************************/
+__STATIC_INLINE  void KBI_RstSP(KBI_Type *pKBI)
+{
+    pKBI->SC |= KBI_SC_RSTKBSP_MASK;        
+}
+#endif
+
+/*! @} End of kbi_api_list                                                  */
+
+/******************************************************************************
+* Global functions
+******************************************************************************/
+
+void KBI_Init(KBI_Type *pKBI, KBI_ConfigType *pConfig);
+void KBI_SetCallback(KBI_Type *pKBI, KBI_CallbackType pfnCallback);
+
+#ifdef __cplusplus
+}
+#endif
+#endif 
diff --git a/bsp/frdm-ke02/device/lib/inc/ke02_config.h b/bsp/frdm-ke02/device/lib/inc/ke02_config.h
new file mode 100755
index 0000000..c4a4b51
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/ke02_config.h
@@ -0,0 +1,187 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file kexx_config.h
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun 25, 2013
+*
+* @brief library and board configuration code. 
+*
+*******************************************************************************
+*
+* NOTE:
+*	printf call may occupy a lot of memory (around 1924 bytes), so please
+*	consider your code size before using printf.
+******************************************************************************/
+
+#ifndef _KExx_CONFIG_H_
+#define _KExx_CONFIG_H_
+
+/******************************************************************************
+* Includes
+******************************************************************************/
+#include <stdint.h>
+/******************************************************************************
+* Constants
+******************************************************************************/
+
+/******************************************************************************
+* Macros
+******************************************************************************/
+
+
+//#define     TEST_ON_EVB           /*!< if running on freedom board, this line must be commented */
+#define TRIM_IRC                    /*!< trim internal reference clock */
+#define SPI0_PINREMAP               /*!< remap SPI0 pins to alternative pins */
+
+/*! define print system log */      
+/* NOTE: for RAM version, comment it */
+//#define PRINT_SYS_LOG             /*!< this macro prints system log information */
+
+#if     !defined(BOOT_LOADER)
+    //#define PRINT_SYS_LOG           /*!< this macro prints system log information */
+#endif
+
+/* define output bus clock */
+//#define OUTPUT_BUSCLK             /*!< this macro allows output of bus clock */
+#define ICS_TRIM_VALUE  0x4C        /*!< trim IRC to 39.0625KHz and FLL output=40MHz */
+
+#if defined(TEST_ON_EVB)
+
+    /*! define what clock mode at startup on EVB board
+     * if USE_FEE is not defined by commenting out the following line, 
+     * then it will use FEI mode which is default mode 
+     * after reset  
+     */
+    //#define USE_FEE                       /*!< use FEE clock mode */
+    #define USE_FEE_OSC                     /*!< use FEE clock mode with external active oscillator */
+    //#define USE_FEI                       /*!< use FEI clock mode */
+
+    /* define external crystal frequency */
+    //#define EXT_CLK_FREQ_KHZ	32          /* in KHz */
+    //#define EXT_CLK_FREQ_KHZ	4000        /* in KHz */
+    #define EXT_CLK_FREQ_KHZ	8000        /* in KHz */
+    //#define EXT_CLK_FREQ_KHZ	10000       /* in KHz */
+
+    //#define CRYST_HIGH_GAIN
+    //#define XOSC_STOP_ENABLE
+
+    /* define SCI port # to be used */
+    #define TERM_PORT   UART0               /*!< UART0 is used on KE02 EVB board */
+
+#else
+    /*! define what clock mode at startup on freedom board
+     * if USE_FEE is not defined by commenting out the following line, 
+     * then it will use FEI mode which is default mode 
+     * after reset.  
+     */
+    #define USE_FEE                         /*!< use FEE clock mode */
+    //#define USE_FEE_OSC                   /*!< use FEE clock mode with external active oscillator */
+    //#define USE_FEI                       /*!< use FEI clock mode */
+
+    /*! define external crystal frequency. */
+    //#define EXT_CLK_FREQ_KHZ	32          /* in KHz */
+    //#define EXT_CLK_FREQ_KHZ	4000        /* in KHz */
+    //#define EXT_CLK_FREQ_KHZ	8000        /* in KHz */
+    #define EXT_CLK_FREQ_KHZ	10000       /* in KHz */
+
+    /*! define UART port # to be used */
+    #define TERM_PORT   UART1               /*!< UART1 is used on KE02 freedom board */
+
+#endif
+
+    /* define BUS clock in HZ */
+    #if	defined(USE_FEI)
+        #define  BUS_CLK_HZ		20000000L
+    #elif  (EXT_CLK_FREQ_KHZ == 20000)
+        #define  BUS_CLK_HZ		20000000L
+    #elif  (EXT_CLK_FREQ_KHZ == 10000)
+        #define  BUS_CLK_HZ		20000000L
+    #elif  (EXT_CLK_FREQ_KHZ == 8000)
+        #define  BUS_CLK_HZ		16000000L
+    #elif  (EXT_CLK_FREQ_KHZ == 4000)
+        #define  BUS_CLK_HZ		16000000L
+    #elif  (EXT_CLK_FREQ_KHZ == 32)
+        #define  BUS_CLK_HZ		16777216L
+    #else   
+        #define  BUS_CLK_HZ		20000000L
+    #endif
+
+    /*! define UART baud rate */
+    #define UART_PRINT_BITRATE              115200      /*! UART bit rate */
+
+/*! USER LED definitions */
+/*! LED maps 
+ * code	        KE02
+ * RED   <----> PTH1
+ * GREEN <----> PTH2
+ * BLUE  <----> PTE7
+ *  
+ */
+#define LED0_Init()            	GPIOB->PDDR |= (1<<25)    /*! RED Light */
+#define LED0_Toggle()           GPIOB->PTOR = (1<<25)
+#define LED0_On()               GPIOB->PCOR = (1<<25)
+#define LED0_Off()              GPIOB->PSOR = (1<<25)
+
+#define LED1_Init()            	GPIOB->PDDR |= (1<<26)    /*! Green */
+#define LED1_Toggle()           GPIOB->PTOR = (1<<26)
+#define LED1_On()               GPIOB->PCOR = (1<<26)
+#define LED1_Off()              GPIOB->PSOR = (1<<26)
+
+#define LED2_Init()            	GPIOB->PDDR |= (1<<7)     /*! Blue */
+#define LED2_Toggle()           GPIOB->PTOR = (1<<7)
+#define LED2_On()               GPIOB->PCOR = (1<<7)
+#define LED2_Off()              GPIOB->PSOR = (1<<7)
+
+#define RED_Init()              LED0_Init()
+#define RED_Set()               LED0_Off()
+#define RED_Clear()             LED0_On()
+#define RED_Toggle()            LED0_Toggle()
+
+#define GREEN_Init()            LED1_Init()
+#define GREEN_Set()             LED1_Off()
+#define GREEN_Clear()           LED1_On()
+#define GREEN_Toggle()          LED1_Toggle()
+
+#define BLUE_Init()             LED2_Init()
+#define BLUE_Set()              LED2_Off()
+#define BLUE_Clear()            LED2_On()
+#define BLUE_Toggle()           LED2_Toggle()
+
+/******************************************************************************
+* Types
+******************************************************************************/
+
+
+/******************************************************************************
+* Global variables
+******************************************************************************/
+
+/******************************************************************************
+* Global functions
+******************************************************************************/
+
+#endif /* _KExx_CONFIG_H_ */
diff --git a/bsp/frdm-ke02/device/lib/inc/memtest.h b/bsp/frdm-ke02/device/lib/inc/memtest.h
new file mode 100755
index 0000000..2795065
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/memtest.h
@@ -0,0 +1,60 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file memtest.h
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief provide general-purpose memory testing functions. 
+*
+*******************************************************************************/
+
+#ifndef _memtest_h
+#define _memtest_h
+
+
+/*
+ * Define NULL pointer value.
+ */
+#ifndef NULL
+#define NULL  (void *) 0
+#endif
+
+/*
+ * Set the data bus width.
+ */
+typedef unsigned long datum;
+
+/*
+ * Function prototypes.
+ */
+datum   memTestDataBus(volatile datum * address);
+datum * memTestAddressBus(volatile datum * baseAddress, unsigned long nBytes);
+datum * memTestDevice(volatile datum * baseAddress, unsigned long nBytes);
+
+
+#endif /* _memtest_h */
+
diff --git a/bsp/frdm-ke02/device/lib/inc/mscan.h b/bsp/frdm-ke02/device/lib/inc/mscan.h
new file mode 100755
index 0000000..ccb7054
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/mscan.h
@@ -0,0 +1,1671 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file mscan.h
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Oct. 25, 2013
+*
+* @brief header file for MSCAN module utilities (MSCAN). 
+*
+*******************************************************************************
+*
+* provide APIs for accessing MSCAN module (MSCAN)
+******************************************************************************/
+#ifndef _MSCAN_H__
+#define _MSCAN_H__
+#ifdef __cplusplus
+extern "C" {
+#endif
+/******************************************************************************
+* Global variables
+******************************************************************************/
+
+/******************************************************************************
+* Constants and macros
+******************************************************************************/
+/******************************************************************************
+* define MSCAN Data Buffer Frame status
+*
+*//*! @addtogroup data_buffer_frame_list
+* @{
+*******************************************************************************/
+#define BUFFER_FRAME_INVALID				0x00	/*!< data frame is invalid */
+#define BUFFER_FRAME_VALID					0x55	/*!< data frame is valid */
+/*! @} End of data_buffer_frame_list							*/
+
+
+/******************************************************************************
+* define MSCAN baud rate 
+*
+*//*! @addtogroup baud_rate_list
+* @{
+*******************************************************************************/
+#define BAUD_RATE_SJW             	SJW_3TQ	/*!< 1 set Synchronization Jump Width. */
+#define BAUD_RATE_BRP				0		/*!< 1 Baud Rate Prescaler */	
+#define BAUD_RATE_SAMP				0		/*!< 0-One sample per bit, 1-three sample per bit. */	
+#define BAUD_RATE_TSEG1				TSEG_10  /*!< Time Segment 1*/
+#define BAUD_RATE_TSEG2				TSEG_7  /*!< Time Segment 2*/
+#define BAUD_RATE_CLOCK				8000000L/*!< clock source for MSCAN*/
+#define Baud_RATE					BAUD_RATE_CLOCK/(BAUD_RATE_BRP+1)/\
+									(BAUD_RATE_SJW+1)/(3 + BAUD_RATE_TSEG1+\
+									BAUD_RATE_TSEG2)
+/*! @} End of baud_rate_list													*/
+
+/******************************************************************************
+* define MSCAN receiver and transmitter buffer length
+*
+*//*! @addtogroup can_buffer_length_list
+* @{
+*******************************************************************************/
+#define MSCAN_RX_BUFFER_LENGTH			5		/*!< 5 buffer for mscan receiver*/
+#define MSCAN_TX_BUFFER_LENGTH			3		/*!< 5 buffer for mscan transmitter*/
+
+/*! @} End of can_buffer_length_list    */
+
+
+/******************************************************************************
+* define MSCAN Synchronization Jump Width
+*
+*//*! @addtogroup Syn_Jump_Width_list
+* @{
+*******************************************************************************/
+#define SJW_1TQ                        0x00			/*!< 1 Tq clock cycle. */
+#define SJW_2TQ                        0x01			/*!< 2 Tq clock cycle. */
+#define SJW_3TQ                        0x02			/*!< 3 Tq clock cycle. */
+#define SJW_4TQ                        0x03			/*!< 4 Tq clock cycle. */
+
+/*! @} End of Syn_Jump_Width_list                                             		*/
+
+
+
+/******************************************************************************
+* define Time Segment
+*
+*//*! @addtogroup Time_Segment_list
+* @{
+*******************************************************************************/
+#define TSEG_1						   0x00			/*!< 1 Tq clock cycle. */
+#define TSEG_2						   0x01			/*!< 2 Tq clock cycle. */
+#define TSEG_3						   0x02			/*!< 3 Tq clock cycle. */
+#define TSEG_4						   0x03			/*!< 4 Tq clock cycle. */
+#define TSEG_5						   0x04			/*!< 5 Tq clock cycle. */
+#define TSEG_6						   0x05			/*!< 6 Tq clock cycle. */
+#define TSEG_7						   0x06			/*!< 7 Tq clock cycle. */
+#define TSEG_8						   0x07			/*!< 8 Tq clock cycle. */
+#define TSEG_9						   0x08			/*!< 9 Tq clock cycle. */
+#define TSEG_10						   0x09			/*!< 10 Tq clock cycle. */
+#define TSEG_11						   0x0a			/*!< 11 Tq clock cycle. */
+#define TSEG_12						   0x0b			/*!< 12 Tq clock cycle. */
+#define TSEG_13						   0x0c			/*!< 13 Tq clock cycle. */
+#define TSEG_14						   0x0d			/*!< 14 Tq clock cycle. */
+#define TSEG_15						   0x0e			/*!< 15 Tq clock cycle. */
+#define TSEG_16						   0x0f			/*!< 16 Tq clock cycle. */
+
+/*! @} End of Time_Segment_list                                             		*/
+
+
+/******************************************************************************
+* define MSCAN Receiver Status
+*
+*//*! @addtogroup can_receiver_status_list
+* @{
+*******************************************************************************/
+#define RECEIVER_STATUS_RXOK	0<<4		/*!<0receive error counter<96*/
+#define RECEIVER_STATUS_RXWRN	1<<4		/*!<96receive error counter<128*/
+#define RECEIVER_STATUS_RXERR	2<<4		/*!<128receive error counter*/
+#define RECEIVER_STATUS_RXBUS_OFF	3<<4	/*!<256transmit error counter1*/
+
+/*! @} End of can_receiver_status_list                                             		*/
+
+/******************************************************************************
+* define MSCAN Transmitter Status
+*
+*//*! @addtogroup can_transmitter_status_list
+* @{
+*******************************************************************************/
+#define TRANSMITTER_STATUS_TXOK			0<<2		/*!<0transmit error counter<96*/
+#define TRANSMITTER_STATUS_TXWRN		1<<2		/*!<96transmit error counter<128*/
+#define TRANSMITTER_STATUS_TXERR		2<<2		/*!<128transmit error counter*/
+#define TRANSMITTER_STATUS_TXBUS_OFF	3<<2		/*!<256transmit error counter1*/
+
+/*! @} End of can_transmitter_status_list                                              */
+
+/******************************************************************************
+* define MSCAN Transmitter Buffer Empty Flag
+*
+*//*! @addtogroup can_transmitter_buffer_empty_flag_list
+* @{
+*******************************************************************************/
+#define TRANSMITTER_TX0_EMPTY			1<<0		/*!<transmitter 0 empty*/
+#define TRANSMITTER_TX1_EMPTY			1<<1		/*!<transmitter 1 empty*/
+#define TRANSMITTER_TX2_EMPTY			1<<2		/*!<transmitter 2 empty*/
+#define TRANSMITTER_TX_NO_EMPTY			0			/*!<all transmitter are not empty*/
+
+/*! @} End of can_transmitter_buffer_empty_flag_list                                             	*/
+/******************************************************************************
+* define MSCAN Transmitter Empty Interrupt Enable
+*
+*//*! @addtogroup can_transmitter_empty_int_list
+* @{
+*******************************************************************************/
+#define TRANSMITTER_TX0_EMPTY_INT_EN	1<<0		/*!<transmitter 0 empty interrupt enable*/
+#define TRANSMITTER_TX1_EMPTY_INT_EN	1<<1		/*!<transmitter 1 empty interrupt enable*/
+#define TRANSMITTER_TX2_EMPTY_INT_EN	1<<2		/*!<transmitter 2 empty interrupt enable*/
+
+/*! @} End of can_transmitter_empty_int_list                                             	*/
+/******************************************************************************
+* define MSCAN Transmitter Message Abort Request
+*
+*//*! @addtogroup can_transmitter_message_abort_list
+* @{
+*******************************************************************************/
+#define TRANSMITTER_TX0_REQEST_ABORT	1<<0		/*!<request transmitter 0 to be aborted*/
+#define TRANSMITTER_TX1_REQEST_ABORT	1<<1		/*!<request transmitter 1 to be aborted*/
+#define TRANSMITTER_TX2_REQEST_ABORT	1<<2		/*!<request transmitter 2 to be aborted*/
+
+/*! @} End of can_transmitter_message_abort_list                                             	*/
+/******************************************************************************
+* define MSCAN Transmitter Message Abort Acknowledge
+*
+*//*! @addtogroup can_transmitter_message_abort_flag_list
+* @{
+*******************************************************************************/
+#define TRANSMITTER_TX0_ABORT_FLAG	1<<0		/*!<transmitter 0 to be aborted*/
+#define TRANSMITTER_TX1_ABORT_FLAG	1<<1		/*!<transmitter 1 to be aborted*/
+#define TRANSMITTER_TX2_ABORT_FLAG	1<<2		/*!<transmitter 2 to be aborted*/
+
+/*! @} End of can_transmitter_message_abort_flag_list                                             	*/
+/******************************************************************************
+* define MSCAN Identifier Acceptance Mode
+*
+*//*! @addtogroup can_identifier_acceptance_mode_list
+* @{
+*******************************************************************************/
+#define ID_ACCEPT_MODE_TWO32    	0<<4		/*!<Two 32-bit acceptance filters*/
+#define ID_ACCEPT_MODE_FOUR16    	1<<4		/*!<Four 16-bit acceptance filters*/
+#define ID_ACCEPT_MODE_EIGHT8    	2<<4		/*!<Eight 8-bit acceptance filters*/
+#define ID_ACCEPT_MODE_FILTER_CLOSE 3<<4		/*!<Filter closed*/
+
+/*! @} End of can_identifier_acceptance_mode_list                                             	*/
+
+/******************************************************************************
+* define MSCAN Identifier Acceptance Hit Indicator
+*
+*//*! @addtogroup can_identifier_acceptance_hit_list
+* @{
+*******************************************************************************/
+#define ID_ACCEPT_FILTER0_HIT    	0		/*!<Filter 0 hit*/
+#define ID_ACCEPT_FILTER1_HIT    	1		/*!<Filter 1 hit*/
+#define ID_ACCEPT_FILTER2_HIT    	2		/*!<Filter 2 hit*/
+#define ID_ACCEPT_FILTER3_HIT    	3		/*!<Filter 3 hit*/
+#define ID_ACCEPT_FILTER4_HIT    	4		/*!<Filter 4 hit*/
+#define ID_ACCEPT_FILTER5_HIT    	5		/*!<Filter 5 hit*/
+#define ID_ACCEPT_FILTER6_HIT    	6		/*!<Filter 6 hit*/
+#define ID_ACCEPT_FILTER7_HIT    	7		/*!<Filter 7 hit*/
+
+/*! @} End of can_identifier_acceptance_mode_list                                             	*/
+
+
+/******************************************************************************
+* Local types
+******************************************************************************/
+
+/******************************************************************************
+* Local function prototypes
+******************************************************************************/
+
+/******************************************************************************
+* Local variables
+******************************************************************************/
+
+
+/******************************************************************************
+*
+*//*! @addtogroup mscan_setting_type
+* @{
+*******************************************************************************/
+/*!
+ * @brief MSCAN setting type.
+ *
+ */
+typedef struct
+{
+	uint16_t bStopEn        :1;     			/*!< 1: The module ceases to be clocked during wait mode. */
+	uint16_t bTimerEn       :1;    				/*!< Enable internal MSCAN timer for timer stamp */
+	uint16_t bWakeUpEn      :1;     			/*!< MSCAN wake up enable */
+	uint16_t bCanEn		    :1;     			/*!< MSCAN Enable */
+	uint16_t bCLKSRC	    :1;     			/*!< MSCAN Clock Source, bus clock or oscillator clock*/
+	uint16_t bLoopModeEn    :1;     			/*!< Loopback Self Test Mode */
+	uint16_t bWUPM	        :1;     			/*!< WakeUp Mode */
+	uint16_t bListenModeEn  :1;     			/*!< enable Listen Only Mode */
+	uint16_t bWakeUpIEn		:1;    				/*!< WakeUp Interrupt Enable */
+	uint16_t bStatusChangeIEn:1;  				/*!< CAN Status Change Interrupt Enable */
+	uint16_t bRxStatusChangeIEn:1;  			/*!< CAN receive Status Change Interrupt Enable */
+	uint16_t bTxStatusChangeIEn:1;  			/*!< CAN transmitter Status Change Interrupt Enable */
+    uint16_t bOverRunIEn    :1;					/*!< Overrun Interrupt Enable */
+    uint16_t bRxFullIEn		:1;					/*!< Receiver Full Interrupt Enable */
+    uint16_t bTxEmptyIEn	:1;					/*!< Transmitter Empty Interrupt Enable */
+    uint16_t bBusOffUser    :1;                 /*!< Bus off recovery mode, 1 - user, 0 - Auto */
+}MSCAN_SettingType;
+/*! @} End of mscan_setting_type                                       						*/
+
+/******************************************************************************
+*
+*//*! @addtogroup mscan_baudrate_setting_type
+* @{
+*******************************************************************************/
+/*!
+ * @brief MSCAN baud rate setting type.
+ *
+ */
+typedef struct
+{
+	uint16_t SJW        :2;     			/*!< Synchronization Jump Width. */
+	uint16_t BRP		:6;					/*!< Baud Rate Prescaler. */
+	uint16_t SAMP       :1;					/*!< Sampling. */
+	uint16_t TSEG2      :3;					/*!< Time Segment 2. */
+	uint16_t TSEG1      :4;					/*!< Time Segment 1. */
+}MSCAN_BaudRateSettingType;
+/*! @} End of mscan_baudrate_setting_type                                       				*/
+
+
+
+/******************************************************************************
+*
+*//*! @addtogroup mscan_config_type
+* @{
+*******************************************************************************/
+/*!
+ * @brief MSCAN configure type.
+ *
+ */
+typedef struct
+{
+    MSCAN_SettingType 			sSetting;			/*!< can setting structure */
+    MSCAN_BaudRateSettingType	sBaudRateSetting; /*!< can baud rate setting structure */
+    uint8_t u8IDARMode;         /*!< Set  Identifier Acceptance Mode */
+    uint8_t u8IDARHit;			/*!< Set  Identifier Acceptance Hit Indicator */
+    uint32_t u32IDAR0;			/*!< MSCAN Identifier Acceptance Register n of First Bank */
+    uint32_t u32IDAR1;			/*!< MSCAN Identifier Acceptance Register n of Second Bank */
+    uint32_t u32IDMR0;			/*!< MSCAN Identifier Mask Register n of First Bank */
+    uint32_t u32IDMR1;			/*!< MSCAN Identifier Mask Register n of Second Bank */
+}MSCAN_ConfigType, *MSCAN_ConfigPtr;
+/*! @} End of mscan_config_type                                             				*/
+
+/******************************************************************************
+*
+*//*! @addtogroup mscan_tx_rx_idr1_type
+* @{
+*******************************************************************************/
+/*!
+ * @brief MSCAN tx and rx IDR1 struct type.
+ *
+ */
+typedef struct
+{
+	uint8_t EID17_15			:3;	/*!< Extended Format Identifier 17-15*/
+	uint8_t R_TEIDE				:1; /*!< ID Extended */
+	uint8_t R_TSRR				:1; /*!< Substitute Remote Request */
+	uint8_t EID20_18_OR_SID2_0	:3;	/*!< Extended Format Identifier 18-20 or standard format bit 0-2*/	
+}MSCAN_IDR1Type;	
+/*! @} End of mscan_tx_rx_idr1_type                                       				*/
+
+
+
+/******************************************************************************
+*
+*//*! @addtogroup mscan_tx_rx_idr3_type
+* @{
+*******************************************************************************/
+/*!
+ * @brief MSCAN tx and rx IDR3 struct type.
+ *
+ */
+typedef struct
+{
+	uint8_t ERTR	:1; /*!< Remote Transmission Request*/
+	uint8_t EID6_0	:7;/*!< Extended Format Identifier 6-0*/
+}MSCAN_IDR3Type;	
+/*! @} End of mscan_tx_rx_idr3_type                                       				*/
+
+/******************************************************************************
+*
+*//*! @addtogroup IDR1_IDR3_union
+* @{
+*******************************************************************************/
+/*!
+ * @brief MSCAN idr1 and idr3 union
+ *
+ */
+typedef union{
+	MSCAN_IDR1Type	IDR1;	/*!< structure for identifier 1 */
+	MSCAN_IDR3Type  IDR3; /*!< structure for identifier 3 */
+	uint8_t Bytes;        /*!< bytes */
+	}IDR1_3_UNION;	
+/*! @} End of IDR1_IDR3_union                                       				*/
+
+
+/******************************************************************************
+*
+*//*! @addtogroup mscan_extend_id_type
+* @{
+*******************************************************************************/
+/*!
+ * @brief MSCAN extend ID struct type.
+ *
+ */
+typedef struct
+{
+	uint32_t EID6_0 	:7;		/*!< ID[0:6] */
+	uint32_t EID14_7	:8;		/*!< ID[14:7] */
+	uint32_t EID17_15   :3;		/*!< ID[17:15] */
+	uint32_t EID20_18  	:3;		/*!< ID[20:18] */
+	uint32_t EID28_21   :8;  	/*!< ID[28:21] */
+	uint32_t Reverse    :3;
+}MSCAN_ExtendIDType;	
+/*! @} End of mscan_extend_id_type                                       				*/
+
+/******************************************************************************
+*
+*//*! @addtogroup mscan_standard_id_type
+* @{
+*******************************************************************************/
+/*!
+ * @brief MSCAN standard ID struct type.
+ *
+ */
+typedef struct
+{
+	uint32_t EID2_0 	:3;		/*!< ID[0:2] */
+	uint32_t EID10_3	:8;		/*!< ID[10:3] */
+	uint32_t Reverse    :21;
+}MSCAN_StandardIDType;	
+/*! @} End of mscan_standard_id_type                                       				*/
+
+
+/******************************************************************************
+*
+*//*! @addtogroup mscan_frame_type
+* @{
+*******************************************************************************/
+/*!
+ * @brief MSCAN frame struct type.
+ *
+ */
+typedef struct
+{
+	union{
+	MSCAN_StandardIDType StandID; /*!< standard format type */
+	MSCAN_ExtendIDType   ExtID;	  /*!< extend format type */
+	uint32_t ID;                  /*!< Identifire with 32 bit format */
+	}ID_Type;											/*!< identifier union */
+	uint8_t DSR[8];               /*!< data segment */
+	uint8_t DLR;									/*!< data length */
+	uint8_t BPR;									/*!< transmit buffer priority */
+	uint8_t bIsRemoteFrame;				/*!< remote frame or not */
+	uint8_t bIsExtOrStand;				/*!< extend frame or not */
+	uint8_t u8TSRH;								/*!< time stamp high byte */
+	uint8_t u8TSRL;								/*!< time stamp low byte */
+}MSCAN_FrameType,*MSCAN_FramePtr;
+/*! @} End of mscan_frame_type                                       				*/
+
+
+/******************************************************************************
+*
+*//*! @addtogroup mscan_register_frame_struct_type
+* @{
+*******************************************************************************/
+/*!
+ * @brief MSCAN register frame struct type, same with register definition.
+ *
+ */
+typedef struct
+{
+	uint8_t EIDR0;							/*!< Extended Identifier Register 0 */
+	uint8_t EIDR1;							/*!< Extended Identifier Register 1 */
+	uint8_t EIDR2;							/*!< Extended Identifier Register 2 */
+	uint8_t EIDR3;							/*!< Extended Identifier Register 3 */
+	uint8_t EDSR[8];						/*!< Extended Data Segment Register */
+	uint8_t DLR;								/*!< data length field */
+	uint8_t BPR;								/*!< Buffer Priority Register */
+	uint8_t TSRH;								/*!< Time Stamp Register High */
+	uint8_t TSRL;								/*!< Time Stamp Register Low */
+}MSCAN_RegisterFrameType,*MSCAN_RegisterFramePtr;
+/*! @} End of mscan_register_frame_struct_type                                 	*/
+
+
+
+/******************************************************************************
+*
+*//*! @addtogroup mscan_callback
+* @{
+*******************************************************************************/
+typedef void (*MSCAN_CallbackType)(void);		/*!< MSCAN call back function */
+/*! @} End of mscan_callback                                             						*/
+
+/******************************************************************************
+* inline functions
+******************************************************************************/
+/******************************************************************************
+*
+*//*! @addtogroup mscan_api_list
+* @{
+*******************************************************************************/
+/*****************************************************************************//*!
+   *
+   * @brief Check Received Frame Flag.
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return Received Frame Flag
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t CAN_IsRxFrameFlag(MSCAN_Type *pCANx)
+{
+    return pCANx->CANCTL0 & MSCAN_CANCTL0_RXFRM_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Check Receiver Active Status.
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return Receiver Active Status
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t CAN_IsReceiving(MSCAN_Type *pCANx)
+{
+    return pCANx->CANCTL0 & MSCAN_CANCTL0_RXACT_MASK;
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief Check CAN Synchronized Status.
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return Synchronized Status
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t CAN_IsSynToBus(MSCAN_Type *pCANx)
+{
+    return pCANx->CANCTL0 & MSCAN_CANCTL0_SYNCH_MASK;
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief Sleep Mode Request.
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_SleepModeReq(MSCAN_Type *pCANx)
+{
+    pCANx->CANCTL0 |= MSCAN_CANCTL0_SLPRQ_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Initialization Mode Request.
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_InitialModeReq(MSCAN_Type *pCANx)
+{
+    pCANx->CANCTL0 |= MSCAN_CANCTL0_INITRQ_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Normal Mode Request.
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_NormalModeReq(MSCAN_Type *pCANx)
+{
+    pCANx->CANCTL0 &= ~MSCAN_CANCTL0_INITRQ_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Loopback Self Test Mode Enable.
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_LoopModeEn(MSCAN_Type *pCANx)
+{
+    pCANx->CANCTL1 |= MSCAN_CANCTL1_LOOPB_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Loopback Self Test Mode Disable.
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_LoopModeDisable(MSCAN_Type *pCANx)
+{
+    pCANx->CANCTL1 &= ~MSCAN_CANCTL1_LOOPB_MASK;
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief Listen Only Mode Enable.
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_ListenModeEn(MSCAN_Type *pCANx)
+{
+    pCANx->CANCTL1 |= MSCAN_CANCTL1_LISTEN_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Listen Only Mode Disable.
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_ListenModeDisable(MSCAN_Type *pCANx)
+{
+    pCANx->CANCTL1 &= ~MSCAN_CANCTL1_LISTEN_MASK;
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief Bus-Off Recovery Mode - user request.
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_BusOffUserRecovery(MSCAN_Type *pCANx)
+{
+    pCANx->CANCTL1 |= MSCAN_CANCTL1_BORM_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Bus-Off Recovery Mode - Auto.
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_BusOffAutoRecovery(MSCAN_Type *pCANx)
+{
+    pCANx->CANCTL1 &= ~MSCAN_CANCTL1_BORM_MASK;
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief Check Sleep Mode Acknowledge.
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return Sleep Mode Acknowledge
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t CAN_IsSleepMode(MSCAN_Type *pCANx)
+{
+    return pCANx->CANCTL1 & MSCAN_CANCTL1_SLPAK_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Check Initialization Mode Acknowledge.
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return Initialization Mode Acknowledge
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t CAN_IsInitialMode(MSCAN_Type *pCANx)
+{
+    return pCANx->CANCTL1 & MSCAN_CANCTL1_INITAK_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Check Wake-Up Interrupt Flag.
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return Wake-Up Interrupt Flag
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t CAN_IsWakeUpIntFlag(MSCAN_Type *pCANx)
+{
+    return pCANx->CANRFLG& MSCAN_CANRFLG_WUPIF_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Check CAN Status Change Interrupt Flag.
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return CAN Status Change Interrupt Flag
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t CAN_IsStatusChangeFlag(MSCAN_Type *pCANx)
+{
+    return pCANx->CANRFLG& MSCAN_CANRFLG_CSCIF_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Check Overrun Interrupt Flag
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return Overrun Interrupt Flag
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t CAN_IsOverRunFlag(MSCAN_Type *pCANx)
+{
+    return pCANx->CANRFLG& MSCAN_CANRFLG_OVRIF_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Check Receive Buffer Full Flag
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return Overrun Interrupt Flag
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t CAN_IsRxBuffFull(MSCAN_Type *pCANx)
+{
+    return pCANx->CANRFLG & MSCAN_CANRFLG_RXF_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Get Receiver Status
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return Receiver Status
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t CAN_GetReceiverStatus(MSCAN_Type *pCANx)
+{
+    return pCANx->CANRFLG & MSCAN_CANRFLG_RSTAT_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Get Transmitter Status
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return Transmitter Status
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t CAN_GetTransmitterStatus(MSCAN_Type *pCANx)
+{
+    return pCANx->CANRFLG & MSCAN_CANRFLG_TSTAT_MASK;
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief Get Transmitter Buffer Empty Flag
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return Transmitter Buffer Empty Flag
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t CAN_GetTransmitterBufferEmptyFlag(MSCAN_Type *pCANx)
+{
+    return pCANx->CANTFLG & MSCAN_CANTFLG_TXE_MASK;
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief Transmitter Empty Interrupt Enable
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_TransmitterEmptyIntEn(MSCAN_Type *pCANx)
+{
+    pCANx->CANTIER |= MSCAN_CANTIER_TXEIE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Transmitter Empty Interrupt Disable
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_TransmitterEmptyIntDisable(MSCAN_Type *pCANx)
+{
+    pCANx->CANTIER &= ~MSCAN_CANTIER_TXEIE_MASK;
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief Write Abort Request Register 
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   * @param[in] u8AbortRequest     abort request to tx buffer.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_WriteAbortRequestReg(MSCAN_Type *pCANx,uint8_t u8AbortRequest)
+{
+    pCANx->CANTARQ = MSCAN_CANTARQ_ABTRQ(u8AbortRequest&0x07);
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief Get Abort Acknowledge
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return Abort Acknowledge
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t CAN_GetAbortFlag(MSCAN_Type *pCANx)
+{
+    return (pCANx->CANTAAK & MSCAN_CANTAAK_ABTAK_MASK);
+}
+/*****************************************************************************//*!
+   *
+   * @brief Transmit Buffer Select - The lowest numbered bit places the respective transmit buffer in
+   *           the CANTXFG register space
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   * @param[in] u8TxBuff       tx buff to be selected.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_TxBuffSelect(MSCAN_Type *pCANx,uint8_t u8TxBuff)
+{
+    pCANx->CANTBSEL = MSCAN_CANTBSEL_TX(u8TxBuff);
+}
+/*****************************************************************************//*!
+   *
+   * @brief Get the selected transmitter buffer
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t CAN_GetTxBuffSelect(MSCAN_Type *pCANx)
+{
+    return pCANx->CANTBSEL&MSCAN_CANTBSEL_TX_MASK;
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief Set Identifier Acceptance Mode
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   * @param[in] u8IDAcceptMode       Identifier Acceptance Mode.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_IDAcceptMode(MSCAN_Type *pCANx,uint8_t u8IDAcceptMode)
+{
+    pCANx->CANIDAC = MSCAN_CANIDAC_IDAM(u8IDAcceptMode);
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief Set Identifier Acceptance Hit Indicator
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   * @param[in] u8IDAcceptHit       Identifier Acceptance Hit Indicator.
+   *
+   * @return filter number for hit
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t CAN_IDAcceptHit(MSCAN_Type *pCANx)
+{
+    return pCANx->CANIDAC & MSCAN_CANIDAC_IDHIT_MASK;
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief Check if is Bus-Off Status
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return Bus-Off Status
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t CAN_IsBusOff(MSCAN_Type *pCANx)
+{
+    return pCANx->CANMISC |= MSCAN_CANMISC_BOHOLD_MASK;
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief Get Receive Error Counter
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return Receive Error Counter
+   *
+   * @ Pass/ Fail criteria: This field is read only in sleep mode (SLPRQ = 1 and SLPAK = 1) or initialization mode (INITRQ = 1 and
+   *                                INITAK = 1)
+*****************************************************************************/
+__STATIC_INLINE uint8_t CAN_GetReceiveErrorCount(MSCAN_Type *pCANx)
+{
+    return pCANx->CANRXERR & MSCAN_CANRXERR_RXERR_MASK;
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief CAN enable
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_Enable(MSCAN_Type *pCANx)
+{
+    pCANx->CANCTL1 |= MSCAN_CANCTL1_CANE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief CAN disable
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_Disable(MSCAN_Type *pCANx)
+{
+    pCANx->CANCTL1 &= ~MSCAN_CANCTL1_CANE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief WakeUp Interrupt Enable
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_WakeUpIntEn(MSCAN_Type *pCANx)
+{
+    pCANx->CANRIER |= MSCAN_CANRIER_WUPIE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief WakeUp Interrupt Disable
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_WakeUpIntDisable(MSCAN_Type *pCANx)
+{
+    pCANx->CANRIER &= ~MSCAN_CANRIER_WUPIE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief CAN Status Change Interrupt Enable
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_StatusChangeIntEn(MSCAN_Type *pCANx)
+{
+    pCANx->CANRIER |= MSCAN_CANRIER_CSCIE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief CAN Status Change Interrupt Disable
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_StatusChangeIntDisable(MSCAN_Type *pCANx)
+{
+    pCANx->CANRIER &= ~MSCAN_CANRIER_CSCIE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Receiver Status Change Enable
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_ReceiverStatusChangeIntEn(MSCAN_Type *pCANx)
+{
+    pCANx->CANRIER |= MSCAN_CANRIER_RSTATE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief CAN Receiver Status Change Disable
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_ReceiverStatusChangeIntDisable(MSCAN_Type *pCANx)
+{
+    pCANx->CANRIER &= ~MSCAN_CANRIER_RSTATE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Transmitter Status Change Enable
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_TransmitterStatusChangeIntEn(MSCAN_Type *pCANx)
+{
+    pCANx->CANRIER |= MSCAN_CANRIER_TSTATE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Transmitter Status Change Disable
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_TransmitterStatusChangeIntDisable(MSCAN_Type *pCANx)
+{
+    pCANx->CANRIER &= ~MSCAN_CANRIER_TSTATE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Overrun Interrupt Enable
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_OverrunIntEn(MSCAN_Type *pCANx)
+{
+    pCANx->CANRIER |= MSCAN_CANRIER_OVRIE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Overrun Interrupt Disable
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_OverrunIntDisable(MSCAN_Type *pCANx)
+{
+    pCANx->CANRIER &= ~MSCAN_CANRIER_OVRIE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Receiver Full Interrupt Enable
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_ReceiverFullIntEn(MSCAN_Type *pCANx)
+{
+    pCANx->CANRIER |= MSCAN_CANRIER_RXFIE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Receiver Full Interrupt Disable
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_ReceiverFullIntDisable(MSCAN_Type *pCANx)
+{
+    pCANx->CANRIER &= ~MSCAN_CANRIER_RXFIE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Timer Enable
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_TimerEn(MSCAN_Type *pCANx)
+{
+    pCANx->CANCTL0 |= MSCAN_CANCTL0_TIME_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Timer Disable
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_TimerDisable(MSCAN_Type *pCANx)
+{
+    pCANx->CANCTL0 &= ~MSCAN_CANCTL0_TIME_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief CAN Stops in Wait Mode Enable
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_StopInWaitModeEn(MSCAN_Type *pCANx)
+{
+    pCANx->CANCTL0 |= MSCAN_CANCTL0_CSWAI_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief CAN Stops in Wait Mode Disable
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_StopInWaitModeDisable(MSCAN_Type *pCANx)
+{
+    pCANx->CANCTL0 &= ~MSCAN_CANCTL0_CSWAI_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief WakeUp Enable
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_WakeUpEn(MSCAN_Type *pCANx)
+{
+    pCANx->CANCTL0 |= MSCAN_CANCTL0_WUPE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief WakeUp Disable
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_WakeUpDisable(MSCAN_Type *pCANx)
+{
+    pCANx->CANCTL0 &= ~MSCAN_CANCTL0_WUPE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief MSCAN wakes up only in case of a dominant pulse on the CAN bus that has a length of Twup.
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_WakeUpModeFilter(MSCAN_Type *pCANx)
+{
+    pCANx->CANCTL1 |= MSCAN_CANCTL1_WUPM_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief MSCAN wakes up on any dominant level on the CAN bus.
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_WakeUpModeNoFilter(MSCAN_Type *pCANx)
+{
+    pCANx->CANCTL1 &= ~MSCAN_CANCTL1_WUPM_MASK;
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief write MSCAN Identifier Acceptance Register n of First Bank
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_WriteIDAR0Reg(MSCAN_Type *pCANx,uint8_t *pID)
+{
+    pCANx->CANIDAR_BANK_1[0] = pID[3];
+    pCANx->CANIDAR_BANK_1[1] = pID[2];
+    pCANx->CANIDAR_BANK_1[2] = pID[1];
+    pCANx->CANIDAR_BANK_1[3] = pID[0];
+}
+/*****************************************************************************//*!
+   *
+   * @brief write MSCAN Identifier Acceptance Register n of Second Bank
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_WriteIDAR1Reg(MSCAN_Type *pCANx,uint8_t *pID)
+{
+    pCANx->CANIDAR_BANK_2[0] = pID[3];
+    pCANx->CANIDAR_BANK_2[1] = pID[2];
+    pCANx->CANIDAR_BANK_2[2] = pID[1];
+    pCANx->CANIDAR_BANK_2[3] = pID[0];
+}
+/*****************************************************************************//*!
+   *
+   * @brief write MSCAN Identifier Mask Register n of First Bank
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+
+__STATIC_INLINE void CAN_WriteIDAM0Reg(MSCAN_Type *pCANx,uint8_t *pID)
+{
+    pCANx->CANIDMR_BANK_1[0] = pID[3];
+    pCANx->CANIDMR_BANK_1[1] = pID[2];
+    pCANx->CANIDMR_BANK_1[2] = pID[1];
+    pCANx->CANIDMR_BANK_1[3] = pID[0];
+}
+/*****************************************************************************//*!
+   *
+   * @brief write MSCAN Bus Timming Register
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_SetBaudRateReg(MSCAN_Type *pCANx,MSCAN_BaudRateSettingType sBspSetting)
+{
+    pCANx->CANBTR0 = MSCAN_CANBTR0_SJW(sBspSetting.SJW) | MSCAN_CANBTR0_BRP(sBspSetting.BRP);
+    pCANx->CANBTR1 = MSCAN_CANBTR1_TSEG1(sBspSetting.TSEG1)
+    				|MSCAN_CANBTR1_TSEG2(sBspSetting.TSEG2);
+   	if(sBspSetting.SAMP)
+   	{
+		pCANx->CANBTR1 |= MSCAN_CANBTR1_SAMP_MASK;
+   	}
+   	else
+   	{
+		pCANx->CANBTR1 &= ~MSCAN_CANBTR1_SAMP_MASK;
+   	}
+    				
+}
+/*****************************************************************************//*!
+   *
+   * @brief write MSCAN Identifier Mask Register n of Second Bank
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_WriteIDAM1Reg(MSCAN_Type *pCANx,uint8_t *pID)
+{
+    pCANx->CANIDMR_BANK_2[0] = pID[3];
+    pCANx->CANIDMR_BANK_2[1] = pID[2];
+    pCANx->CANIDMR_BANK_2[2] = pID[1];
+    pCANx->CANIDMR_BANK_2[3] = pID[0];
+}
+/*****************************************************************************//*!
+   *
+   * @brief Clear Transmitter Buffer Empty Flag to schedule for transmission
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   * @param[in] TxBuffer    point to CAN transmitter buffer to be launched.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_LaunchTransmitBuffer(MSCAN_Type *pCANx,uint8_t TxBuffer)
+{
+    pCANx->CANTFLG = TxBuffer&0x07;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Write Transmit Extended and Standard Identifier Register 0
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   * @param[in] ucBuffer    the data written to IDR0 register.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_WriteTEIDR0Reg(MSCAN_Type *pCANx,uint8_t ucBuffer)
+{
+    pCANx->TEIDR0 = ucBuffer;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Write Transmit Extended  Identifier Register 1
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   * @param[in] ucBuffer    the data written to TEIDR1 register.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_WriteTEIDR1Reg(MSCAN_Type *pCANx,uint8_t ucBuffer)
+{
+    pCANx->TEIDR1 = ucBuffer;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Write Transmit Extended  Identifier Register 2
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   * @param[in] ucBuffer    the data written to TEIDR2 register.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_WriteTEIDR2Reg(MSCAN_Type *pCANx,uint8_t ucBuffer)
+{
+    pCANx->TEIDR2 = ucBuffer;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Write Transmit Extended  Identifier Register 3
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   * @param[in] ucBuffer    the data written to TEIDR3 register.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_WriteTEIDR3Reg(MSCAN_Type *pCANx,uint8_t ucBuffer)
+{
+    pCANx->TEIDR3 = ucBuffer;
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief Write Transmit Standard  Identifier Register 1
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   * @param[in] ucBuffer    the data written to TSID1 register.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_WriteTSIDR1Reg(MSCAN_Type *pCANx,uint8_t ucBuffer)
+{
+    pCANx->TSIDR1 = ucBuffer;
+}
+
+
+/*****************************************************************************//*!
+   *
+   * @brief Read receiver extend and standard identifier register 1
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return REIDR0 or RSIDR0
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t CAN_ReadIDR1Reg(MSCAN_Type *pCANx)
+{
+    return pCANx->REIDR1;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Read receiver extend and standard identifier register 0
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return REIDR1 or RSIDR1
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t CAN_ReadIDR0Reg(MSCAN_Type *pCANx)
+{
+    return pCANx->REIDR0;
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief Read receiver extend identifier register 2
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return REIDR2
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t CAN_ReadIDR2Reg(MSCAN_Type *pCANx)
+{
+    return pCANx->REIDR2;
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief Read receiver extend identifier register 3
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return REIDR3
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t CAN_ReadIDR3Reg(MSCAN_Type *pCANx)
+{
+    return pCANx->REIDR3;
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief Read receiver stamps registers high bytes
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return RTSRH
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t CAN_ReadRTSRHReg(MSCAN_Type *pCANx)
+{
+    return pCANx->RTSRH;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Read receiver stamps registers low bytes
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return RTSRL
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t CAN_ReadRTSRLReg(MSCAN_Type *pCANx)
+{
+    return pCANx->RTSRL;
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief Read transmitter stamps registers high byte
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return TTSRH
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t CAN_ReadTTSRHReg(MSCAN_Type *pCANx)
+{
+    return pCANx->TTSRH;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Read transmitter stamps registers low byte
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return TTSRL
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t CAN_ReadTTSRLReg(MSCAN_Type *pCANx)
+{
+    return pCANx->TTSRL;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Clear Wake-Up Interrupt Flag
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_ClearWUPIF_Flag(MSCAN_Type *pCANx)
+{
+    pCANx->CANRFLG |= MSCAN_CANRFLG_WUPIF_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Clear CAN Status Change Interrupt Flag
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_ClearCSCIF_Flag(MSCAN_Type *pCANx)
+{
+    pCANx->CANRFLG |= MSCAN_CANRFLG_CSCIF_MASK;
+}
+
+
+/*****************************************************************************//*!
+   *
+   * @brief Clear Overrun Interrupt Flag
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_ClearOVRIF_Flag(MSCAN_Type *pCANx)
+{
+    pCANx->CANRFLG |= MSCAN_CANRFLG_OVRIF_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Clear Receive Buffer Full Flag
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_ClearRXF_Flag(MSCAN_Type *pCANx)
+{
+    pCANx->CANRFLG |= MSCAN_CANRFLG_RXF_MASK;
+}
+
+/*****************************************************************************//*!
+   *
+   * @brief Clear Received Frame Flag
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_ClearRXFRM_Flag(MSCAN_Type *pCANx)
+{
+    pCANx->CANCTL0 |= MSCAN_CANCTL0_RXFRM_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Clear Sleep Mode Request
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_ClearSLPRQ_Flag(MSCAN_Type *pCANx)
+{
+    pCANx->CANCTL0 &= ~MSCAN_CANCTL0_SLPRQ_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Identifier Acceptance Mode
+   *        
+   * @param[in] pCANx      point to CAN module type.
+   *
+   * @return none
+   *
+   * @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void CAN_SetIDAMode(MSCAN_Type *pCANx,uint8_t IDAMode)
+{
+    pCANx->CANIDAC = MSCAN_CANIDAC_IDAM(IDAMode);
+}
+
+
+/******************************************************************************
+* Global functions
+******************************************************************************/
+
+
+void CAN_Init(MSCAN_Type *pCANx,MSCAN_ConfigPtr pCANConfig);
+uint8_t CAN_DeInit(MSCAN_Type *pCANx);
+uint8_t CAN_EnterSleep(MSCAN_Type *pCANx);
+uint8_t CAN_WakeUpFromSleep(MSCAN_Type *pCANx);
+uint8_t CAN_LaunchInitialRequest(MSCAN_Type *pCANx);
+uint8_t CAN_ReadOneFrameFromBuff(MSCAN_Type *pCANx,MSCAN_FramePtr pRxFrame);
+uint8_t CAN_LoadOneFrameToBuff(MSCAN_Type *pCANx,MSCAN_RegisterFramePtr pFrameBuff);
+void MSCAN_SetRxCallBack( MSCAN_CallbackType pCallBack );
+void MSCAN_SetTxCallBack( MSCAN_CallbackType pCallBack );
+void MSCAN_RxIsr( void );
+void MSCAN_TxIsr( void );
+
+
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif //
+
+
diff --git a/bsp/frdm-ke02/device/lib/inc/pit.h b/bsp/frdm-ke02/device/lib/inc/pit.h
new file mode 100755
index 0000000..b041513
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/pit.h
@@ -0,0 +1,345 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file     pit.h
+*
+* @author   Freescale
+*
+* @version  0.0.1
+*
+* @date     Jun 25, 2013
+*
+* @brief    Periodic Interrupt Timer (PIT) driver head file. 
+*
+******************************************************************************/
+#ifndef PIT_H_
+#define PIT_H_
+#ifdef __cplusplus
+extern "C" {
+#endif
+/******************************************************************************
+* Includes
+******************************************************************************/
+
+/******************************************************************************
+* Constants
+******************************************************************************/
+
+/******************************************************************************
+* PIT channel number list
+*
+*//*! @addtogroup pit_channelnumber
+* @{
+*******************************************************************************/
+enum
+{
+    PIT_CHANNEL0 = 0,       /*!< PIT channel 0 */
+    PIT_CHANNEL1            /*!< PIT channel 1 */
+};
+
+/*! @} End of pit_channelnumber                                               */
+
+/******************************************************************************
+* Macros
+******************************************************************************/
+
+/******************************************************************************
+* Types
+******************************************************************************/
+
+/*
+ * Callback type
+ */
+
+/******************************************************************************
+* PIT callback function declaration
+*
+*//*! @addtogroup pit_callback
+* @{
+*******************************************************************************/
+typedef void (*PIT_CallbackType)(void);             /*!< PIT callback type */
+
+/*! @} End of pit_callback                                                    */
+
+/* PIT configuration structure 
+ */  
+/*!
+ * @brief PIT configuration type.
+ *
+ */
+typedef struct
+{   
+    uint8_t bFreeze         : 1;    /*!< 1: stop in debug mode, 0: run in debug mode */
+    uint8_t bModuleDis      : 1;    /*!< 1: PIT module is disable, 0: PIT module is enable */    
+    uint8_t bReserved0      : 1;    /*!< reserved bit */ 
+    uint8_t bReserved1      : 5;    /*!< reserved bit */ 
+    uint8_t bTimerEn        : 1;    /*!< 1: channel timer is enable, 0: channel timer is disable */ 
+    uint8_t bInterruptEn    : 1;    /*!< 1: channel timer interrupt is enable, 0: channel timer interrupt is disable */ 
+    uint8_t bChainMode      : 1;    /*!< 1: chain mode is enable, 0: chain mode is disable */ 
+    uint8_t bReserved2      : 5;    /*!< reserved bit */ 
+    uint8_t bFlag           : 1;    /*!< 1: flag is set,and write 1 to clear flag, 0: no flag is set */
+    uint8_t bReserved3      : 7;    /*!< reserved bit */   
+    uint32_t u32LoadValue      ;    /*!< 32-bit channel load value */  
+} PIT_ConfigType, *PIT_ConfigPtr; 
+
+
+/******************************************************************************
+* Global variables
+******************************************************************************/
+
+
+/*!
+ * inline functions
+ */
+
+/******************************************************************************
+* PIT API list
+*
+*//*! @addtogroup pit_api_list
+* @{
+*******************************************************************************/
+
+/*****************************************************************************//*!
+*
+* @brief enable pit module.
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void PIT_Enable(void)
+{
+
+    PIT->MCR &= ~PIT_MCR_MDIS_MASK; 
+    
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief disable pit module.
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void PIT_Disable(void)
+{
+
+    PIT->MCR |= PIT_MCR_MDIS_MASK; 
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief pit timers are stopped in debug mode.
+*        
+* @param  none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void PIT_SetDebugFreeze(void)
+{
+
+    PIT->MCR |= PIT_MCR_FRZ_MASK;
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief pit timers are running in debug mode.
+*        
+* @param  none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void PIT_SetDebugOn(void)
+{
+
+    PIT->MCR &= ~PIT_MCR_FRZ_MASK;
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief enable pit channel timer.
+*        
+* @param[in]   u8Channel.
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void PIT_ChannelEnable(uint8_t u8Channel)
+
+{
+
+    PIT->CHANNEL[u8Channel].TCTRL |= PIT_TCTRL_TEN_MASK; 
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief disable pit channel timer.
+*        
+* @param[in]   u8Channel.
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void PIT_ChannelDisable(uint8_t u8Channel)
+{
+
+    PIT->CHANNEL[u8Channel].TCTRL &= ~PIT_TCTRL_TEN_MASK; 
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief enable pit channel timer interrupt.
+*        
+* @param[in]  u8Channel.
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void PIT_ChannelEnableInt(uint8_t u8Channel)
+
+{
+
+    PIT->CHANNEL[u8Channel].TCTRL |= PIT_TCTRL_TIE_MASK; 
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief disable pit channel timer interrupt .
+*        
+* @param[in]   u8Channel.
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void PIT_ChannelDisableInt(uint8_t u8Channel)
+
+{
+
+    PIT->CHANNEL[u8Channel].TCTRL &= ~PIT_TCTRL_TIE_MASK; 
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief  enable pit channel timer chain mode.
+*        
+* @param[in]   u8Channel.
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void PIT_ChannelEnableChain(uint8_t u8Channel)
+{
+    PIT->CHANNEL[u8Channel].TCTRL |= PIT_TCTRL_CHN_MASK;
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief  disable pit channel timer chain mode.
+*        
+* @param[in]   u8Channel.
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void PIT_ChannelDisableChain(uint8_t u8Channel)
+
+{
+    PIT->CHANNEL[u8Channel].TCTRL &= ~PIT_TCTRL_CHN_MASK;
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief get pit channel timer interrrupt flag.
+*        
+* @param[in]   u8Channel.
+*
+* @return bflag.
+*
+* @ Pass/ Fail criteria: none
+
+*****************************************************************************/
+__STATIC_INLINE uint8_t PIT_ChannelGetFlags(uint8_t u8Channel)
+
+{
+    uint8_t bflag;  
+    
+    bflag = (PIT->CHANNEL[u8Channel].TFLG & PIT_TFLG_TIF_MASK);    
+    
+    return bflag;
+    
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief clear pit channel timer interrrupt flag.
+*        
+* @param[in] u8Channel
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void PIT_ChannelClrFlags(uint8_t u8Channel)
+{
+    PIT->CHANNEL[u8Channel].TFLG |= PIT_TFLG_TIF_MASK;       
+}
+
+
+/******************************************************************************
+* Global functions
+******************************************************************************/
+void PIT_Init(uint8_t u8Channel_No, PIT_ConfigType *pConfig);
+void PIT_SetLoadVal(uint8_t u8Channel, uint32_t u32loadvalue);
+void PIT_SetCallback(uint8_t u8Channel_No, PIT_CallbackType pfnCallback);
+void PIT_DeInit(void);
+/*! @} End of pit_api_list                                                   */
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* PIT_H_ */
diff --git a/bsp/frdm-ke02/device/lib/inc/pmc.h b/bsp/frdm-ke02/device/lib/inc/pmc.h
new file mode 100755
index 0000000..6d8ade9
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/pmc.h
@@ -0,0 +1,401 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file pmc.h
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief header file for PMC. 
+*
+*******************************************************************************
+*
+* provide APIs for accessing PMC
+******************************************************************************/
+#ifndef PMC_H_
+#define PMC_H_
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/******************************************************************************
+* Includes
+******************************************************************************/
+
+/******************************************************************************
+* Macros
+******************************************************************************/
+/******************************************************************************
+* PMC system mode definition
+*
+*//*! @addtogroup pmc_sysmode
+* @{
+*******************************************************************************/
+#define PmcModeRun     0                     /*!< run mode */
+#define PmcModeWait    1                     /*!< wait mode */
+#define PmcModeStop4   2                     /*!< stop4 mode */
+#define PmcModeStop3   3                     /*!< stop3 mode */
+/*! @} End of pmc_sysmode                                                     */
+
+/******************************************************************************
+* PMC LVD and LVW voltage definition
+*
+*//*! @addtogroup pmc_voltageselect
+* @{
+*******************************************************************************/
+#define PmcLVDTrip_Low   0                    /*!< LVD low trip point */
+#define PmcLVDTrip_High  1                     /*!< LVD high trip point  */
+
+#define PmcLVWTrip_Low   0                     /*!< LVW low trip point */
+#define PmcLVWTrip_Mid1  1                     /*!< LVW mid1 trip point */
+#define PmcLVWTrip_Mid2  2                     /*!< LVW mid2 trip point */
+#define PmcLVWTrip_High  3                     /*!< LVW high trip point */
+/*! @} End of pmc_voltageselect                                               */
+
+
+/******************************************************************************
+* Types
+******************************************************************************/
+
+/******************************************************************************
+* PMC control  struct
+*
+*//*! @addtogroup pmc_ctrlstruct
+* @{
+*******************************************************************************/
+/*!
+ * @brief PMC Control Structure Type.
+ *
+ */
+
+typedef union 
+{
+   uint8_t byte;						  /*!< byte field of union type */
+   struct 
+   {     
+       uint8_t bBandgapEn        :1;      /*!< bandgap enable */
+       uint8_t bBandgapDrv       :1;      /*!< bandgap drive select */
+       uint8_t bLvdEn            :1;      /*!< LVD enable */
+       uint8_t bLvdStopEn        :1;      /*!< LVD enable in stop mode */
+       uint8_t bLvdRstEn         :1;      /*!< reset enable when VLD evvent */
+       uint8_t bLvwIrqEn         :1;      /*!< LVW int enable */
+       uint8_t bLvwAck           :1;      /*!< LVW acknowledge */
+       uint8_t bLvwFlag          :1;      /*!< LVW flag */
+   }bits; 								  /*!< bitfield of union type */
+}PMC_Ctrl1Type, *PMC_Ctrl1Ptr;		  /*!< PMC control1 reg structure */
+/*! @} End of pmc_ctrlstruct                                                  */
+
+/******************************************************************************
+* PMC control-- voltage select type.
+*
+*//*! @addtogroup pmc_voltselectstruct
+* @{
+*******************************************************************************/
+/*!
+ * @brief PMC control-- voltage select type.
+ *
+ */
+typedef union 
+{
+   uint8_t byte;						   /*!< byte field of union type */
+   struct 
+   {     
+       uint8_t           :4;               /*!< none */  
+       uint8_t bLVWV     :2;               /*!< LVW voltage select */  
+       uint8_t bLVDV     :1;               /*!< LVD voltage select */  
+       uint8_t           :1;               /*!< none */                 
+   }bits;  								   /*!< bitfield of union type */
+}PMC_Ctrl2Type, *PMC_Ctrl2Ptr;		   /*!< PMC control2 reg structure */
+/*! @} End of pmc_voltselectstruct                                            */
+
+/******************************************************************************
+* PMC configrue type.
+*
+*//*! @addtogroup pmc_configstruct
+* @{
+*******************************************************************************/
+/*!
+ * @brief PMC configrue type.
+ *
+ */
+
+typedef struct 
+{
+    PMC_Ctrl1Type    sCtrlstatus;          /*!< PMC control and status */  
+    PMC_Ctrl2Type    sDetectVoltSelect;    /*!< LVW and LVW voltage select */  
+}PMC_ConfigType, *PMC_ConfigPtr;		   /*!< PMC configuration structure */
+/*! @} End of pmc_configstruct                                            */  
+
+
+
+/******************************************************************************
+* Global variables
+******************************************************************************/
+
+/*!
+ * inline functions
+ */
+/******************************************************************************
+* PMC api list.
+*
+*//*! @addtogroup pmc_api_list
+* @{
+*******************************************************************************/
+/*****************************************************************************//*!
+*
+* @brief  enable LVD events during stop mode.
+* 
+* @param[in]  pPMC              pointer to the PMC module.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see PMC_DisableLVDInStopMode.
+*
+*****************************************************************************/
+__STATIC_INLINE void PMC_EnableLVDInStopMode(PMC_Type *pPMC)
+{
+    pPMC->SPMSC1 |= PMC_SPMSC1_LVDSE_MASK;
+}
+
+/*****************************************************************************//*!
+*
+* @brief  disable LVD events during stop mode.
+* 
+* @param[in]  pPMC              pointer to the PMC module.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see PMC_EnableLVDInStopMode.
+*
+*****************************************************************************/
+__STATIC_INLINE void PMC_DisableLVDInStopMode(PMC_Type *pPMC)
+{
+    pPMC->SPMSC1 &= ~PMC_SPMSC1_LVDSE_MASK;
+}
+
+/*****************************************************************************//*!
+*
+* @brief  enable LVD events to generate a hardware reset,  note: write once.
+* 
+* @param[in]  pPMC              pointer to the PMC module.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see PMC_DisableLVDRst.
+*
+*****************************************************************************/
+__STATIC_INLINE void PMC_EnableLVDRst(PMC_Type *pPMC)
+{
+    pPMC->SPMSC1 |= PMC_SPMSC1_LVDRE_MASK;
+}
+
+/*****************************************************************************//*!
+*
+* @brief  disable LVD events to generate a hardware reset,  note: write once.
+* 
+* @param[in]  pPMC              pointer to the PMC module.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see PMC_EnableLVDRst.
+*
+*****************************************************************************/
+__STATIC_INLINE void PMC_DisableLVDRst(PMC_Type *pPMC)
+{
+    pPMC->SPMSC1 &= ~PMC_SPMSC1_LVDRE_MASK;
+}
+
+/*****************************************************************************//*!
+*
+* @brief  enable low-voltage detect logic,  note: write once.
+* 
+* @param[in]  pPMC              pointer to the PMC module.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see PMC_DisableLVD.
+*
+*****************************************************************************/
+__STATIC_INLINE void PMC_EnableLVD(PMC_Type *pPMC)
+{
+    pPMC->SPMSC1 |= PMC_SPMSC1_LVDE_MASK;
+}
+
+/*****************************************************************************//*!
+*
+* @brief  disable low-voltage detect logic,  note: write once
+* 
+* @param[in]  pPMC              pointer to the PMC module.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none
+*
+* @see PMC_EnableLVD.
+*
+*****************************************************************************/
+__STATIC_INLINE void PMC_DisableLVD(PMC_Type *pPMC)
+{
+    pPMC->SPMSC1 &= ~PMC_SPMSC1_LVDE_MASK;
+}
+
+/*****************************************************************************//*!
+*
+* @brief  set the low-voltage detect trip point voltage, note: write once.
+* 
+* @param[in]  pPMC              pointer to the PMC module.
+* @param[in]  Trippoint         LVD trip point voltage,0~1.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see PMC_SetLVWTripVolt.
+*
+*****************************************************************************/
+__STATIC_INLINE void PMC_SetLVDTripVolt(PMC_Type *pPMC, uint8_t Trippoint)
+{
+    if(Trippoint)
+        pPMC->SPMSC2 |= PMC_SPMSC2_LVDV_MASK;
+    else
+        pPMC->SPMSC2 &= ~PMC_SPMSC2_LVDV_MASK;
+}
+
+/*****************************************************************************//*!
+*
+* @brief  set the low-voltage warning (LVW) trip point voltage.
+* 
+* @param[in]  pPMC              pointer to the PMC module.
+* @param[in]  Trippoint         LVW trip point voltage,0~3.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see PMC_SetLVDTripVolt.
+*
+*****************************************************************************/
+__STATIC_INLINE void PMC_SetLVWTripVolt(PMC_Type *pPMC, uint8_t Trippoint)
+{
+    pPMC->SPMSC2 &= ~PMC_SPMSC2_LVWV_MASK;
+    pPMC->SPMSC2 |= PMC_SPMSC2_LVWV(Trippoint);
+}
+
+/*****************************************************************************//*!
+*
+* @brief  Enable hardware interrupt requests for LVWF.
+* 
+* @param[in]  pPMC              pointer to the PMC module.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see PMC_DisableLVWInterrupt.
+*
+*****************************************************************************/
+__STATIC_INLINE void PMC_EnableLVWInterrupt(PMC_Type *pPMC)
+{
+   pPMC->SPMSC1 |= PMC_SPMSC1_LVWIE_MASK;
+}
+
+/*****************************************************************************//*!
+*
+* @brief  Disable hardware interrupt requests for LVWF.
+* 
+* @param[in]  pPMC              pointer to the PMC module.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see PMC_EnableLVWInterrupt.
+*
+*****************************************************************************/
+__STATIC_INLINE void PMC_DisableLVWInterrupt(PMC_Type *pPMC)
+{
+   pPMC->SPMSC1 &= ~PMC_SPMSC1_LVWIE_MASK;
+}
+
+/*****************************************************************************//*!
+*
+* @brief  get the lvw warning flag.
+* 
+* @param[in]  pPMC              pointer to the PMC module.
+*
+* @return uint8_t lvw warning flag.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see PMC_ClrLVWFlag.
+*
+*****************************************************************************/
+__STATIC_INLINE uint8_t PMC_GetLVWFlag(PMC_Type *pPMC)
+{
+   return (pPMC->SPMSC1 & PMC_SPMSC1_LVWF_MASK);
+}
+
+/*****************************************************************************//*!
+*
+* @brief  clear the lvw warning flag.
+* 
+* @param[in]  pPMC              pointer to the PMC module.
+*
+* @return none.
+*
+* @ Pass/ Fail criteria: none.
+*
+* @see PMC_GetLVWFlag.
+*
+*****************************************************************************/
+__STATIC_INLINE void PMC_ClrLVWFlag(PMC_Type *pPMC)
+{
+   pPMC->SPMSC1 |= PMC_SPMSC1_LVWACK_MASK;
+}
+
+/*! @} End of pmc_api_list                                                    */
+
+/******************************************************************************
+* Global functions
+******************************************************************************/
+
+void PMC_Init(PMC_Type *pPMC, PMC_ConfigType *pPMC_Config);
+void PMC_DeInit(PMC_Type *pPMC);
+void PMC_SetMode(PMC_Type *pPMC,uint8_t u8PmcMode);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* PMC_H_ */
diff --git a/bsp/frdm-ke02/device/lib/inc/pwt.h b/bsp/frdm-ke02/device/lib/inc/pwt.h
new file mode 100755
index 0000000..4d9f356
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/pwt.h
@@ -0,0 +1,418 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file     pwt.h
+*
+* @author   Freescale
+*
+* @version  0.0.1
+*
+* @date     Jun 25, 2013
+*
+* @brief    Periodic Interrupt Timer (PWT) driver head file. 
+*
+******************************************************************************/
+#ifndef PWT_H_
+#define PWT_H_
+#ifdef __cplusplus
+extern "C" {
+#endif
+/******************************************************************************
+* Includes
+******************************************************************************/
+
+/******************************************************************************
+* Constants
+******************************************************************************/
+
+/******************************************************************************
+* Macros
+******************************************************************************/
+
+/******************************************************************************
+* PWT control bit definition
+*
+*//*! @addtogroup pwt_controlbit
+* @{
+*******************************************************************************/
+
+#define PWT_PCLKS_BUS               0 	/*!< select bus clock as PWT clock source  */
+#define PWT_PCLKS_ALTCLK            1	/*!< select alternative clock as PWT clock source  */
+
+#define PWT_PINSEL_PTC4             0	/*!< PWTIN[0]  */
+#define PWT_PINSEL_PTB0             1	/*!< PWTIN[1]  */
+#define PWT_PINSEL_ACMP0_OUTPUT     2	/*!< PWTIN[2]  */
+#define PWT_PINSEL_ACMP1_OUTPUT     3	/*!< PWTIN[3]  */
+
+#define FALLING_START_CAPTURE_FALLING           0	/*!< first falling-edge start to measure, all falling-edge capture */
+#define RISING_START_CAPTURE_ALL                1	/*!< first rising-edge start to measure, all edge capture */
+#define FALLING_START_CAPTURE_ALL               2	/*!< first falling-edge start to measure, all edge capture */
+#define RISING_START_CAPTURE_RISING             3	/*!< first rising-edge start to measure, all rising-edge capture */
+
+#define PWT_CLK_PRESCALER_1         0	/*!< presalcer is 1  */
+#define PWT_CLK_PRESCALER_2         1	/*!< presalcer is 2  */
+#define PWT_CLK_PRESCALER_4         2	/*!< presalcer is 4  */
+#define PWT_CLK_PRESCALER_8         3	/*!< presalcer is 8  */
+#define PWT_CLK_PRESCALER_16        4	/*!< presalcer is 16 */
+#define PWT_CLK_PRESCALER_32        5	/*!< presalcer is 32 */
+#define PWT_CLK_PRESCALER_64        6	/*!< presalcer is 64 */
+#define PWT_CLK_PRESCALER_128       7	/*!< presalcer is 64 */
+
+/*! @} End of pwt_controlbit                                                  */
+        
+/******************************************************************************
+* Types
+******************************************************************************/
+
+/*
+ * Callback type
+ */
+
+/******************************************************************************
+* PWT callback function declaration
+*
+*//*! @addtogroup pwt_callback
+* @{
+*******************************************************************************/
+typedef void (*PWT_CallbackType)(void);             /*!< PWT callback type */
+
+/*! @} End of pwt_callback                                                    */
+
+/* PWT configuration structure 
+ */  
+/******************************************************************************
+* define PWT configuration structure
+*
+*//*! @addtogroup pwt_config_type
+* @{
+*******************************************************************************/
+
+/*!
+ * @brief PWT configuration type.
+ *
+ */
+typedef struct
+{   
+    uint8_t bCounterOverflow         : 1;    /*!< 1: overflow bit is set, 0: rno overflow */
+    uint8_t bRegisterReady           : 1;    /*!< 1: register has been updated, 0: no up-to-date */    
+    uint8_t bSoftReset               : 1;    /*!< 1: reset PWT, 0: no action */ 
+    uint8_t bOverflowIntEn           : 1;    /*!< 1: enable overflow interrupt, 0: disable overflow interrupt */ 
+    uint8_t bReadyIntEn              : 1;    /*!< 1: enable data ready interrupt, 0: disable data ready interrupt */   
+    uint8_t bPWTIntEn                : 1;    /*!< 1: enable PWT module interrupt, 0: disable PWT module interrupt */    
+    uint8_t bPWTEn                   : 1;    /*!< 1: enable PWT module, 0: disable PWT module */      
+    uint8_t bClockPrescaler          : 3;    /*!< prescaler value is from 1 to 128 */  
+    uint8_t bEdgeSensitivity         : 2;    /*!< select edge triggers */
+    uint8_t bPinSelect               : 2;    /*!< input pin select */    
+    uint8_t bClockSource             : 1;    /*!< 1: PWT clock source is alternative clock, 0: PWT clock source is bus clock*/    
+     
+} PWT_ConfigType, *PWT_ConfigPtr; 
+/*! @} End of pwt_config_type                                                */
+
+/******************************************************************************
+* Global variables
+******************************************************************************/
+
+
+/*!
+ * inline functions
+ */
+
+/******************************************************************************
+* PWT API list
+*
+*//*! @addtogroup pwt_api_list
+* @{
+*******************************************************************************/
+
+/*****************************************************************************//*!
+*
+* @brief enable pwt module.
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void PWT_Enable(void)
+{
+
+    PWT->R1 |= PWT_R1_PWTEN_MASK; 
+    
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief disable pwt module.
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void PWT_Disable(void)
+{
+
+    PWT->R1 &= ~PWT_R1_PWTEN_MASK;
+}
+
+/*****************************************************************************//*!
+*
+* @brief enable pwt module interrupt.
+*        
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void PWT_EnableInt(void)
+
+{
+    PWT->R1 |= PWT_R1_PWTIE_MASK; 
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief disable pwt module interrupt .
+*        
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void PWT_DisableInt(void)
+
+{
+    PWT->R1 &= ~PWT_R1_PWTIE_MASK;
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief enable pwt module timer over flow interrupt.
+*        
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void PWT_EnableOverFlowInt(void)
+
+{
+    PWT->R1 |= PWT_R1_POVIE_MASK; 
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief disable pwt module timer over flow interrupt.
+*        
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void PWT_DisableOverFlowInt(void)
+
+{
+    PWT->R1 &= ~PWT_R1_POVIE_MASK; 
+}
+
+/*****************************************************************************//*!
+*
+* @brief enable pwt module data ready interrupt.
+*        
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void PWT_EnableReadyInt(void)
+
+{
+    PWT->R1 |= PWT_R1_PRDYIE_MASK; 
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief disable pwt module data ready interrupt.
+*        
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void PWT_DisableReadyInt(void)
+
+{
+    PWT->R1 &= ~PWT_R1_PRDYIE_MASK; 
+}
+
+/*****************************************************************************//*!
+*
+* @brief set pwt module soft reset.
+*        
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void PWT_SetSoftReset(void)
+{
+    PWT->R1 |= PWT_R1_PWTSR_MASK; 
+}
+
+/*****************************************************************************//*!
+*
+* @brief set pwt module input pin selct.
+*        
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void PWT_SetPinSelect(uint8_t u8PinSelect)
+{
+    PWT->R1 &= ~PWT_R1_PINSEL_MASK; 
+    PWT->R1 |= PWT_R1_PINSEL(u8PinSelect);     
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief set pwt module input edge sensitivity.
+*        
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void PWT_SetEdgeSensitivity(uint8_t u8EdgeSensitivity)
+{
+    PWT->R1 &= ~PWT_R1_EDGE_MASK; 
+    PWT->R1 |= PWT_R1_EDGE(u8EdgeSensitivity);   
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief set pwt module input clock presacler.
+*        
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void PWT_SetClockPresacler(uint8_t u8ClockPresacler)
+{
+    PWT->R1 &= ~PWT_R1_PRE_MASK; 
+    PWT->R1 |= PWT_R1_PRE(u8ClockPresacler);     
+}
+
+/*****************************************************************************//*!
+*
+* @brief get pwt overflow flag.
+*        
+*
+* @return bOverflowflag.
+*
+* @ Pass/ Fail criteria: none
+
+*****************************************************************************/
+__STATIC_INLINE uint8_t PWT_GetOverflowFlag(void)
+
+{
+    uint8_t bOverflowflag;  
+    
+    bOverflowflag = (PWT->R1 & PWT_R1_PWTOV_MASK);    
+    
+    return bOverflowflag;
+    
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief clear pwt overflow flag.
+*        
+*
+*
+* @ Pass/ Fail criteria: none
+
+*****************************************************************************/
+__STATIC_INLINE void PWT_ClrOverflowFlag(void)
+
+{
+    PWT->R1 &= ~PWT_R1_PWTOV_MASK; 
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief get pwt ready flag.
+*        
+*
+* @return bflag.
+*
+* @ Pass/ Fail criteria: none
+
+*****************************************************************************/
+__STATIC_INLINE uint8_t PWT_GetReadyFlag(void)
+
+{
+    uint8_t bReadyflag;  
+    
+    bReadyflag = (PWT->R1 & PWT_R1_PWTRDY_MASK);    
+    
+    return bReadyflag;  
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief clear pwt ready flag.
+*        
+*
+*
+* @ Pass/ Fail criteria: none
+
+*****************************************************************************/
+__STATIC_INLINE void PWT_ClrReadyFlag(void)
+
+{  
+    PWT->R1 &= ~PWT_R1_PWTRDY_MASK;
+}
+
+/******************************************************************************
+* Global functions
+******************************************************************************/
+void PWT_Init(PWT_ConfigType *pConfig);
+void PWT_SetCallback(PWT_CallbackType pfnCallback);
+void PWT_DeInit(void);
+/*! @} End of pwt_api_list                                                   */
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* PWT_H_ */
diff --git a/bsp/frdm-ke02/device/lib/inc/queue.h b/bsp/frdm-ke02/device/lib/inc/queue.h
new file mode 100755
index 0000000..6fd12a9
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/queue.h
@@ -0,0 +1,80 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file queue.h
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief Implement a first in, first out linked list. 
+*
+*******************************************************************************/
+
+#ifndef _QUEUE_H_
+#define _QUEUE_H_
+
+/********************************************************************/
+
+/* 
+ * Individual queue node
+ */
+typedef struct NODE
+{
+    struct NODE *next;
+} QNODE;
+
+/* 
+ * Queue Struture - linked list of qentry items 
+ */
+typedef struct
+{
+    QNODE *head;
+    QNODE *tail;
+} QUEUE;
+
+/*
+ * Functions provided by queue.c
+ */
+void
+queue_init(QUEUE *);
+
+int
+queue_isempty(QUEUE *);
+
+void
+queue_add(QUEUE *, QNODE *);
+
+QNODE*
+queue_remove(QUEUE *);
+
+QNODE*
+queue_peek(QUEUE *);
+
+void
+queue_move(QUEUE *, QUEUE *);
+
+/********************************************************************/
+
+#endif /* _QUEUE_H_ */
diff --git a/bsp/frdm-ke02/device/lib/inc/rtc.h b/bsp/frdm-ke02/device/lib/inc/rtc.h
new file mode 100755
index 0000000..beec23b
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/rtc.h
@@ -0,0 +1,252 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file     rtc.h
+*
+* @author   Freescale
+*
+* @version  0.0.1
+*
+* @date     Jun 25, 2013
+*
+* @brief    Real-time counter (RTC) driver head file.  
+*
+******************************************************************************/
+#ifndef RTC_H_
+#define RTC_H_
+#ifdef __cplusplus
+extern "C" {
+#endif
+/******************************************************************************
+* Includes
+******************************************************************************/
+
+/******************************************************************************
+* Constants
+******************************************************************************/
+
+/******************************************************************************
+* Macros
+******************************************************************************/
+
+/******************************************************************************
+* RTC control bit definition
+*
+*//*! @addtogroup rtc_controlbit
+* @{
+*******************************************************************************/
+
+#define RTC_OUTPUT_ENABLE           1	/*!< enable RTCO pin  */ 
+#define RTC_INTERRUPT_ENABLE        1	/*!< enable RTC interrupt  */ 
+#define RTC_CLKSRC_EXTERNAL         0	/*!< select external clock as RTC clock source  */
+#define RTC_CLKSRC_1KHZ             1	/*!< select LPO as RTC clock source  */
+#define RTC_CLKSRC_IREF             2	/*!< select internal reference clock as RTC clock source  */
+#define RTC_CLKSRC_BUS              3	/*!< select bus clock as RTC clock source  */
+#define RTC_CLK_PRESCALER_128       1	/*!< presalcer is 1 or 128 according to RTCLKS bits */
+#define RTC_CLK_PRESCALER_256       2	/*!< presalcer is 2 or 256 according to RTCLKS bits */
+#define RTC_CLK_PRESCALER_512       3	/*!< presalcer is 4 or 512 according to RTCLKS bits */
+#define RTC_CLK_PRESCALER_1024      4	/*!< presalcer is 8 or 1024 according to RTCLKS bits */
+#define RTC_CLK_PRESCALER_2048      5	/*!< presalcer is 16 or 2048 according to RTCLKS bits */
+#define RTC_CLK_PRESCALER_100       6	/*!< presalcer is 32 or 100 according to RTCLKS bits */
+#define RTC_CLK_PRESCALER_1000      7	/*!< presalcer is 64 or 1000 according to RTCLKS bits */
+
+
+/*! @} End of rtc_controlbit                                                  */
+
+/******************************************************************************
+* Types
+******************************************************************************/
+
+/*
+ * Callback type
+ */
+
+/******************************************************************************
+* RTC callback function declaration
+*
+*//*! @addtogroup rtc_callback
+* @{
+*******************************************************************************/
+
+/*!
+ * @brief RTC Callback type.
+ *
+ */
+
+typedef void (*RTC_CallbackType)(void);
+
+/*! @} End of rtc_callback                                                    */
+
+
+/* RTC configuration structure 
+ */  
+/*!
+ * @brief RTC configuration type.
+ *
+ */
+typedef struct
+{   
+    uint16_t bReserved                  : 4;    /*!< reserved */     
+    uint16_t bRTCOut                    : 1;    /*!< 1: RTCO pin is enable, 0: RTCO pin is disable */
+    uint16_t bReserved1                 : 1;    /*!< reserved */ 
+    uint16_t bInterruptEn               : 1;    /*!< 1: RTC interrupt is enable, 0: RTC interrupt is disable */
+    uint16_t bFlag                      : 1;    /*!< 1: RTC flag is set, 0: RTC flag is not set */   
+    uint16_t bClockPresaler             : 3;    /*!< 1: RTC presclaer, from 0x0 to 0x7 */    
+    uint16_t bReserved2                 : 3;    /*!< reserved */ 
+    uint16_t bClockSource               : 2;    /*!< RTC clock source selection from 0x0 to 0x3 */
+    uint16_t u16ModuloValue                ;    /*!< 16-bit rtc modulo value */
+} RTC_ConfigType, *RTC_ConfigPtr; 
+
+
+/******************************************************************************
+* Global variables
+******************************************************************************/
+
+/*!
+ * inline functions
+ */
+
+/******************************************************************************
+* RTC API list
+*
+*//*! @addtogroup rtc_api_list
+* @{
+*******************************************************************************/
+
+/*****************************************************************************//*!
+*
+* @brief enable rtc interrupt.
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void RTC_EnableInt(void)
+{
+    RTC->SC |= RTC_SC_RTIE_MASK;
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief disable rtc interrupt.
+*        
+* @param   none
+*
+* @return non
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void RTC_DisableInt(void)
+{
+    RTC->SC &= ~RTC_SC_RTIE_MASK;
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief set rtc modulo value.
+*        
+* @param[in]   u16Mod_Value
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void RTC_SetModulo(uint16_t u16Mod_Value)
+{
+ 
+    RTC->MOD = u16Mod_Value;
+}
+
+/*****************************************************************************//*!
+*
+* @brief set rtc clock source and presalcer.
+*        
+* @param[in]   u16Clock_Number clock source number
+* @param[in]   u16Presalcer prescaler value
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void RTC_SetClock(uint16_t u16Clock_Number, uint16_t u16Presalcer)
+{
+    uint32_t u32rtc_sc;
+        
+    u32rtc_sc  = RTC->SC; 
+    u32rtc_sc &= ~(RTC_SC_RTCLKS_MASK | RTC_SC_RTCPS_MASK);
+    u32rtc_sc |= RTC_SC_RTCLKS(u16Clock_Number) | RTC_SC_RTCPS(u16Presalcer); 
+    RTC->SC   = u32rtc_sc;
+}
+
+/*****************************************************************************//*!
+*
+* @brief get rtc flag bit.
+*        
+* @param  none 
+*
+* @return bflag.
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t RTC_GetFlags(void)
+{
+  uint8_t bflag;
+  
+  bflag = RTC->SC & RTC_SC_RTIF_MASK; 
+  
+  return bflag;  
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief clear rtc flag bit.
+*        
+* @param  none 
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void RTC_ClrFlags(void)
+{
+    RTC->SC |= RTC_SC_RTIF_MASK; 
+}
+
+
+/******************************************************************************
+* Global functions
+******************************************************************************/
+void RTC_Init(RTC_ConfigType *pConfig);
+void RTC_SetCallback(RTC_CallbackType pfnCallback);
+void RTC_DeInit(void);
+
+/*! @} End of rtc_api_list                                                   */
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* RTC_H_ */
diff --git a/bsp/frdm-ke02/device/lib/inc/sim.h b/bsp/frdm-ke02/device/lib/inc/sim.h
new file mode 100755
index 0000000..97a7b58
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/sim.h
@@ -0,0 +1,2535 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file sim.h
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief header file for SIM utilities. 
+*
+*******************************************************************************
+*
+* provide APIs for accessing SIM
+******************************************************************************/
+
+#ifndef SIM_H_
+#define SIM_H_
+
+/******************************************************************************
+* Includes
+******************************************************************************/
+
+/******************************************************************************
+* Constants
+******************************************************************************/
+
+/******************************************************************************
+* define SIM device ID types
+*
+*//*! @addtogroup sim_id_types
+* @{
+*******************************************************************************/
+
+typedef enum {
+    ID_TYPE_FAMID,                  /*!< device Family ID */
+    ID_TYPE_SUBFAMID,               /*!< device Subfamily ID */ 
+    ID_TYPE_REVID,                  /*!< device Revision ID */
+    ID_TYPE_PINID                   /*!< device Pin ID (Pin count) */
+} IDType;
+/*! @} End of sim_id_types                                                    					*/
+
+/******************************************************************************
+* Macros
+******************************************************************************/ 
+
+/******************************************************************************
+* Types
+******************************************************************************/
+    
+/* SIM configuration structure 
+ */ 
+ 
+/******************************************************************************
+* define SIM configuration structure
+*
+*//*! @addtogroup sim_config_type
+* @{
+*******************************************************************************/
+
+/*!
+ * @brief SIM configuration structure.
+ *
+ */
+#if defined(CPU_KE02)
+typedef struct{
+    struct{
+        uint32_t bEnableCLKOUT  : 1;        /*!< 1: enable , 0: disable */
+        uint32_t bTXDME         : 1;        /*!< 1: enable TXDME, 0: disable */
+        uint32_t bFTMSYNC       : 1;        /*!< 1: enable FTM SYNC, 0: no sync */
+        uint32_t bRXDFE         : 1;        /*!< 1: enable RXD filter, 0: no filter */
+        uint32_t bRXDCE         : 1;        /*!< 1: enable RXD capture, 0: no capture */
+        uint32_t bACIC          : 1;        /*!< 1: ACMP0 to FTM1 channel0 connection, 0: no connection */
+        uint32_t bRTCC          : 1;        /*!< 1: RTC overflow connected to FTM1 channel1, 0: no connection */
+        uint32_t u8ADHWT        : 2;        /*!< ADC h/w trigger source selection */
+        uint32_t bDisableSWD    : 1;        /*!< 1: disable SWD, 0: enable */
+        uint32_t bDisableRESET  : 1;        /*!< 1: disable RESET pin, 0: enable */
+        uint32_t bDisableNMI    : 1;        /*!< 1: disable NMI pin, 0: enable */
+        uint32_t bBusDiv        : 1;        /*!< bus divider BUSDIV value */
+    } sBits;
+    uint8_t     u8Delay;                /*!< delay value */
+    uint8_t     u8BusRef;               /*!< bus reference */
+    uint32_t    u32PinSel;              /*!< pin select reg value */
+    uint32_t    u32SCGC;                /*!< clock gating value register */   
+} SIM_ConfigType, *SIM_ConfigPtr; /*!< sim configuration structure type */
+#elif defined(CPU_KE04)
+typedef struct{
+    struct{
+        uint32_t bEnableCLKOUT  : 1;        /*!< 1: enable , 0: disable */
+        uint32_t bTXDME         : 1;        /*!< 1: enable TXDME, 0: disable */
+        uint32_t bFTMSYNC       : 1;        /*!< 1: enable FTM SYNC, 0: no sync */
+        uint32_t bRXDCE         : 1;        /*!< 1: enable RXD capture, 0: no capture */
+        uint32_t bRXDFE         : 2;        /*!< 1: enable RXD filter, 0: no filter */
+        uint32_t u8ADHWT        : 3;        /*!< ADC h/w trigger source selection */
+        uint32_t bFTMIC         : 2;        /*!< FTM0CH0 input capture source selection */
+        uint32_t bACTRG         : 1;        /*!< ACMP Trigger FTM2 selection*/
+        uint32_t bDisableSWD    : 1;        /*!< 1: disable SWD, 0: enable */
+        uint32_t bDisableRESET  : 1;        /*!< 1: disable RESET pin, 0: enable */
+        uint32_t bDisableNMI    : 1;        /*!< 1: disable NMI pin, 0: enable */
+    } sBits;
+    uint8_t     u8Delay;                /*!< delay value */
+    uint8_t     u8BusRef;               /*!< bus reference */
+    uint32_t    u32PinSel;              /*!< pin select reg value */
+    uint32_t    u32SCGC;                /*!< clock gating value register */ 
+    uint32_t    u32CLKDIV;              /*!< clock divider CLKDIV value */   
+} SIM_ConfigType, *SIM_ConfigPtr; /*!< sim configuration structure type */
+#elif defined(CPU_KE06)
+typedef struct{
+    struct{
+        uint32_t bEnableCLKOUT  : 1;        /*!< 1: enable , 0: disable */
+        uint32_t bTXDME         : 1;        /*!< 1: enable TXDME, 0: disable */
+        uint32_t bFTMSYNC       : 1;        /*!< 1: enable FTM SYNC, 0: no sync */
+        uint32_t bRXDCE         : 1;        /*!< 1: enable RXD capture, 0: no capture */
+        uint32_t bRXDFE         : 2;        /*!< 1: enable RXD filter, 0: no filter */
+        uint32_t u8ADHWT        : 3;        /*!< ADC h/w trigger source selection */
+        uint32_t bACTRG         : 1;        /*!< ACMP Trigger FTM2 selection*/
+        uint32_t bDisableSWD    : 1;        /*!< 1: disable SWD, 0: enable */
+        uint32_t bDisableRESET  : 1;        /*!< 1: disable RESET pin, 0: enable */
+        uint32_t bDisableNMI    : 1;        /*!< 1: disable NMI pin, 0: enable */
+    } sBits;
+    uint8_t     u8Delay;                /*!< delay value */
+    uint8_t     u8BusRef;               /*!< bus reference */
+    uint32_t    u32PinSel;              /*!< pin select reg value */
+    uint32_t    u32SCGC;                /*!< clock gating value register */ 
+    uint32_t    u32CLKDIV;              /*!< clock divider CLKDIV value */   
+} SIM_ConfigType, *SIM_ConfigPtr; /*!< sim configuration structure type */
+#endif
+/*! @} End of sim_config_type                                                    					*/
+  
+/******************************************************************************
+* Global variables
+******************************************************************************/
+
+/******************************************************************************
+* Global functions
+******************************************************************************/
+/******************************************************************************
+* define SIM API list
+*
+*//*! @addtogroup sim_api_list
+* @{
+*******************************************************************************/
+#if defined(CPU_KE02)
+/*****************************************************************************//*!
+*
+* @brief delay FTM2 triggering ADC for u8Delay bus clock output divide. 
+*        
+* @param[in]   u8Delay     delay value of Bus clock output divide.
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_DelayFTM2Trig2ADC(uint8_t u8Delay)
+{
+    SIM->SOPT = (SIM->SOPT & ~(SIM_SOPT_DELAY_MASK)) | SIM_SOPT_DELAY(u8Delay);    
+}
+/*****************************************************************************//*!
+*
+* @brief enable clock output.
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+* @see  SIM_DisableClockOutput
+*****************************************************************************/
+__STATIC_INLINE void SIM_EnableClockOutput(void)
+{
+    SIM->SOPT |= (SIM_SOPT_CLKOE_MASK);    
+}
+
+/*****************************************************************************//*!
+*
+* @brief disable clock output.
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+* @see  SIM_EnableClockOutput
+*****************************************************************************/
+__STATIC_INLINE void SIM_DisableClockOutput(void)
+{
+    SIM->SOPT &= ~(SIM_SOPT_CLKOE_MASK);    
+}
+/*****************************************************************************//*!
+*
+* @brief set bus clock output divide. 
+*        
+* @param[in]  u8Divide     divide (3-bits)
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SetClockOutputDivide(uint8_t u8Divide)
+{
+    SIM->SOPT = (SIM->SOPT & ~(SIM_SOPT_BUSREF_MASK)) | SIM_SOPT_BUSREF(u8Divide & 0x07);    
+}
+/*****************************************************************************//*!
+*
+* @brief enable UART0 RXD connect with UART0 module  and FTM0 channel 1.. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_EnableUART0RXDConnectFTMOCH1(void)
+{
+    SIM->SOPT |= (SIM_SOPT_RXDCE_MASK);    
+}
+/*****************************************************************************//*!
+*
+* @brief enable UART0 TX modulation. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_EnableUART0Modulation(void)
+{
+    SIM->SOPT |= (SIM_SOPT_TXDME_MASK);    
+}
+
+/*****************************************************************************//*!
+*
+* @brief disable UART0 TX modulation. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_DisableUART0Modulation(void)
+{
+    SIM->SOPT &= ~(SIM_SOPT_TXDME_MASK);    
+}
+/*****************************************************************************//*!
+*
+* @brief generate a softare sync trigger to FTM2 module (trigger).
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_GenerateSoftwareTrig2FTM2(void)
+{
+    SIM->SOPT |= (SIM_SOPT_FTMSYNC_MASK);    
+}
+/*****************************************************************************//*!
+*
+* @brief remap FTM2CH3 pin from default to the other. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM2CH3Pin(void)
+{
+    SIM->PINSEL |= SIM_PINSEL_FTM2PS3_MASK;    
+}
+
+/*****************************************************************************//*!
+*
+* @brief remap FTM2CH2 pin from default  to the other. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM2CH2Pin(void)
+{
+    SIM->PINSEL |= SIM_PINSEL_FTM2PS2_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap FTM0CH1 pin from default  to the other. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM0CH1Pin(void)
+{
+    SIM->PINSEL |= SIM_PINSEL_FTM0PS1_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap FTM0CH0 pin from default  to the other. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM0CH0Pin(void)
+{
+    SIM->PINSEL |= SIM_PINSEL_FTM0PS0_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap UART0 pin from default  to the other. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapUART0Pin(void)
+{
+    SIM->PINSEL |= SIM_PINSEL_UART0PS_MASK;    
+}
+
+/*****************************************************************************//*!
+*
+* @brief remap SPI0 pin from default  to the other. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapSPI0Pin(void)
+{
+    SIM->PINSEL |= SIM_PINSEL_SPI0PS_MASK;    
+}
+
+/*****************************************************************************//*!
+*
+* @brief remap I2C pin from default  to the other. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapI2CPin(void)
+{
+    SIM->PINSEL |= SIM_PINSEL_IICPS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief enable UART0 RX filter. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_EnableUART0Filter(void)
+{
+    SIM->SOPT |= (SIM_SOPT_RXDFE_MASK);    
+}
+/******************************************************************************!
+
+* @function name: SIM_DisableUART0Filter
+*
+* @brief disable UART0 RX filter. 
+*        
+* @param         
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_DisableUART0Filter(void)
+{
+    SIM->SOPT &= ~(SIM_SOPT_RXDFE_MASK);    
+}
+/*****************************************************************************//*!
+*
+* @brief set ADC hardware trigger source to RTC overflow. 
+*        
+* @param  none        
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_TriggerADCByRTC(void)
+{
+    SIM->SOPT &= ~(SIM_SOPT_ADHWT_MASK);    
+}
+/*****************************************************************************//*!
+*
+* @brief set ADC hardware trigger source to PIT . 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_TriggerADCByPIT(void)
+{
+    SIM->SOPT = (SIM->SOPT & ~(SIM_SOPT_ADHWT_MASK)) | SIM_SOPT_ADHWT(1);    
+}
+/*****************************************************************************//*!
+*
+* @brief set ADC hardware trigger source to FTM2 init trigger with 8-bit programmable delay. 
+*        
+* @param  none      
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_TriggerADCByFTM2Init(void)
+{
+    SIM->SOPT = (SIM->SOPT & ~(SIM_SOPT_ADHWT_MASK)) | SIM_SOPT_ADHWT(2);    
+}
+
+/*****************************************************************************//*!
+*
+* @brief set ADC hardware trigger source to FTM2 match trigger with 8-bit programmable delay. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_TriggerADCByFTM2Match(void)
+{
+    SIM->SOPT = (SIM->SOPT & ~(SIM_SOPT_ADHWT_MASK)) | SIM_SOPT_ADHWT(3);    
+}
+/*****************************************************************************//*!
+*
+* @brief enable RTC capture to FTM1 input channel1. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_EnableRTCCapture(void)
+{
+    SIM->SOPT |= (SIM_SOPT_RTCC_MASK);    
+}
+/*****************************************************************************//*!
+*
+* @brief disable RTC capture to FTM1 input channel1. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_DisableRTCCapture(void)
+{
+    SIM->SOPT &= ~(SIM_SOPT_RTCC_MASK);    
+}
+/*****************************************************************************//*!
+*
+* @brief enable ACMP0 input capture to FTM1 input channel0. 
+*        
+* @param  none      
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_EnableACMP0InputCapture(void)
+{
+    SIM->SOPT |= (SIM_SOPT_ACIC_MASK);    
+}
+/*****************************************************************************//*!
+*
+* @brief disable ACMP0 input capture to FTM1 input channel0. 
+*        
+* @param  none      
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_DisableACMP0InputCapture(void)
+{
+    SIM->SOPT &= ~(SIM_SOPT_ACIC_MASK);    
+}
+/*****************************************************************************//*!
+*
+* @brief remap RTC pin from default  to the other. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapRTCPin(void)
+{
+    SIM->PINSEL |= SIM_PINSEL_RTCPS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief set bus divide BUSDIV.
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SetBusDivide(uint8_t u8Divide)
+{
+    SIM->BUSDIV = u8Divide;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap FTM2CH1 pin from default  to the other. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM2CH1Pin(void)
+{
+    SIM->PINSEL |= SIM_PINSEL_FTM2PS1_MASK;    
+}
+
+/*****************************************************************************//*!
+*
+* @brief remap FTM2CH0 pin from default  to the other. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM2CH0Pin(void)
+{
+    SIM->PINSEL |= SIM_PINSEL_FTM2PS0_MASK;    
+}
+
+/*****************************************************************************//*!
+*
+* @brief remap FTM1CH1 pin from default  to the other. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM1CH1Pin(void)
+{
+    SIM->PINSEL |= SIM_PINSEL_FTM1PS1_MASK;    
+}
+
+/*****************************************************************************//*!
+*
+* @brief remap FTM1CH0 pin from default  to the other. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM1CH0Pin(void)
+{
+    SIM->PINSEL |= SIM_PINSEL_FTM1PS0_MASK;    
+}
+#elif defined(CPU_KE04)
+/*****************************************************************************//*!
+*
+* @brief delay FTM2 triggering ADC for u8Delay bus clock output divide. 
+*        
+* @param[in]   u8Delay     delay value of Bus clock output divide.
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_DelayFTM2Trig2ADC(uint8_t u8Delay)
+{
+    SIM->SOPT = (SIM->SOPT & ~(SIM_SOPT_DELAY_MASK)) | SIM_SOPT_DELAY(u8Delay);    
+}
+/*****************************************************************************//*!
+*
+* @brief enable clock output.
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+* @see  SIM_DisableClockOutput
+*****************************************************************************/
+__STATIC_INLINE void SIM_EnableClockOutput(void)
+{
+    SIM->SOPT |= (SIM_SOPT_CLKOE_MASK);    
+}
+
+/*****************************************************************************//*!
+*
+* @brief disable clock output.
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+* @see  SIM_EnableClockOutput
+*****************************************************************************/
+__STATIC_INLINE void SIM_DisableClockOutput(void)
+{
+    SIM->SOPT &= ~(SIM_SOPT_CLKOE_MASK);    
+}
+/*****************************************************************************//*!
+*
+* @brief set bus clock output divide. 
+*        
+* @param[in]  u8Divide     divide (3-bits)
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SetClockOutputDivide(uint8_t u8Divide)
+{
+    SIM->SOPT = (SIM->SOPT & ~(SIM_SOPT_BUSREF_MASK)) | SIM_SOPT_BUSREF(u8Divide & 0x07);    
+}
+/*****************************************************************************//*!
+*
+* @brief enable UART0 RXD connect with UART0 module  and FTM0 channel 1.. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_EnableUART0RXDConnectFTMOCH1(void)
+{
+    SIM->SOPT |= (SIM_SOPT_RXDCE_MASK);    
+}
+/*****************************************************************************//*!
+*
+* @brief enable UART0 TX modulation. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_EnableUART0Modulation(void)
+{
+    SIM->SOPT |= (SIM_SOPT_TXDME_MASK);    
+}
+
+/*****************************************************************************//*!
+*
+* @brief disable UART0 TX modulation. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_DisableUART0Modulation(void)
+{
+    SIM->SOPT &= ~(SIM_SOPT_TXDME_MASK);    
+}
+/*****************************************************************************//*!
+*
+* @brief generate a softare sync trigger to FTM2 module (trigger).
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_GenerateSoftwareTrig2FTM2(void)
+{
+    SIM->SOPT |= (SIM_SOPT_FTMSYNC_MASK);    
+}
+/*****************************************************************************//*!
+*
+* @brief remap FTM2CH3 pin from default to the other. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM2CH3Pin(void)
+{
+    SIM->PINSEL |= SIM_PINSEL_FTM2PS3_MASK;    
+}
+
+/*****************************************************************************//*!
+*
+* @brief remap FTM2CH2 pin from default  to the other. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM2CH2Pin(void)
+{
+    SIM->PINSEL |= SIM_PINSEL_FTM2PS2_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap FTM0CH1 pin from default  to the other. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM0CH1Pin(void)
+{
+    SIM->PINSEL |= SIM_PINSEL_FTM0PS1_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap FTM0CH0 pin from default  to the other. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM0CH0Pin(void)
+{
+    SIM->PINSEL |= SIM_PINSEL_FTM0PS0_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap UART0 pin from default  to the other. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapUART0Pin(void)
+{
+    SIM->PINSEL |= SIM_PINSEL_UART0PS_MASK;    
+}
+
+/*****************************************************************************//*!
+*
+* @brief remap SPI0 pin from default  to the other. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapSPI0Pin(void)
+{
+    SIM->PINSEL |= SIM_PINSEL_SPI0PS_MASK;    
+}
+
+/*****************************************************************************//*!
+*
+* @brief remap I2C pin from default  to the other. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapI2CPin(void)
+{
+    SIM->PINSEL |= SIM_PINSEL_IICPS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief UART0 RXD input signal is connected to UART0 module directly. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_EnableUART0Filter(void)
+{
+    SIM->SOPT &= ~(SIM_SOPT_RXDFE_MASK);   
+}
+/*****************************************************************************//*!
+*
+* @brief UART0 RXD input signal is filtered by ACMP0, then injected to UART0. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_EnableUART0FilterByACMP0(void)
+{
+    SIM->SOPT = (SIM->SOPT & ~(SIM_SOPT_RXDFE_MASK)) | SIM_SOPT_RXDFE(1);  
+}
+/*****************************************************************************//*!
+*
+* @brief UART0 RXD input signal is filtered by ACMP1, then injected to UART0. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_EnableUART0FilterByACMP1(void)
+{
+    SIM->SOPT = (SIM->SOPT & ~(SIM_SOPT_RXDFE_MASK)) | SIM_SOPT_RXDFE(2);  
+}
+/*****************************************************************************//*!
+*
+* @brief set ADC hardware trigger source to RTC overflow. 
+*        
+* @param  none        
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_TriggerADCByRTC(void)
+{
+    SIM->SOPT &= ~(SIM_SOPT_ADHWT_MASK);    
+}
+/*****************************************************************************//*!
+*
+* @brief set ADC hardware trigger source to FTM0 init trigger . 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_TriggerADCByPIT(void)
+{
+    SIM->SOPT = (SIM->SOPT & ~(SIM_SOPT_ADHWT_MASK)) | SIM_SOPT_ADHWT(1);    
+}
+/*****************************************************************************//*!
+*
+* @brief set ADC hardware trigger source to FTM2 init trigger with 8-bit programmable delay. 
+*        
+* @param  none      
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_TriggerADCByFTM2Init(void)
+{
+    SIM->SOPT = (SIM->SOPT & ~(SIM_SOPT_ADHWT_MASK)) | SIM_SOPT_ADHWT(2);    
+}
+
+/*****************************************************************************//*!
+*
+* @brief set ADC hardware trigger source to FTM2 match trigger with 8-bit programmable delay. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_TriggerADCByFTM2Match(void)
+{
+    SIM->SOPT = (SIM->SOPT & ~(SIM_SOPT_ADHWT_MASK)) | SIM_SOPT_ADHWT(3);    
+}
+
+/*****************************************************************************//*!
+*
+* @brief set ADC hardware trigger source to PIT channel0 overflow. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_TriggerADCByPITCH0Overflow(void)
+{
+    SIM->SOPT = (SIM->SOPT & ~(SIM_SOPT_ADHWT_MASK)) | SIM_SOPT_ADHWT(4);    
+}
+/*****************************************************************************//*!
+*
+* @brief set ADC hardware trigger source to PIT channel1 overflow. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_TriggerADCByPITChannel1Overflow(void)
+{
+    SIM->SOPT = (SIM->SOPT & ~(SIM_SOPT_ADHWT_MASK)) | SIM_SOPT_ADHWT(5);    
+}
+/*****************************************************************************//*!
+*
+* @brief set ADC hardware trigger source to ACMP0 out. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_TriggerADCByACMP0Out(void)
+{
+    SIM->SOPT = (SIM->SOPT & ~(SIM_SOPT_ADHWT_MASK)) | SIM_SOPT_ADHWT(6);    
+}
+/*****************************************************************************//*!
+*
+* @brief set ADC hardware trigger source to ACMP1 out. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_TriggerADCByACMP1Out(void)
+{
+    SIM->SOPT = (SIM->SOPT & ~(SIM_SOPT_ADHWT_MASK)) | SIM_SOPT_ADHWT(7);    
+}
+/*****************************************************************************//*!
+*
+* @brief Select FTM0CH0 as FTM0CH0 Input Capture Source. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SelFTM0CH0AsFTM0CH0ICS(void)
+{
+    SIM->SOPT &= ~(SIM_SOPT_FTMIC_MASK);   
+}
+/*****************************************************************************//*!
+*
+* @brief Select ACMP0 OUT as FTM0CH0 Input Capture Source. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SelACMP0AsFTM0CH0ICS(void)
+{
+    SIM->SOPT = (SIM->SOPT & ~(SIM_SOPT_FTMIC_MASK)) | SIM_SOPT_FTMIC(1);  
+}
+/*****************************************************************************//*!
+*
+* @brief Select ACMP1 OUT as FTM0CH0 Input Capture Source. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SelACMP1AsFTM0CH0ICS(void)
+{
+    SIM->SOPT = (SIM->SOPT & ~(SIM_SOPT_FTMIC_MASK)) | SIM_SOPT_FTMIC(2);  
+}
+/*****************************************************************************//*!
+*
+* @brief Select RTC overflow as FTM0CH0 Input Capture Source. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SelRTCOverflowAsFTM0CH0ICS(void)
+{
+    SIM->SOPT = (SIM->SOPT & ~(SIM_SOPT_FTMIC_MASK)) | SIM_SOPT_FTMIC(3);  
+}
+/*****************************************************************************//*!
+*
+* @brief Select ACMP0 output as the trigger0 input of FTM2. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SelACMP0AsFTM2Trigger0(void)
+{
+    SIM->SOPT &= ~(SIM_SOPT_ACTRG_MASK);  
+}
+/*****************************************************************************//*!
+*
+* @brief Select ACMP1 output as the trigger0 input of FTM2. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SelACMP1AsFTM2Trigger0(void)
+{
+    SIM->SOPT |= (SIM_SOPT_ACTRG_MASK);  
+}
+/*****************************************************************************//*!
+*
+* @brief set clock3 divide CLKDIV.
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SetClock3Divide(void)
+{
+    SIM->CLKDIV |= SIM_CLKDIV_OUTDIV3_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief set clock2 divide CLKDIV.
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SetClock2Divide(void)
+{
+    SIM->CLKDIV |= SIM_CLKDIV_OUTDIV2_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief set clock1 divide CLKDIV.
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SetClock1Divide(uint8_t u8divide)
+{
+    SIM->CLKDIV |= SIM_CLKDIV_OUTDIV1(u8divide);    
+}
+/*****************************************************************************//*!
+*
+* @brief select TCLK2 for PWT module. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SelectTCLK2ForPWT(void)
+{
+    SIM->PINSEL |= SIM_PINSEL_PWTCLKPS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief select TCLK1 for PWT module. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SelectTCLK1ForPWT(void)
+{
+    SIM->PINSEL &= ~SIM_PINSEL_PWTCLKPS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief select TCLK2 for FTM2 module. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SelectTCLK2ForFTM2(void)
+{
+    SIM->PINSEL |= SIM_PINSEL_FTM2CLKPS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief select TCLK1 for FTM2 module. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SelectTCLK1ForFTM2(void)
+{
+    SIM->PINSEL &= ~SIM_PINSEL_FTM2CLKPS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief select TCLK2 for FTM0 module. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SelectTCLK2ForFTM0(void)
+{
+    SIM->PINSEL |= SIM_PINSEL_FTM0CLKPS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief select TCLK1 for FTM0 module. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SelectTCLK1ForFTM0(void)
+{
+    SIM->PINSEL &= ~SIM_PINSEL_FTM0CLKPS_MASK;    
+}
+#elif defined(CPU_KE06)
+/*****************************************************************************//*!
+*
+* @brief delay FTM2 triggering ADC for u8Delay bus clock output divide. 
+*        
+* @param[in]   u8Delay     delay value of Bus clock output divide.
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_DelayFTM2Trig2ADC(uint8_t u8Delay)
+{
+    SIM->SOPT0 = (SIM->SOPT0 & ~(SIM_SOPT0_DELAY_MASK)) | SIM_SOPT0_DELAY(u8Delay);    
+}
+/*****************************************************************************//*!
+*
+* @brief enable clock output.
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+* @see  SIM_DisableClockOutput
+*****************************************************************************/
+__STATIC_INLINE void SIM_EnableClockOutput(void)
+{
+    SIM->SOPT0 |= (SIM_SOPT0_CLKOE_MASK);    
+}
+
+/*****************************************************************************//*!
+*
+* @brief disable clock output.
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+* @see  SIM_EnableClockOutput
+*****************************************************************************/
+__STATIC_INLINE void SIM_DisableClockOutput(void)
+{
+    SIM->SOPT0 &= ~(SIM_SOPT0_CLKOE_MASK);    
+}
+/*****************************************************************************//*!
+*
+* @brief set bus clock output divide. 
+*        
+* @param[in]  u8Divide     divide (3-bits)
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SetClockOutputDivide(uint8_t u8Divide)
+{
+    SIM->SOPT0 = (SIM->SOPT0 & ~(SIM_SOPT0_BUSREF_MASK)) | SIM_SOPT0_BUSREF(u8Divide & 0x07);    
+}
+/*****************************************************************************//*!
+*
+* @brief enable UART0 RXD connect with UART0 module  and FTM0 channel 1.. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_EnableUART0RXDConnectFTMOCH1(void)
+{
+    SIM->SOPT0 |= (SIM_SOPT0_RXDCE_MASK);    
+}
+/*****************************************************************************//*!
+*
+* @brief enable UART0 TX modulation. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_EnableUART0Modulation(void)
+{
+    SIM->SOPT0 |= (SIM_SOPT0_TXDME_MASK);    
+}
+
+/*****************************************************************************//*!
+*
+* @brief disable UART0 TX modulation. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_DisableUART0Modulation(void)
+{
+    SIM->SOPT0 &= ~(SIM_SOPT0_TXDME_MASK);    
+}
+/*****************************************************************************//*!
+*
+* @brief generate a softare sync trigger to FTM2 module (trigger).
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_GenerateSoftwareTrig2FTM2(void)
+{
+    SIM->SOPT0 |= (SIM_SOPT0_FTMSYNC_MASK);    
+}
+/*****************************************************************************//*!
+*
+* @brief select PWTIN3 input signal from UART0RX.
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+
+__STATIC_INLINE void SIM_SetPWTIN3InputFromUART0Rx(void)
+{
+    SIM->SOPT1 = (SIM->SOPT1 & (~SIM_SOPT1_UARTPWTS_MASK)) | SIM_SOPT1_UARTPWTS(0);    
+}
+/*****************************************************************************//*!
+*
+* @brief select PWTIN3 input signal from UART1RX.
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+
+__STATIC_INLINE void SIM_SetPWTIN3InputFromUART1Rx(void)
+{
+    SIM->SOPT1 = (SIM->SOPT1 & (~SIM_SOPT1_UARTPWTS_MASK)) | SIM_SOPT1_UARTPWTS(1);    
+}
+/*****************************************************************************//*!
+*
+* @brief select PWTIN3 input signal from UART2RX.
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+
+__STATIC_INLINE void SIM_SetPWTIN3InputFromUART2Rx(void)
+{
+    SIM->SOPT1 = (SIM->SOPT1 & (~SIM_SOPT1_UARTPWTS_MASK)) | SIM_SOPT1_UARTPWTS(2);    
+}
+/*****************************************************************************//*!
+*
+* @brief select PWTIN2 input signal from ACMP0_OUT.
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SetPWTIN2InputFromACMP0(void)
+{
+    SIM->SOPT1 &= (~SIM_SOPT1_ACPWTS_MASK);    
+}
+/*****************************************************************************//*!
+*
+* @brief select PWTIN2 input signal from ACMP1_OUT.
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SetPWTIN2InputFromACMP1(void)
+{
+    SIM->SOPT1 |= SIM_SOPT1_ACPWTS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief enable invertion of the I2C output.
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_EnableI2C0OuputInvertion(void)
+{
+    SIM->SOPT1 |= SIM_SOPT1_I2C0OINV_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief disable invertion of the I2C output.
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_DisableI2C0OuputInvertion(void)
+{
+    SIM->SOPT1 &= ~SIM_SOPT1_I2C0OINV_MASK;    
+}
+
+/*****************************************************************************//*!
+*
+* @brief enable 4-wire I2C.
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_Enable4WireI2C0(void)
+{
+    SIM->SOPT1 |= SIM_SOPT1_I2C04WEN_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief  disable 4-wire I2C..
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_Disable4WireI2C0(void)
+{
+    SIM->SOPT1 &= ~SIM_SOPT1_I2C04WEN_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief UART0 RXD input signal is connected to UART0 module directly. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_EnableUART0Filter(void)
+{
+    SIM->SOPT0 &= ~(SIM_SOPT0_RXDFE_MASK);   
+}
+/*****************************************************************************//*!
+*
+* @brief UART0 RXD input signal is filtered by ACMP0, then injected to UART0. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_EnableUART0FilterByACMP0(void)
+{
+    SIM->SOPT0 = (SIM->SOPT0 & ~(SIM_SOPT0_RXDFE_MASK)) | SIM_SOPT0_RXDFE(1);  
+}
+/*****************************************************************************//*!
+*
+* @brief UART0 RXD input signal is filtered by ACMP1, then injected to UART0. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_EnableUART0FilterByACMP1(void)
+{
+    SIM->SOPT0 = (SIM->SOPT0 & ~(SIM_SOPT0_RXDFE_MASK)) | SIM_SOPT0_RXDFE(2);  
+}
+/*****************************************************************************//*!
+*
+* @brief set ADC hardware trigger source to RTC overflow. 
+*        
+* @param  none        
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_TriggerADCByRTC(void)
+{
+    SIM->SOPT0 &= ~(SIM_SOPT0_ADHWT_MASK);    
+}
+/*****************************************************************************//*!
+*
+* @brief set ADC hardware trigger source to PIT . 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_TriggerADCByPIT(void)
+{
+    SIM->SOPT0 = (SIM->SOPT0 & ~(SIM_SOPT0_ADHWT_MASK)) | SIM_SOPT0_ADHWT(1);    
+}
+/*****************************************************************************//*!
+*
+* @brief set ADC hardware trigger source to FTM2 init trigger with 8-bit programmable delay. 
+*        
+* @param  none      
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_TriggerADCByFTM2Init(void)
+{
+    SIM->SOPT0 = (SIM->SOPT0 & ~(SIM_SOPT0_ADHWT_MASK)) | SIM_SOPT0_ADHWT(2);    
+}
+
+/*****************************************************************************//*!
+*
+* @brief set ADC hardware trigger source to FTM2 match trigger with 8-bit programmable delay. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_TriggerADCByFTM2Match(void)
+{
+    SIM->SOPT0 = (SIM->SOPT0 & ~(SIM_SOPT0_ADHWT_MASK)) | SIM_SOPT0_ADHWT(3);    
+}
+/*****************************************************************************//*!
+*
+* @brief set ADC hardware trigger source to PIT channel0 overflow. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_TriggerADCByPITCH0Overflow(void)
+{
+    SIM->SOPT0 = (SIM->SOPT0 & ~(SIM_SOPT0_ADHWT_MASK)) | SIM_SOPT0_ADHWT(4);    
+}
+/*****************************************************************************//*!
+*
+* @brief set ADC hardware trigger source to PIT channel1 overflow. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_TriggerADCByPITChannel1Overflow(void)
+{
+    SIM->SOPT0 = (SIM->SOPT0 & ~(SIM_SOPT0_ADHWT_MASK)) | SIM_SOPT0_ADHWT(5);    
+}
+/*****************************************************************************//*!
+*
+* @brief set ADC hardware trigger source to ACMP0 out. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_TriggerADCByACMP0Out(void)
+{
+    SIM->SOPT0 = (SIM->SOPT0 & ~(SIM_SOPT0_ADHWT_MASK)) | SIM_SOPT0_ADHWT(6);    
+}
+/*****************************************************************************//*!
+*
+* @brief set ADC hardware trigger source to ACMP1 out. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_TriggerADCByACMP1Out(void)
+{
+    SIM->SOPT0 = (SIM->SOPT0 & ~(SIM_SOPT0_ADHWT_MASK)) | SIM_SOPT0_ADHWT(7);    
+}
+/*****************************************************************************//*!
+*
+* @brief Select ACMP0 output as the trigger0 input of FTM2. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SelACMP0AsFTM2Trigger0(void)
+{
+    SIM->SOPT0 &= ~(SIM_SOPT0_ACTRG_MASK);  
+}
+/*****************************************************************************//*!
+*
+* @brief Select ACMP1 output as the trigger0 input of FTM2. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SelACMP1AsFTM2Trigger0(void)
+{
+    SIM->SOPT0 |= (SIM_SOPT0_ACTRG_MASK);  
+}
+/*****************************************************************************//*!
+*
+* @brief enable RTC capture to FTM1 input channel1. 
+*        
+* @param  none       
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_EnableRTCCapture(void)
+{
+    SIM->SOPT0 |= (SIM_SOPT0_RTCC_MASK);    
+}
+/*****************************************************************************//*!
+*
+* @brief enable ACMP0 input capture to FTM1 input channel0. 
+*        
+* @param  none      
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_EnableACMP0InputCapture(void)
+{
+    SIM->SOPT0 |= (SIM_SOPT0_ACIC_MASK);    
+}
+/*****************************************************************************//*!
+*
+* @brief select TCLK0 for PWT module. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SelectTCLK0ForPWT(void)
+{
+    SIM->PINSEL &= ~SIM_PINSEL_PWTCLKPS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief select TCLK1 for PWT module. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SelectTCLK1ForPWT(void)
+{
+    SIM->PINSEL = (SIM->PINSEL&(~SIM_PINSEL_PWTCLKPS_MASK)) | SIM_PINSEL_PWTCLKPS(1) ;    
+}
+/*****************************************************************************//*!
+*
+* @brief select TCLK2 for PWT module. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SelectTCLK2ForPWT(void)
+{
+    SIM->PINSEL = (SIM->PINSEL&(~SIM_PINSEL_PWTCLKPS_MASK)) | SIM_PINSEL_PWTCLKPS(2) ;    
+}
+/*****************************************************************************//*!
+*
+* @brief select TCLK0 for FTM2 module. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SelectTCLK0ForFTM2(void)
+{
+    SIM->PINSEL &= ~SIM_PINSEL_FTM2CLKPS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief select TCLK1 for FTM2 module. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SelectTCLK1ForFTM2(void)
+{
+    SIM->PINSEL = (SIM->PINSEL & (~SIM_PINSEL_FTM2CLKPS_MASK)) | (((uint32_t)0x1)<<SIM_PINSEL_FTM2CLKPS_SHIFT);    
+}
+/*****************************************************************************//*!
+*
+* @brief select TCLK2 for FTM2 module. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SelectTCLK2ForFTM2(void)
+{
+    SIM->PINSEL =(SIM->PINSEL & (~SIM_PINSEL_FTM2CLKPS_MASK)) | (((uint32_t)0x2)<<SIM_PINSEL_FTM2CLKPS_SHIFT);    
+}
+/*****************************************************************************//*!
+*
+* @brief select TCLK0 for FTM1 module. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SelectTCLK0ForFTM1(void)
+{
+    SIM->PINSEL &= ~SIM_PINSEL_FTM1CLKPS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief select TCLK1 for FTM1 module. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SelectTCLK1ForFTM1(void)
+{
+    SIM->PINSEL = (SIM->PINSEL & (~SIM_PINSEL_FTM1CLKPS_MASK)) | (((uint32_t)0x1)<<SIM_PINSEL_FTM1CLKPS_SHIFT);    
+}
+/*****************************************************************************//*!
+*
+* @brief select TCLK2 for FTM1 module. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SelectTCLK2ForFTM1(void)
+{
+    SIM->PINSEL = (SIM->PINSEL & (~SIM_PINSEL_FTM1CLKPS_MASK)) | (((uint32_t)0x2)<<SIM_PINSEL_FTM1CLKPS_SHIFT);    
+}
+/*****************************************************************************//*!
+*
+* @brief select TCLK0 for FTM0 module. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SelectTCLK0ForFTM0(void)
+{
+    SIM->PINSEL &= ~SIM_PINSEL_FTM0CLKPS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief select TCLK1 for FTM0 module. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SelectTCLK1ForFTM0(void)
+{
+    SIM->PINSEL = (SIM->PINSEL &(~SIM_PINSEL_FTM0CLKPS_MASK)) | (((uint32_t)0x1)<<SIM_PINSEL_FTM0CLKPS_SHIFT);    
+}
+/*****************************************************************************//*!
+*
+* @brief select TCLK2 for FTM0 module. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SelectTCLK2ForFTM0(void)
+{
+    SIM->PINSEL = (SIM->PINSEL &(~SIM_PINSEL_FTM0CLKPS_MASK)) | (((uint32_t)0x2)<<SIM_PINSEL_FTM0CLKPS_SHIFT);    
+}
+/*****************************************************************************//*!
+*
+* @brief remap FTM1CH1 to pin PTC5 (default). 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM1CH1ToPTC5(void)
+{
+    SIM->PINSEL &= ~SIM_PINSEL_FTM1PS1_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap FTM1CH1 to pin PTE7. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM1CH1ToPTE7(void)
+{
+    SIM->PINSEL |= SIM_PINSEL_FTM1PS1_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap FTM1CH0 to pin PTC4 (default). 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM1CH0ToPTC4(void)
+{
+    SIM->PINSEL &= ~SIM_PINSEL_FTM1PS0_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap FTM1CH0 to pin PTH2. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM1CH0ToPTH2(void)
+{
+    SIM->PINSEL |= SIM_PINSEL_FTM1PS0_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap FTM0CH1 to pin PTA1 (default). 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM0CH1ToPTA1(void)
+{
+    SIM->PINSEL |= SIM_PINSEL_FTM0PS1_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap FTM0CH1 to pin PTB3. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM0CH1ToPTB3(void)
+{
+    SIM->PINSEL &= ~SIM_PINSEL_FTM0PS1_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap FTM0CH0 to pin PTA0 (default). 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM0CH0ToPTA1(void)
+{
+    SIM->PINSEL |= SIM_PINSEL_FTM0PS0_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap FTM0CH0 to pin PTB2. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM0CH0ToPTB3(void)
+{
+    SIM->PINSEL &= ~SIM_PINSEL_FTM0PS0_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap UART0 to pin PTB0/1 (default). 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapUART0ToPTB_0_1(void)
+{
+    SIM->PINSEL &= ~SIM_PINSEL_UART0PS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap UART0 to pin PTA2/3. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapUART0ToPTA_2_3(void)
+{
+    SIM->PINSEL |= SIM_PINSEL_UART0PS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap SPI0 to pin PTB2/3/4/5 (default).  
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapSPI0ToPTB_2_3_4_5(void)
+{
+    SIM->PINSEL &= ~SIM_PINSEL_SPI0PS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap SPI0 to pin PTE01/2/3.  
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapSPI0ToPTE_0_12_3(void)
+{
+    SIM->PINSEL |= SIM_PINSEL_SPI0PS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap I2C to pin PTA2/3 (default).  
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapI2CToPTA_2_3(void)
+{
+    SIM->PINSEL &= ~SIM_PINSEL_I2C0PS_MASK;    
+}   
+/*****************************************************************************//*!
+*
+* @brief remap I2C to pin PTB6/7 (default).  
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapI2CToPTB_6_7(void)
+{
+    SIM->PINSEL |= SIM_PINSEL_I2C0PS_MASK;    
+} 
+/*****************************************************************************//*!
+*
+* @brief remap RTC to pin PTC4 (default). 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapRTCToPTC4(void)
+{
+    SIM->PINSEL &= ~SIM_PINSEL_RTCPS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap RTC to pin PTC5. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapRTCToPTC5(void)
+{
+    SIM->PINSEL |= SIM_PINSEL_RTCPS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap MSCAN to pin PTC6/7 (default). 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapMSCANToPTC_6_7(void)
+{
+    SIM->PINSEL1 &= ~SIM_PINSEL1_MSCANPS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap MSCAN to pin PTH2/7. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapMSCANToPTH_2_7(void)
+{
+    SIM->PINSEL1 |= SIM_PINSEL1_MSCANPS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap PWTIN1 to pin PTB0 (default). 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapPWTIN1ToPTB0(void)
+{
+    SIM->PINSEL1 &= ~SIM_PINSEL1_MSCANPS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap PWTIN1 to pin PTH7. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapPWTIN1ToPTH7(void)
+{
+    SIM->PINSEL1 |= SIM_PINSEL1_MSCANPS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap PWTIN0 to pin PTD5 (default). 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapPWTIN0ToPTD5(void)
+{
+    SIM->PINSEL1 &= ~SIM_PINSEL1_MSCANPS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap PWTIN0 to pin PTE2. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapPWTIN0ToPTE2(void)
+{
+    SIM->PINSEL1 |= SIM_PINSEL1_MSCANPS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap UART2 to pin PTD6/7 (default). 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapUART2ToPTD_6_7(void)
+{
+    SIM->PINSEL1 &= ~SIM_PINSEL1_UART2PS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap UART2 to pin PTI0/1. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapUART2ToPTI_0_1(void)
+{
+    SIM->PINSEL1 |= SIM_PINSEL1_UART2PS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap UART1 to pin PTC6/7 (default). 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapUART1ToPTC_6_7(void)
+{
+    SIM->PINSEL1 &= ~SIM_PINSEL1_UART1PS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap UART1 to pin PTF2/3. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapUART1ToPTF_2_3(void)
+{
+    SIM->PINSEL1 |= SIM_PINSEL1_UART1PS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap SPI1 to pin PTD0/1/2/3 (default). 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapSPI1ToPTD_0_1_2_3(void)
+{
+    SIM->PINSEL1 &= ~SIM_PINSEL1_SPI1PS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap SPI1 to pin PTG4/5/6/7. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapSPI1ToPTG_4_5_6_7(void)
+{
+    SIM->PINSEL1 |= SIM_PINSEL1_SPI1PS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap I2C1 to pin PTE0/1 (default). 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapI2C1ToPTE_0_1(void)
+{
+    SIM->PINSEL1 &= ~SIM_PINSEL1_I2C1PS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap I2C1 to pin PTH3/4. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapI2C1ToPTH_3_4(void)
+{
+    SIM->PINSEL1 |= SIM_PINSEL1_I2C1PS_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap FTM2CH5 to pin PTB5 (default). 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM2CH5ToPTB5(void)
+{
+    SIM->PINSEL1 &= ~SIM_PINSEL1_FTM2PS5_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap FTM2CH5 to pin PTG7. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM2CH5ToPTG7(void)
+{
+    SIM->PINSEL1 |= SIM_PINSEL1_FTM2PS5_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap FTM2CH4 to pin PTB4 (default). 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM2CH4ToPTB4(void)
+{
+    SIM->PINSEL1 &= ~SIM_PINSEL1_FTM2PS4_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap FTM2CH4 to pin PTG6. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM2CH4ToPTG6(void)
+{
+    SIM->PINSEL1 |= SIM_PINSEL1_FTM2PS4_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap FTM2CH3 to pin PTC3 (default). 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM2CH3ToPTC3(void)
+{
+    SIM->PINSEL1 &= ~SIM_PINSEL1_FTM2PS3_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap FTM2CH3 to pin PTD1. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM2CH3ToPTD1(void)
+{
+    SIM->PINSEL1 = (SIM->PINSEL1 & (~SIM_PINSEL1_FTM2PS3_MASK)) | SIM_PINSEL1_FTM2PS3(1);    
+}
+/*****************************************************************************//*!
+*
+* @brief remap FTM2CH3 to pin PTG5. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM2CH3ToPTG5(void)
+{
+    SIM->PINSEL1 = (SIM->PINSEL1 & (~SIM_PINSEL1_FTM2PS3_MASK)) | SIM_PINSEL1_FTM2PS3(2);    
+}
+/*****************************************************************************//*!
+*
+* @brief remap FTM2CH2 to pin PTC2 (default). 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM2CH2ToPTC2(void)
+{
+    SIM->PINSEL1 &= ~SIM_PINSEL1_FTM2PS2_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap FTM2CH2 to pin PTD0. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM2CH2ToPTD0(void)
+{
+    SIM->PINSEL1 = (SIM->PINSEL1 & (~SIM_PINSEL1_FTM2PS2_MASK)) | SIM_PINSEL1_FTM2PS2(1);    
+}
+/*****************************************************************************//*!
+*
+* @brief remap FTM2CH2 to pin PTG4. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM2CH2ToPTG4(void)
+{
+    SIM->PINSEL1 = (SIM->PINSEL1 & (~SIM_PINSEL1_FTM2PS2_MASK)) | SIM_PINSEL1_FTM2PS2(2);    
+}
+/*****************************************************************************//*!
+*
+* @brief remap FTM2CH1 to pin PTC1 (default). 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM2CH1ToPTC1(void)
+{
+    SIM->PINSEL1 &= ~SIM_PINSEL1_FTM2PS1_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap FTM2CH1 to pin PTH1. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM2CH1ToPTH1(void)
+{
+    SIM->PINSEL1 = (SIM->PINSEL1 & (~SIM_PINSEL1_FTM2PS1_MASK)) | SIM_PINSEL1_FTM2PS1(1);    
+}
+/*****************************************************************************//*!
+*
+* @brief remap FTM2CH1 to pin PTF1. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM2CH1ToPTF1(void)
+{
+    SIM->PINSEL1 = (SIM->PINSEL1 & (~SIM_PINSEL1_FTM2PS1_MASK)) | SIM_PINSEL1_FTM2PS1(2);    
+}
+/*****************************************************************************//*!
+*
+* @brief remap FTM2CH0 to pin PTC0 (default). 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM2CH0ToPTC0(void)
+{
+    SIM->PINSEL1 &= ~SIM_PINSEL1_FTM2PS0_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief remap FTM2CH0 to pin PTH0. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM2CH0ToPTH0(void)
+{
+    SIM->PINSEL1 = (SIM->PINSEL1 & (~SIM_PINSEL1_FTM2PS0_MASK)) | SIM_PINSEL1_FTM2PS0(1);    
+}
+/*****************************************************************************//*!
+*
+* @brief remap FTM2CH0 to pin PTF0. 
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_RemapFTM2CH0ToPTF0(void)
+{
+    SIM->PINSEL1 = (SIM->PINSEL1 &(~SIM_PINSEL1_FTM2PS0_MASK)) | SIM_PINSEL1_FTM2PS0(2);    
+}
+/*****************************************************************************//*!
+*
+* @brief set clock3 divide CLKDIV.
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SetClock3Divide(void)
+{
+    SIM->CLKDIV |= SIM_CLKDIV_OUTDIV3_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief set clock2 divide CLKDIV.
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SetClock2Divide(void)
+{
+    SIM->CLKDIV |= SIM_CLKDIV_OUTDIV2_MASK;    
+}
+/*****************************************************************************//*!
+*
+* @brief set clock1 divide CLKDIV.
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SetClock1Divide(uint8_t u8divide)
+{
+    SIM->CLKDIV |= SIM_CLKDIV_OUTDIV1(u8divide);    
+}
+/*****************************************************************************//*!
+*
+* @brief set bus divide BUSDIV.
+*        
+* @param   none
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE void SIM_SetBusDivide(uint8_t u8Divide)
+{
+    SIM->CLKDIV = u8Divide;    
+}
+
+#endif
+
+
+/*! @} End of sim_api_list                                                   */
+
+void SIM_Init(SIM_ConfigType *pConfig);
+void SIM_SetClockGating(uint32_t u32PeripheralMask, uint8_t u8GateOn);
+uint32_t SIM_GetStatus(uint32_t u32StatusMask);
+uint8_t SIM_ReadID(IDType sID);
+
+#endif /* SIM_H_ */
+
+
diff --git a/bsp/frdm-ke02/device/lib/inc/spi.h b/bsp/frdm-ke02/device/lib/inc/spi.h
new file mode 100755
index 0000000..b94e5b2
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/spi.h
@@ -0,0 +1,662 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file spi.h
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief header file for SPI module utilities (SPI). 
+*
+*******************************************************************************
+*
+* provide APIs for accessing SPI module (SPI)
+******************************************************************************/
+
+#ifndef SPI_H_
+#define SPI_H_
+#ifdef __cplusplus
+extern "C" {
+#endif
+/******************************************************************************
+* Includes
+******************************************************************************/
+
+/******************************************************************************
+* Constants
+******************************************************************************/
+
+/******************************************************************************
+* Macros
+******************************************************************************/
+/* maximum number of SPIs */
+#define     MAX_SPI_NO              2
+
+
+
+/******************************************************************************
+* define SPI register default value
+*
+*//*! @addtogroup spi_default_value
+* @{
+*******************************************************************************/
+
+#define SPI_C1_DEFAULT          0x04						/*!< SPI C1 register */
+#define SPI_C2_DEFAULT          0x00						/*!< SPI C2 register */
+#define SPI_BR_DEFAULT          0x00						/*!< SPI BR register */
+#define SPI_S_DEFAULT           0x20						/*!< SPI S register */
+#define SPI_M_DEFAULT           0x00						/*!< SPI M register */
+/*! @} End of spi_default_value                                                    					*/
+
+/******************************************************************************
+* define SPI error status
+*
+*//*! @addtogroup spi_error_list
+* @{
+*******************************************************************************/
+
+#define     SPI_ERR_SUCCESS            0                                /*!< success */
+#define     SPI_ERR_CODE_BASE         ((uint32)SPI0 - 0x40000000L)      /*!< error code base for SPI */
+#define     SPI_ERR_TXBUF_NOT_EMPTY   (SPI_ERR_CODE_BASE+1)             /*!< failure due to SPTEF (empty) not set */
+#define     SPI_ERR_RXBUF_NOT_FULL    (SPI_ERR_CODE_BASE+2)             /*!< failure due to SPRF (full) not set */
+/*! @} End of spi_error_list                                            */
+        
+/******************************************************************************
+* Types
+******************************************************************************/
+
+typedef uint8_t   SPI_WidthType;  /* SPI width type */
+typedef uint32_t  ResultType;     /* SPI routine Result code */
+
+/******************************************************************************
+* define SPI call back funtion
+*
+*//*! @addtogroup spi_callback
+* @{
+*******************************************************************************/
+typedef void (*SPI_CallbackType)(void);  /*!< SPI call back function */
+/*! @} End of spi_callback                                            */
+
+/******************************************************************************
+*
+*//*! @addtogroup spi_setting_type
+* @{
+*******************************************************************************/
+/*!
+ * @brief SPI setting type.
+ *
+ */
+typedef struct
+{
+    uint32_t bIntEn                               : 1; /*!< 1: Interrupt Enable, 0: Interrupt disable */
+    uint32_t bModuleEn                            : 1; /*!< 1: SPI module Enable, 0: SPI module disable */
+    uint32_t bTxIntEn                             : 1; /*!< 1: Tx Interrupt Enable, 0: Tx Interrupt disable */
+    uint32_t bMasterMode                          : 1; /*!< 1: Master mode, 0: Slave mode */
+    uint32_t bClkPolarityLow                      : 1; /*!< 1: Active-low SPI clock, 0: Active-HIgh SPI clock */
+    uint32_t bClkPhase1                           : 1; /*!< Set clock phase */
+    uint32_t bMasterAutoDriveSS                   : 1; /*!< Slave select output enable */
+    uint32_t bShiftLSBFirst                       : 1; /*!< 1: LSB first, 0: MSB first */
+    uint32_t bMatchIntEn                          : 1; /*!< 1: Match interrupt Enable, 0: Match interrupt disable */
+    uint32_t bModeFaultEn                         : 1; /*!< Master mode-fault function enable */
+    uint32_t bBidirectionModeEn                   : 1; /*!< Bidirectional mode output enable */
+    uint32_t bPinAsOuput                          : 1; /*!< enables bidirectional pin configurations */
+    uint32_t bStopInWaitMode                      : 1; /*!< SPI stop in wait mode */
+    uint32_t bRsvd                                : 19;
+} SPI_SettingType;
+/*! @} End of spi_setting_type                                            */
+
+/******************************************************************************
+*
+*//*! @addtogroup spi_config_type
+* @{
+*******************************************************************************/
+/*!
+ * @brief SPI configuration type.
+ *
+ */
+typedef struct 
+{
+    SPI_SettingType     sSettings;              /*!< SPI settings */
+    uint32_t              u32BitRate;             /*!< set baud rate */
+    uint32_t              u32BusClkHz;            /*!< input bus clock */
+} SPI_ConfigType;                              /*!< SPI configuration structure */
+/*! @} End of spi_config_type                                            */
+
+/******************************************************************************
+* Global variables
+******************************************************************************/
+
+/******************************************************************************
+* inline function
+******************************************************************************/
+/******************************************************************************
+*
+*//*! @addtogroup spi_api_list
+* @{
+*******************************************************************************/
+/*****************************************************************************//*!
+   *
+   * @brief LSB first (shifter direction).
+   *        
+   * @param[in]  pSPI   point to SPI module type.  
+   *
+   * @return  none.
+   *
+   * @ Pass/ Fail criteria: none.
+   *****************************************************************************/
+
+ __STATIC_INLINE void SPI_SetLSBFirst(SPI_Type *pSPI)
+{
+	pSPI->C1 |= SPI_C1_LSBFE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief MSB first (shifter direction).
+   *        
+   * @param[in]  pSPI   point to SPI module type.  
+   *
+   * @return  none.
+   *
+   * @ Pass/ Fail criteria: none.
+   *****************************************************************************/
+
+ __STATIC_INLINE void SPI_SetMSBFirst(SPI_Type *pSPI)
+{
+	pSPI->C1 &= ~SPI_C1_LSBFE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief set SPI clock polarity.
+   *        
+   * @param[in]  pSPI   point to SPI module type.  
+   * @param[in]  u8PolLow   set clock polarity, 1 - Active-low SPI clock (idles high).  
+   * @return  none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+
+ __STATIC_INLINE void SPI_SetClockPol(SPI_Type *pSPI,uint8_t u8PolLow)
+{
+	if( u8PolLow )
+	{
+		pSPI->C1 |= SPI_C1_CPOL_MASK;	
+	}
+	else
+	{
+		pSPI->C1 &= ~SPI_C1_CPOL_MASK;	
+	}
+}
+/*****************************************************************************//*!
+   *
+   * @brief set SPI clock phase.
+   *        
+   * @param[in]  pSPI   point to SPI module type.  
+   * @param[in]  u8Phase   set clock phase, 1 - First edge on SPSCK occurs at the start of the first cycle of a data transfer. 
+   * 
+   * @return  none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+
+ __STATIC_INLINE void SPI_SetClockPhase(SPI_Type *pSPI,uint8_t u8Phase)
+{
+	if( u8Phase )
+	{
+		pSPI->C1 |= SPI_C1_CPHA_MASK;	
+	}
+	else
+	{
+		pSPI->C1 &= ~SPI_C1_CPHA_MASK;	
+	}
+}
+/*****************************************************************************//*!
+   *
+   * @brief enable SPI module.
+   *        
+   * @param[in]  pSPI   point to SPI module type.  
+   *
+   * @return  none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+
+ __STATIC_INLINE void SPI_Enable(SPI_Type *pSPI)
+{
+	pSPI->C1 |= SPI_C1_SPE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief disable SPI module.
+   *        
+   * @param[in]  pSPI   point to SPI module type.  
+   *  
+   * @return  none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+
+ __STATIC_INLINE void SPI_Disable(SPI_Type *pSPI)
+{
+	pSPI->C1 &= ~SPI_C1_SPE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief enable SPI interrupt.
+   *        
+   * @param[in]  pSPI   point to SPI module type.  
+   *
+   * @return  none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+
+ __STATIC_INLINE void SPI_IntEnable(SPI_Type *pSPI)
+{
+	pSPI->C1 |= SPI_C1_SPIE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief disable SPI interrupt.
+   *        
+   * @param[in]  pSPI   point to SPI module type.  
+   *
+   * @return  none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+ __STATIC_INLINE void SPI_IntDisable(SPI_Type *pSPI)
+{
+	pSPI->C1 &= ~SPI_C1_SPIE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief set SPI to master mode.
+   *        
+   * @param[in]  pSPI   point to SPI module type.  
+   *
+   * @return  none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+ __STATIC_INLINE void SPI_SetMasterMode(SPI_Type *pSPI)
+{
+	pSPI->C1 |= SPI_C1_MSTR_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief set SPI to slave mode.
+   *        
+   * @param[in]  pSPI   point to SPI module type.  
+   *
+   * @return  none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+ __STATIC_INLINE void SPI_SetSlaveMode(SPI_Type *pSPI)
+{
+	pSPI->C1 &= ~SPI_C1_MSTR_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief SPI transmit interrupt enable.
+   *        
+   * @param[in]  pSPI   point to SPI module type.  
+   *
+   * @return  none.
+   *
+   * @ Pass/ Fail criteria: none.
+   *****************************************************************************/
+ __STATIC_INLINE void SPI_TxIntEnable(SPI_Type *pSPI)
+{
+	pSPI->C1 |= SPI_C1_SPTIE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief SPI transmit interrupt disable.
+   *        
+   * @param[in]  pSPI   point to SPI module type.  
+   *
+   * @return  none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+ __STATIC_INLINE void SPI_TxIntDisable(SPI_Type *pSPI)
+{
+	pSPI->C1 &= ~SPI_C1_SPTIE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Slave select output enable.
+   *        
+   * @param[in]  pSPI   point to SPI module type.  
+   *
+   * @return  none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+ __STATIC_INLINE void SPI_SSOutputEnable(SPI_Type *pSPI )
+{
+	pSPI->C1 |= SPI_C1_SSOE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Slave select output disable.
+   *        
+   * @param[in]  pSPI   point to SPI module type.  
+   *
+   * @return  none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+ __STATIC_INLINE void SPI_SSOutputDisable(SPI_Type *pSPI )
+{
+	pSPI->C1 &= ~SPI_C1_SSOE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief SPI match interrupt enable.
+   *        
+   * @param[in]  pSPI   point to SPI module type.  
+   * 
+   * @return  none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+ __STATIC_INLINE void SPI_MatchIntEnable(SPI_Type *pSPI )
+{
+	pSPI->C2 |= SPI_C2_SPMIE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief SPI match interrupt disable.
+   *        
+   * @param[in]  pSPI   point to SPI module type.  
+   *
+   * @return  none.
+   *
+   * @ Pass/ Fail criteria: none.
+   *****************************************************************************/
+ __STATIC_INLINE void SPI_MatchIntDisable(SPI_Type *pSPI )
+{
+	pSPI->C2 &= ~SPI_C2_SPMIE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Master mode-fault function disable.
+   *        
+   * @param[in]  pSPI   point to SPI module type.  
+   *
+   * @return  none.
+   *
+   * @ Pass/ Fail criteria: none.
+   *****************************************************************************/
+ __STATIC_INLINE void SPI_ModfDisable(SPI_Type *pSPI )
+{
+	pSPI->C2 &= ~SPI_C2_MODFEN_MASK;
+}
+/*****************************************************************************//*!
+
+   *
+   * @brief Master mode-fault function enable.
+   *        
+   * @param[in]  pSPI   point to SPI module type.  
+   *
+   * @return  none.
+   *
+   * @ Pass/ Fail criteria: none.
+   *****************************************************************************/
+ __STATIC_INLINE void SPI_ModfEnable(SPI_Type *pSPI )
+{
+	pSPI->C2 |= SPI_C2_MODFEN_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Bidirectional mode output enable.
+   *        
+   * @param[in]  pSPI   point to SPI module type.  
+   *
+   * @return  none.
+   *
+   * @ Pass/ Fail criteria: none.
+   *****************************************************************************/
+ __STATIC_INLINE void SPI_BidirOutEnable(SPI_Type *pSPI )
+{
+	pSPI->C2 |= SPI_C2_BIDIROE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief Bidirectional mode output disable.
+   *        
+   * @param[in]  pSPI   point to SPI module type.  
+   *
+   * @return  none.
+   *
+   * @ Pass/ Fail criteria: none.
+   *****************************************************************************/
+ __STATIC_INLINE void SPI_BidirOutDisable(SPI_Type *pSPI )
+{
+	pSPI->C2 &= ~SPI_C2_BIDIROE_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief SPI stop in wait mode
+   *        
+   * @param[in]  pSPI   point to SPI module type.  
+   * 
+   * @return  none.
+   *
+   * @ Pass/ Fail criteria: none.
+   *****************************************************************************/
+ __STATIC_INLINE void SPI_ClockStopDisable(SPI_Type *pSPI )
+{
+	pSPI->C2 &= ~SPI_C2_SPISWAI_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief SPI stop in wait mode.
+   *        
+   * @param[in]  pSPI   point to SPI module type.  
+   *  
+   * @return  none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+ __STATIC_INLINE void SPI_ClockStopEnable(SPI_Type *pSPI )
+{
+	pSPI->C2 |= SPI_C2_SPISWAI_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief enables bidirectional pin configurations.
+   *        
+   * @param[in]  pSPI   point to SPI module type.  
+   *   
+   * @return  none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+ __STATIC_INLINE void SPI_BidirPinEnable(SPI_Type *pSPI)
+{
+	pSPI->C2 |= SPI_C2_SPC0_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief enables bidirectional pin configurations.
+   *        
+   * @param[in]  pSPI   point to SPI module type.  
+   *   
+   * @return  none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+ __STATIC_INLINE void SPI_BidirPinDisable(SPI_Type *pSPI)
+{
+	pSPI->C2 &= ~SPI_C2_SPC0_MASK;
+}
+/*****************************************************************************//*!
+   *
+   * @brief check SPI read buffer full flag.
+   *        
+   * @param[in]  pSPI   point to SPI module type.  
+   *    
+   * @return  TRUE or FALSE.
+   *
+   * @ Pass/ Fail criteria: none.
+   *****************************************************************************/
+ __STATIC_INLINE uint8_t SPI_IsSPRF(SPI_Type *pSPI )
+{
+	return(pSPI->S & SPI_S_SPRF_MASK);
+}
+/*****************************************************************************//*!
+   *
+   * @brief check SPI match flag.
+   *        
+   * @param[in]  pSPI   point to SPI module type.  
+   *    
+   * @return  TRUE or FALSE.
+   *
+   * @ Pass/ Fail criteria: none.
+   *****************************************************************************/
+ __STATIC_INLINE uint8_t SPI_IsSPMF(SPI_Type *pSPI )
+{
+	return(pSPI->S & SPI_S_SPMF_MASK);
+}
+/*****************************************************************************//*!
+   *
+   * @brief check SPI transmit buffer empty flag.
+   *        
+   * @param[in]  pSPI   point to SPI module type.  
+   *    
+   * @return  TRUE or FALSE.
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+ __STATIC_INLINE uint8_t SPI_IsSPTEF(SPI_Type *pSPI )
+{
+	return(pSPI->S & SPI_S_SPTEF_MASK);
+}
+/*****************************************************************************//*!
+   *
+   * @brief check master mode fault flag.
+   *        
+   * @param[in]  pSPI   point to SPI module type.  
+   *    
+   * @return  TRUE or FALSE.
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+ __STATIC_INLINE uint8_t SPI_IsMODF(SPI_Type *pSPI )
+{
+	return(pSPI->S & SPI_S_MODF_MASK);
+}
+/*****************************************************************************//*!
+   *
+   * @brief read SPI data register.
+   *        
+   * @param[in]  pSPI   point to SPI module type.  
+   *    
+   * @return data register value
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+ __STATIC_INLINE uint8_t SPI_ReadDataReg(SPI_Type *pSPI )
+{
+	return pSPI->D;
+}
+/*****************************************************************************//*!
+   *
+   * @brief write SPI data register.
+   *        
+   * @param[in]  pSPI   point to SPI module type. 
+   * @param[in]  u8WrBuff   data buffer write to spi data register. 
+   *
+   * @return  none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+ __STATIC_INLINE void SPI_WriteDataReg(SPI_Type *pSPI, uint8_t u8WrBuff )
+{
+	pSPI->D = u8WrBuff;
+}
+/*****************************************************************************//*!
+   *
+   * @brief write SPI match  register.
+   *        
+   * @param[in]  pSPI   point to SPI module type. 
+   * @param[in]  u8WrBuff   the data buffer write to match register. 
+   *
+   * @return  none
+   *
+   * @ Pass/ Fail criteria: none
+   *****************************************************************************/
+ __STATIC_INLINE void SPI_WriteMatchValue(SPI_Type *pSPI, uint8_t u8WrBuff )
+{
+	pSPI->M = u8WrBuff;
+}
+/******************************************************************************
+* Global functions
+******************************************************************************/
+void SPI_Enable(SPI_Type *pSPI);
+void SPI_Disable(SPI_Type *pSPI);
+void SPI_SetLSBFirst(SPI_Type *pSPI);
+void SPI_SetMSBFirst(SPI_Type *pSPI);
+void SPI_IntEnable(SPI_Type *pSPI);
+void SPI_IntDisable(SPI_Type *pSPI);
+void SPI_SetMasterMode(SPI_Type *pSPI);
+void SPI_SetSlaveMode(SPI_Type *pSPI);
+void SPI_TxIntEnable(SPI_Type *pSPI);
+void SPI_TxIntDisable(SPI_Type *pSPI);
+void SPI_SSOutputEnable(SPI_Type *pSPI );
+void SPI_SSOutputDisable(SPI_Type *pSPI );
+void SPI_MatchIntEnable(SPI_Type *pSPI );
+void SPI_MatchIntDisable(SPI_Type *pSPI );
+void SPI_ModfDisable(SPI_Type *pSPI );
+void SPI_ModfEnable(SPI_Type *pSPI );
+void SPI_BidirOutEnable(SPI_Type *pSPI );
+void SPI_BidirOutDisable(SPI_Type *pSPI );
+void SPI_ClockStopDisable(SPI_Type *pSPI );
+void SPI_ClockStopEnable(SPI_Type *pSPI );
+void SPI_BidirPinEnable(SPI_Type *pSPI );
+void SPI_BidirPinDisable(SPI_Type *pSPI );
+void SPI_SetClockPol(SPI_Type *pSPI,uint8_t u8PolLow);
+void SPI_SetClockPhase(SPI_Type *pSPI,uint8_t u8Phase);
+void SPI_SetBaudRate(SPI_Type *pSPI,uint32_t u32BusClock,uint32_t u32Bps );
+uint8_t SPI_IsSPRF(SPI_Type *pSPI );
+uint8_t SPI_IsSPMF(SPI_Type *pSPI );
+uint8_t SPI_IsSPTEF(SPI_Type *pSPI );
+uint8_t SPI_IsMODF(SPI_Type *pSPI );
+uint8_t SPI_ReadDataReg(SPI_Type *pSPI );
+void SPI_WriteDataReg(SPI_Type *pSPI, uint8_t u8WrBuff );
+void SPI_WriteMatchValue(SPI_Type *pSPI, uint8_t u8WrBuff );
+void SPI_Init(SPI_Type *pSPI, SPI_ConfigType *pConfig);
+void SPI_DeInit(SPI_Type *pSPI);
+ResultType SPI_TransferWait(SPI_Type *pSPI, SPI_WidthType* pRdBuff, SPI_WidthType *pWrBuff,uint32 uiLength);
+void SPI_SetCallback(SPI_Type *pSPI,SPI_CallbackType pfnCallback);
+
+/*! @} End of spi_api_list                                            */
+#ifdef __cplusplus
+}
+#endif
+#endif /* SPI_H_ */
diff --git a/bsp/frdm-ke02/device/lib/inc/start.h b/bsp/frdm-ke02/device/lib/inc/start.h
new file mode 100755
index 0000000..7aae2c2
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/start.h
@@ -0,0 +1,38 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file start.h
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief provide high-level startup routines for KExx.
+*
+*******************************************************************************/
+
+/* Function prototypes */
+void cpu_identify(void);
+void flash_identify(void);
+void start(void);
diff --git a/bsp/frdm-ke02/device/lib/inc/startup.h b/bsp/frdm-ke02/device/lib/inc/startup.h
new file mode 100755
index 0000000..267514a
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/startup.h
@@ -0,0 +1,44 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file startup.h
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief Implement generic Kinetis startup code. 
+*
+*******************************************************************************/
+
+#ifndef _STARTUP_H_
+#define _STARTUP_H_
+
+/********************************************************************/
+
+void common_startup(void);
+
+/********************************************************************/
+
+#endif /* _STARTUP_H_ */
diff --git a/bsp/frdm-ke02/device/lib/inc/stdlib.h b/bsp/frdm-ke02/device/lib/inc/stdlib.h
new file mode 100755
index 0000000..4060796
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/stdlib.h
@@ -0,0 +1,101 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file stdlib.h
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief Implement some basic functions normally found in a standard C lib. 
+*
+*******************************************************************************/
+
+#ifndef _STDLIB_H
+#define _STDLIB_H
+
+/********************************************************************
+ * Standard library functions
+ ********************************************************************/
+
+int
+isspace (int);
+
+int
+isalnum (int);
+
+int
+isdigit (int);
+
+int
+isupper (int);
+
+int
+strcasecmp (const char *, const char *);
+
+int
+strncasecmp (const char *, const char *, int);
+
+unsigned long
+strtoul (char *, char **, int);
+
+//int
+//strlen (const char *);
+
+char *
+strcat (char *, const char *);
+
+//char *
+//strncat (char *, const char *, int);
+
+char *
+strcpy (char *, const char *);
+
+//char *
+//strncpy (char *, const char *, int );
+
+int
+strcmp (const char *, const char *);
+
+//int
+//strncmp (const char *, const char *, int);
+
+void *
+memcpy (void *, const void *, unsigned);
+
+void *
+memset (void *, int, unsigned);
+
+void
+free (void *);
+ 
+void *
+malloc (unsigned);
+
+int
+strlen (const char *str);
+
+/********************************************************************/
+
+#endif
diff --git a/bsp/frdm-ke02/device/lib/inc/sysinit.h b/bsp/frdm-ke02/device/lib/inc/sysinit.h
new file mode 100755
index 0000000..c744ea6
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/sysinit.h
@@ -0,0 +1,67 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file sysinit.h
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief provide system init routine/configuration for KExx.
+*
+*******************************************************************************/
+
+/********************************************************************/
+
+#ifndef SYSINIT_H_
+#define SYSINIT_H_
+
+/******************************************************************************
+* Includes
+******************************************************************************/
+
+/******************************************************************************
+* Constants
+******************************************************************************/
+
+
+/******************************************************************************
+* Macros
+******************************************************************************/ 
+#define SIM_SCGC_VALUE      0x00003000L  
+
+  
+/******************************************************************************
+* Global variables
+******************************************************************************/
+
+/******************************************************************************
+* Global functions
+******************************************************************************/
+void sysinit (void);
+void enable_abort_button(void);
+void end_test(void);
+
+/********************************************************************/
+#endif /* SYSINIT_H_ */
diff --git a/bsp/frdm-ke02/device/lib/inc/system_MKE02Z2.h b/bsp/frdm-ke02/device/lib/inc/system_MKE02Z2.h
new file mode 100755
index 0000000..f1b479b
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/system_MKE02Z2.h
@@ -0,0 +1,90 @@
+/*
+** ###################################################################
+**     Compilers:           ARM Compiler
+**                          Freescale C/C++ for Embedded ARM
+**                          GNU C Compiler
+**                          IAR ANSI C/C++ Compiler for ARM
+**
+**     Reference manual:    MKE02Z64M20SF0RM, Rev.2.1, Apr-23 2013
+**     Version:             rev. 1.4, 2013-07-10
+**
+**     Abstract:
+**         Provides a system configuration function and a global variable that
+**         contains the system frequency. It configures the device and initializes
+**         the oscillator (PLL) that is part of the microcontroller device.
+**
+**     Copyright: 2013 Freescale, Inc. All Rights Reserved.
+**
+**     http:                 www.freescale.com
+**     mail:                 support@freescale.com
+**
+**     Revisions:
+**     - rev. 1.0 (2013-02-06)
+**         Initial version.
+**     - rev. 1.1 (2013-04-05)
+**         Changed start of doxygen comment.
+**     - rev. 1.2 (2013-05-07)
+**         Update according to reference manual rev. 2.1.
+**     - rev. 1.3 (2013-06-13)
+**         Device types PTA,PTB,FPTA,FPTB changed to GPIOA,GPIOB,FGPIOA,FGPIOB.
+**     - rev. 1.4 (2013-07-10)
+**         NV - DFPROT register renamed to EEPROT.
+**         WDOG - Peripheral register layout structure has been extended with 16-bit access registers CNT, TOVAL, WIN.
+**
+** ###################################################################
+*/
+
+/*!
+ * @file MKE02Z2
+ * @version 1.4
+ * @date 2013-07-10
+ * @brief Device specific configuration file for MKE02Z2 (header file)
+ *
+ * Provides a system configuration function and a global variable that contains
+ * the system frequency. It configures the device and initializes the oscillator
+ * (PLL) that is part of the microcontroller device.
+ */
+
+#ifndef SYSTEM_MKE02Z2_H_
+#define SYSTEM_MKE02Z2_H_                        /**< Symbol preventing repeated inclusion */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+
+/**
+ * @brief System clock frequency (core clock)
+ *
+ * The system clock frequency supplied to the SysTick timer and the processor
+ * core clock. This variable can be used by the user application to setup the
+ * SysTick timer or configure other parameters. It may also be used by debugger to
+ * query the frequency of the debug timer or configure the trace clock speed
+ * SystemCoreClock is initialized with a correct predefined value.
+ */
+extern uint32_t SystemCoreClock;
+
+/**
+ * @brief Setup the microcontroller system.
+ *
+ * Typically this function configures the oscillator (PLL) that is part of the
+ * microcontroller device. For systems with variable clock speed it also updates
+ * the variable SystemCoreClock. SystemInit is called from startup_device file.
+ */
+void SystemInit (void);
+
+/**
+ * @brief Updates the SystemCoreClock variable.
+ *
+ * It must be called whenever the core clock is changed during program
+ * execution. SystemCoreClockUpdate() evaluates the clock register settings and calculates
+ * the current core clock.
+ */
+void SystemCoreClockUpdate (void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* #if !defined(SYSTEM_MKE02Z2_H_) */
diff --git a/bsp/frdm-ke02/device/lib/inc/systick.h b/bsp/frdm-ke02/device/lib/inc/systick.h
new file mode 100755
index 0000000..0509c30
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/systick.h
@@ -0,0 +1,51 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file systick.h
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief provide systick utility routines.
+*
+*******************************************************************************/
+
+#ifndef __SYSTICK_H
+#define __SYSTICK_H
+
+
+#define SYS_COUNT_TIME		10 //ms
+#define SYS_COUNT 				MCU_CLCOK*SYS_COUNT_TIME/16
+/* Global variables */
+extern uint32_t cnt_start_value;
+extern uint32_t cnt_end_value;
+extern uint32_t overhead;
+
+/* Function declaration */
+void systick_init(void);
+void systick_disable(void);
+void cal_systick_read_overhead(void);
+
+#endif
diff --git a/bsp/frdm-ke02/device/lib/inc/typedef.h b/bsp/frdm-ke02/device/lib/inc/typedef.h
new file mode 100755
index 0000000..dcb79a8
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/typedef.h
@@ -0,0 +1,77 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file typedef.h
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief provide some type definitions which are not CMSIS style. 
+*
+*******************************************************************************/
+
+#ifndef __TYPEDEF_H__
+#define __TYPEDEF_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef	s8
+#define s8		char
+#endif
+#ifndef	u8
+#define u8		unsigned char
+#endif
+#ifndef	s16
+#define s16		short
+#endif
+#ifndef	u16
+#define u16		unsigned short
+#endif
+#ifndef	s32
+#define s32		long
+#endif
+#ifndef	u32
+#define u32		unsigned long
+#endif
+#ifndef	sint
+#define sint		int
+#endif
+#ifndef	uint
+#define uint		unsigned int
+#endif
+#ifndef	s64
+#define s64		long long
+#endif
+#ifndef	u64
+#define u64		unsigned long long
+#endif
+
+#ifdef __cplusplus 
+} 
+#endif 
+
+#endif	/* __TYPEDEF_H__ */
\ No newline at end of file
diff --git a/bsp/frdm-ke02/device/lib/inc/uart.h b/bsp/frdm-ke02/device/lib/inc/uart.h
new file mode 100755
index 0000000..b60965c
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/uart.h
@@ -0,0 +1,524 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file UART.h
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun 6, 2013
+*
+* @brief provide commond UART utilities. 
+*
+*******************************************************************************/
+#ifndef _UART_H_
+#define _UART_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/******************************************************************************
+* Includes
+******************************************************************************/
+#include "common.h"
+#include "wdog.h"
+/******************************************************************************
+* Constants
+******************************************************************************/
+
+/******************************************************************************
+* Macros
+******************************************************************************/
+#define MAX_UART_NO             3
+
+/******************************************************************************
+* Types
+******************************************************************************/
+
+/******************************************************************************
+*define uart setting type
+*
+*//*! @addtogroup uart_setting_type
+* @{
+*******************************************************************************/  
+
+/*!
+* @brief UART setting type.
+*
+*/ 
+
+typedef struct
+{
+    uint32_t bEnable      : 1;                /*!< 1: enable, 0: disable */
+    uint32_t resvd        : 31;               /*!< 1: reserved bit field */
+} UART_SettingType;
+/*! @} End of uart_setting_type */
+
+/******************************************************************************
+*define uart config type
+*
+*//*! @addtogroup uart_config_type
+* @{
+******************************************************************************/
+ /*!
+ * @brief UART Configuration structure.
+ *
+ */   
+typedef struct 
+{
+    UART_SettingType    sSettings;              /*!< UART settings */
+    uint32_t    u32SysClkHz;        /*!< system clock */
+    uint32_t    u32Baudrate;        /*!< UART baudrate */
+} UART_ConfigType;
+/*! @} End of uart_config_type  */
+
+/******************************************************************************
+*define uart config baudrate type
+*
+*//*! @addtogroup uart_config_baudrate_type
+* @{
+******************************************************************************/
+ /*!
+ * @brief UART baudrate type structure.
+ *
+ */   
+typedef struct
+{
+    uint32_t    u32SysClkHz;        /*!< system clock */
+    uint32_t    u32Baudrate;        /*!< UART baudrate */
+} UART_ConfigBaudrateType;
+/*! @} End of uart_config_baudrate_type */
+
+/******************************************************************************
+*define uart config mode type list
+*
+*//*! @addtogroup uart_mode_type_list
+* @{
+******************************************************************************/
+typedef enum
+{
+    UART_Mode8Bit,                  /*!< 8 bit mode */
+    UART_Mode9Bit,                  /*!< 9 bit mode */
+    UART_ModeEnableLoopback,        /*!< enable looback mode */
+    UART_ModeDisableLoopback,       /*!< disable loopback mode*/
+    UART_ModeEnableSingleWire,      /*!< enable single wire mode */
+    UART_ModeDisableSingleWire,     /*!< disable single wire mode */
+} UART_ModeType;
+/*! @} End of uart_mode_type_list   */
+
+/******************************************************************************
+*define uart interrupt type list
+*
+*//*! @addtogroup uart_interrupt_type_list
+* @{
+******************************************************************************/
+
+typedef enum
+{
+    UART_TxBuffEmptyInt,            /*!< transmit buffer empty interrupt */
+    UART_TxCompleteInt,             /*!< transmit complete interrupt */
+    UART_RxBuffFullInt,             /*!< receive buffer full interrupt */
+
+    UART_IdleLineInt,               /*!< idle line interrupt */
+
+    UART_RxOverrunInt,              /*!< receive overrun interrupt */
+    UART_NoiseErrorInt,             /*!< noise error interrupt */
+    UART_FramingErrorInt,           /*!< framing error interrupt */
+    UART_ParityErrorInt,            /*!< parity error interrupt */
+} UART_InterruptType;
+/*! @} End of uart_interrupt_type_list  */
+
+/******************************************************************************
+*define uart flag type list
+*
+*//*! @addtogroup uart_flag_type_list
+* @{
+******************************************************************************/
+typedef enum
+{
+    UART_FlagPF = 0,        /*!< Parity error flag */
+    UART_FlagFE,            /*!< Framing error flag */
+    UART_FlagNF,            /*!< Noise flag */
+    UART_FlagOR,            /*!< Receive overrun */
+    UART_FlagIDLE,          /*!< Idle line flag */
+    UART_FlagRDRF,          /*!< Receive data register full flag */
+    UART_FlagTC,            /*!< Transmission complete flag */
+    UART_FlagTDRE,          /*!< Transmit data register flag */
+
+    UART_FlagRAF,           /*!< Receiver active flag */
+    UART_FlagLBKDE,         /*!< LIN break detection enable */
+    UART_FlagBRK13,         /*!< Break character generation length */ 
+    UART_FlagRWUID,         /*!< Receive wake up idle detect */
+    UART_FlagRXINV,         /*!< Receive data inversion */
+    UART_FlagRev1,          /*!< Reserved */
+    UART_FlagRXEDGIF,       /*!< RxD pin active edge interrupt flag */
+    UART_FlagLBKDIF,        /*!< LIN break detect interrupt flag */
+} UART_FlagType;
+/*! @} End of uart_flag_type_list   */
+
+/* callback types */
+typedef void (*UART_CallbackType)(UART_Type *pUART);
+
+/******************************************************************************
+* Global variables
+******************************************************************************/
+
+/******************************************************************************
+* Inline functions
+******************************************************************************/
+
+/******************************************************************************
+* define UART APIs
+*
+*//*! @addtogroup uart_api_list
+* @{
+*******************************************************************************/
+
+/*****************************************************************************//*!
+*
+* @brief read receive buffer
+*        
+* @param[in] pUART       base of UART port
+*
+* @return unsign char received char
+*
+*****************************************************************************/
+__STATIC_INLINE uint8_t UART_ReadDataReg(UART_Type *pUART)
+{
+    /* Return the 8-bit data from the receiver */
+    return pUART->D;
+}
+/*****************************************************************************//*!
+*
+* @brief write transmit buffer
+*        
+* @param[in] pUART       base of UART port
+* @param[in] u8Char      char to send
+*
+* @return none
+*
+*****************************************************************************/
+__STATIC_INLINE void UART_WriteDataReg(UART_Type *pUART, uint8_t u8Char)
+{
+    /* Send the character */
+    pUART->D = (uint8_t)u8Char;
+}
+
+/*****************************************************************************//*!
+*
+* @brief check if a character has been received
+*
+* @param[in] pUART  base of UART port
+*
+* @return 0, No character received; no-zero, Character has been received
+*
+* @ Pass/ Fail criteria:
+*****************************************************************************/
+__STATIC_INLINE uint8_t UART_CharPresent(UART_Type *pUART)
+{  
+    return (pUART->S1 & UART_S1_RDRF_MASK);
+}
+/*****************************************************************************//*!
+*
+* @brief enable transmit
+*        
+* @param[in] pUART       base of UART port
+*
+* @return none
+*
+*****************************************************************************/
+__STATIC_INLINE void UART_EnableTx(UART_Type *pUART)
+{
+    
+    pUART->C2 |= UART_C2_TE_MASK;
+}
+/*****************************************************************************//*!
+*
+* @brief disable transmit
+*        
+* @param[in] pUART       base of UART port
+*
+* @return none
+*
+*****************************************************************************/
+__STATIC_INLINE void UART_DisableTx(UART_Type *pUART)
+{    
+    pUART->C2 &= (~UART_C2_TE_MASK);
+}
+/*****************************************************************************//*!
+*
+* @brief enable receive
+*        
+* @param[in] pUART       base of UART port
+*
+* @return none
+*
+*****************************************************************************/
+__STATIC_INLINE void UART_EnableRx(UART_Type *pUART)
+{    
+    pUART->C2 |= UART_C2_RE_MASK;
+}
+/*****************************************************************************//*!
+*
+* @brief disable receive
+*        
+* @param[in] pUART       base of UART port
+*
+* @return none
+*
+*****************************************************************************/
+__STATIC_INLINE void UART_DisableRx(UART_Type *pUART)
+{    
+    pUART->C2 &= (~UART_C2_RE_MASK);
+}
+/*****************************************************************************//*!
+*
+* @brief Enable loopback mode
+*        
+* @param[in] pUART       base of UART port
+*
+* @return none
+*
+*****************************************************************************/
+__STATIC_INLINE void UART_EnableLoopback(UART_Type *pUART)
+{
+    pUART->C1 |= UART_C1_LOOPS_MASK;
+    pUART->C1 &= (~UART_C1_RSRC_MASK);
+}
+/*****************************************************************************//*!
+*
+* @brief enable single wire mode
+*        
+* @param[in] pUART       base of UART port
+*
+* @return none
+*
+*****************************************************************************/
+__STATIC_INLINE void UART_EnableSingleWire(UART_Type *pUART)
+{
+    pUART->C1 |= UART_C1_LOOPS_MASK;
+    pUART->C1 |= UART_C1_RSRC_MASK;
+}
+/*****************************************************************************//*!
+*
+* @brief set 8-bit mode
+*        
+* @param[in] pUART       base of UART port
+*
+* @return none
+*
+*****************************************************************************/
+__STATIC_INLINE void UART_Set8BitMode(UART_Type *pUART)
+{
+    pUART->C1 &= (~UART_C1_M_MASK);
+}
+/*****************************************************************************//*!
+*
+* @brief set 9-bit mode
+*        
+* @param[in] pUART       base of UART port
+*
+* @return none
+*
+*****************************************************************************/
+__STATIC_INLINE void UART_Set9BitMode(UART_Type *pUART)
+{
+    pUART->C1 |= UART_C1_M_MASK;
+}
+/*****************************************************************************//*!
+*
+* @brief enable transmit buffer empty interrupt
+*        
+* @param[in] pUART       base of UART port
+*
+* @return none
+*
+* @ Pass/ Fail criteria:
+*****************************************************************************/
+__STATIC_INLINE void UART_EnableTxBuffEmptyInt(UART_Type *pUART)
+{
+    pUART->C2 |= UART_C2_TIE_MASK;
+}
+/*****************************************************************************//*!
+*
+* @brief enable transmit complete interrupt
+*        
+* @param[in] pUART       base of UART port
+*
+* @return none
+*
+* @ Pass/ Fail criteria:
+*****************************************************************************/
+__STATIC_INLINE void UART_EnableTxCompleteInt(UART_Type *pUART)
+{
+    pUART->C2 |= UART_C2_TCIE_MASK;
+}
+/*****************************************************************************//*!
+*
+* @brief enable receive buffer full interrupt
+*        
+* @param[in] pUART       base of UART port
+*
+* @return none
+*
+* @ Pass/ Fail criteria:
+*****************************************************************************/
+__STATIC_INLINE void UART_EnableRxBuffFullInt(UART_Type *pUART)
+{
+    pUART->C2 |= UART_C2_RIE_MASK;
+}
+/*****************************************************************************//*!
+*
+* @brief disable transmit buffer empty interrupt
+*        
+* @param[in] pUART       base of UART port
+*
+* @return none
+*
+* @ Pass/ Fail criteria:
+*****************************************************************************/
+__STATIC_INLINE void UART_DisableTxBuffEmptyInt(UART_Type *pUART)
+{
+        pUART->C2 &= (~UART_C2_TIE_MASK);    
+}
+/*****************************************************************************//*!
+*
+* @brief disable transmit complete interrupt
+*        
+* @param[in] pUART       base of UART port
+*
+* @return none
+*
+* @ Pass/ Fail criteria:
+*****************************************************************************/
+__STATIC_INLINE void UART_DisableTxCompleteInt(UART_Type *pUART)
+{
+    pUART->C2 &= (~UART_C2_TCIE_MASK);   
+}
+/*****************************************************************************//*!
+*
+* @brief disable receive buffer full interrupt
+*        
+* @param[in] pUART       base of UART port
+*
+* @return none
+*
+* @ Pass/ Fail criteria:
+*****************************************************************************/
+__STATIC_INLINE void UART_DisableRxBuffFullInt(UART_Type *pUART)
+{
+    pUART->C2 &= (~UART_C2_RIE_MASK);  
+}
+/*****************************************************************************//*!
+*
+* @brief print out break character
+*        
+* @param[in] pUART  base of UART port
+*
+* @return       none
+*
+* @ Pass/ Fail criteria:
+*****************************************************************************/
+__STATIC_INLINE void UART_PutBreak(UART_Type *pUART)
+{
+    /* Write 1 then write 0 to UART_C2[SBK] bit, will put break character */
+    pUART->C2 |= UART_C2_SBK_MASK; 
+    pUART->C2 &= (~UART_C2_SBK_MASK);
+}
+
+/*****************************************************************************//*!
+*
+* @brief check whether tx is complete,i.e. data has been sent out.
+*        
+* @param[in] pUART  base of UART port
+*
+* @return       
+*               1, Tx complete flag is set
+*               0, Tx complete flag is clear
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t UART_IsTxComplete(UART_Type *pUART)
+{
+    return (pUART->S1 & UART_S1_TC_MASK);
+}
+/*****************************************************************************//*!
+*
+* @brief check whether Tx buffer is empty
+*        
+* @param[in] pUART  base of UART port
+*
+* @return       
+*               1, Tx buffer is empty
+*               0, Tx buffer is not empty
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t UART_IsTxBuffEmpty(UART_Type *pUART)
+{
+    return (pUART->S1 & UART_S1_TDRE_MASK);
+}
+/*****************************************************************************//*!
+*
+* @brief check whether Rx buffer is full, i.e. receive a character
+*        
+* @param[in] pUART  base of UART port
+*
+* @return       
+*               1, Rx buffer is full
+*               0, Rx buffer is not full
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+__STATIC_INLINE uint8_t UART_IsRxBuffFull(UART_Type *pUART)
+{
+    return (pUART->S1 & UART_S1_RDRF_MASK);
+}
+/*! @} End of uart_api_list */
+
+
+/******************************************************************************
+* Global functions declaration
+******************************************************************************/
+void UART_Init(UART_Type *pUART, UART_ConfigType *pConfig);
+uint8_t UART_GetChar(UART_Type *pUART);
+void UART_PutChar(UART_Type *pUART, uint8_t u8Char);
+void UART_SetBaudrate(UART_Type *pUART, UART_ConfigBaudrateType *pConfig);
+void UART_EnableInterrupt(UART_Type *pUART, UART_InterruptType InterruptType);
+void UART_DisableInterrupt(UART_Type *pUART, UART_InterruptType InterruptType);
+uint16_t UART_GetFlags(UART_Type *pUART);
+uint8_t UART_CheckFlag(UART_Type *pUART, UART_FlagType FlagType);
+void UART_SendWait(UART_Type *pUART, uint8_t *pSendBuff, uint32_t u32Length);
+void UART_ReceiveWait(UART_Type *pUART, uint8_t *pReceiveBuff, uint32_t u32Length);
+void UART_WaitTxComplete(UART_Type *pUART);
+void UART_SetCallback(UART_CallbackType pfnCallback);
+void UART0_Isr(void);
+void UART1_Isr(void);
+void UART2_Isr(void);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* #ifndef _UART_H_ */
diff --git a/bsp/frdm-ke02/device/lib/inc/uif.h b/bsp/frdm-ke02/device/lib/inc/uif.h
new file mode 100755
index 0000000..920c93c
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/uif.h
@@ -0,0 +1,152 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file uif.h
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief provide an interactive user interface. 
+*
+*   The commands, set/show parameters, and prompt are configured at the project level.
+*******************************************************************************/
+
+#ifndef _UIF_H_
+#define _UIF_H_
+
+/********************************************************************/
+
+/*
+ * Function prototypes
+ */
+char *
+get_line (char *);
+
+uint32
+get_value (char *, int *, int);
+
+void
+run_cmd (void);
+
+int
+make_argv (char *, char **);
+
+void
+uif_cmd_help (int, char **);
+
+void
+uif_cmd_set (int, char **);
+
+void
+uif_cmd_show (int, char **);
+
+/*
+ * Maximum command line arguments
+ */
+#define UIF_MAX_ARGS    10
+
+/*
+ * Maximum length of the command line
+ */
+#define UIF_MAX_LINE    80
+
+/*
+ * The command table entry data structure
+ */
+typedef const struct
+{
+    char *  cmd;                    /* command name user types, ie. GO  */
+    int     min_args;               /* min num of args command accepts  */
+    int     max_args;               /* max num of args command accepts  */
+    int     flags;                  /* command flags (e.g. repeat)      */
+    void    (*func)(int, char **);  /* actual function to call          */
+    char *  description;            /* brief description of command     */
+    char *  syntax;                 /* syntax of command                */
+} UIF_CMD;
+
+/*
+ * Prototype and macro for size of the command table
+ */
+extern UIF_CMD UIF_CMDTAB[];
+extern const int UIF_NUM_CMD;
+#define UIF_CMDTAB_SIZE             (sizeof(UIF_CMDTAB)/sizeof(UIF_CMD))
+
+#define UIF_CMD_FLAG_REPEAT         0x1
+
+/*
+ * Macros for User InterFace command table entries
+ */
+#ifndef UIF_CMD_HELP
+#define UIF_CMD_HELP    \
+    {"help",0,1,0,uif_cmd_help,"Help","<cmd>"},
+#endif
+
+#ifndef UIF_CMD_SET
+#define UIF_CMD_SET \
+    {"set",0,2,0,uif_cmd_set,"Set Config","<option value>"},
+#endif
+
+#ifndef UIF_CMD_SHOW
+#define UIF_CMD_SHOW    \
+    {"show",0,1,0,uif_cmd_show,"Show Config","<option>"},
+#endif
+
+/*
+ * Macro to include all standard user interface commands
+ */
+#define UIF_CMDS_ALL    \
+    UIF_CMD_HELP        \
+    UIF_CMD_SET         \
+    UIF_CMD_SHOW
+
+/*
+ * The set/show table entry data structure
+ */
+typedef const struct
+{
+    char *  option;
+    int     min_args;
+    int     max_args;
+    void    (*func)(int, char **);
+    char *  syntax;
+} UIF_SETCMD;
+
+/*
+ * Prototype and macro for size of the table
+ */
+extern UIF_SETCMD UIF_SETCMDTAB[];
+extern const int UIF_NUM_SETCMD;
+#define UIF_SETCMDTAB_SIZE      (sizeof(UIF_SETCMDTAB)/sizeof(UIF_SETCMD))
+
+/*
+ * Strings defined in uif.c that may be useful to external functions
+ */
+extern const char HELPMSG[];
+extern const char INVARG[];
+extern const char INVALUE[];
+
+/********************************************************************/
+
+#endif /* _UIF_H_ */
diff --git a/bsp/frdm-ke02/device/lib/inc/vectors.h b/bsp/frdm-ke02/device/lib/inc/vectors.h
new file mode 100755
index 0000000..fa7ad51
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/vectors.h
@@ -0,0 +1,176 @@
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file vectors.h
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief provide interrupt vector table for Kinetis E.
+*
+*******************************************************************************/
+
+
+#ifndef __VECTORS_H
+#define __VECTORS_H     1
+
+// function prototype for default_isr in vectors.c
+void default_isr(void);
+void abort_isr(void);
+
+
+void hard_fault_handler_c(unsigned int * hardfault_args);
+
+/* Interrupt Vector Table Function Pointers */
+typedef void pointer(void);
+
+extern void __startup(void);
+extern unsigned long __BOOT_STACK_ADDRESS[];
+extern unsigned long __initial_sp[];
+extern void Reset_Handler( void );
+#if (defined(__GNUC__))
+extern unsigned long _estack;
+extern void __thumb_startup(void);
+#define VECTOR_000      (pointer*)&_estack	//          ARM core        Initial Supervisor SP
+#define VECTOR_001      __thumb_startup	// 0x0000_0004 1 -          ARM core        Initial Program Counter
+//#define VECTOR_001      __startup //__thumb_startup	// 0x0000_0004 1 -          ARM core        Initial Program Counter
+#elif (defined(KEIL))
+#define VECTOR_000      (pointer*)__initial_sp	//          ARM core        Initial Supervisor SP
+#define VECTOR_001      Reset_Handler						// 0x0000_0004 1 -          ARM core        Initial Program Counter
+#else
+    																						// Address     Vector IRQ   Source module   Source description
+#define VECTOR_000      (pointer*)__BOOT_STACK_ADDRESS	//          ARM core        Initial Supervisor SP
+#define VECTOR_001      __startup	// 0x0000_0004 1 -          ARM core        Initial Program Counter
+#endif
+#define VECTOR_002      default_isr     // 0x0000_0008 2 -          ARM core        Non-maskable Interrupt (NMI)
+#define VECTOR_003      default_isr     // 0x0000_000C 3 -          ARM core        Hard Fault
+#define VECTOR_004      default_isr     // 0x0000_0010 4 -
+#define VECTOR_005      default_isr     // 0x0000_0014 5 -          ARM core         Bus Fault
+#define VECTOR_006      default_isr     // 0x0000_0018 6 -          ARM core         Usage Fault
+#define VECTOR_007      default_isr     // 0x0000_001C 7 -                           
+#define VECTOR_008      default_isr     // 0x0000_0020 8 -                           
+#define VECTOR_009      default_isr     // 0x0000_0024 9 -
+#define VECTOR_010      default_isr     // 0x0000_0028 10 -
+#define VECTOR_011      default_isr     // 0x0000_002C 11 -         ARM core         Supervisor call (SVCall)
+#define VECTOR_012      default_isr     // 0x0000_0030 12 -         ARM core         Debug Monitor
+#define VECTOR_013      default_isr     // 0x0000_0034 13 -                          
+#define VECTOR_014      default_isr     // 0x0000_0038 14 -         ARM core         Pendable request for system service (PendableSrvReq)
+#define VECTOR_015      default_isr     // 0x0000_003C 15 -         ARM core         System tick timer (SysTick)
+#define VECTOR_016      default_isr     // 0x0000_0040 16     0     Reserved DMA     DMA Channel 0 transfer complete
+#define VECTOR_017      default_isr     // 0x0000_0044 17     1     Reserved DMA     DMA Channel 1 transfer complete
+#define VECTOR_018      default_isr     // 0x0000_0048 18     2     Reserved DMA     DMA Channel 2 transfer complete
+#define VECTOR_019      default_isr     // 0x0000_004C 19     3     Reserved DMA     DMA Channel 3 transfer complete
+#define VECTOR_020      default_isr     // 0x0000_0050 20     4     Reserved MCM     MCM
+#define VECTOR_021      default_isr     // 0x0000_0054 21     5     NVM              FTMRH flash memory command complete,ECC fault
+#define VECTOR_022      default_isr     // 0x0000_0058 22     6     PMC              LVD,LVW interrupt
+#define VECTOR_023      default_isr     // 0x0000_005C 23     7     LLWU             LLWU/IRQ
+#define VECTOR_024      default_isr     // 0x0000_0060 24     8     I2C0             I2C
+#define VECTOR_025      default_isr     // 0x0000_0064 25     9     -             --
+#define VECTOR_026      default_isr     // 0x0000_0068 26    10     SPI0             SPI0
+#define VECTOR_027      default_isr     // 0x0000_006C 27    11     SPI1             SPI1
+#define VECTOR_028      default_isr     // 0x0000_0070 28    12     SCI0             UART0
+#define VECTOR_029      default_isr     // 0x0000_0074 29    13     SCI1             UART1
+#define VECTOR_030      default_isr     // 0x0000_0078 30    14     SCI2             UART2
+#define VECTOR_031      default_isr     // 0x0000_007C 31    15     ADC0             ADC conversion complete
+#define VECTOR_032      default_isr     // 0x0000_0080 32    16     ACMP0            ACMP0
+#define VECTOR_033      default_isr     // 0x0000_0084 33    17     FTM0             FlexTimer0
+#define VECTOR_034      default_isr     // 0x0000_0088 34    18     FTM1             FlexTimer1
+#define VECTOR_035      default_isr     // 0x0000_008C 35    19     FTM2             FlexTimer2
+#define VECTOR_036      default_isr     // 0x0000_0090 36    20     RTC              RTC overflow
+#define VECTOR_037      default_isr     // 0x0000_0094 37    21     ACMP1            ACMP1
+#define VECTOR_038      default_isr     // 0x0000_0098 38    22     PIT_CH0          PIT_CH0 overflow
+#define VECTOR_039      default_isr     // 0x0000_009C 39    23	    PIT_CH1          PIT_CH1 overflow
+#define VECTOR_040      default_isr     // 0x0000_00A0 40    24     KBI0             Keyboard0 interrupt
+#define VECTOR_041      default_isr     // 0x0000_00A4 41    25     KBI1             Keyboard1 interrupt
+#define VECTOR_042      default_isr     // 0x0000_00A8 42    26     Reserved         ---
+#define VECTOR_043      default_isr     // 0x0000_00AC 43    27     ICS              ICS loss of lock
+#define VECTOR_044      default_isr     // 0x0000_00B0 44    28     WDOG             Watchdog timeout
+#define VECTOR_045      default_isr     // 0x0000_00B4 45    29     Reserved         
+#define VECTOR_046      default_isr     // 0x0000_00B8 46    30     Reserved         
+#define VECTOR_047      default_isr     // 0x0000_00BC 47    31     Reserved         // END of real vector table
+/********************************************************************************************************************/
+#define VECTOR_048      default_isr     // 0x0000_00C0 48    32     Reserved        
+#define VECTOR_049      default_isr     // 0x0000_00C4 49    33     Reserved        
+#define VECTOR_050      default_isr     // 0x0000_00C8 50    34     Reserved           
+#define VECTOR_051      default_isr     // 0x0000_00CC 51    35     Reserved          
+#define VECTOR_052      default_isr     // 0x0000_00D0 52    36     Reserved          
+#define VECTOR_053      default_isr     // 0x0000_00D4 53    37     Reserved          
+#define VECTOR_054      default_isr     // 0x0000_00D8 54    38     Reserved        
+#define VECTOR_055      default_isr     // 0x0000_00DC 55    39     Reserved            
+#define VECTOR_056      default_isr     // 0x0000_00E0 56    40     Reserved         
+#define VECTOR_057      default_isr     // 0x0000_00E4 57    41     Reserved          
+#define VECTOR_058      default_isr     // 0x0000_00E8 58    42     Reserved        
+#define VECTOR_059      default_isr     // 0x0000_00EC 59    43     Reserved        
+#define VECTOR_060      default_isr     // 0x0000_00F0 60    44     Reserved             
+#define VECTOR_061      default_isr     // 0x0000_00F4 61    45     Reserved            Single interrupt vector for SCI status sources
+#define VECTOR_062      default_isr     // 0x0000_00F8 62    46     Reserved            Single interrupt vector for SCI error sources
+#define VECTOR_063      default_isr     // 0x0000_00FC 63    47     Reserved            Single interrupt vector for SCI status sources
+#define VECTOR_064      default_isr     // 0x0000_0100 64    48     Reserved            Single interrupt vector for SCI error sources
+#define VECTOR_065      default_isr     // 0x0000_0104 65    49     Reserved            Single interrupt vector for SCI status sources
+#define VECTOR_066      default_isr     // 0x0000_0108 66    50     Reserved            Single interrupt vector for SCI error sources
+#define VECTOR_067      default_isr     // 0x0000_010C 67    51     Reserved            Single interrupt vector for SCI status sources
+#define VECTOR_068      default_isr     // 0x0000_0110 68    52     Reserved            Single interrupt vector for SCI error sources
+#define VECTOR_069      default_isr     // 0x0000_0114 69    53     Reserved            Single interrupt vector for SCI status sources
+#define VECTOR_070      default_isr     // 0x0000_0118 70    54     Reserved            Single interrupt vector for SCI error sources
+#define VECTOR_071      default_isr     // 0x0000_011C 71    55     Reserved            Single interrupt vector for SCI status sources
+#define VECTOR_072      default_isr     // 0x0000_0120 72    56     Reserved            Single interrupt vector for SCI error sources
+#define VECTOR_073      default_isr     // 0x0000_0124 73    57     Reserved
+#define VECTOR_074      default_isr     // 0x0000_0128 74    58     Reserved
+#define VECTOR_075      default_isr     // 0x0000_012C 75    59     Reserved             
+#define VECTOR_076      default_isr     // 0x0000_0130 76    60     Reserved
+#define VECTOR_077      default_isr     // 0x0000_0134 77    61     Reserved
+#define VECTOR_078      default_isr     // 0x0000_0138 78    62     Reserved 			 Single interrupt vector for all sources
+#define VECTOR_079      default_isr     // 0x0000_013C 79    63     Reserved 			 Single interrupt vector for all sources
+#define VECTOR_080      default_isr     // 0x0000_0140 80    64     Reserved 			 Single interrupt vector for all sources
+#define VECTOR_081      default_isr     // 0x0000_0144 81    65     Reserved
+#define VECTOR_082      default_isr     // 0x0000_0148 82    66     Reserved
+#define VECTOR_083      default_isr     // 0x0000_014C 83    67
+#define VECTOR_084      default_isr     // 0x0000_0150 84    68      
+#define VECTOR_085      default_isr     // 0x0000_0154 85    69      
+#define VECTOR_086      default_isr     // 0x0000_0158 86    70      
+#define VECTOR_087      default_isr     // 0x0000_015C 87    71     
+#define VECTOR_088      default_isr     // 0x0000_0160 88    72     
+#define VECTOR_089      default_isr     // 0x0000_0164 89    73      
+#define VECTOR_090      default_isr     // 0x0000_0168 90    74     
+#define VECTOR_091      default_isr     // 0x0000_016C 91    75		 					 
+#define VECTOR_092      default_isr     // 0x0000_0170 92    76					 
+#define VECTOR_093      default_isr     // 0x0000_0174 93    77					
+#define VECTOR_094      default_isr     // 0x0000_0178 94    78					 
+#define VECTOR_095      default_isr     // 0x0000_017C 95    79     
+#define VECTOR_096      default_isr     // 0x0000_0180 96    80     
+#define VECTOR_097      default_isr     // 0x0000_0184 97    81     
+#define VECTOR_098      default_isr     // 0x0000_0188 98    82     
+#define VECTOR_099      default_isr     // 0x0000_018C 99    83      			
+
+#ifdef USE_BOOTLOADER
+#else
+#define CONFIG_1		0xffffffff 
+#define CONFIG_2		0xffffffff 
+#define CONFIG_3		0xffffffff
+#define CONFIG_4		0xfffeffff
+#endif
+#endif /*__VECTORS_H*/
+
+/* End of "vectors.h" */
diff --git a/bsp/frdm-ke02/device/lib/inc/wdog.h b/bsp/frdm-ke02/device/lib/inc/wdog.h
new file mode 100755
index 0000000..8b0e340
--- /dev/null
+++ b/bsp/frdm-ke02/device/lib/inc/wdog.h
@@ -0,0 +1,234 @@
+
+/******************************************************************************
+*
+* Freescale Semiconductor Inc.
+* (c) Copyright 2013 Freescale Semiconductor, Inc.
+* ALL RIGHTS RESERVED.
+*
+***************************************************************************
+*
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************//*!
+*
+* @file wdog.h
+*
+* @author Freescale
+*
+* @version 0.0.1
+*
+* @date Jun. 25, 2013
+*
+* @brief provide commond watch dog utilities. 
+*
+* @history:
+* 	Jun.25, 2013	modified the watch dog unlock sequence and disable sequence.
+*******************************************************************************
+*
+* provide APIs for accessing watch dog
+******************************************************************************/
+
+#ifndef __WDOG_H__
+#define __WDOG_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/******************************************************************************
+* Includes
+******************************************************************************/
+#include "sim.h"
+
+/******************************************************************************
+* Constants
+******************************************************************************/
+
+/******************************************************************************
+* Macros
+******************************************************************************/
+/* wdog_unlock sequence must be performed within 16 bus clock cycles without
+ * any interrupt 
+ */
+
+   
+/* WDOG clock sources option */
+/******************************************************************************
+* define watchdog clock source selection
+*
+*//*! @addtogroup wdog_clock_sources
+* @{
+*******************************************************************************/
+
+#define WDOG_CLK_BUS                    0   /*!< clock source is bus clock */
+#define WDOG_CLK_INTERNAL_32KHZ         2   /*!< clock source is internal oscillator 32 kHz (ICSIRCLK) */
+#define WDOG_CLK_INTERNAL_1KHZ	        1   /*!< clock source is internal LPO 1 KHz */
+#define WDOG_CLK_EXTERNAL               3   /*!< clock source is external clock */
+/*! @} End of wdog_clock_sources                                                    					*/
+
+/* WDOG clock source selection */
+#define WDOG_CLK  (WDOG_CLK_INTERNAL_1KHZ)
+    
+/* WDOG default values */
+#define WDOG_CS1_DEFAULT_VALUE      0x80
+#define WDOG_CS2_DEFAULT_VALUE      0x01
+#define WDOG_TOVAL_DEFAULT_VALUE    0x0400
+#define WDOG_WIN_DEFAULT_VALUE      0x0000
+     
+/* WDOG utilities */  
+
+/******************************************************************************
+* define watchdog API list
+*
+*//*! @addtogroup wdog_api_list
+* @{
+*******************************************************************************/
+/*! 
+ * @brief watchdog unlock routine.
+ */
+#define WDOG_Unlock()        WDOG->CNT = 0x20C5; WDOG->CNT = 0x28D9        
+//#define WDOG_Unlock()       DisableInterrupts; WDOG->CNT = 0x20C5; WDOG->CNT = 0x28D9; EnableInterrupts        
+/*! @} End of wdog_api_list                                                    					*/
+
+/******************************************************************************
+* Types
+******************************************************************************/
+
+/******************************************************************************
+* define watchdog configuration structure
+*
+*//*! @addtogroup wdog_config_type
+* @{
+*******************************************************************************/
+
+/*!
+ * @brief watchdog configuration structure.
+ *
+ */
+typedef struct {	
+    struct {
+	uint16_t    bIntEnable      : 1;    /*!< watchdog interrupt enable */
+	uint16_t    bDisable        : 1;    /*!< disable watchdog */
+	uint16_t    bWaitEnable     : 1;    /*!< enable watchdog in wait mode */
+	uint16_t    bStopEnable     : 1;    /*!< enable watchdog in stop mode */
+	uint16_t    bDbgEnable      : 1;    /*!< enable watchdog in debug mode */
+	uint16_t    bWinEnable      : 1;    /*!< enable watchdog window mode */
+	uint16_t    bUpdateEnable   : 1;    /*!< enable update of watchdog control */
+	uint16_t    bClkSrc         : 2;    /*!< watchdog clock source selection */  
+	uint16_t    bPrescaler      : 1;    /*!< prescaler */  
+    }sBits;                             /*!< bitfield structure  */
+    uint16_t    u16TimeOut;             /*!< watchdog timeout value */
+    uint16_t    u16WinTime;             /*!< watchdog window value */
+} WDOG_ConfigType, *WDOG_ConfigPtr;  /*!< watchdog configuration structure type */
+/*! @} End of wdog_config_type                                                    					*/
+
+/******************************************************************************
+* Global variables
+******************************************************************************/
+
+/******************************************************************************
+* Global functions
+******************************************************************************/
+
+/******************************************************************************
+* define watchdog API list
+*
+*//*! @addtogroup wdog_api_list
+* @{
+*******************************************************************************/
+
+
+/*****************************************************************************//*!
+*
+* @brief set time out value for WDOG.
+*        
+* @param[in]   u16TimeOut  timeout value to TOVAL register.
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*
+*****************************************************************************/
+
+__STATIC_INLINE void WDOG_SetTimeOut(uint16_t u16TimeOut)
+{
+    WDOG->CNT = 0x20C5; 
+    WDOG->CNT = 0x28D9;
+    WDOG->TOVAL8B.TOVALL  = u16TimeOut;
+    WDOG->TOVAL8B.TOVALH  = u16TimeOut >> 8;
+}
+
+
+/*****************************************************************************//*!
+*
+* @brief set window value for WDOG.
+*        
+* @param[in]   u16WinTime  window value to WIN register.
+*
+* @return none
+*
+* @ Pass/ Fail criteria: none
+*
+*****************************************************************************/
+
+__STATIC_INLINE void WDOG_SetWindow(uint16_t u16WinTime)
+{
+    WDOG->CNT = 0x20C5; 
+    WDOG->CNT = 0x28D9;
+    WDOG->WIN8B.WINL  = u16WinTime;
+    WDOG->WIN8B.WINH  = u16WinTime >> 8;
+}
+
+/*****************************************************************************//*!
+*
+* @brief check if watchdog reset occurs.
+*        
+* @param    none.
+*
+* @return   TRUE if watchdog reset occurs, FALSE otherwise.
+*
+* @ Pass/ Fail criteria: none
+*****************************************************************************/
+
+__STATIC_INLINE uint8_t WDOG_IsReset(void)
+{
+    if(SIM_GetStatus(SIM_SRSID_WDOG_MASK))
+    {
+        return (TRUE);
+    }
+    return (FALSE);
+}
+
+/*! @} End of wdog_api_list                                                    					*/
+
+
+void WDOG_Init(WDOG_ConfigPtr pConfig);
+void WDOG_DeInit(void);
+void WDOG_Disable(void);
+void WDOG_DisableWDOGEnableUpdate(void);
+void WDOG_Enable(void);
+void WDOG_Feed(void);
+void WDOG_SetTimeOut(uint16_t u16TimeOut);
+void WDOG_SetWindow(uint16_t u16WinTime);
+void WDOG_EnableUpdate(void);
+void WDOG_DisableUpdate(void);
+uint8_t WDOG_IsReset(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+/********************************************************************/
+#endif /* __WDOG_H__ */
+
diff --git a/bsp/frdm-ke02/device/startup_gcc/startup.c b/bsp/frdm-ke02/device/startup_gcc/startup.c
new file mode 100755
index 0000000..57c66d1
--- /dev/null
+++ b/bsp/frdm-ke02/device/startup_gcc/startup.c
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2013 - 2014, Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * o Redistributions of source code must retain the above copyright notice, this list
+ *   of conditions and the following disclaimer.
+ *
+ * o Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
+ *   contributors may be used to endorse or promote products derived from this
+ *   software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <stdint.h>
+#include "startup.h"
+
+/*******************************************************************************
+ * Code
+ ******************************************************************************/
+
+void init_data_bss(void)
+{
+    extern char __bss_start[];
+    extern char __bss_end[];
+
+    /* Declare a counter we'll use in all of the copy loops */
+    uint32_t n;
+
+    uint8_t * bss_start, * bss_end;
+
+	bss_start = (uint8_t *)__bss_start__;
+	bss_end = (uint8_t *)__bss_end__;
+
+    /* Clear the zero-initialized data section */
+    n = bss_end - bss_start;
+    while(n--)
+    {
+        *bss_start++ = 0;
+    }
+}
+
+/*******************************************************************************
+ * EOF
+ ******************************************************************************/
+
diff --git a/bsp/frdm-ke02/device/startup_gcc/startup.h b/bsp/frdm-ke02/device/startup_gcc/startup.h
new file mode 100755
index 0000000..9e5712e
--- /dev/null
+++ b/bsp/frdm-ke02/device/startup_gcc/startup.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2013 - 2014, Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * o Redistributions of source code must retain the above copyright notice, this list
+ *   of conditions and the following disclaimer.
+ *
+ * o Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
+ *   contributors may be used to endorse or promote products derived from this
+ *   software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _STARTUP_H_
+#define _STARTUP_H_
+
+/*******************************************************************************
+ * API
+ ******************************************************************************/
+
+void init_data_bss(void);
+
+#endif /* _STARTUP_H_*/
+/*******************************************************************************
+ * EOF
+ ******************************************************************************/
+
diff --git a/bsp/frdm-ke02/device/startup_gcc/startup_MKE02Z2.s b/bsp/frdm-ke02/device/startup_gcc/startup_MKE02Z2.s
new file mode 100755
index 0000000..e769f6e
--- /dev/null
+++ b/bsp/frdm-ke02/device/startup_gcc/startup_MKE02Z2.s
@@ -0,0 +1,273 @@
+/* K64F startup ARM GCC
+ * Purpose: startup file for Cortex-M4 devices. Should use with
+ *   GCC for ARM Embedded Processors
+ * Version: V1.2
+ * Date: 15 Nov 2011
+ *
+ * Copyright (c) 2011, ARM Limited
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of the ARM Limited nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL ARM LIMITED BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+    .syntax unified
+    .arch armv6-m
+    
+/* Memory Model
+   The HEAP starts at the end of the DATA section and grows upward.
+
+   The STACK starts at the end of the RAM and grows downward.
+
+   The HEAP and stack STACK are only checked at compile time:
+   (DATA_SIZE + HEAP_SIZE + STACK_SIZE) < RAM_SIZE
+
+   This is just a check for the bare minimum for the Heap+Stack area before
+   aborting compilation, it is not the run time limit:
+   Heap_Size + Stack_Size = 0x80 + 0x80 = 0x100
+ */
+    .section .stack
+    .align 3
+#ifdef __STACK_SIZE
+    .equ    Stack_Size, __STACK_SIZE
+#else
+    .equ    Stack_Size, 0x100
+#endif
+    .globl    __StackTop
+    .globl    __StackLimit
+__StackLimit:
+    .space    Stack_Size
+    .size __StackLimit, . - __StackLimit
+__StackTop:
+    .size __StackTop, . - __StackTop
+
+    .section .heap
+    .align 3
+#ifdef __HEAP_SIZE
+    .equ    Heap_Size, __HEAP_SIZE
+#else
+    .equ    Heap_Size, 0x100
+#endif
+    .globl    __HeapBase
+    .globl    __HeapLimit
+__HeapBase:
+    .space    Heap_Size
+    .size __HeapBase, . - __HeapBase
+__HeapLimit:
+    .size __HeapLimit, . - __HeapLimit
+
+    .section .vector_table,"a",%progbits
+    .align 2
+    .globl __isr_vector
+__isr_vector:
+    	.long   __StackTop                  /* Top of Stack */
+    	.long   Reset_Handler               /* Reset Handler */
+    	.long   NMI_Handler                 /* NMI Handler                  */
+    	.long   0           /* Hard Fault Handler           */
+    	.long   0           /* MPU Fault Handler            */
+    	.long   0            /* Bus Fault Handler            */
+    	.long   0          /* Usage Fault Handler          */
+    	.long   0                           /* Reserved                     */
+    	.long   0                           /* Reserved                     */
+    	.long   0                           /* Reserved                     */
+    	.long   0                           /* Reserved                     */
+    	.long   SVC_Handler                 /* SVCall Handler               */
+        .long   0            /* Debug Monitor Handler        */
+        .long   0                           /* Reserved                     */
+        .long   PendSV_Handler              /* PendSV Handler               */
+        .long   SysTick_Handler             /* SysTick Handler              */
+
+    /* External Interrupts */
+	.long	  Reserved16_IRQHandler  /* Reserved interrupt 16*/
+	.long     Reserved17_IRQHandler  /* Reserved interrupt 17*/
+	.long     Reserved18_IRQHandler  /* Reserved interrupt 18*/
+	.long     Reserved19_IRQHandler  /* Reserved interrupt 19*/
+	.long     Reserved20_IRQHandler  /* Reserved interrupt 20*/
+	.long     FTMRH_IRQHandler  /* FTMRH command complete/read collision interrupt*/
+	.long     LVD_LVW_IRQHandler	/* Low Voltage Detect, Low Voltage Warning*/
+	.long     IRQ_IRQHandler  /* External interrupt*/
+	.long     I2C0_IRQHandler  /* I2C0 interrupt*/
+	.long     Reserved25_IRQHandler  /* Reserved interrupt 25*/
+	.long     SPI0_IRQHandler  /* SPI0 interrupt*/
+	.long     SPI1_IRQHandler  /* SPI1 interrupt*/
+	.long     UART0_IRQHandler  /* UART0 status/error interrupt*/
+	.long     UART1_IRQHandler  /* UART1 status/error interrupt*/
+	.long     UART2_IRQHandler  /* UART2 status/error interrupt*/
+	.long     ADC0_IRQHandler  /* ADC0 interrupt*/
+	.long     ACMP0_IRQHandler  /* ACMP0 interrupt*/
+	.long     FTM0_IRQHandler  /* FTM0 Single interrupt vector for all sources*/
+	.long     FTM1_IRQHandler  /* FTM1 Single interrupt vector for all sources*/
+	.long     FTM2_IRQHandler  /* FTM2 Single interrupt vector for all sources*/
+	.long     RTC_IRQHandler  /* RTC overflow*/
+	.long     ACMP1_IRQHandler  /* ACMP1 interrupt*/
+	.long     PIT_CH0_IRQHandler	/* PIT CH0 overflow*/
+	.long     PIT_CH1_IRQHandler	/* PIT CH1 overflow*/
+	.long     KBI0_IRQHandler  /* Keyboard interrupt 0*/
+	.long     KBI1_IRQHandler  /* Keyboard interrupt 1*/
+	.long     Reserved42_IRQHandler  /* Reserved interrupt 42*/
+	.long     ICS_IRQHandler  /* MCG interrupt*/
+	.long     Watchdog_IRQHandler  /* WDOG Interrupt*/
+	.long     Reserved45_IRQHandler  /* Reserved interrupt 45*/
+	.long     Reserved46_IRQHandler  /* Reserved interrupt 46*/
+	.long     Reserved47_IRQHandler  /* Reserved interrupt 47*/
+
+            
+    
+    .size    __isr_vector, . - __isr_vector
+
+    .section .text.Reset_Handler
+    .thumb
+    .thumb_func
+    .align  2
+    .globl   Reset_Handler
+    .type    Reset_Handler, %function
+Reset_Handler:
+/*     Loop to copy data from read only memory to RAM. The ranges
+ *      of copy from/to are specified by following symbols evaluated in
+ *      linker script.
+ *      __etext: End of code section, i.e., begin of data sections to copy from.
+ *      __data_start__/__data_end__: RAM address range that data should be
+ *      copied to. Both must be aligned to 4 bytes boundary.  */
+
+    ldr    r1, =__etext
+    ldr    r2, =__data_start__
+    ldr    r3, =__data_end__
+
+    subs   r3, r2
+    ble    .Lflash_to_ram_loop_end
+
+    movs    r4, 0
+.Lflash_to_ram_loop:
+    ldr    r0, [r1,r4]
+    str    r0, [r2,r4]
+    adds   r4, 4
+    cmp    r4, r3
+    blt    .Lflash_to_ram_loop
+.Lflash_to_ram_loop_end:
+
+    /*ldr   r0, =init_data_bss
+    blx   r0*/   
+    /*     This part of work usually is done in C library startup code. Otherwise,
+ *     define this macro to enable it in this startup.
+ *
+ *     Loop to zero out BSS section, which uses following symbols
+ *     in linker script:
+ *      __bss_start__: start of BSS section. Must align to 4
+ *      __bss_end__: end of BSS section. Must align to 4
+ */
+    ldr r1, =__bss_start__
+    ldr r2, =__bss_end__
+
+    subs    r2, r1
+    ble .LC3
+
+    movs    r0, 0
+.LC2:
+    str r0, [r1, r2]
+    subs    r2, 4
+    bge .LC2
+.LC3:
+    ldr   r0, =SystemInit
+    blx   r0
+    ldr   r0, =main
+    bx    r0
+    .pool
+    .size Reset_Handler, . - Reset_Handler
+
+    .text
+/*    Macro to define default handlers. Default handler
+ *    will be weak symbol and just dead loops. They can be
+ *    overwritten by other handlers */
+    .macro    def_default_handler    handler_name
+    .align 1
+    .thumb_func
+    .weak    \handler_name
+    .type    \handler_name, %function
+\handler_name :
+    b    .
+    .size    \handler_name, . - \handler_name
+    .endm
+
+/* Exception Handlers */
+
+    def_default_handler    NMI_Handler
+    def_default_handler    HardFault_Handler
+    def_default_handler    MemManage_Handler
+    def_default_handler    BusFault_Handler
+    def_default_handler    UsageFault_Handler
+    def_default_handler    SVC_Handler
+    def_default_handler    DebugMon_Handler
+    def_default_handler    PendSV_Handler
+    def_default_handler    SysTick_Handler
+    def_default_handler    Default_Handler
+    
+    .macro    def_irq_default_handler    handler_name
+    .weak     \handler_name
+    .set      \handler_name, Default_Handler
+    .endm
+
+/* IRQ Handlers */
+    def_irq_default_handler     Reserved16_IRQHandler
+    def_irq_default_handler     Reserved17_IRQHandler
+    def_irq_default_handler     Reserved18_IRQHandler
+    def_irq_default_handler     Reserved19_IRQHandler
+    def_irq_default_handler     Reserved20_IRQHandler
+    def_irq_default_handler     FTMRH_IRQHandler
+    def_irq_default_handler     LVD_LVW_IRQHandler
+    def_irq_default_handler     IRQ_IRQHandler
+    def_irq_default_handler     I2C0_IRQHandler
+    def_irq_default_handler     Reserved25_IRQHandler
+    def_irq_default_handler     SPI0_IRQHandler
+    def_irq_default_handler     SPI1_IRQHandler
+    def_irq_default_handler     UART0_IRQHandler
+    def_irq_default_handler     UART1_IRQHandler
+    def_irq_default_handler     UART2_IRQHandler
+    def_irq_default_handler     ADC0_IRQHandler
+    def_irq_default_handler     ACMP0_IRQHandler
+    def_irq_default_handler     FTM0_IRQHandler
+    def_irq_default_handler     FTM1_IRQHandler
+    def_irq_default_handler     FTM2_IRQHandler
+    def_irq_default_handler     RTC_IRQHandler
+    def_irq_default_handler     ACMP1_IRQHandler
+    def_irq_default_handler     PIT_CH0_IRQHandler
+    def_irq_default_handler     PIT_CH1_IRQHandler
+    def_irq_default_handler     KBI0_IRQHandler
+    def_irq_default_handler     KBI1_IRQHandler
+    def_irq_default_handler     Reserved42_IRQHandler
+    def_irq_default_handler     ICS_IRQHandler
+    def_irq_default_handler     Watchdog_IRQHandler
+    def_irq_default_handler     Reserved45_IRQHandler
+    def_irq_default_handler     Reserved46_IRQHandler
+    def_irq_default_handler     Reserved47_IRQHandler
+    def_irq_default_handler     DefaultISR
+    
+/* Flash protection region, placed at 0x400 */
+    .text
+    .thumb
+    .align 2
+    .section .kinetis_flash_config_field,"a",%progbits
+kinetis_flash_config:
+    .long 0xffffffff
+    .long 0xffffffff
+    .long 0xffffffff
+    .long 0xfffffffe
+
+    .end
diff --git a/bsp/frdm-ke02/device/startup_keil/startup_MKE02Z2.s b/bsp/frdm-ke02/device/startup_keil/startup_MKE02Z2.s
new file mode 100755
index 0000000..1d9dffa
--- /dev/null
+++ b/bsp/frdm-ke02/device/startup_keil/startup_MKE02Z2.s
@@ -0,0 +1,354 @@
+; * @file:    startup_MK20D7.s
+;/*****************************************************************************
+; * @file:    startup_MKE02Z2.s
+; * @purpose: CMSIS Cortex-M0plus Core Device Startup File for the
+; *           MKE02Z2
+; * @version: 1.2
+; * @date:    2013-5-7
+; *
+; * Copyright: 1997 - 2013 Freescale Semiconductor, Inc. All Rights Reserved.
+;*
+; *------- <<< Use Configuration Wizard in Context Menu >>> ------------------
+; *
+; *****************************************************************************/
+
+
+; <h> Stack Configuration
+;   <o> Stack Size (in Bytes) <0x0-0xFFFFFFFF:8>
+; </h>
+
+Stack_Size      EQU     0x00000200
+
+                AREA    STACK, NOINIT, READWRITE, ALIGN=3
+Stack_Mem       SPACE   Stack_Size
+__initial_sp
+
+
+; <h> Heap Configuration
+;   <o>  Heap Size (in Bytes) <0x0-0xFFFFFFFF:8>
+; </h>
+
+Heap_Size       EQU     0x00000000
+
+                AREA    HEAP, NOINIT, READWRITE, ALIGN=3
+__heap_base
+Heap_Mem        SPACE   Heap_Size
+__heap_limit
+
+
+                PRESERVE8
+                THUMB
+
+
+; Vector Table Mapped to Address 0 at Reset
+
+                AREA    RESET, DATA, READONLY
+                EXPORT  __Vectors
+                EXPORT  __Vectors_End
+                EXPORT  __Vectors_Size
+
+__Vectors       DCD     __initial_sp  ; Top of Stack
+                DCD     Reset_Handler  ; Reset Handler
+                DCD     NMI_Handler  ; NMI Handler
+                DCD     0  ; Reserved
+                DCD     0  ; Reserved
+                DCD     0  ; Reserved
+                DCD     0  ; Reserved
+                DCD     0  ; Reserved
+                DCD     0  ; Reserved
+                DCD     0  ; Reserved
+                DCD     0  ; Reserved
+                DCD     SVC_Handler  ; SVCall Handler
+                DCD     0  ; Reserved
+                DCD     0  ; Reserved
+                DCD     PendSV_Handler  ; PendSV Handler
+                DCD     SysTick_Handler  ; SysTick Handler
+
+                ; External Interrupts
+                DCD     Reserved16_IRQHandler  ; Reserved interrupt 16
+                DCD     Reserved17_IRQHandler  ; Reserved interrupt 17
+                DCD     Reserved18_IRQHandler  ; Reserved interrupt 18
+                DCD     Reserved19_IRQHandler  ; Reserved interrupt 19
+                DCD     Reserved20_IRQHandler  ; Reserved interrupt 20
+                DCD     FTMRH_IRQHandler  ; FTMRH command complete/read collision interrupt
+                DCD     LVD_LVW_IRQHandler  ; Low Voltage Detect, Low Voltage Warning
+                DCD     IRQ_IRQHandler  ; External interrupt
+                DCD     I2C0_IRQHandler  ; I2C0 interrupt
+                DCD     Reserved25_IRQHandler  ; Reserved interrupt 25
+                DCD     SPI0_IRQHandler  ; SPI0 interrupt
+                DCD     SPI1_IRQHandler  ; SPI1 interrupt
+                DCD     UART0_IRQHandler  ; UART0 status/error interrupt
+                DCD     UART1_IRQHandler  ; UART1 status/error interrupt
+                DCD     UART2_IRQHandler  ; UART2 status/error interrupt
+                DCD     ADC0_IRQHandler  ; ADC0 interrupt
+                DCD     ACMP0_IRQHandler  ; ACMP0 interrupt
+                DCD     FTM0_IRQHandler  ; FTM0 Single interrupt vector for all sources
+                DCD     FTM1_IRQHandler  ; FTM1 Single interrupt vector for all sources
+                DCD     FTM2_IRQHandler  ; FTM2 Single interrupt vector for all sources
+                DCD     RTC_IRQHandler  ; RTC overflow
+                DCD     ACMP1_IRQHandler  ; ACMP1 interrupt
+                DCD     PIT_CH0_IRQHandler  ; PIT CH0 overflow
+                DCD     PIT_CH1_IRQHandler  ; PIT CH1 overflow
+                DCD     KBI0_IRQHandler  ; Keyboard interrupt 0
+                DCD     KBI1_IRQHandler  ; Keyboard interrupt 1
+                DCD     Reserved42_IRQHandler  ; Reserved interrupt 42
+                DCD     ICS_IRQHandler  ; MCG interrupt
+                DCD     Watchdog_IRQHandler  ; WDOG Interrupt
+                DCD     Reserved45_IRQHandler  ; Reserved interrupt 45
+                DCD     Reserved46_IRQHandler  ; Reserved interrupt 46
+                DCD     Reserved47_IRQHandler  ; Reserved interrupt 47
+__Vectors_End
+
+__Vectors_Size 	EQU     __Vectors_End - __Vectors
+
+; <h> Flash Configuration
+;   <i> 16-byte flash configuration field that stores default protection settings (loaded on reset)
+;   <i> and security information that allows the MCU to restrict acces to the FTFL module.
+;   <h> Backdoor Comparison Key
+;     <o0>  Backdoor Key 0  <0x0-0xFF:2>
+;     <o1>  Backdoor Key 1  <0x0-0xFF:2>
+;     <o2>  Backdoor Key 2  <0x0-0xFF:2>
+;     <o3>  Backdoor Key 3  <0x0-0xFF:2>
+;     <o4>  Backdoor Key 4  <0x0-0xFF:2>
+;     <o5>  Backdoor Key 5  <0x0-0xFF:2>
+;     <o6>  Backdoor Key 6  <0x0-0xFF:2>
+;     <o7>  Backdoor Key 7  <0x0-0xFF:2>
+BackDoorK0      EQU     0xFF
+BackDoorK1      EQU     0xFF
+BackDoorK2      EQU     0xFF
+BackDoorK3      EQU     0xFF
+BackDoorK4      EQU     0xFF
+BackDoorK5      EQU     0xFF
+BackDoorK6      EQU     0xFF
+BackDoorK7      EQU     0xFF
+;   </h>
+;   <h> EEPROM Protection Register (EEPROT)
+;     <i> The DFPROT register defines which D-Flash sectors are protected against program and erase operations.
+;     <o.7>  DPOPEN
+;       <0=> Enables EEPROM memory protection
+;       <1=> Disables EEPROM memory protection
+;     <o.0..2> DPS
+;       <0=> Flash address range: 0x00_0000 - 0x00_001F; protected size: 32 bytes
+;       <1=> Flash address range: 0x00_0000 - 0x00_003F; protected size: 64 bytes
+;       <2=> Flash address range: 0x00_0000 - 0x00_005F; protected size: 96 bytes
+;       <3=> Flash address range: 0x00_0000 - 0x00_007F; protected size: 128 bytes
+;       <4=> Flash address range: 0x00_0000 - 0x00_009F; protected size: 160 bytes
+;       <5=> Flash address range: 0x00_0000 - 0x00_00BF; protected size: 192 bytes
+;       <6=> Flash address range: 0x00_0000 - 0x00_00DF; protected size: 224 bytes
+;       <7=> Flash address range: 0x00_0000 - 0x00_00FF; protected size: 256 bytes
+EEPROT          EQU     0xFF
+;     </h>
+;     <h> FPROT
+;       <i> P-Flash Protection Register
+;       <o.7> FPOPEN
+;         <0=> FPHDIS and FPLDIS bits define unprotected address ranges as specified by the corresponding FPHS and FPLS bits FPROT1.1
+;         <1=> FPHDIS and FPLDIS bits enable protection for the address range specified by the corresponding FPHS and FPLS bits
+;       <o.5> FPHDIS
+;         <0=> Protection/Unprotection enabled
+;         <1=> Protection/Unprotection disabled
+;       <o.3..4> FPHS
+;         <0=> Address range: 0x00_7C00-0x00_7FFF; protected size: 1 KB
+;         <1=> Address range: 0x00_7800-0x00_7FFF; protected size: 2 KB
+;         <2=> Address range: 0x00_7000-0x00_7FFF; protected size: 4 KB
+;         <3=> Address range: 0x00_6000-0x00_7FFF; protected size: 8 KB
+;       <o.5> FPLDIS
+;         <0=> Protection/Unprotection enabled
+;         <1=> Protection/Unprotection disabled
+;       <o.3..4> FPLS
+;         <0=> Address range: 0x00_0000-0x00_07FF; protected size: 2 KB
+;         <1=> Address range: 0x00_0000-0x00_0FFF; protected size: 4 KB
+;         <2=> Address range: 0x00_0000-0x00_1FFF; protected size: 8 KB
+;         <3=> Address range: 0x00_0000-0x00_3FFF; protected size: 16 KB
+FPROT         EQU     0xFF
+;     </h>
+;   </h>
+;   <h> Flash security byte (FSEC)
+;     <i> WARNING: If SEC field is configured as "MCU security status is secure" and MEEN field is configured as "Mass erase is disabled",
+;     <i> MCU's security status cannot be set back to unsecure state since Mass erase via the debugger is blocked !!!
+;     <o.0..1> SEC
+;       <2=> MCU security status is unsecure
+;       <3=> MCU security status is secure
+;         <i> Flash Security
+;         <i> This bits define the security state of the MCU.
+;     <o.6..7> KEYEN
+;       <2=> Backdoor key access enabled
+;       <3=> Backdoor key access disabled
+;         <i> Backdoor key Security Enable
+;         <i> These bits enable and disable backdoor key access to the FTFL module.
+FSEC            EQU     0xFE
+;   </h>
+;   <h> Flash Option Register (FOPT)
+FOPT            EQU     0xFE
+;   </h>
+                IF      :LNOT::DEF:RAM_TARGET
+                AREA    |.ARM.__at_0x400|, CODE, READONLY
+                DCB     BackDoorK0, BackDoorK1, BackDoorK2, BackDoorK3
+                DCB     BackDoorK4, BackDoorK5, BackDoorK6, BackDoorK7
+                DCB     0xFF,       0xFF,       0xFF,       0xFF
+                DCB     EEPROT,      FPROT,     FSEC,       FOPT              ;Modified by ARM.  DCB     FPROT,      EEPROT,     FOPT,       FSEC
+                ENDIF
+
+                AREA    |.text|, CODE, READONLY
+
+
+; Reset Handler
+
+Reset_Handler   PROC
+                EXPORT  Reset_Handler             [WEAK]
+                IMPORT  SystemInit
+                IMPORT  __main
+                LDR     R0, =SystemInit
+                BLX     R0
+                LDR     R0, =__main
+                BX      R0
+                ENDP
+
+
+; Dummy Exception Handlers (infinite loops which can be modified)
+
+NMI_Handler     PROC
+                EXPORT  NMI_Handler               [WEAK]
+                B       .
+                ENDP
+HardFault_Handler\
+                PROC
+                EXPORT  HardFault_Handler         [WEAK]
+                B       .
+                ENDP
+MemManage_Handler\
+                PROC
+                EXPORT  MemManage_Handler         [WEAK]
+                B       .
+                ENDP
+BusFault_Handler\
+                PROC
+                EXPORT  BusFault_Handler          [WEAK]
+                B       .
+                ENDP
+UsageFault_Handler\
+                PROC
+                EXPORT  UsageFault_Handler        [WEAK]
+                B       .
+                ENDP
+SVC_Handler     PROC
+                EXPORT  SVC_Handler               [WEAK]
+                B       .
+                ENDP
+DebugMon_Handler\
+                PROC
+                EXPORT  DebugMon_Handler          [WEAK]
+                B       .
+                ENDP
+PendSV_Handler  PROC
+                EXPORT  PendSV_Handler            [WEAK]
+                B       .
+                ENDP
+SysTick_Handler PROC
+                EXPORT  SysTick_Handler           [WEAK]
+                B       .
+                ENDP
+
+Default_Handler PROC
+                EXPORT  Reserved16_IRQHandler     [WEAK]
+                EXPORT  Reserved17_IRQHandler     [WEAK]
+                EXPORT  Reserved18_IRQHandler     [WEAK]
+                EXPORT  Reserved19_IRQHandler     [WEAK]
+                EXPORT  Reserved20_IRQHandler     [WEAK]
+                EXPORT  FTMRH_IRQHandler     [WEAK]
+                EXPORT  LVD_LVW_IRQHandler     [WEAK]
+                EXPORT  IRQ_IRQHandler     [WEAK]
+                EXPORT  I2C0_IRQHandler     [WEAK]
+                EXPORT  Reserved25_IRQHandler     [WEAK]
+                EXPORT  SPI0_IRQHandler     [WEAK]
+                EXPORT  SPI1_IRQHandler     [WEAK]
+                EXPORT  UART0_IRQHandler     [WEAK]
+                EXPORT  UART1_IRQHandler     [WEAK]
+                EXPORT  UART2_IRQHandler     [WEAK]
+                EXPORT  ADC0_IRQHandler     [WEAK]
+                EXPORT  ACMP0_IRQHandler     [WEAK]
+                EXPORT  FTM0_IRQHandler     [WEAK]
+                EXPORT  FTM1_IRQHandler     [WEAK]
+                EXPORT  FTM2_IRQHandler     [WEAK]
+                EXPORT  RTC_IRQHandler     [WEAK]
+                EXPORT  ACMP1_IRQHandler     [WEAK]
+                EXPORT  PIT_CH0_IRQHandler     [WEAK]
+                EXPORT  PIT_CH1_IRQHandler     [WEAK]
+                EXPORT  KBI0_IRQHandler     [WEAK]
+                EXPORT  KBI1_IRQHandler     [WEAK]
+                EXPORT  Reserved42_IRQHandler     [WEAK]
+                EXPORT  ICS_IRQHandler     [WEAK]
+                EXPORT  Watchdog_IRQHandler     [WEAK]
+                EXPORT  Reserved45_IRQHandler     [WEAK]
+                EXPORT  Reserved46_IRQHandler     [WEAK]
+                EXPORT  Reserved47_IRQHandler     [WEAK]
+                EXPORT  DefaultISR                      [WEAK]
+
+Reserved16_IRQHandler
+Reserved17_IRQHandler
+Reserved18_IRQHandler
+Reserved19_IRQHandler
+Reserved20_IRQHandler
+FTMRH_IRQHandler
+LVD_LVW_IRQHandler
+IRQ_IRQHandler
+I2C0_IRQHandler
+Reserved25_IRQHandler
+SPI0_IRQHandler
+SPI1_IRQHandler
+UART0_IRQHandler
+UART1_IRQHandler
+UART2_IRQHandler
+ADC0_IRQHandler
+ACMP0_IRQHandler
+FTM0_IRQHandler
+FTM1_IRQHandler
+FTM2_IRQHandler
+RTC_IRQHandler
+ACMP1_IRQHandler
+PIT_CH0_IRQHandler
+PIT_CH1_IRQHandler
+KBI0_IRQHandler
+KBI1_IRQHandler
+Reserved42_IRQHandler
+ICS_IRQHandler
+Watchdog_IRQHandler
+Reserved45_IRQHandler
+Reserved46_IRQHandler
+Reserved47_IRQHandler
+DefaultISR
+
+                B       .
+
+                ENDP
+
+
+                ALIGN
+
+
+; User Initial Stack & Heap
+
+                IF      :DEF:__MICROLIB
+
+                EXPORT  __initial_sp
+                EXPORT  __heap_base
+                EXPORT  __heap_limit
+
+                ELSE
+
+                IMPORT  __use_two_region_memory
+                EXPORT  __user_initial_stackheap
+__user_initial_stackheap
+
+                LDR     R0, =  Heap_Mem
+                LDR     R1, =(Stack_Mem + Stack_Size)
+                LDR     R2, = (Heap_Mem +  Heap_Size)
+                LDR     R3, = Stack_Mem
+                BX      LR
+
+                ALIGN
+
+                ENDIF
+
+
+                END
+
diff --git a/bsp/frdm-ke02/ke02.ld b/bsp/frdm-ke02/ke02.ld
new file mode 100755
index 0000000..13fa843
--- /dev/null
+++ b/bsp/frdm-ke02/ke02.ld
@@ -0,0 +1,165 @@
+/*
+ * K64F ARM GCC linker script file
+ */
+
+MEMORY
+{
+  VECTORS (rx)          : ORIGIN = 0x00000000, LENGTH = 0x00000400
+  FLASH_PROTECTION (rx) : ORIGIN = 0x00000400, LENGTH = 0x00000010
+  FLASH (rx)            : ORIGIN = 0x00000410, LENGTH = 0x00010000 - 0x00000410
+  RAM (rwx)             : ORIGIN = 0x1FFFFC00, LENGTH = 0x00001000
+}
+
+/* Linker script to place sections and symbol values. Should be used together
+ * with other linker script that defines memory regions FLASH and RAM.
+ * It references following symbols, which must be defined in code:
+ * _reset_init : Entry of reset handler
+ *
+ * It defines following symbols, which code can use without definition:
+ * __exidx_start
+ * __exidx_end
+ * __etext
+ * __data_start__
+ * __preinit_array_start
+ * __preinit_array_end
+ * __init_array_start
+ * __init_array_end
+ * __fini_array_start
+ * __fini_array_end
+ * __data_end__
+ * __bss_start__
+ * __bss_end__
+ * __end__
+ * end
+ * __HeapLimit
+ * __StackLimit
+ * __StackTop
+ * __stack
+ */
+ENTRY(Reset_Handler)
+
+SECTIONS
+{
+    .isr_vector :
+    {
+        __vector_table = .;
+        KEEP(*(.vector_table))
+        *(.text.Reset_Handler)
+        *(.text.SystemInit)
+         . = ALIGN(4);
+    } > VECTORS
+
+    .flash_protect :
+    {
+        KEEP(*(.kinetis_flash_config_field))
+         . = ALIGN(4);
+    } > FLASH_PROTECTION
+
+    .text :
+    {
+        *(.text*)
+
+        KEEP(*(.init))
+        KEEP(*(.fini))
+
+        /* .ctors */
+        *crtbegin.o(.ctors)
+        *crtbegin?.o(.ctors)
+        *(EXCLUDE_FILE(*crtend?.o *crtend.o) .ctors)
+        *(SORT(.ctors.*))
+        *(.ctors)
+
+        /* .dtors */
+        *crtbegin.o(.dtors)
+        *crtbegin?.o(.dtors)
+        *(EXCLUDE_FILE(*crtend?.o *crtend.o) .dtors)
+        *(SORT(.dtors.*))
+        *(.dtors)
+
+        *(.rodata*)
+
+
+        KEEP(*(.eh_frame*))
+    } > FLASH
+
+    .ARM.extab :
+    {
+        *(.ARM.extab* .gnu.linkonce.armextab.*)
+    } > FLASH
+
+    __exidx_start = .;
+    .ARM.exidx :
+    {
+        *(.ARM.exidx* .gnu.linkonce.armexidx.*)
+    } > FLASH
+    __exidx_end = .;
+
+    __etext = .;
+
+    .data : AT (__etext)
+    {
+        __data_start__ = .;
+        *(vtable)
+        *(.data*)
+
+        . = ALIGN(4);
+        /* preinit data */
+        PROVIDE_HIDDEN (__preinit_array_start = .);
+        KEEP(*(.preinit_array))
+        PROVIDE_HIDDEN (__preinit_array_end = .);
+
+        . = ALIGN(4);
+        /* init data */
+        PROVIDE_HIDDEN (__init_array_start = .);
+        KEEP(*(SORT(.init_array.*)))
+        KEEP(*(.init_array))
+        PROVIDE_HIDDEN (__init_array_end = .);
+
+
+        . = ALIGN(4);
+        /* finit data */
+        PROVIDE_HIDDEN (__fini_array_start = .);
+        KEEP(*(SORT(.fini_array.*)))
+        KEEP(*(.fini_array))
+        PROVIDE_HIDDEN (__fini_array_end = .);
+
+        . = ALIGN(4);
+        /* All data end */
+        __data_end__ = .;
+
+    } > RAM
+    
+    .bss :
+    {
+        __bss_start__ = .;
+        *(.bss*)
+        *(COMMON)
+        __bss_end__ = .;
+    } > RAM
+    
+    .heap :
+    {
+        __end__ = .;
+        end = __end__;
+        *(.heap*)
+        __HeapLimit = .;
+    } > RAM
+
+    /* .stack_dummy section doesn't contains any symbols. It is only
+     * used for linker to calculate size of stack sections, and assign
+     * values to stack symbols later */
+    .stack_dummy :
+    {
+        *(.stack)
+    } > RAM
+
+    /* Set stack top to end of RAM, and stack limit move down by
+     * size of stack_dummy section */
+    __StackTop = ORIGIN(RAM) + LENGTH(RAM);
+    __StackLimit = __StackTop - SIZEOF(.stack_dummy);
+    PROVIDE(__stack = __StackTop);
+
+    /* Check if data + heap + stack exceeds RAM limit */
+    ASSERT(__StackLimit >= __HeapLimit, "region RAM overflowed with stack")
+}
+
diff --git a/bsp/frdm-ke02/ke02.sct b/bsp/frdm-ke02/ke02.sct
new file mode 100755
index 0000000..5b25df1
--- /dev/null
+++ b/bsp/frdm-ke02/ke02.sct
@@ -0,0 +1,17 @@
+
+LR_IROM1 0x00000000 0x10000  {    ; load region size_region (1000k)
+  ER_IROM1 0x00000000 0x10000  {  ; load address = execution address
+   *.o (RESET, +First)
+   *(InRoot$$Sections)
+   .ANY (+RO)
+  }
+  ; 8_byte_aligned(62 vect * 4 bytes) =  8_byte_aligned(0x194) = 0x198
+  ; 0x10000 - 0x198 = 0x0FE68
+  RW_IRAM1 0x1FFFFC00 0x00400 {
+   .ANY (+RW +ZI)
+  }
+  RW_IRAM2 0x20000000 0x00C00 {
+   .ANY (+RW +ZI)
+  }
+}
+
diff --git a/bsp/frdm-ke02/make-disco.sh b/bsp/frdm-ke02/make-disco.sh
new file mode 100755
index 0000000..948932b
--- /dev/null
+++ b/bsp/frdm-ke02/make-disco.sh
@@ -0,0 +1,5 @@
+#! /bin/bash
+#export RTT_EXEC_PATH="d:/Program Files/CodeSourcery/Sourcery_CodeBench_Lite_for_ARM_EABI/bin"
+scons.bat
+#openocd -f openocd.cfg -c "mt_flash_bin rtthread.bin 0"
+jlink.exe burn.txt
diff --git a/bsp/frdm-ke02/openocd.cfg b/bsp/frdm-ke02/openocd.cfg
new file mode 100755
index 0000000..59b45ed
--- /dev/null
+++ b/bsp/frdm-ke02/openocd.cfg
@@ -0,0 +1,18 @@
+source [find interface/cmsis-dap.cfg]
+# increase working area to 16KB
+set _WORKAREASIZE 0x2000
+
+# chip name
+set _CHIPNAME k20 
+source [find target/k20.cfg]
+
+init
+
+proc flash_image {} {
+    reset halt
+    flash write_image erase rtthread.bin 0x00000000
+
+    reset init
+    shutdown
+    reset
+}
diff --git a/bsp/frdm-ke02/project.uvopt b/bsp/frdm-ke02/project.uvopt
new file mode 100755
index 0000000..f96ba54
--- /dev/null
+++ b/bsp/frdm-ke02/project.uvopt
@@ -0,0 +1,1097 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
+<ProjectOpt xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="project_opt.xsd">
+
+  <SchemaVersion>1.0</SchemaVersion>
+
+  <Header>### uVision Project, (C) Keil Software</Header>
+
+  <Extensions>
+    <cExt>*.c</cExt>
+    <aExt>*.s*; *.src; *.a*</aExt>
+    <oExt>*.obj</oExt>
+    <lExt>*.lib</lExt>
+    <tExt>*.txt; *.h; *.inc</tExt>
+    <pExt>*.plm</pExt>
+    <CppX>*.cpp</CppX>
+  </Extensions>
+
+  <DaveTm>
+    <dwLowDateTime>0</dwLowDateTime>
+    <dwHighDateTime>0</dwHighDateTime>
+  </DaveTm>
+
+  <Target>
+    <TargetName>RT-Thread</TargetName>
+    <ToolsetNumber>0x4</ToolsetNumber>
+    <ToolsetName>ARM-ADS</ToolsetName>
+    <TargetOption>
+      <CLKADS>8000000</CLKADS>
+      <OPTTT>
+        <gFlags>1</gFlags>
+        <BeepAtEnd>1</BeepAtEnd>
+        <RunSim>1</RunSim>
+        <RunTarget>0</RunTarget>
+      </OPTTT>
+      <OPTHX>
+        <HexSelection>1</HexSelection>
+        <FlashByte>65535</FlashByte>
+        <HexRangeLowAddress>0</HexRangeLowAddress>
+        <HexRangeHighAddress>0</HexRangeHighAddress>
+        <HexOffset>0</HexOffset>
+      </OPTHX>
+      <OPTLEX>
+        <PageWidth>79</PageWidth>
+        <PageLength>66</PageLength>
+        <TabStop>8</TabStop>
+        <ListingPath>.\build\</ListingPath>
+      </OPTLEX>
+      <ListingPage>
+        <CreateCListing>1</CreateCListing>
+        <CreateAListing>1</CreateAListing>
+        <CreateLListing>1</CreateLListing>
+        <CreateIListing>0</CreateIListing>
+        <AsmCond>1</AsmCond>
+        <AsmSymb>1</AsmSymb>
+        <AsmXref>0</AsmXref>
+        <CCond>1</CCond>
+        <CCode>0</CCode>
+        <CListInc>0</CListInc>
+        <CSymb>0</CSymb>
+        <LinkerCodeListing>0</LinkerCodeListing>
+      </ListingPage>
+      <OPTXL>
+        <LMap>1</LMap>
+        <LComments>1</LComments>
+        <LGenerateSymbols>1</LGenerateSymbols>
+        <LLibSym>1</LLibSym>
+        <LLines>1</LLines>
+        <LLocSym>1</LLocSym>
+        <LPubSym>1</LPubSym>
+        <LXref>0</LXref>
+        <LExpSel>0</LExpSel>
+      </OPTXL>
+      <OPTFL>
+        <tvExp>1</tvExp>
+        <tvExpOptDlg>0</tvExpOptDlg>
+        <IsCurrentTarget>1</IsCurrentTarget>
+      </OPTFL>
+      <CpuCode>14</CpuCode>
+      <Books>
+        <Book>
+          <Number>0</Number>
+          <Title>Technical Reference Manual</Title>
+          <Path>datashts\arm\cortex_m0p\r0p0\DDI0484B_CORTEX_M0P_R0P0_TRM.PDF</Path>
+        </Book>
+        <Book>
+          <Number>1</Number>
+          <Title>Generic User Guide</Title>
+          <Path>datashts\arm\cortex_m0p\r0p0\DUI0662A_CORTEX_M0P_R0P0_DGUG.PDF</Path>
+        </Book>
+      </Books>
+      <DllOpt>
+        <SimDllName>SARMCM3.DLL</SimDllName>
+        <SimDllArguments></SimDllArguments>
+        <SimDlgDllName>DARMCM1.DLL</SimDlgDllName>
+        <SimDlgDllArguments>-pCM0+</SimDlgDllArguments>
+        <TargetDllName>SARMCM3.DLL</TargetDllName>
+        <TargetDllArguments></TargetDllArguments>
+        <TargetDlgDllName>TARMCM1.DLL</TargetDlgDllName>
+        <TargetDlgDllArguments>-pCM0+</TargetDlgDllArguments>
+      </DllOpt>
+      <DebugOpt>
+        <uSim>0</uSim>
+        <uTrg>1</uTrg>
+        <sLdApp>1</sLdApp>
+        <sGomain>1</sGomain>
+        <sRbreak>1</sRbreak>
+        <sRwatch>1</sRwatch>
+        <sRmem>1</sRmem>
+        <sRfunc>1</sRfunc>
+        <sRbox>1</sRbox>
+        <tLdApp>1</tLdApp>
+        <tGomain>1</tGomain>
+        <tRbreak>1</tRbreak>
+        <tRwatch>1</tRwatch>
+        <tRmem>1</tRmem>
+        <tRfunc>0</tRfunc>
+        <tRbox>1</tRbox>
+        <tRtrace>1</tRtrace>
+        <sRunDeb>0</sRunDeb>
+        <sLrtime>0</sLrtime>
+        <nTsel>7</nTsel>
+        <sDll></sDll>
+        <sDllPa></sDllPa>
+        <sDlgDll></sDlgDll>
+        <sDlgPa></sDlgPa>
+        <sIfile></sIfile>
+        <tDll></tDll>
+        <tDllPa></tDllPa>
+        <tDlgDll></tDlgDll>
+        <tDlgPa></tDlgPa>
+        <tIfile></tIfile>
+        <pMon>Segger\JL2CM3.dll</pMon>
+      </DebugOpt>
+      <TargetDriverDllRegistry>
+        <SetRegEntry>
+          <Number>0</Number>
+          <Key>DLGTARM</Key>
+          <Name>(1010=-1,-1,-1,-1,0)(1007=-1,-1,-1,-1,0)(1008=-1,-1,-1,-1,0)(1009=-1,-1,-1,-1,0)</Name>
+        </SetRegEntry>
+        <SetRegEntry>
+          <Number>0</Number>
+          <Key>ARMDBGFLAGS</Key>
+          <Name></Name>
+        </SetRegEntry>
+        <SetRegEntry>
+          <Number>0</Number>
+          <Key>DLGUARM</Key>
+          <Name></Name>
+        </SetRegEntry>
+        <SetRegEntry>
+          <Number>0</Number>
+          <Key>JL2CM3</Key>
+          <Name>-U621000000 -O207 -S0 -A0 -C0 -JU1 -JI127.0.0.1 -JP0 -RST0 -N00("ARM CoreSight SW-DP") -D00(0BC11477) -L00(0) -TO18 -TC10000000 -TP21 -TDS8007 -TDT0 -TDC1F -TIEFFFFFFFF -TIP8 -TB1 -TFE0 -FO15 -FD1FFFFC00 -FC400 -FN2 -FF0MKE02Zxxx_P64KB -FS00 -FL010000 -FF1MKE02Zxxx_EE256B -FS110000000 -FL1100</Name>
+        </SetRegEntry>
+        <SetRegEntry>
+          <Number>0</Number>
+          <Key>UL2CM3</Key>
+          <Name>UL2CM3(-O207 -S0 -C0 -FO15 -FD20000000 -FC800 -FN2 -FF0MKE02Zxxx_P64KB -FS00 -FL010000 -FF1MKE02Zxxx_EE256B -FS110000000 -FL1100)</Name>
+        </SetRegEntry>
+        <SetRegEntry>
+          <Number>0</Number>
+          <Key>ULP2CM3</Key>
+          <Name>ULP2CM3(-O2510 -S0 -C0 -FO15  -FN1 -FC800 -FD20000000 -FF0MK_P64_50MHZ -FL010000 -FS00</Name>
+        </SetRegEntry>
+      </TargetDriverDllRegistry>
+      <Breakpoint/>
+      <Tracepoint>
+        <THDelay>0</THDelay>
+      </Tracepoint>
+      <DebugFlag>
+        <trace>0</trace>
+        <periodic>0</periodic>
+        <aLwin>1</aLwin>
+        <aCover>0</aCover>
+        <aSer1>0</aSer1>
+        <aSer2>0</aSer2>
+        <aPa>0</aPa>
+        <viewmode>1</viewmode>
+        <vrSel>0</vrSel>
+        <aSym>0</aSym>
+        <aTbox>0</aTbox>
+        <AscS1>0</AscS1>
+        <AscS2>0</AscS2>
+        <AscS3>0</AscS3>
+        <aSer3>0</aSer3>
+        <eProf>0</eProf>
+        <aLa>0</aLa>
+        <aPa1>0</aPa1>
+        <AscS4>0</AscS4>
+        <aSer4>0</aSer4>
+        <StkLoc>0</StkLoc>
+        <TrcWin>0</TrcWin>
+        <newCpu>0</newCpu>
+        <uProt>0</uProt>
+      </DebugFlag>
+      <LintExecutable></LintExecutable>
+      <LintConfigFile></LintConfigFile>
+    </TargetOption>
+  </Target>
+
+  <Group>
+    <GroupName>Applications</GroupName>
+    <tvExp>0</tvExp>
+    <tvExpOptDlg>0</tvExpOptDlg>
+    <cbSel>0</cbSel>
+    <RteFlg>0</RteFlg>
+    <File>
+      <GroupNumber>1</GroupNumber>
+      <FileNumber>1</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>1</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>1</TopLine>
+      <CurrentLine>1</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>applications\application.c</PathWithFileName>
+      <FilenameWithoutPath>application.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>1</GroupNumber>
+      <FileNumber>2</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>61</TopLine>
+      <CurrentLine>81</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>applications\startup.c</PathWithFileName>
+      <FilenameWithoutPath>startup.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+  </Group>
+
+  <Group>
+    <GroupName>Board</GroupName>
+    <tvExp>1</tvExp>
+    <tvExpOptDlg>0</tvExpOptDlg>
+    <cbSel>0</cbSel>
+    <RteFlg>0</RteFlg>
+    <File>
+      <GroupNumber>2</GroupNumber>
+      <FileNumber>3</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>21</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>15</TopLine>
+      <CurrentLine>16</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>board\board.c</PathWithFileName>
+      <FilenameWithoutPath>board.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>2</GroupNumber>
+      <FileNumber>4</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>31</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>123</TopLine>
+      <CurrentLine>132</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>board\drv_uart.c</PathWithFileName>
+      <FilenameWithoutPath>drv_uart.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>2</GroupNumber>
+      <FileNumber>5</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>board\led.c</PathWithFileName>
+      <FilenameWithoutPath>led.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+  </Group>
+
+  <Group>
+    <GroupName>Device</GroupName>
+    <tvExp>0</tvExp>
+    <tvExpOptDlg>0</tvExpOptDlg>
+    <cbSel>0</cbSel>
+    <RteFlg>0</RteFlg>
+    <File>
+      <GroupNumber>3</GroupNumber>
+      <FileNumber>6</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>device\lib\drivers\acmp.c</PathWithFileName>
+      <FilenameWithoutPath>acmp.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>3</GroupNumber>
+      <FileNumber>7</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>device\lib\drivers\adc.c</PathWithFileName>
+      <FilenameWithoutPath>adc.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>3</GroupNumber>
+      <FileNumber>8</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>device\lib\drivers\arm_cm0.c</PathWithFileName>
+      <FilenameWithoutPath>arm_cm0.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>3</GroupNumber>
+      <FileNumber>9</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>device\lib\drivers\crc.c</PathWithFileName>
+      <FilenameWithoutPath>crc.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>3</GroupNumber>
+      <FileNumber>10</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>device\lib\drivers\flash.c</PathWithFileName>
+      <FilenameWithoutPath>flash.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>3</GroupNumber>
+      <FileNumber>11</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>device\lib\drivers\ftm.c</PathWithFileName>
+      <FilenameWithoutPath>ftm.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>3</GroupNumber>
+      <FileNumber>12</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>device\lib\drivers\gpio.c</PathWithFileName>
+      <FilenameWithoutPath>gpio.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>3</GroupNumber>
+      <FileNumber>13</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>device\lib\drivers\i2c.c</PathWithFileName>
+      <FilenameWithoutPath>i2c.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>3</GroupNumber>
+      <FileNumber>14</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>120</TopLine>
+      <CurrentLine>121</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>device\lib\drivers\ics.c</PathWithFileName>
+      <FilenameWithoutPath>ics.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>3</GroupNumber>
+      <FileNumber>15</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>device\lib\drivers\kbi.c</PathWithFileName>
+      <FilenameWithoutPath>kbi.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>3</GroupNumber>
+      <FileNumber>16</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>device\lib\drivers\memtest.c</PathWithFileName>
+      <FilenameWithoutPath>memtest.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>3</GroupNumber>
+      <FileNumber>17</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>device\lib\drivers\pit.c</PathWithFileName>
+      <FilenameWithoutPath>pit.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>3</GroupNumber>
+      <FileNumber>18</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>device\lib\drivers\pmc.c</PathWithFileName>
+      <FilenameWithoutPath>pmc.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>3</GroupNumber>
+      <FileNumber>19</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>device\lib\drivers\queue.c</PathWithFileName>
+      <FilenameWithoutPath>queue.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>3</GroupNumber>
+      <FileNumber>20</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>device\lib\drivers\rtc.c</PathWithFileName>
+      <FilenameWithoutPath>rtc.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>3</GroupNumber>
+      <FileNumber>21</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>323</TopLine>
+      <CurrentLine>372</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>device\lib\drivers\sim.c</PathWithFileName>
+      <FilenameWithoutPath>sim.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>3</GroupNumber>
+      <FileNumber>22</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>device\lib\drivers\spi.c</PathWithFileName>
+      <FilenameWithoutPath>spi.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>3</GroupNumber>
+      <FileNumber>23</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>1</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>72</TopLine>
+      <CurrentLine>121</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>device\lib\drivers\start.c</PathWithFileName>
+      <FilenameWithoutPath>start.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>3</GroupNumber>
+      <FileNumber>24</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>6</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>52</TopLine>
+      <CurrentLine>103</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>device\lib\drivers\startup.c</PathWithFileName>
+      <FilenameWithoutPath>drivers_startup.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>3</GroupNumber>
+      <FileNumber>25</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>4</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>133</TopLine>
+      <CurrentLine>142</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>device\lib\drivers\sysinit.c</PathWithFileName>
+      <FilenameWithoutPath>sysinit.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>3</GroupNumber>
+      <FileNumber>26</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>device\lib\drivers\systick.c</PathWithFileName>
+      <FilenameWithoutPath>systick.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>3</GroupNumber>
+      <FileNumber>27</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>107</TopLine>
+      <CurrentLine>114</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>device\lib\drivers\uart.c</PathWithFileName>
+      <FilenameWithoutPath>uart.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>3</GroupNumber>
+      <FileNumber>28</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>93</TopLine>
+      <CurrentLine>102</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>device\lib\drivers\wdog.c</PathWithFileName>
+      <FilenameWithoutPath>wdog.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>3</GroupNumber>
+      <FileNumber>29</FileNumber>
+      <FileType>2</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>192</TopLine>
+      <CurrentLine>200</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>device\startup_keil\startup_MKE02Z2.s</PathWithFileName>
+      <FilenameWithoutPath>startup_MKE02Z2.s</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+  </Group>
+
+  <Group>
+    <GroupName>Kernel</GroupName>
+    <tvExp>0</tvExp>
+    <tvExpOptDlg>0</tvExpOptDlg>
+    <cbSel>0</cbSel>
+    <RteFlg>0</RteFlg>
+    <File>
+      <GroupNumber>4</GroupNumber>
+      <FileNumber>30</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>..\..\src\clock.c</PathWithFileName>
+      <FilenameWithoutPath>clock.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>4</GroupNumber>
+      <FileNumber>31</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>..\..\src\device.c</PathWithFileName>
+      <FilenameWithoutPath>device.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>4</GroupNumber>
+      <FileNumber>32</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>..\..\src\idle.c</PathWithFileName>
+      <FilenameWithoutPath>idle.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>4</GroupNumber>
+      <FileNumber>33</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>..\..\src\ipc.c</PathWithFileName>
+      <FilenameWithoutPath>ipc.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>4</GroupNumber>
+      <FileNumber>34</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>..\..\src\irq.c</PathWithFileName>
+      <FilenameWithoutPath>irq.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>4</GroupNumber>
+      <FileNumber>35</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>..\..\src\kservice.c</PathWithFileName>
+      <FilenameWithoutPath>kservice.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>4</GroupNumber>
+      <FileNumber>36</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>..\..\src\mem.c</PathWithFileName>
+      <FilenameWithoutPath>mem.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>4</GroupNumber>
+      <FileNumber>37</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>..\..\src\mempool.c</PathWithFileName>
+      <FilenameWithoutPath>mempool.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>4</GroupNumber>
+      <FileNumber>38</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>..\..\src\object.c</PathWithFileName>
+      <FilenameWithoutPath>object.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>4</GroupNumber>
+      <FileNumber>39</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>..\..\src\scheduler.c</PathWithFileName>
+      <FilenameWithoutPath>scheduler.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>4</GroupNumber>
+      <FileNumber>40</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>..\..\src\thread.c</PathWithFileName>
+      <FilenameWithoutPath>thread.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>4</GroupNumber>
+      <FileNumber>41</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>..\..\src\timer.c</PathWithFileName>
+      <FilenameWithoutPath>timer.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+  </Group>
+
+  <Group>
+    <GroupName>CORTEX-M0</GroupName>
+    <tvExp>0</tvExp>
+    <tvExpOptDlg>0</tvExpOptDlg>
+    <cbSel>0</cbSel>
+    <RteFlg>0</RteFlg>
+    <File>
+      <GroupNumber>5</GroupNumber>
+      <FileNumber>42</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>..\..\libcpu\arm\cortex-m0\cpuport.c</PathWithFileName>
+      <FilenameWithoutPath>cpuport.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>5</GroupNumber>
+      <FileNumber>43</FileNumber>
+      <FileType>2</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>..\..\libcpu\arm\cortex-m0\context_rvds.S</PathWithFileName>
+      <FilenameWithoutPath>context_rvds.S</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>5</GroupNumber>
+      <FileNumber>44</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>..\..\libcpu\arm\common\backtrace.c</PathWithFileName>
+      <FilenameWithoutPath>backtrace.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>5</GroupNumber>
+      <FileNumber>45</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>..\..\libcpu\arm\common\div0.c</PathWithFileName>
+      <FilenameWithoutPath>div0.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>5</GroupNumber>
+      <FileNumber>46</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>..\..\libcpu\arm\common\showmem.c</PathWithFileName>
+      <FilenameWithoutPath>showmem.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+  </Group>
+
+  <Group>
+    <GroupName>DeviceDrivers</GroupName>
+    <tvExp>0</tvExp>
+    <tvExpOptDlg>0</tvExpOptDlg>
+    <cbSel>0</cbSel>
+    <RteFlg>0</RteFlg>
+    <File>
+      <GroupNumber>6</GroupNumber>
+      <FileNumber>47</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>..\..\components\drivers\serial\serial.c</PathWithFileName>
+      <FilenameWithoutPath>serial.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>6</GroupNumber>
+      <FileNumber>48</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>..\..\components\drivers\src\completion.c</PathWithFileName>
+      <FilenameWithoutPath>completion.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>6</GroupNumber>
+      <FileNumber>49</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>..\..\components\drivers\src\dataqueue.c</PathWithFileName>
+      <FilenameWithoutPath>dataqueue.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>6</GroupNumber>
+      <FileNumber>50</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>..\..\components\drivers\src\pipe.c</PathWithFileName>
+      <FilenameWithoutPath>pipe.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>6</GroupNumber>
+      <FileNumber>51</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>..\..\components\drivers\src\portal.c</PathWithFileName>
+      <FilenameWithoutPath>portal.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>6</GroupNumber>
+      <FileNumber>52</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>..\..\components\drivers\src\ringbuffer.c</PathWithFileName>
+      <FilenameWithoutPath>ringbuffer.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+    <File>
+      <GroupNumber>6</GroupNumber>
+      <FileNumber>53</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>..\..\components\drivers\src\workqueue.c</PathWithFileName>
+      <FilenameWithoutPath>workqueue.c</FilenameWithoutPath>
+      <RteFlg>0</RteFlg>
+      <bShared>0</bShared>
+    </File>
+  </Group>
+
+</ProjectOpt>
diff --git a/bsp/frdm-ke02/project.uvproj b/bsp/frdm-ke02/project.uvproj
new file mode 100755
index 0000000..4ef57c1
--- /dev/null
+++ b/bsp/frdm-ke02/project.uvproj
@@ -0,0 +1,691 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
+<Project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="project_proj.xsd">
+
+  <SchemaVersion>1.1</SchemaVersion>
+
+  <Header>### uVision Project, (C) Keil Software</Header>
+
+  <Targets>
+    <Target>
+      <TargetName>RT-Thread</TargetName>
+      <ToolsetNumber>0x4</ToolsetNumber>
+      <ToolsetName>ARM-ADS</ToolsetName>
+      <TargetOption>
+        <TargetCommonOption>
+          <Device>MKE02Z64xxx2</Device>
+          <Vendor>Freescale Semiconductor</Vendor>
+          <Cpu>IRAM(0x1FFFFC00-0x1FFFFFFF) IRAM2(0x20000000-0x20000BFF) IROM(0x0-0xFFFF) CLOCK(8000000) CPUTYPE("Cortex-M0+") ELITTLE</Cpu>
+          <FlashUtilSpec></FlashUtilSpec>
+          <StartupFile>"STARTUP\Freescale\Kinetis\startup_MKE02Z2.s" ("Freescale MKE02Z32xxx2 Startup Code")</StartupFile>
+          <FlashDriverDll>UL2CM3(-O207 -S0 -C0 -FO15 -FD20000000 -FC800 -FN2 -FF0MKE02Zxxx_P64KB -FS00 -FL010000 -FF1MKE02Zxxx_EE256B -FS110000000 -FL1100)</FlashDriverDll>
+          <DeviceId>6995</DeviceId>
+          <RegisterFile>MKE02Z2.h</RegisterFile>
+          <MemoryEnv></MemoryEnv>
+          <Cmp></Cmp>
+          <Asm></Asm>
+          <Linker></Linker>
+          <OHString></OHString>
+          <InfinionOptionDll></InfinionOptionDll>
+          <SLE66CMisc></SLE66CMisc>
+          <SLE66AMisc></SLE66AMisc>
+          <SLE66LinkerMisc></SLE66LinkerMisc>
+          <SFDFile>SFD\Freescale\Kinetis\MKE02Z2.sfr</SFDFile>
+          <UseEnv>0</UseEnv>
+          <BinPath></BinPath>
+          <IncludePath></IncludePath>
+          <LibPath></LibPath>
+          <RegisterFilePath>Freescale\Kinetis\</RegisterFilePath>
+          <DBRegisterFilePath>Freescale\Kinetis\</DBRegisterFilePath>
+          <TargetStatus>
+            <Error>0</Error>
+            <ExitCodeStop>0</ExitCodeStop>
+            <ButtonStop>0</ButtonStop>
+            <NotGenerated>0</NotGenerated>
+            <InvalidFlash>1</InvalidFlash>
+          </TargetStatus>
+          <OutputDirectory>.\build\</OutputDirectory>
+          <OutputName>rt-thread-ke02</OutputName>
+          <CreateExecutable>1</CreateExecutable>
+          <CreateLib>0</CreateLib>
+          <CreateHexFile>1</CreateHexFile>
+          <DebugInformation>1</DebugInformation>
+          <BrowseInformation>1</BrowseInformation>
+          <ListingPath>.\build\</ListingPath>
+          <HexFormatSelection>1</HexFormatSelection>
+          <Merge32K>0</Merge32K>
+          <CreateBatchFile>1</CreateBatchFile>
+          <BeforeCompile>
+            <RunUserProg1>0</RunUserProg1>
+            <RunUserProg2>0</RunUserProg2>
+            <UserProg1Name></UserProg1Name>
+            <UserProg2Name></UserProg2Name>
+            <UserProg1Dos16Mode>0</UserProg1Dos16Mode>
+            <UserProg2Dos16Mode>0</UserProg2Dos16Mode>
+            <nStopU1X>0</nStopU1X>
+            <nStopU2X>0</nStopU2X>
+          </BeforeCompile>
+          <BeforeMake>
+            <RunUserProg1>0</RunUserProg1>
+            <RunUserProg2>0</RunUserProg2>
+            <UserProg1Name></UserProg1Name>
+            <UserProg2Name></UserProg2Name>
+            <UserProg1Dos16Mode>0</UserProg1Dos16Mode>
+            <UserProg2Dos16Mode>0</UserProg2Dos16Mode>
+          </BeforeMake>
+          <AfterMake>
+            <RunUserProg1>0</RunUserProg1>
+            <RunUserProg2>1</RunUserProg2>
+            <UserProg1Name>D:\Keil\ARM\ARMCC\BIN\fromelf.exe --bin rtthread-ke02.axf -o rtthread.bin</UserProg1Name>
+            <UserProg2Name>fromelf.exe --bin -o .\build\rtthread.bin .\build\rt-thread-ke02.axf</UserProg2Name>
+            <UserProg1Dos16Mode>0</UserProg1Dos16Mode>
+            <UserProg2Dos16Mode>0</UserProg2Dos16Mode>
+          </AfterMake>
+          <SelectedForBatchBuild>0</SelectedForBatchBuild>
+          <SVCSIdString></SVCSIdString>
+        </TargetCommonOption>
+        <CommonProperty>
+          <UseCPPCompiler>0</UseCPPCompiler>
+          <RVCTCodeConst>0</RVCTCodeConst>
+          <RVCTZI>0</RVCTZI>
+          <RVCTOtherData>0</RVCTOtherData>
+          <ModuleSelection>0</ModuleSelection>
+          <IncludeInBuild>1</IncludeInBuild>
+          <AlwaysBuild>0</AlwaysBuild>
+          <GenerateAssemblyFile>0</GenerateAssemblyFile>
+          <AssembleAssemblyFile>0</AssembleAssemblyFile>
+          <PublicsOnly>0</PublicsOnly>
+          <StopOnExitCode>3</StopOnExitCode>
+          <CustomArgument></CustomArgument>
+          <IncludeLibraryModules></IncludeLibraryModules>
+        </CommonProperty>
+        <DllOption>
+          <SimDllName>SARMCM3.DLL</SimDllName>
+          <SimDllArguments></SimDllArguments>
+          <SimDlgDll>DARMCM1.DLL</SimDlgDll>
+          <SimDlgDllArguments>-pCM0+</SimDlgDllArguments>
+          <TargetDllName>SARMCM3.DLL</TargetDllName>
+          <TargetDllArguments></TargetDllArguments>
+          <TargetDlgDll>TARMCM1.DLL</TargetDlgDll>
+          <TargetDlgDllArguments>-pCM0+</TargetDlgDllArguments>
+        </DllOption>
+        <DebugOption>
+          <OPTHX>
+            <HexSelection>1</HexSelection>
+            <HexRangeLowAddress>0</HexRangeLowAddress>
+            <HexRangeHighAddress>0</HexRangeHighAddress>
+            <HexOffset>0</HexOffset>
+            <Oh166RecLen>16</Oh166RecLen>
+          </OPTHX>
+          <Simulator>
+            <UseSimulator>0</UseSimulator>
+            <LoadApplicationAtStartup>1</LoadApplicationAtStartup>
+            <RunToMain>1</RunToMain>
+            <RestoreBreakpoints>1</RestoreBreakpoints>
+            <RestoreWatchpoints>1</RestoreWatchpoints>
+            <RestoreMemoryDisplay>1</RestoreMemoryDisplay>
+            <RestoreFunctions>1</RestoreFunctions>
+            <RestoreToolbox>1</RestoreToolbox>
+            <LimitSpeedToRealTime>0</LimitSpeedToRealTime>
+          </Simulator>
+          <Target>
+            <UseTarget>1</UseTarget>
+            <LoadApplicationAtStartup>1</LoadApplicationAtStartup>
+            <RunToMain>1</RunToMain>
+            <RestoreBreakpoints>1</RestoreBreakpoints>
+            <RestoreWatchpoints>1</RestoreWatchpoints>
+            <RestoreMemoryDisplay>1</RestoreMemoryDisplay>
+            <RestoreFunctions>0</RestoreFunctions>
+            <RestoreToolbox>1</RestoreToolbox>
+            <RestoreTracepoints>1</RestoreTracepoints>
+          </Target>
+          <RunDebugAfterBuild>0</RunDebugAfterBuild>
+          <TargetSelection>7</TargetSelection>
+          <SimDlls>
+            <CpuDll></CpuDll>
+            <CpuDllArguments></CpuDllArguments>
+            <PeripheralDll></PeripheralDll>
+            <PeripheralDllArguments></PeripheralDllArguments>
+            <InitializationFile></InitializationFile>
+          </SimDlls>
+          <TargetDlls>
+            <CpuDll></CpuDll>
+            <CpuDllArguments></CpuDllArguments>
+            <PeripheralDll></PeripheralDll>
+            <PeripheralDllArguments></PeripheralDllArguments>
+            <InitializationFile></InitializationFile>
+            <Driver>Segger\JL2CM3.dll</Driver>
+          </TargetDlls>
+        </DebugOption>
+        <Utilities>
+          <Flash1>
+            <UseTargetDll>1</UseTargetDll>
+            <UseExternalTool>0</UseExternalTool>
+            <RunIndependent>0</RunIndependent>
+            <UpdateFlashBeforeDebugging>1</UpdateFlashBeforeDebugging>
+            <Capability>1</Capability>
+            <DriverSelection>4099</DriverSelection>
+          </Flash1>
+          <bUseTDR>0</bUseTDR>
+          <Flash2>Segger\JL2CM3.dll</Flash2>
+          <Flash3>"" ()</Flash3>
+          <Flash4></Flash4>
+        </Utilities>
+        <TargetArmAds>
+          <ArmAdsMisc>
+            <GenerateListings>0</GenerateListings>
+            <asHll>1</asHll>
+            <asAsm>1</asAsm>
+            <asMacX>1</asMacX>
+            <asSyms>1</asSyms>
+            <asFals>1</asFals>
+            <asDbgD>1</asDbgD>
+            <asForm>1</asForm>
+            <ldLst>0</ldLst>
+            <ldmm>1</ldmm>
+            <ldXref>1</ldXref>
+            <BigEnd>0</BigEnd>
+            <AdsALst>1</AdsALst>
+            <AdsACrf>1</AdsACrf>
+            <AdsANop>0</AdsANop>
+            <AdsANot>0</AdsANot>
+            <AdsLLst>1</AdsLLst>
+            <AdsLmap>1</AdsLmap>
+            <AdsLcgr>1</AdsLcgr>
+            <AdsLsym>1</AdsLsym>
+            <AdsLszi>1</AdsLszi>
+            <AdsLtoi>1</AdsLtoi>
+            <AdsLsun>1</AdsLsun>
+            <AdsLven>1</AdsLven>
+            <AdsLsxf>1</AdsLsxf>
+            <RvctClst>0</RvctClst>
+            <GenPPlst>0</GenPPlst>
+            <AdsCpuType>"Cortex-M0+"</AdsCpuType>
+            <RvctDeviceName></RvctDeviceName>
+            <mOS>0</mOS>
+            <uocRom>0</uocRom>
+            <uocRam>0</uocRam>
+            <hadIROM>1</hadIROM>
+            <hadIRAM>1</hadIRAM>
+            <hadXRAM>0</hadXRAM>
+            <uocXRam>0</uocXRam>
+            <RvdsVP>0</RvdsVP>
+            <hadIRAM2>1</hadIRAM2>
+            <hadIROM2>0</hadIROM2>
+            <StupSel>8</StupSel>
+            <useUlib>1</useUlib>
+            <EndSel>0</EndSel>
+            <uLtcg>0</uLtcg>
+            <RoSelD>3</RoSelD>
+            <RwSelD>3</RwSelD>
+            <CodeSel>0</CodeSel>
+            <OptFeed>0</OptFeed>
+            <NoZi1>0</NoZi1>
+            <NoZi2>0</NoZi2>
+            <NoZi3>0</NoZi3>
+            <NoZi4>0</NoZi4>
+            <NoZi5>0</NoZi5>
+            <Ro1Chk>0</Ro1Chk>
+            <Ro2Chk>0</Ro2Chk>
+            <Ro3Chk>0</Ro3Chk>
+            <Ir1Chk>1</Ir1Chk>
+            <Ir2Chk>0</Ir2Chk>
+            <Ra1Chk>0</Ra1Chk>
+            <Ra2Chk>0</Ra2Chk>
+            <Ra3Chk>0</Ra3Chk>
+            <Im1Chk>1</Im1Chk>
+            <Im2Chk>1</Im2Chk>
+            <OnChipMemories>
+              <Ocm1>
+                <Type>0</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </Ocm1>
+              <Ocm2>
+                <Type>0</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </Ocm2>
+              <Ocm3>
+                <Type>0</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </Ocm3>
+              <Ocm4>
+                <Type>0</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </Ocm4>
+              <Ocm5>
+                <Type>0</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </Ocm5>
+              <Ocm6>
+                <Type>0</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </Ocm6>
+              <IRAM>
+                <Type>0</Type>
+                <StartAddress>0x1ffffc00</StartAddress>
+                <Size>0x400</Size>
+              </IRAM>
+              <IROM>
+                <Type>1</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x10000</Size>
+              </IROM>
+              <XRAM>
+                <Type>0</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </XRAM>
+              <OCR_RVCT1>
+                <Type>1</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </OCR_RVCT1>
+              <OCR_RVCT2>
+                <Type>1</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </OCR_RVCT2>
+              <OCR_RVCT3>
+                <Type>1</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </OCR_RVCT3>
+              <OCR_RVCT4>
+                <Type>1</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x10000</Size>
+              </OCR_RVCT4>
+              <OCR_RVCT5>
+                <Type>1</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </OCR_RVCT5>
+              <OCR_RVCT6>
+                <Type>0</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </OCR_RVCT6>
+              <OCR_RVCT7>
+                <Type>0</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </OCR_RVCT7>
+              <OCR_RVCT8>
+                <Type>0</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </OCR_RVCT8>
+              <OCR_RVCT9>
+                <Type>0</Type>
+                <StartAddress>0x1ffffc00</StartAddress>
+                <Size>0x400</Size>
+              </OCR_RVCT9>
+              <OCR_RVCT10>
+                <Type>0</Type>
+                <StartAddress>0x20000000</StartAddress>
+                <Size>0xc00</Size>
+              </OCR_RVCT10>
+            </OnChipMemories>
+            <RvctStartVector></RvctStartVector>
+          </ArmAdsMisc>
+          <Cads>
+            <interw>1</interw>
+            <Optim>2</Optim>
+            <oTime>0</oTime>
+            <SplitLS>0</SplitLS>
+            <OneElfS>0</OneElfS>
+            <Strict>0</Strict>
+            <EnumInt>0</EnumInt>
+            <PlainCh>0</PlainCh>
+            <Ropi>0</Ropi>
+            <Rwpi>0</Rwpi>
+            <wLevel>0</wLevel>
+            <uThumb>0</uThumb>
+            <uSurpInc>0</uSurpInc>
+            <VariousControls>
+              <MiscControls></MiscControls>
+              <Define>KEIL FRDM_KE02  CPU_KE02 CMSIS</Define>
+              <Undefine></Undefine>
+              <IncludePath>applications;.;board;device;device\lib\inc;..\..\include;..\..\libcpu\arm\cortex-m0;..\..\libcpu\arm\common;..\..\components\drivers\include;..\..\components\drivers\include</IncludePath>
+            </VariousControls>
+          </Cads>
+          <Aads>
+            <interw>1</interw>
+            <Ropi>0</Ropi>
+            <Rwpi>0</Rwpi>
+            <thumb>0</thumb>
+            <SplitLS>0</SplitLS>
+            <SwStkChk>0</SwStkChk>
+            <NoWarn>0</NoWarn>
+            <uSurpInc>0</uSurpInc>
+            <VariousControls>
+              <MiscControls></MiscControls>
+              <Define></Define>
+              <Undefine></Undefine>
+              <IncludePath></IncludePath>
+            </VariousControls>
+          </Aads>
+          <LDads>
+            <umfTarg>1</umfTarg>
+            <Ropi>0</Ropi>
+            <Rwpi>0</Rwpi>
+            <noStLib>0</noStLib>
+            <RepFail>1</RepFail>
+            <useFile>0</useFile>
+            <TextAddressRange>0x00000000</TextAddressRange>
+            <DataAddressRange>0x1FFF0000</DataAddressRange>
+            <ScatterFile></ScatterFile>
+            <IncludeLibs></IncludeLibs>
+            <IncludeLibsPath></IncludeLibsPath>
+            <Misc></Misc>
+            <LinkerInputFile></LinkerInputFile>
+            <DisabledWarnings></DisabledWarnings>
+          </LDads>
+        </TargetArmAds>
+      </TargetOption>
+      <Groups>
+        <Group>
+          <GroupName>Applications</GroupName>
+          <Files>
+            <File>
+              <FileName>application.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>applications\application.c</FilePath>
+            </File>
+            <File>
+              <FileName>startup.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>applications\startup.c</FilePath>
+            </File>
+          </Files>
+        </Group>
+        <Group>
+          <GroupName>Board</GroupName>
+          <Files>
+            <File>
+              <FileName>board.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>board\board.c</FilePath>
+            </File>
+            <File>
+              <FileName>drv_uart.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>board\drv_uart.c</FilePath>
+            </File>
+            <File>
+              <FileName>led.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>board\led.c</FilePath>
+            </File>
+          </Files>
+        </Group>
+        <Group>
+          <GroupName>Device</GroupName>
+          <Files>
+            <File>
+              <FileName>acmp.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>device\lib\drivers\acmp.c</FilePath>
+            </File>
+            <File>
+              <FileName>adc.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>device\lib\drivers\adc.c</FilePath>
+            </File>
+            <File>
+              <FileName>arm_cm0.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>device\lib\drivers\arm_cm0.c</FilePath>
+            </File>
+            <File>
+              <FileName>crc.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>device\lib\drivers\crc.c</FilePath>
+            </File>
+            <File>
+              <FileName>flash.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>device\lib\drivers\flash.c</FilePath>
+            </File>
+            <File>
+              <FileName>ftm.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>device\lib\drivers\ftm.c</FilePath>
+            </File>
+            <File>
+              <FileName>gpio.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>device\lib\drivers\gpio.c</FilePath>
+            </File>
+            <File>
+              <FileName>i2c.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>device\lib\drivers\i2c.c</FilePath>
+            </File>
+            <File>
+              <FileName>ics.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>device\lib\drivers\ics.c</FilePath>
+            </File>
+            <File>
+              <FileName>kbi.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>device\lib\drivers\kbi.c</FilePath>
+            </File>
+            <File>
+              <FileName>memtest.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>device\lib\drivers\memtest.c</FilePath>
+            </File>
+            <File>
+              <FileName>pit.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>device\lib\drivers\pit.c</FilePath>
+            </File>
+            <File>
+              <FileName>pmc.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>device\lib\drivers\pmc.c</FilePath>
+            </File>
+            <File>
+              <FileName>queue.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>device\lib\drivers\queue.c</FilePath>
+            </File>
+            <File>
+              <FileName>rtc.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>device\lib\drivers\rtc.c</FilePath>
+            </File>
+            <File>
+              <FileName>sim.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>device\lib\drivers\sim.c</FilePath>
+            </File>
+            <File>
+              <FileName>spi.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>device\lib\drivers\spi.c</FilePath>
+            </File>
+            <File>
+              <FileName>start.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>device\lib\drivers\start.c</FilePath>
+            </File>
+            <File>
+              <FileName>drivers_startup.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>device\lib\drivers\startup.c</FilePath>
+            </File>
+            <File>
+              <FileName>sysinit.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>device\lib\drivers\sysinit.c</FilePath>
+            </File>
+            <File>
+              <FileName>systick.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>device\lib\drivers\systick.c</FilePath>
+            </File>
+            <File>
+              <FileName>uart.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>device\lib\drivers\uart.c</FilePath>
+            </File>
+            <File>
+              <FileName>wdog.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>device\lib\drivers\wdog.c</FilePath>
+            </File>
+            <File>
+              <FileName>startup_MKE02Z2.s</FileName>
+              <FileType>2</FileType>
+              <FilePath>device\startup_keil\startup_MKE02Z2.s</FilePath>
+            </File>
+          </Files>
+        </Group>
+        <Group>
+          <GroupName>Kernel</GroupName>
+          <Files>
+            <File>
+              <FileName>clock.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>..\..\src\clock.c</FilePath>
+            </File>
+            <File>
+              <FileName>device.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>..\..\src\device.c</FilePath>
+            </File>
+            <File>
+              <FileName>idle.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>..\..\src\idle.c</FilePath>
+            </File>
+            <File>
+              <FileName>ipc.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>..\..\src\ipc.c</FilePath>
+            </File>
+            <File>
+              <FileName>irq.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>..\..\src\irq.c</FilePath>
+            </File>
+            <File>
+              <FileName>kservice.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>..\..\src\kservice.c</FilePath>
+            </File>
+            <File>
+              <FileName>mem.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>..\..\src\mem.c</FilePath>
+            </File>
+            <File>
+              <FileName>mempool.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>..\..\src\mempool.c</FilePath>
+            </File>
+            <File>
+              <FileName>object.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>..\..\src\object.c</FilePath>
+            </File>
+            <File>
+              <FileName>scheduler.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>..\..\src\scheduler.c</FilePath>
+            </File>
+            <File>
+              <FileName>thread.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>..\..\src\thread.c</FilePath>
+            </File>
+            <File>
+              <FileName>timer.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>..\..\src\timer.c</FilePath>
+            </File>
+          </Files>
+        </Group>
+        <Group>
+          <GroupName>CORTEX-M0</GroupName>
+          <Files>
+            <File>
+              <FileName>cpuport.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>..\..\libcpu\arm\cortex-m0\cpuport.c</FilePath>
+            </File>
+            <File>
+              <FileName>context_rvds.S</FileName>
+              <FileType>2</FileType>
+              <FilePath>..\..\libcpu\arm\cortex-m0\context_rvds.S</FilePath>
+            </File>
+            <File>
+              <FileName>backtrace.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>..\..\libcpu\arm\common\backtrace.c</FilePath>
+            </File>
+            <File>
+              <FileName>div0.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>..\..\libcpu\arm\common\div0.c</FilePath>
+            </File>
+            <File>
+              <FileName>showmem.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>..\..\libcpu\arm\common\showmem.c</FilePath>
+            </File>
+          </Files>
+        </Group>
+        <Group>
+          <GroupName>DeviceDrivers</GroupName>
+          <Files>
+            <File>
+              <FileName>serial.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>..\..\components\drivers\serial\serial.c</FilePath>
+            </File>
+            <File>
+              <FileName>completion.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>..\..\components\drivers\src\completion.c</FilePath>
+            </File>
+            <File>
+              <FileName>dataqueue.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>..\..\components\drivers\src\dataqueue.c</FilePath>
+            </File>
+            <File>
+              <FileName>pipe.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>..\..\components\drivers\src\pipe.c</FilePath>
+            </File>
+            <File>
+              <FileName>portal.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>..\..\components\drivers\src\portal.c</FilePath>
+            </File>
+            <File>
+              <FileName>ringbuffer.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>..\..\components\drivers\src\ringbuffer.c</FilePath>
+            </File>
+            <File>
+              <FileName>workqueue.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>..\..\components\drivers\src\workqueue.c</FilePath>
+            </File>
+          </Files>
+        </Group>
+      </Groups>
+    </Target>
+  </Targets>
+
+</Project>
diff --git a/bsp/frdm-ke02/rtconfig.h b/bsp/frdm-ke02/rtconfig.h
new file mode 100755
index 0000000..22c2720
--- /dev/null
+++ b/bsp/frdm-ke02/rtconfig.h
@@ -0,0 +1,181 @@
+/* RT-Thread config file */
+#ifndef __RTTHREAD_CFG_H__
+#define __RTTHREAD_CFG_H__
+
+/* RT_NAME_MAX*/
+#define RT_NAME_MAX	   8
+
+/* RT_ALIGN_SIZE*/
+#define RT_ALIGN_SIZE	8
+
+/* PRIORITY_MAX */
+#define RT_THREAD_PRIORITY_MAX	32
+
+/* Tick per Second */
+#define RT_TICK_PER_SECOND	100
+
+/* SECTION: RT_DEBUG */
+/* Thread Debug */
+#define RT_DEBUG
+
+#define RT_USING_OVERFLOW_CHECK
+
+/* Using Hook */
+#define RT_USING_HOOK
+
+#define IDLE_THREAD_STACK_SIZE     1024
+
+/* Using Software Timer */
+/* #define RT_USING_TIMER_SOFT */
+#define RT_TIMER_THREAD_PRIO		4
+#define RT_TIMER_THREAD_STACK_SIZE	512
+#define RT_TIMER_TICK_PER_SECOND	10
+
+/* SECTION: IPC */
+/* Using Semaphore*/
+#define RT_USING_SEMAPHORE
+
+/* Using Mutex */
+#define RT_USING_MUTEX
+
+/* Using Event */
+#define RT_USING_EVENT
+
+/* Using MailBox */
+#define RT_USING_MAILBOX
+
+/* Using Message Queue */
+#define RT_USING_MESSAGEQUEUE
+
+/* SECTION: Memory Management */
+/* Using Memory Pool Management*/
+#define RT_USING_MEMPOOL
+
+/* Using Dynamic Heap Management */
+#define RT_USING_HEAP
+
+/* Using Small MM */
+#define RT_USING_SMALL_MEM
+
+/* "Using Device Driver Framework" default="true" */
+#define RT_USING_DEVICE
+/* Using IPC in Device Driver Framework" default="true" */
+#define RT_USING_DEVICE_IPC
+/* Using Serial Device Driver Framework" default="true" */
+#define RT_USING_SERIAL
+
+
+/* SECTION: Console options */
+#define RT_USING_CONSOLE
+/* the buffer size of console*/
+#define RT_CONSOLEBUF_SIZE	128
+
+/* SECTION: finsh, a C-Express shell */
+/*#define RT_USING_FINSH*/
+/* Using symbol table */
+#define FINSH_USING_SYMTAB
+#define FINSH_USING_DESCRIPTION
+
+/* SECTION: device filesystem */
+/*#define RT_USING_DFS*/
+//#define RT_USING_DFS_ELMFAT
+#define RT_DFS_ELM_WORD_ACCESS
+/* Reentrancy (thread safe) of the FatFs module.  */
+#define RT_DFS_ELM_REENTRANT
+/* Number of volumes (logical drives) to be used. */
+#define RT_DFS_ELM_DRIVES			2
+/* #define RT_DFS_ELM_USE_LFN			1 */
+#define RT_DFS_ELM_MAX_LFN			255
+/* Maximum sector size to be handled. */
+#define RT_DFS_ELM_MAX_SECTOR_SIZE  512
+
+#define RT_USING_DFS_ROMFS
+/*#define RT_USING_MTD_NAND
+#define RT_USING_DFS_UFFS
+#define RT_CONFIG_UFFS_ECC_MODE UFFS_ECC_SOFT
+#define RT_UFFS_DEVICE_MAX	        5
+*/
+/* the max number of mounted filesystem */
+#define DFS_FILESYSTEMS_MAX			2
+/* the max number of opened files 		*/
+#define DFS_FD_MAX					4
+
+/* SECTION: lwip, a lighwight TCP/IP protocol stack */
+/* #define RT_USING_LWIP */
+/* LwIP uses RT-Thread Memory Management */
+#define RT_LWIP_USING_RT_MEM
+/* Enable ICMP protocol*/
+#define RT_LWIP_ICMP
+/* Enable UDP protocol*/
+#define RT_LWIP_UDP
+/* Enable TCP protocol*/
+#define RT_LWIP_TCP
+/* Enable DNS */
+#define RT_LWIP_DNS
+
+/* the number of simulatenously active TCP connections*/
+#define RT_LWIP_TCP_PCB_NUM	5
+
+/* ip address of target*/
+#define RT_LWIP_IPADDR0	192
+#define RT_LWIP_IPADDR1	168
+#define RT_LWIP_IPADDR2	1
+#define RT_LWIP_IPADDR3	201
+
+/* gateway address of target*/
+#define RT_LWIP_GWADDR0	192
+#define RT_LWIP_GWADDR1	168
+#define RT_LWIP_GWADDR2	1
+#define RT_LWIP_GWADDR3	1
+
+/* mask address of target*/
+#define RT_LWIP_MSKADDR0	255
+#define RT_LWIP_MSKADDR1	255
+#define RT_LWIP_MSKADDR2	255
+#define RT_LWIP_MSKADDR3	0
+
+/* tcp thread options */
+#define RT_LWIP_TCPTHREAD_PRIORITY		12
+#define RT_LWIP_TCPTHREAD_MBOX_SIZE		4
+#define RT_LWIP_TCPTHREAD_STACKSIZE		1024
+
+/* ethernet if thread options */
+#define RT_LWIP_ETHTHREAD_PRIORITY		15
+#define RT_LWIP_ETHTHREAD_MBOX_SIZE		4
+#define RT_LWIP_ETHTHREAD_STACKSIZE		512
+
+/* TCP sender buffer space */
+#define RT_LWIP_TCP_SND_BUF	8192
+/* TCP receive window. */
+#define RT_LWIP_TCP_WND		8192
+
+#define CHECKSUM_CHECK_TCP              0
+#define CHECKSUM_CHECK_IP               0
+#define CHECKSUM_CHECK_UDP              0
+
+#define CHECKSUM_GEN_TCP                0
+#define CHECKSUM_GEN_IP                 0
+#define CHECKSUM_GEN_UDP                0
+
+/*#define RT_USING_RTGUI*/
+
+/* name length of RTGUI object */
+#define RTGUI_NAME_MAX		12
+/* support 16 weight font */
+#define RTGUI_USING_FONT16
+/* support Chinese font */
+#define RTGUI_USING_FONTHZ
+/* use DFS as file interface */
+#define RTGUI_USING_DFS_FILERW
+/* use font file as Chinese font */
+#define RTGUI_USING_HZ_FILE
+/* use Chinese bitmap font */
+#define RTGUI_USING_HZ_BMP
+/* use small size in RTGUI */
+#define RTGUI_USING_SMALL_SIZE
+/* use mouse cursor */
+/* #define RTGUI_USING_MOUSE_CURSOR */
+/* default font size in RTGUI */
+#define RTGUI_DEFAULT_FONT_SIZE	16
+
+#endif
diff --git a/bsp/frdm-ke02/rtconfig.py b/bsp/frdm-ke02/rtconfig.py
new file mode 100755
index 0000000..e7fa8eb
--- /dev/null
+++ b/bsp/frdm-ke02/rtconfig.py
@@ -0,0 +1,82 @@
+import os
+
+# toolchains options
+ARCH='arm'
+CPU='cortex-m0'
+CROSS_TOOL='gcc'
+
+if os.getenv('RTT_CC'):
+	CROSS_TOOL = os.getenv('RTT_CC')
+
+# cross_tool provides the cross compiler
+# EXEC_PATH is the compiler execute path, for example, CodeSourcery, Keil MDK, IAR
+if  CROSS_TOOL == 'gcc':
+	PLATFORM 	= 'gcc'
+	EXEC_PATH 	= r'C:/Program Files/CodeSourcery/Sourcery_CodeBench_Lite_for_ARM_EABI/bin'
+elif CROSS_TOOL == 'keil':
+	PLATFORM 	= 'armcc'
+	EXEC_PATH 	= r'D:/Keil'
+elif CROSS_TOOL == 'iar':
+    print '================ERROR============================'
+    print 'Not support iar yet!'
+    print '================================================='
+    exit(0)
+
+if os.getenv('RTT_EXEC_PATH'):
+	EXEC_PATH = os.getenv('RTT_EXEC_PATH')
+
+BUILD = 'debug1'
+
+if PLATFORM == 'gcc':
+    # toolchains
+    PREFIX = 'arm-none-eabi-'
+    CC = PREFIX + 'gcc'
+    AS = PREFIX + 'gcc'
+    AR = PREFIX + 'ar'
+    LINK = PREFIX + 'gcc'
+    TARGET_EXT = 'axf'
+    SIZE = PREFIX + 'size'
+    OBJDUMP = PREFIX + 'objdump'
+    OBJCPY = PREFIX + 'objcopy'
+
+    DEVICE = ' -mcpu=cortex-m0 -mthumb -mfloat-abi=soft -ffunction-sections -fdata-sections'
+    CFLAGS = DEVICE + ' -g -Wall -D__ASSEMBLY__ -DKEIL -DFRDM_KE02 -DCPU_KE02 -DCMSIS'
+    AFLAGS = ' -c' + DEVICE + ' -x assembler-with-cpp -Wa,-mimplicit-it=thumb '
+    LFLAGS = DEVICE + ' -lm -lgcc -lc' + '  -nostartfiles -Wl,--gc-sections,-Map=rtthread-ke02.map,-cref,-u,Reset_Handler -T ke02.ld'
+
+    CPATH = ''
+    LPATH = ''
+
+    if BUILD == 'debug':
+        CFLAGS += ' -O0 -gdwarf-2'
+        AFLAGS += ' -gdwarf-2'
+    else:
+        CFLAGS += ' -O2'
+
+    POST_ACTION = OBJCPY + ' -O binary $TARGET ke02.bin\n' + SIZE + ' $TARGET \n'
+
+elif PLATFORM == 'armcc':
+    # toolchains
+    CC = 'armcc'
+    AS = 'armasm'
+    AR = 'armar'
+    LINK = 'armlink'
+    TARGET_EXT = 'axf'
+
+    DEVICE = ' --device DARMSTM'
+    CFLAGS = DEVICE + ' --apcs=interwork  -D__ASSEMBLY__ -DKEIL -DFRDM_KE02 -DCPU_KE02 -DCMSIS'
+    AFLAGS = DEVICE
+    LFLAGS = DEVICE + ' --info sizes --info totals --info unused --info veneers --list rtthread-k20d.map --scatter ke02.sct'
+
+    CFLAGS += ' -I' + EXEC_PATH + '/ARM/RV31/INC'
+    LFLAGS += ' --libpath ' + EXEC_PATH + '/ARM/RV31/LIB'
+
+    EXEC_PATH += '/arm/bin40/'
+
+    if BUILD == 'debug':
+        CFLAGS += ' -g -O0'
+        AFLAGS += ' -g'
+    else:
+        CFLAGS += ' -O2'
+
+    POST_ACTION = 'fromelf --bin $TARGET --output rtthread.bin \nfromelf -z $TARGET'
diff --git a/bsp/frdm-ke02/template.uvproj b/bsp/frdm-ke02/template.uvproj
new file mode 100755
index 0000000..a806613
--- /dev/null
+++ b/bsp/frdm-ke02/template.uvproj
@@ -0,0 +1,394 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
+<Project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="project_proj.xsd">
+
+  <SchemaVersion>1.1</SchemaVersion>
+
+  <Header>### uVision Project, (C) Keil Software</Header>
+
+  <Targets>
+    <Target>
+      <TargetName>RT-Thread</TargetName>
+      <ToolsetNumber>0x4</ToolsetNumber>
+      <ToolsetName>ARM-ADS</ToolsetName>
+      <TargetOption>
+        <TargetCommonOption>
+          <Device>MK20DX256xxx7</Device>
+          <Vendor>Freescale Semiconductor</Vendor>
+          <Cpu>IRAM(0x1FFF8000-0x1FFFFFFF) IRAM2(0x20000000-0x20007FFF) IROM(0x0-0x3FFFF) IROM2(0x10000000-0x10007FFF) CLOCK(12000000) CPUTYPE("Cortex-M4") ELITTLE</Cpu>
+          <FlashUtilSpec></FlashUtilSpec>
+          <StartupFile>"STARTUP\Freescale\Kinetis\startup_MK20D7.s" ("Freescale MK20Xxxxxxx7 Startup Code")</StartupFile>
+          <FlashDriverDll>ULP2CM3(-O2510 -S0 -C0 -FO15 -FD20000000 -FC800 -FN2 -FF0MK_P256 -FS00 -FL040000 -FF1MK_D32_72MHZ -FS110000000 -FL108000)</FlashDriverDll>
+          <DeviceId>6298</DeviceId>
+          <RegisterFile>MK20D7.H</RegisterFile>
+          <MemoryEnv></MemoryEnv>
+          <Cmp></Cmp>
+          <Asm></Asm>
+          <Linker></Linker>
+          <OHString></OHString>
+          <InfinionOptionDll></InfinionOptionDll>
+          <SLE66CMisc></SLE66CMisc>
+          <SLE66AMisc></SLE66AMisc>
+          <SLE66LinkerMisc></SLE66LinkerMisc>
+          <SFDFile>SFD\Freescale\Kinetis\MK20D7.sfr</SFDFile>
+          <UseEnv>0</UseEnv>
+          <BinPath></BinPath>
+          <IncludePath></IncludePath>
+          <LibPath></LibPath>
+          <RegisterFilePath>Freescale\Kinetis\</RegisterFilePath>
+          <DBRegisterFilePath>Freescale\Kinetis\</DBRegisterFilePath>
+          <TargetStatus>
+            <Error>0</Error>
+            <ExitCodeStop>0</ExitCodeStop>
+            <ButtonStop>0</ButtonStop>
+            <NotGenerated>0</NotGenerated>
+            <InvalidFlash>1</InvalidFlash>
+          </TargetStatus>
+          <OutputDirectory>.\build\</OutputDirectory>
+          <OutputName>rt-thread-k20d</OutputName>
+          <CreateExecutable>1</CreateExecutable>
+          <CreateLib>0</CreateLib>
+          <CreateHexFile>1</CreateHexFile>
+          <DebugInformation>1</DebugInformation>
+          <BrowseInformation>1</BrowseInformation>
+          <ListingPath>.\build\</ListingPath>
+          <HexFormatSelection>1</HexFormatSelection>
+          <Merge32K>0</Merge32K>
+          <CreateBatchFile>0</CreateBatchFile>
+          <BeforeCompile>
+            <RunUserProg1>0</RunUserProg1>
+            <RunUserProg2>0</RunUserProg2>
+            <UserProg1Name></UserProg1Name>
+            <UserProg2Name></UserProg2Name>
+            <UserProg1Dos16Mode>0</UserProg1Dos16Mode>
+            <UserProg2Dos16Mode>0</UserProg2Dos16Mode>
+            <nStopU1X>0</nStopU1X>
+            <nStopU2X>0</nStopU2X>
+          </BeforeCompile>
+          <BeforeMake>
+            <RunUserProg1>0</RunUserProg1>
+            <RunUserProg2>0</RunUserProg2>
+            <UserProg1Name></UserProg1Name>
+            <UserProg2Name></UserProg2Name>
+            <UserProg1Dos16Mode>0</UserProg1Dos16Mode>
+            <UserProg2Dos16Mode>0</UserProg2Dos16Mode>
+          </BeforeMake>
+          <AfterMake>
+            <RunUserProg1>0</RunUserProg1>
+            <RunUserProg2>1</RunUserProg2>
+            <UserProg1Name>D:\Keil\ARM\ARMCC\BIN\fromelf.exe --bin rtthread-k20d.axf -o rtthread.bin</UserProg1Name>
+            <UserProg2Name>fromelf.exe --bin -o .\build\rtthread.bin .\build\rt-thread-k20d.axf</UserProg2Name>
+            <UserProg1Dos16Mode>0</UserProg1Dos16Mode>
+            <UserProg2Dos16Mode>0</UserProg2Dos16Mode>
+          </AfterMake>
+          <SelectedForBatchBuild>0</SelectedForBatchBuild>
+          <SVCSIdString></SVCSIdString>
+        </TargetCommonOption>
+        <CommonProperty>
+          <UseCPPCompiler>0</UseCPPCompiler>
+          <RVCTCodeConst>0</RVCTCodeConst>
+          <RVCTZI>0</RVCTZI>
+          <RVCTOtherData>0</RVCTOtherData>
+          <ModuleSelection>0</ModuleSelection>
+          <IncludeInBuild>1</IncludeInBuild>
+          <AlwaysBuild>0</AlwaysBuild>
+          <GenerateAssemblyFile>0</GenerateAssemblyFile>
+          <AssembleAssemblyFile>0</AssembleAssemblyFile>
+          <PublicsOnly>0</PublicsOnly>
+          <StopOnExitCode>3</StopOnExitCode>
+          <CustomArgument></CustomArgument>
+          <IncludeLibraryModules></IncludeLibraryModules>
+        </CommonProperty>
+        <DllOption>
+          <SimDllName>SARMCM3.DLL</SimDllName>
+          <SimDllArguments></SimDllArguments>
+          <SimDlgDll>DCM.DLL</SimDlgDll>
+          <SimDlgDllArguments>-pCM4</SimDlgDllArguments>
+          <TargetDllName>SARMCM3.DLL</TargetDllName>
+          <TargetDllArguments></TargetDllArguments>
+          <TargetDlgDll>TCM.DLL</TargetDlgDll>
+          <TargetDlgDllArguments>-pCM4</TargetDlgDllArguments>
+        </DllOption>
+        <DebugOption>
+          <OPTHX>
+            <HexSelection>1</HexSelection>
+            <HexRangeLowAddress>0</HexRangeLowAddress>
+            <HexRangeHighAddress>0</HexRangeHighAddress>
+            <HexOffset>0</HexOffset>
+            <Oh166RecLen>16</Oh166RecLen>
+          </OPTHX>
+          <Simulator>
+            <UseSimulator>0</UseSimulator>
+            <LoadApplicationAtStartup>1</LoadApplicationAtStartup>
+            <RunToMain>1</RunToMain>
+            <RestoreBreakpoints>1</RestoreBreakpoints>
+            <RestoreWatchpoints>1</RestoreWatchpoints>
+            <RestoreMemoryDisplay>1</RestoreMemoryDisplay>
+            <RestoreFunctions>1</RestoreFunctions>
+            <RestoreToolbox>1</RestoreToolbox>
+            <LimitSpeedToRealTime>0</LimitSpeedToRealTime>
+          </Simulator>
+          <Target>
+            <UseTarget>1</UseTarget>
+            <LoadApplicationAtStartup>1</LoadApplicationAtStartup>
+            <RunToMain>1</RunToMain>
+            <RestoreBreakpoints>1</RestoreBreakpoints>
+            <RestoreWatchpoints>1</RestoreWatchpoints>
+            <RestoreMemoryDisplay>1</RestoreMemoryDisplay>
+            <RestoreFunctions>0</RestoreFunctions>
+            <RestoreToolbox>1</RestoreToolbox>
+            <RestoreTracepoints>1</RestoreTracepoints>
+          </Target>
+          <RunDebugAfterBuild>0</RunDebugAfterBuild>
+          <TargetSelection>14</TargetSelection>
+          <SimDlls>
+            <CpuDll></CpuDll>
+            <CpuDllArguments></CpuDllArguments>
+            <PeripheralDll></PeripheralDll>
+            <PeripheralDllArguments></PeripheralDllArguments>
+            <InitializationFile></InitializationFile>
+          </SimDlls>
+          <TargetDlls>
+            <CpuDll></CpuDll>
+            <CpuDllArguments></CpuDllArguments>
+            <PeripheralDll></PeripheralDll>
+            <PeripheralDllArguments></PeripheralDllArguments>
+            <InitializationFile></InitializationFile>
+            <Driver>BIN\CMSIS_AGDI.dll</Driver>
+          </TargetDlls>
+        </DebugOption>
+        <Utilities>
+          <Flash1>
+            <UseTargetDll>1</UseTargetDll>
+            <UseExternalTool>0</UseExternalTool>
+            <RunIndependent>0</RunIndependent>
+            <UpdateFlashBeforeDebugging>1</UpdateFlashBeforeDebugging>
+            <Capability>1</Capability>
+            <DriverSelection>4100</DriverSelection>
+          </Flash1>
+          <bUseTDR>1</bUseTDR>
+          <Flash2>BIN\ULP2CM3.DLL</Flash2>
+          <Flash3>"" ()</Flash3>
+          <Flash4></Flash4>
+        </Utilities>
+        <TargetArmAds>
+          <ArmAdsMisc>
+            <GenerateListings>0</GenerateListings>
+            <asHll>1</asHll>
+            <asAsm>1</asAsm>
+            <asMacX>1</asMacX>
+            <asSyms>1</asSyms>
+            <asFals>1</asFals>
+            <asDbgD>1</asDbgD>
+            <asForm>1</asForm>
+            <ldLst>0</ldLst>
+            <ldmm>1</ldmm>
+            <ldXref>1</ldXref>
+            <BigEnd>0</BigEnd>
+            <AdsALst>1</AdsALst>
+            <AdsACrf>1</AdsACrf>
+            <AdsANop>0</AdsANop>
+            <AdsANot>0</AdsANot>
+            <AdsLLst>1</AdsLLst>
+            <AdsLmap>1</AdsLmap>
+            <AdsLcgr>1</AdsLcgr>
+            <AdsLsym>1</AdsLsym>
+            <AdsLszi>1</AdsLszi>
+            <AdsLtoi>1</AdsLtoi>
+            <AdsLsun>1</AdsLsun>
+            <AdsLven>1</AdsLven>
+            <AdsLsxf>1</AdsLsxf>
+            <RvctClst>0</RvctClst>
+            <GenPPlst>0</GenPPlst>
+            <AdsCpuType>"Cortex-M4"</AdsCpuType>
+            <RvctDeviceName></RvctDeviceName>
+            <mOS>0</mOS>
+            <uocRom>0</uocRom>
+            <uocRam>0</uocRam>
+            <hadIROM>1</hadIROM>
+            <hadIRAM>1</hadIRAM>
+            <hadXRAM>0</hadXRAM>
+            <uocXRam>0</uocXRam>
+            <RvdsVP>0</RvdsVP>
+            <hadIRAM2>1</hadIRAM2>
+            <hadIROM2>1</hadIROM2>
+            <StupSel>8</StupSel>
+            <useUlib>0</useUlib>
+            <EndSel>0</EndSel>
+            <uLtcg>0</uLtcg>
+            <RoSelD>3</RoSelD>
+            <RwSelD>3</RwSelD>
+            <CodeSel>0</CodeSel>
+            <OptFeed>0</OptFeed>
+            <NoZi1>0</NoZi1>
+            <NoZi2>0</NoZi2>
+            <NoZi3>0</NoZi3>
+            <NoZi4>0</NoZi4>
+            <NoZi5>0</NoZi5>
+            <Ro1Chk>0</Ro1Chk>
+            <Ro2Chk>0</Ro2Chk>
+            <Ro3Chk>0</Ro3Chk>
+            <Ir1Chk>1</Ir1Chk>
+            <Ir2Chk>0</Ir2Chk>
+            <Ra1Chk>0</Ra1Chk>
+            <Ra2Chk>0</Ra2Chk>
+            <Ra3Chk>0</Ra3Chk>
+            <Im1Chk>1</Im1Chk>
+            <Im2Chk>1</Im2Chk>
+            <OnChipMemories>
+              <Ocm1>
+                <Type>0</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </Ocm1>
+              <Ocm2>
+                <Type>0</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </Ocm2>
+              <Ocm3>
+                <Type>0</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </Ocm3>
+              <Ocm4>
+                <Type>0</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </Ocm4>
+              <Ocm5>
+                <Type>0</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </Ocm5>
+              <Ocm6>
+                <Type>0</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </Ocm6>
+              <IRAM>
+                <Type>0</Type>
+                <StartAddress>0x1fff8000</StartAddress>
+                <Size>0x8000</Size>
+              </IRAM>
+              <IROM>
+                <Type>1</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x40000</Size>
+              </IROM>
+              <XRAM>
+                <Type>0</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </XRAM>
+              <OCR_RVCT1>
+                <Type>1</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </OCR_RVCT1>
+              <OCR_RVCT2>
+                <Type>1</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </OCR_RVCT2>
+              <OCR_RVCT3>
+                <Type>1</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </OCR_RVCT3>
+              <OCR_RVCT4>
+                <Type>1</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x40000</Size>
+              </OCR_RVCT4>
+              <OCR_RVCT5>
+                <Type>1</Type>
+                <StartAddress>0x10000000</StartAddress>
+                <Size>0x8000</Size>
+              </OCR_RVCT5>
+              <OCR_RVCT6>
+                <Type>0</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </OCR_RVCT6>
+              <OCR_RVCT7>
+                <Type>0</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </OCR_RVCT7>
+              <OCR_RVCT8>
+                <Type>0</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </OCR_RVCT8>
+              <OCR_RVCT9>
+                <Type>0</Type>
+                <StartAddress>0x1fff8000</StartAddress>
+                <Size>0x8000</Size>
+              </OCR_RVCT9>
+              <OCR_RVCT10>
+                <Type>0</Type>
+                <StartAddress>0x20000000</StartAddress>
+                <Size>0x8000</Size>
+              </OCR_RVCT10>
+            </OnChipMemories>
+            <RvctStartVector></RvctStartVector>
+          </ArmAdsMisc>
+          <Cads>
+            <interw>1</interw>
+            <Optim>2</Optim>
+            <oTime>0</oTime>
+            <SplitLS>0</SplitLS>
+            <OneElfS>0</OneElfS>
+            <Strict>0</Strict>
+            <EnumInt>0</EnumInt>
+            <PlainCh>0</PlainCh>
+            <Ropi>0</Ropi>
+            <Rwpi>0</Rwpi>
+            <wLevel>0</wLevel>
+            <uThumb>0</uThumb>
+            <uSurpInc>0</uSurpInc>
+            <VariousControls>
+              <MiscControls></MiscControls>
+              <Define></Define>
+              <Undefine></Undefine>
+              <IncludePath></IncludePath>
+            </VariousControls>
+          </Cads>
+          <Aads>
+            <interw>1</interw>
+            <Ropi>0</Ropi>
+            <Rwpi>0</Rwpi>
+            <thumb>0</thumb>
+            <SplitLS>0</SplitLS>
+            <SwStkChk>0</SwStkChk>
+            <NoWarn>0</NoWarn>
+            <uSurpInc>0</uSurpInc>
+            <VariousControls>
+              <MiscControls></MiscControls>
+              <Define></Define>
+              <Undefine></Undefine>
+              <IncludePath></IncludePath>
+            </VariousControls>
+          </Aads>
+          <LDads>
+            <umfTarg>1</umfTarg>
+            <Ropi>0</Ropi>
+            <Rwpi>0</Rwpi>
+            <noStLib>0</noStLib>
+            <RepFail>1</RepFail>
+            <useFile>0</useFile>
+            <TextAddressRange>0x00000000</TextAddressRange>
+            <DataAddressRange>0x1FFF0000</DataAddressRange>
+            <ScatterFile></ScatterFile>
+            <IncludeLibs></IncludeLibs>
+            <IncludeLibsPath></IncludeLibsPath>
+            <Misc></Misc>
+            <LinkerInputFile></LinkerInputFile>
+            <DisabledWarnings></DisabledWarnings>
+          </LDads>
+        </TargetArmAds>
+      </TargetOption>
+    </Target>
+  </Targets>
+
+</Project>
