diff --git a/bsp/tm4c129x/applications/application.c b/bsp/tm4c129x/applications/application.c
index 0ed8ab2..917a72d 100644
--- a/bsp/tm4c129x/applications/application.c
+++ b/bsp/tm4c129x/applications/application.c
@@ -13,23 +13,210 @@
  */
 
 #include <rtthread.h>
+#include <rtdevice.h>
+#include <board.h>
 #include <components.h>
 
+#ifdef RT_USING_LWIP
+#include "drv_eth.h"
+#endif
+#include "led.h"
+#include "con_socket.h"
+
+#include <lwip/netdb.h>
+#include <lwip/sockets.h>
+
+char buf[]="123456789";
+extern void set_if6(char* netif_name, char* ip6_addr);
+extern void netio_init(void);
+
+/* led thread entry */
+static void led_thread_entry(void* parameter)
+{
+	//rt_hw_led_init();
+	const void *data_ptr;
+    rt_size_t data_size;
+    const void *last_data_ptr;
+	while(1)
+	{
+		rt_hw_led_on();
+		rt_thread_delay(RT_TICK_PER_SECOND/2);
+		rt_hw_led_off();
+		rt_thread_delay(RT_TICK_PER_SECOND/2);
+		//list_thread1();
+		//list_mem1();
+		//list_tcps1();
+	}
+}
+#if 0
+struct rt_semaphore rx_sem;
+
+static rt_err_t uart_rx_ind(rt_device_t dev, rt_size_t size)
+{
+    /* release semaphore to let finsh thread rx data */
+	//DBG("uart_rx_ind %d\r\n",size);
+    rt_sem_release(&rx_sem);
+    return RT_EOK;
+}
+
+#if 1
+rt_device_t uart_dev;
+bool phy_link=false;
+
+static void dump_thread_entry(void* parameter)
+{
+	const void *data_ptr;
+    rt_size_t data_size;
+    const void *last_data_ptr;
+	int dev=(int)parameter;
+	long sent_size=0,receive_size=0;
+	char uart[6];
+	rt_uint8_t uart_buf[512];
+	if(dev==1)
+	{
+		rt_memset(uart,'\0',6);
+		rt_sprintf(uart,"uart%d",dev-1);
+		uart_dev = rt_device_find(uart);
+		if (uart_dev == RT_NULL)
+		{
+			rt_kprintf("app_uart: can not find device: uart%d\n", dev-1);
+			return ;
+		}
+		if (rt_device_open(uart_dev, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_INT_RX) == RT_EOK)
+		{
+			rt_device_set_rx_indicate(uart_dev, uart_rx_ind);
+		}
+		rt_sem_init(&(rx_sem), uart, 0, 0);
+	}
+	while(1)
+	{
+		if(dev==1)
+		{
+			if(rt_sem_take(&(rx_sem), RT_WAITING_FOREVER) != RT_EOK) continue;
+			//rt_kprintf("uart got\n");
+			int len,i;
+			char *ptr;
+			ptr=uart_buf;
+			len=rt_device_read(uart_dev, 0, ptr, 512);
+			if(phy_link&&(len>0))
+			{				
+				if((is_right(g_conf.config[dev/2],CONFIG_IPV6)&&g_ip6[dev/2].connected)||(!is_right(g_conf.config[dev/2],CONFIG_IPV6)&&g_ip4[dev/2].connected))
+				{					
+					rt_data_queue_push(&g_data_queue[dev-1], ptr, len, RT_WAITING_FOREVER);
+					//if(!is_right(g_conf.config[dev/2],CONFIG_TCP))
+					//rt_thread_delay(10);
+				}
+			}
+		}
+		else
+		{
+			#if 1
+			rt_data_queue_pop(&g_data_queue[dev], &last_data_ptr, &data_size, RT_WAITING_FOREVER);
+			if(data_size!=0&&last_data_ptr)
+			{			
+				rt_data_queue_push(&g_data_queue[dev-1], last_data_ptr, data_size, 0); 
+				sent_size+=data_size;
+				receive_size+=data_size;
+				char *ptr=(char *)rt_malloc((data_size+1)*sizeof(char));
+				rt_memcpy(ptr,last_data_ptr,data_size);
+				ptr[data_size]='\0';
+				//rt_kprintf("socket %d sent %d receive %d=>%s\n",dev/2,sent_size,receive_size,ptr);
+				rt_free(ptr);
+			}
+			#else
+			rt_data_queue_push(&g_data_queue[dev-1], buf, strlen(buf),RT_WAITING_FOREVER); 
+			rt_thread_delay(RT_TICK_PER_SECOND/2);
+			#endif
+		}
+	}
+}
+static void dump_thread_entry1(void* parameter)
+{
+	//rt_hw_led_init();
+	const void *data_ptr;
+    rt_size_t data_size;
+    const void *last_data_ptr;
+	int dev=(int)parameter;
+	while(1)
+	{
+		rt_data_queue_pop(&g_data_queue[dev], &last_data_ptr, &data_size, RT_WAITING_FOREVER);
+		if(data_size!=0&&last_data_ptr)
+		{			
+			rt_device_write(uart_dev, 0, last_data_ptr, data_size);
+		}
+	}
+}
+#endif
+#endif
 /* thread phase init */
 void rt_init_thread_entry(void *parameter)
 {
     /* Initialization RT-Thread Components */
+	int i;
+#ifdef RT_USING_LWIP
+		rt_hw_tiva_eth_init();
+#endif
     rt_components_init();
+#ifdef RT_USING_FINSH
+    finsh_set_device(RT_CONSOLE_DEVICE_NAME);
+#endif
+	
+	
+	//app_uart_init();
+	//uart_init();
+	//ring_buffer_init();
+	//ping_test("192.168.1.7",5,32);
+	//usbtest();
+	g_data_queue=(struct rt_data_queue *)rt_malloc(sizeof(struct rt_data_queue)*8);
+	for(i=0;i<8;i++)//0,1 for socket0,2,3 for socket1,4,5 for socket2,6,7 for socket3
+	{
+		if((i%2)==0)
+			rt_data_queue_init(&g_data_queue[i], 32, 1, RT_NULL);
+		else
+			rt_data_queue_init(&g_data_queue[i], 32, 1, RT_NULL);
+	}
+	common_init(DEV_USB);
+	//test_select_connect();
+	//test_select_accept();
+	netio_init();
+	//socket_init();
+	//ping_test6("fe80::5867:8730:e9e6:d5c5%11",5,32);
+	//ping_test6("fe80::483:d903:e2ee:d05e%12",5,32);
+	//ping_test("192.168.2.32",5,32);
+	//ping_test("192.168.2.32",5,32);
 }
 
 int rt_application_init(void)
 {
     rt_thread_t tid;
+    rt_thread_t led_thread;
+	int i;
+	char buf[5];
     tid = rt_thread_create("init",
                            rt_init_thread_entry, RT_NULL,
                            2048, RT_THREAD_PRIORITY_MAX / 3, 20);
     if (tid != RT_NULL) rt_thread_startup(tid);
-
+    /* Create led thread */
+    led_thread = rt_thread_create("led",
+			    led_thread_entry, RT_NULL,
+			    2048, 20, 20);
+    if(led_thread != RT_NULL)
+		  rt_thread_startup(led_thread);
+	#if 0
+	for(i=0;i<4;i++)
+	{
+		rt_sprintf(buf,"led%d",i);
+		led_thread = rt_thread_create(buf,
+					dump_thread_entry, (void *)(i*2+1),
+					1024, 20, 20);
+		if(led_thread != RT_NULL)
+			  rt_thread_startup(led_thread);
+	}
+			led_thread = rt_thread_create("uart0_read",
+						dump_thread_entry1, (void *)(1),
+						1024, 20, 20);
+			if(led_thread != RT_NULL)
+				  rt_thread_startup(led_thread);
+	#endif
     return 0;
 }
-
diff --git a/bsp/tm4c129x/applications/board.c b/bsp/tm4c129x/applications/board.c
index b1837fa..57ccedb 100644
--- a/bsp/tm4c129x/applications/board.c
+++ b/bsp/tm4c129x/applications/board.c
@@ -15,9 +15,9 @@
 
 #include <rthw.h>
 #include <rtthread.h>
-#include <components.h>
-#include "board.h"
 
+#include "board.h"
+#include "drv_uart.h"
 
 #include "driverlib/interrupt.h"
 #include "driverlib/sysctl.h"
@@ -61,27 +61,23 @@ extern void HardFault_Handler(void);
  */
 void rt_hw_board_init()
 {
-    //init low level drivers. e.g. cpu uart etc.
-    rt_components_board_init();
-    //redirect RTT stdio to CONSOLE device
-    rt_console_set_device(RT_CONSOLE_DEVICE_NAME);
-}
-
-int rt_hw_cpu_init(void)
-{
     MAP_IntMasterDisable();
     IntRegister(FAULT_HARD, HardFault_Handler);	
     IntRegister(FAULT_PENDSV, PendSV_Handler);
     IntRegister(FAULT_SYSTICK, SysTick_Handler);
     
+	  //
     // Enable lazy stacking for interrupt handlers.  This allows floating-point
     // instructions to be used within interrupt handlers, but at the expense of
     // extra stack usage.
+    //
     MAP_FPULazyStackingEnable();
 
+    //
     // Set the clocking to run directly from the external crystal/oscillator.
     // TODO: The SYSCTL_XTAL_ value must be changed to match the value of the
     // crystal on your board.
+    //
     SysClock = MAP_SysCtlClockFreqSet(
                 (SYSCTL_XTAL_25MHZ | SYSCTL_OSC_MAIN | SYSCTL_USE_PLL | SYSCTL_CFG_VCO_480),
                 SYS_CLOCK_DEFAULT);
@@ -91,8 +87,17 @@ int rt_hw_cpu_init(void)
     MAP_SysTickIntEnable();
     MAP_SysTickEnable();	
 
-    return 0;
+    /* set pend exception priority */
+    //IntPrioritySet(FAULT_PENDSV, (1 << 5) - 1);
+    
+    /*init uart device*/		
+    rt_hw_uart_init(1);
+    //redirect RTT stdio to CONSOLE device
+	#ifdef RT_USING_CONSOLE 
+	rt_console_set_device(RT_CONSOLE_DEVICE_NAME);
+	#endif
+    //
+    // Enable interrupts to the processor.
+    //
+    MAP_IntMasterEnable();
 }
-// rt_hw_cpu_init should be run before any other INIT_BOARD_EXPORT
-// We use INIT_EXPORT here and set the sequence index to "0.xxxx"
-INIT_EXPORT(rt_hw_cpu_init, "0.post");
diff --git a/bsp/tm4c129x/applications/board.h b/bsp/tm4c129x/applications/board.h
index 9423c80..232da0d 100644
--- a/bsp/tm4c129x/applications/board.h
+++ b/bsp/tm4c129x/applications/board.h
@@ -30,7 +30,10 @@ extern uint32_t SysClock;
 // <bool name="RT_USING_UART1" description="Using UART1" default="true" />
 //#define RT_USING_UART1
 // <bool name="RT_USING_UART2" description="Using UART2" default="true" />
-//#define RT_USING_UART2
+#define RT_USING_UART2
+#define RT_USING_UART3
+#define RT_USING_UART4
+#define RT_USING_UART6
 
 // </RDTConfigurator>
 
diff --git a/bsp/tm4c129x/applications/con_common.c b/bsp/tm4c129x/applications/con_common.c
new file mode 100755
index 0000000..5ce8975
--- /dev/null
+++ b/bsp/tm4c129x/applications/con_common.c
@@ -0,0 +1,1427 @@
+#include "con_socket.h"
+#include <rthw.h>
+#include <rtthread.h>
+#include <rtdevice.h>
+
+#include "board.h"
+
+#include "inc/hw_memmap.h"
+#include "driverlib/sysctl.h"
+#include "driverlib/gpio.h"
+#include "driverlib/uart.h"
+#include "driverlib/pin_map.h"
+#include "driverlib/interrupt.h"
+#include "driverlib/rom_map.h"
+#define CONFIG_BIN 1 //test socket 1
+#define CONFIG_IT 0 //test  config 1
+
+#if 0
+void IntGpioD()
+{
+	if(MAP_GPIOIntStatus(GPIO_PORTD_BASE, true)&GPIO_PIN_2)
+	{			
+		MAP_GPIOIntClear(GPIO_PORTD_BASE, GPIO_PIN_2);
+		if(MAP_GPIOPinRead(GPIO_PORTD_BASE, GPIO_PIN_2)!=GPIO_PIN_2)
+			MAP_GPIOPinWrite(GPIO_PORTB_BASE, GPIO_PIN_4, 0);
+		else
+			MAP_GPIOPinWrite(GPIO_PORTB_BASE, GPIO_PIN_4, GPIO_PIN_4);
+		//ind[3]=((MAP_GPIOPinRead(GPIO_PORTD_BASE, GPIO_PIN_2)&(GPIO_PIN_2))==0)?RT_TRUE:RT_FALSE;
+		rt_kprintf("gpiod 2 int \r\n");
+	}	
+}
+
+#else
+unsigned char config_local_ip[4+8]				={0xF5,0x8A,0x00,0xff,0xff,0xff,0xff,0x26,0xfa,0x00,0x00};/*local ip*/
+unsigned char config_socket0_local_port[2+8]	={0xF5,0x8A,0x01,0xff,0xff,0x26,0xfa,0x00,0x00};/*local port0*/
+unsigned char config_socket1_local_port[2+8]	={0xF5,0x8A,0x02,0xff,0xff,0x26,0xfa,0x00,0x00};/*local port1*/
+unsigned char config_socket2_local_port[2+8]	={0xF5,0x8A,0x03,0xff,0xff,0x26,0xfa,0x00,0x00};/*local port2*/
+unsigned char config_socket3_local_port[2+8]	={0xF5,0x8A,0x04,0xff,0xff,0x26,0xfa,0x00,0x00};/*local port3*/
+unsigned char config_sub_msk[4+8]				={0xF5,0x8A,0x05,0xff,0xff,0xff,0xff,0x26,0xfa,0x00,0x00};/*sub msk*/
+unsigned char config_gw[4+8]					={0xF5,0x8A,0x06,0xff,0xff,0xff,0xff,0x26,0xfa,0x00,0x00};/*gw*/
+unsigned char config_mac[6+8]					={0xF5,0x8A,0x07,0xff,0xff,0xff,0xff,0xff,0xff,0x26,0xfa,0x00,0x00};/*mac*/
+unsigned char config_socket0_ip[4+8]			={0xF5,0x8A,0x08,0xff,0xff,0xff,0xff,0x26,0xfa,0x00,0x00};/*socket 0 ip*/
+unsigned char config_socket1_ip[4+8]			={0xF5,0x8A,0x09,0xff,0xff,0xff,0xff,0x26,0xfa,0x00,0x00};/*socket 1 ip*/
+unsigned char config_socket2_ip[4+8]			={0xF5,0x8A,0x0a,0xff,0xff,0xff,0xff,0x26,0xfa,0x00,0x00};/*socket 2 ip*/
+unsigned char config_socket3_ip[4+8]			={0xF5,0x8A,0x0b,0xff,0xff,0xff,0xff,0x26,0xfa,0x00,0x00};/*socket 3 ip*/
+unsigned char config_socket0_ip6[64+8]			={0xF5,0x8A,0x0c,0xff,0xff,0xff,0xff,0x26,0xfa,0x00,0x00};/*socket 0 ip6*/
+unsigned char config_socket1_ip6[64+8]			={0xF5,0x8A,0x0d,0xff,0xff,0xff,0xff,0x26,0xfa,0x00,0x00};/*socket 1 ip6*/
+unsigned char config_socket2_ip6[64+8]			={0xF5,0x8A,0x0e,0xff,0xff,0xff,0xff,0x26,0xfa,0x00,0x00};/*socket 2 ip6*/
+unsigned char config_socket3_ip6[64+8]			={0xF5,0x8A,0x0f,0xff,0xff,0xff,0xff,0x26,0xfa,0x00,0x00};/*socket 3 ip6*/
+unsigned char config_socket0_remote_port[2+8]	={0xF5,0x8A,0x10,0xff,0xff,0x26,0xfa,0x00,0x00};/*socket 0 port*/
+unsigned char config_socket1_remote_port[2+8]	={0xF5,0x8A,0x11,0xff,0xff,0x26,0xfa,0x00,0x00};/*socket 1 port*/
+unsigned char config_socket2_remote_port[2+8]	={0xF5,0x8A,0x12,0xff,0xff,0x26,0xfa,0x00,0x00};/*socket 2 port*/
+unsigned char config_socket3_remote_port[2+8]	={0xF5,0x8A,0x13,0xff,0xff,0x26,0xfa,0x00,0x00};/*socket 3 port*/
+unsigned char config_net_protol0[1+8]			={0xF5,0x8A,0x14,0xff,0x26,0xfa,0x00,0x00};/*protol0*/
+unsigned char config_net_protol1[1+8]			={0xF5,0x8A,0x15,0xff,0x26,0xfa,0x00,0x00};/*protol1*/
+unsigned char config_net_protol2[1+8]			={0xF5,0x8A,0x16,0xff,0x26,0xfa,0x00,0x00};/*protol2*/
+unsigned char config_net_protol3[1+8]			={0xF5,0x8A,0x17,0xff,0x26,0xfa,0x00,0x00};/*protol3*/
+unsigned char config_socket_mode0[1+8]			={0xF5,0x8A,0x18,0xff,0x26,0xfa,0x00,0x00};/*server mode0*/
+unsigned char config_socket_mode1[1+8]			={0xF5,0x8A,0x19,0xff,0x26,0xfa,0x00,0x00};/*server mode1*/
+unsigned char config_socket_mode2[1+8]			={0xF5,0x8A,0x1a,0xff,0x26,0xfa,0x00,0x00};/*server mode2*/
+unsigned char config_socket_mode3[1+8]			={0xF5,0x8A,0x1b,0xff,0x26,0xfa,0x00,0x00};/*server mode3*/
+unsigned char config_uart_baud0[1+8]			={0xF5,0x8A,0x1c,0xff,0x26,0xfa,0x00,0x00};/*uart baud*/
+unsigned char config_uart_baud1[1+8]			={0xF5,0x8A,0x1d,0xff,0x26,0xfa,0x00,0x00};/*uart baud*/
+unsigned char config_uart_baud2[1+8]			={0xF5,0x8A,0x1e,0xff,0x26,0xfa,0x00,0x00};/*uart baud*/
+unsigned char config_uart_baud3[1+8]			={0xF5,0x8A,0x1f,0xff,0x26,0xfa,0x00,0x00};/*uart baud*/
+unsigned char config_local_ip6[64+8]			={0xF5,0x8A,0x20,0xff,0xff,0xff,0xff,0x26,0xfa,0x00,0x00};/*local ip6*/
+unsigned char config_tcp0[1+8]					={0xF5,0x8A,0x21,0xff,0x26,0xfa,0x00,0x00};/*protol0*/
+unsigned char config_tcp1[1+8]					={0xF5,0x8A,0x22,0xff,0x26,0xfa,0x00,0x00};/*protol1*/
+unsigned char config_tcp2[1+8]					={0xF5,0x8A,0x23,0xff,0x26,0xfa,0x00,0x00};/*protol2*/
+unsigned char config_tcp3[1+8]					={0xF5,0x8A,0x24,0xff,0x26,0xfa,0x00,0x00};/*protol3*/
+struct rt_mutex mconfigutex;
+
+
+
+
+int times=0;
+
+
+#define COMMAND_FAIL "Command crc fail"
+#define COMMAND_OK "Command exec OK"
+
+void print_config(config g);
+
+unsigned char get_config[35];//			={0xF5,0x8B,0x0f,0xff,0xff,0xff,0xff,0x27,0xfa,0x00,0x00};/*get config 0xf5,0x8b,********0x27,0xfa,0x00,0x00*/
+rt_thread_t tid_common_w[4]={RT_NULL,RT_NULL,RT_NULL,RT_NULL},tid_common_r[4]={RT_NULL,RT_NULL,RT_NULL,RT_NULL};
+rt_device_t common_dev[4] = {RT_NULL,RT_NULL,RT_NULL,RT_NULL};
+bool ind[4]={RT_TRUE,RT_TRUE,RT_TRUE,RT_TRUE};
+bool phy_link=false;
+enum STATE_OP{
+	GET_F5,
+	GET_8A_8B,
+	GET_LEN,
+	GET_DATA,
+	GET_26,
+	GET_FA,
+	GET_CHECSUM
+};
+struct rt_semaphore rx_sem[4];
+struct rt_semaphore usbrx_sem[4];
+
+void configlock()
+{
+    rt_err_t result;
+
+    result = rt_mutex_take(&mconfigutex, RT_WAITING_FOREVER);
+    if (result != RT_EOK)
+    {
+        RT_ASSERT(0);
+    }
+}
+void configunlock()
+{
+    rt_mutex_release(&mconfigutex);
+}
+
+int which_common_dev(rt_device_t *dev,rt_device_t dev2)
+{
+	int i=0;
+	for(i=0;i<4;i++)
+		if(dev[i]==dev2)
+		{
+			//DBG("Uart %d 's setting\r\n",i);
+			break;
+		}
+	return i;
+}
+void IntGpioD()
+{
+	if(MAP_GPIOIntStatus(GPIO_PORTD_BASE, true)&GPIO_PIN_2)
+	{		
+		MAP_GPIOIntClear(GPIO_PORTD_BASE, GPIO_PIN_2);
+		ind[0]=RT_TRUE;//((MAP_GPIOPinRead(GPIO_PORTD_BASE, GPIO_PIN_2)&(GPIO_PIN_2))==GPIO_PIN_2)?RT_TRUE:RT_FALSE;
+		ind[1]=RT_TRUE;
+		ind[2]=RT_TRUE;
+		ind[3]=RT_TRUE;
+		rt_kprintf("gpiod 2 int %d\r\n",ind[0]);
+		
+	}	
+}/*
+void IntGpioB()
+{
+	if(MAP_GPIOIntStatus(GPIO_PORTB_BASE, true)&GPIO_PIN_4)
+	{
+		MAP_GPIOIntClear(GPIO_PORTB_BASE, GPIO_PIN_4);
+		ind[3]=((MAP_GPIOPinRead(GPIO_PORTB_BASE, GPIO_PIN_4)&(GPIO_PIN_4))==0)?RT_TRUE:RT_FALSE;
+		rt_kprintf("gpiob 4 int %d\r\n",ind[3]);
+	}	
+}
+*/
+/*get config data to global config zone, or get socket data to buffer*/
+void default_config()
+{
+	struct netif * netif=netif_list;
+	if(((MAP_GPIOPinRead(GPIO_PORTD_BASE, GPIO_PIN_2)&(GPIO_PIN_2))==GPIO_PIN_2)?RT_TRUE:RT_FALSE)
+	{//server mode high level
+		g_conf.config[0]=CONFIG_TCP|CONFIG_SERVER;
+		g_conf.config[1]=CONFIG_TCP|CONFIG_SERVER;
+		g_conf.config[2]=CONFIG_TCP|CONFIG_SERVER;
+		g_conf.config[3]=CONFIG_TCP|CONFIG_SERVER;
+		memset(g_conf.remote_ip[0],'\0',16);
+		strcpy(g_conf.remote_ip[0],"192.168.2.6");
+		memset(g_conf.remote_ip[1],'\0',16);
+		strcpy(g_conf.remote_ip[1],"192.168.2.6");
+		memset(g_conf.remote_ip[2],'\0',16);
+		strcpy(g_conf.remote_ip[2],"192.168.2.6");
+		memset(g_conf.remote_ip[3],'\0',16);
+		strcpy(g_conf.remote_ip[3],"192.168.2.6");
+		memset(g_conf.local_ip,'\0',16);
+		strcpy(g_conf.local_ip,"192.168.2.32");	
+	}
+	else
+	{//client mode
+		g_conf.config[0]=CONFIG_TCP;//|CONFIG_SERVER;
+		g_conf.config[1]=CONFIG_TCP;//|CONFIG_SERVER;
+		g_conf.config[2]=CONFIG_TCP;//|CONFIG_SERVER;
+		g_conf.config[3]=CONFIG_TCP;//|CONFIG_SERVER;
+		memset(g_conf.remote_ip[0],'\0',16);
+		strcpy(g_conf.remote_ip[0],"192.168.2.32");
+		memset(g_conf.remote_ip[1],'\0',16);
+		strcpy(g_conf.remote_ip[1],"192.168.2.32");
+		memset(g_conf.remote_ip[2],'\0',16);
+		strcpy(g_conf.remote_ip[2],"192.168.2.32");
+		memset(g_conf.remote_ip[3],'\0',16);
+		strcpy(g_conf.remote_ip[3],"192.168.2.32");
+		memset(g_conf.local_ip,'\0',16);
+		strcpy(g_conf.local_ip,"192.168.2.6");	
+	}
+	
+	memset(g_conf.remote_ip6[0],'\0',64);
+	strcpy(g_conf.remote_ip6[0],"fe80::5867:8730:e9e6:d5c5%11");
+	memset(g_conf.remote_ip6[1],'\0',64);
+	strcpy(g_conf.remote_ip6[1],"fe80::5867:8730:e9e6:d5c5%11");
+	memset(g_conf.remote_ip6[2],'\0',64);
+	strcpy(g_conf.remote_ip6[2],"fe80::5867:8730:e9e6:d5c5%11");
+	memset(g_conf.remote_ip6[3],'\0',64);
+	strcpy(g_conf.remote_ip6[3],"fe80::5867:8730:e9e6:d5c5%11");
+	g_conf.local_port[0]=1234;
+	g_conf.local_port[1]=1235;
+	g_conf.local_port[2]=1236;
+	g_conf.local_port[3]=1237;
+	
+	
+	memset(g_conf.local_ip6,'\0',64);
+	strcpy(g_conf.local_ip6,"fe80::1");
+	
+	memset(g_conf.gw,'\0',16);
+	strcpy(g_conf.gw,"192.168.2.1");	
+	memset(g_conf.sub_msk,'\0',16);
+	strcpy(g_conf.sub_msk,"255.255.255.0");
+	memset(g_conf.mac,'\0',64);	
+	rt_sprintf(g_conf.mac,"%d.%d.%d.%d.%d.%d",netif->hwaddr[0],netif->hwaddr[1],netif->hwaddr[2],netif->hwaddr[3],netif->hwaddr[4],netif->hwaddr[5]);
+	g_conf.remote_port[0]=1234;
+	g_conf.remote_port[1]=1235;
+	g_conf.remote_port[2]=1236;
+	g_conf.remote_port[3]=1237;
+	set_if6("e0","fe80::1");
+	set_if("e0",g_conf.local_ip,g_conf.gw,g_conf.sub_msk);
+	
+}
+#if CONFIG_BIN
+void set_config(rt_uint8_t *data,int ipv6_len,int dev)//0 no change ,1 local socket need reconfig ,2 all socket need reconfig
+{
+	
+	bool ipv6_changed=false,ipv4_changed=false;
+	int i;
+	switch(data[0])
+	{
+		case 0:
+		{
+			//set local ipv4 ip
+			rt_uint8_t *tmp=rt_malloc(16);
+			rt_memset(tmp,'\0',16);
+			rt_sprintf(tmp,"%d.%d.%d.%d",data[1],data[2],data[3],data[4]);
+			if(memcmp(tmp,g_conf.local_ip,16)!=0)
+			{
+				ipv4_changed=true;
+				rt_memset(g_conf.local_ip,'\0',16);
+				rt_sprintf(g_conf.local_ip,"%d.%d.%d.%d",data[1],data[2],data[3],data[4]);
+			}
+			rt_free(tmp);
+		}
+		break;
+		case 1:
+		case 2:
+		case 3:
+		case 4:
+		{
+			//set local port
+			if((data[0]-1)==dev)
+			{
+				if(g_conf.local_port[data[0]-1]!=(data[1]<<8|data[2]))
+				{
+					g_conf.local_port[data[0]-1]=(data[1]<<8|data[2]);
+					g_chang[dev].lpc=1;
+					rt_kprintf("local port changed %d\n",dev);
+				}
+			}
+		}
+		break;
+		case 5:
+		{
+			//set sub msk
+			rt_uint8_t *tmp=rt_malloc(16);
+			rt_memset(tmp,'\0',16);
+			rt_sprintf(tmp,"%d.%d.%d.%d",data[1],data[2],data[3],data[4]);
+			if(memcmp(tmp,g_conf.sub_msk,16)!=0)
+			{
+				ipv4_changed=true;
+				rt_memset(g_conf.sub_msk,'\0',16);
+				rt_sprintf(g_conf.sub_msk,"%d.%d.%d.%d",data[1],data[2],data[3],data[4]);
+			}
+			rt_free(tmp);
+		}
+		break;
+		case 6:
+		{
+			//set gateway
+			rt_uint8_t *tmp=rt_malloc(16);
+			rt_memset(tmp,'\0',16);
+			rt_sprintf(tmp,"%d.%d.%d.%d",data[1],data[2],data[3],data[4]);
+			if(memcmp(tmp,g_conf.gw,16)!=0)
+			{
+				ipv4_changed=true;
+				rt_memset(g_conf.gw,'\0',16);
+				rt_sprintf(g_conf.gw,"%d.%d.%d.%d",data[1],data[2],data[3],data[4]);
+			}
+			rt_free(tmp);
+		}
+		break;
+		case 7:
+		{
+			//set mac
+			
+		}
+		break;
+		case 8:
+		case 9:
+		case 10:
+		case 11:
+		{
+			//set remote ipv4 ip
+			if((data[0]-8)==dev)
+			{
+				rt_uint8_t *tmp=rt_malloc(16);
+				rt_memset(tmp,'\0',16);
+				rt_sprintf(tmp,"%d.%d.%d.%d",data[1],data[2],data[3],data[4]);
+				if(memcmp(tmp,g_conf.remote_ip[data[0]-8],16)!=0)
+				{
+					rt_memset(g_conf.remote_ip[data[0]-8],'\0',16);
+					rt_sprintf(g_conf.remote_ip[data[0]-8],"%d.%d.%d.%d",data[1],data[2],data[3],data[4]);
+					g_chang[dev].rip4c=1;
+				}
+				rt_free(tmp);
+			}
+		}
+		break;
+		case 12:
+		case 13:			
+		case 14:
+		case 15:
+		{
+			//set remote ipv6 ip
+			if((data[0]-12)==dev)
+			{
+				rt_uint8_t *tmp=rt_malloc(ipv6_len);
+				rt_memset(tmp,'\0',ipv6_len);
+				for(i=0;i<ipv6_len;i++)
+					tmp[i]=data[i+1];
+				if(memcmp(tmp,g_conf.remote_ip6[data[0]-12],ipv6_len)!=0 || ipv6_len!=sizeof(g_conf.remote_ip6[data[0]-12]))
+				{
+					rt_memset(g_conf.remote_ip6[data[0]-12],'\0',64);
+					for(i=0;i<ipv6_len;i++)
+						g_conf.remote_ip6[data[0]-12][i]=data[i+1];
+					g_chang[dev].rip6c=1;
+				}
+				rt_free(tmp);
+			}
+		}
+		break;
+		case 16:
+		case 17:
+		case 18:
+		case 19:
+		{
+			//set remote port
+			if((data[0]-16)==dev)
+			{
+				if(g_conf.remote_port[data[0]-16]!=(data[1]<<8|data[2]))
+				{
+					g_conf.remote_port[data[0]-16]=(data[1]<<8|data[2]);
+					g_chang[dev].rpc=1;
+				}
+			}
+		}
+		break;
+		case 20:
+		case 21:
+		case 22:
+		case 23:
+		{
+			//set net protol ipv4 or ipv6
+			if((data[0]-20)==dev)
+			{
+				if(data[1])
+				{	
+					if((g_conf.config[data[0]-20]&CONFIG_IPV6)!=CONFIG_IPV6)
+					{
+						g_conf.config[data[0]-20]|=CONFIG_IPV6;
+						g_chang[dev].protol=1;
+					}
+				}
+				else
+				{
+					if((g_conf.config[data[0]-20]&CONFIG_IPV6)==CONFIG_IPV6)
+					{
+						g_conf.config[data[0]-20]&=~CONFIG_IPV6;
+						g_chang[dev].protol=1;
+					}
+				}
+			}
+		}
+		break;
+		case 24:
+		case 25:
+		case 26:
+		case 27:
+		{
+			//set server or client mode
+			if((data[0]-24)==dev)
+			{
+				if(data[1])
+				{
+					if((g_conf.config[data[0]-24]&CONFIG_SERVER)!=CONFIG_SERVER)
+					{
+						g_conf.config[data[0]-24]|=CONFIG_SERVER;
+						g_chang[dev].cs=1;
+					}
+				}
+				else
+				{
+					if((g_conf.config[data[0]-24]&CONFIG_SERVER)==CONFIG_SERVER)
+					{
+						g_conf.config[data[0]-24]&=~CONFIG_SERVER;
+						g_chang[dev].cs=1;
+					}
+				}
+			}
+		}
+		break;
+		case 28:
+		case 29:
+		case 30:
+		case 31:
+		{
+			//set uart baud
+			if((data[0]-28)==dev)
+			{
+				g_conf.config[data[0]-28]=((g_conf.config[data[0]-28]&0x07)|(data[1]<<3));
+				struct serial_configure config;
+				config.baud_rate=baud(g_conf.config[data[0]-28]>>3);
+				config.bit_order = BIT_ORDER_LSB;
+				config.data_bits = DATA_BITS_8;
+				config.parity	 = PARITY_NONE;
+				config.stop_bits = STOP_BITS_1;
+				config.invert	 = NRZ_NORMAL;
+				config.bufsz	 = RT_SERIAL_RB_BUFSZ;
+				rt_device_control(common_dev[dev],RT_DEVICE_CTRL_CONFIG,&config);	
+			}
+		}
+		break;
+		case 32:
+		{
+			//set local ipv6 ip
+			rt_uint8_t *tmp=rt_malloc(ipv6_len);
+			rt_memset(tmp,'\0',ipv6_len);
+			for(i=0;i<ipv6_len;i++)
+				tmp[i]=data[i+1];
+			if(memcmp(tmp,g_conf.local_ip6,ipv6_len)!=0 || ipv6_len!=sizeof(g_conf.local_ip6))
+			{
+				ipv6_changed=true;
+				rt_memset(g_conf.local_ip6,'\0',64);
+				for(i=0;i<ipv6_len;i++)
+					g_conf.local_ip6[i]=data[i+1];
+				g_chang[dev].lip6c=1;
+			}
+			rt_free(tmp);
+		}
+		break;
+		case 33:
+		case 34:
+		case 35:
+		case 36:
+		{//set tcp or udp
+			if((data[0]-33)==dev)
+			{
+				if(data[1])
+				{
+					if((g_conf.config[data[0]-33]&CONFIG_TCP)!=CONFIG_TCP)
+					{
+						g_conf.config[data[0]-33]|=CONFIG_TCP;
+						g_chang[dev].mode=1;
+					}
+				}
+				else
+				{
+					if((g_conf.config[data[0]-33]&CONFIG_TCP)==CONFIG_TCP)
+					{					
+						g_conf.config[data[0]-33]&=~CONFIG_TCP;
+						g_chang[dev].mode=1;
+					}
+				}
+			}
+		}
+		break;
+		default:
+			rt_kprintf("wrong cmd\n");
+	}
+	if(ipv4_changed)
+		set_if("e0",g_conf.local_ip,g_conf.gw,g_conf.sub_msk);
+	if(ipv6_changed)
+		set_if6("e0",g_conf.local_ip6);
+}
+#endif
+bool need_reconfig(int dev)
+{
+#if CONFIG_BIN
+	if(g_chang[dev].cs||g_chang[dev].lip6c||g_chang[dev].lpc||g_chang[dev].mode||
+	   g_chang[dev].protol||g_chang[dev].rip4c||g_chang[dev].rip6c||g_chang[dev].rpc)
+	{
+		if(g_chang[dev].cs)
+			rt_kprintf("%d client/server changed\n",dev);
+		if(g_chang[dev].lip6c)
+			rt_kprintf("%d local ip6 changed\n",dev);
+		if(g_chang[dev].lpc)
+			rt_kprintf("%d local port changed\n",dev);
+		if(g_chang[dev].mode)
+			rt_kprintf("%d tcp/udp changed\n",dev);
+		if(g_chang[dev].protol)
+			rt_kprintf("%d ipv4/ipv6 changed\n",dev);
+		if(g_chang[dev].rip4c)
+			rt_kprintf("%d remote ip4 changed\n",dev);
+		if(g_chang[dev].rip6c)
+			rt_kprintf("%d remote ip6 changed\n",dev);
+		if(g_chang[dev].rpc)
+			rt_kprintf("%d remote port changed\n",dev);
+		//rt_uint8_t *ptr=(rt_uint8_t *)(&g_chang[dev]);
+		//rt_memset(ptr,0,sizeof(change));
+		g_chang[dev].cs=g_chang[dev].lip6c=g_chang[dev].lpc=g_chang[dev].mode=g_chang[dev].protol=g_chang[dev].rip4c=g_chang[dev].rip6c=g_chang[dev].rpc=0;
+		return true;
+	}
+	else
+		return false;
+#else
+	return false;
+#endif
+}
+#if CONFIG_BIN
+char *send_out(int dev,int cmd,int *lenout)
+{
+	#if 0
+	unsigned char config_local_ip[4+7]				={0xF5,0x8A,0x00,0xff,0xff,0xff,0xff,0x26,0xfa,0x00,0x00};/*local ip*/
+	unsigned char config_socket0_local_port[2+7]	={0xF5,0x8A,0x01,0xff,0xff,0x26,0xfa,0x00,0x00};/*local port0*/
+	unsigned char config_socket1_local_port[2+7]	={0xF5,0x8A,0x02,0xff,0xff,0x26,0xfa,0x00,0x00};/*local port1*/
+	unsigned char config_socket2_local_port[2+7]	={0xF5,0x8A,0x03,0xff,0xff,0x26,0xfa,0x00,0x00};/*local port2*/
+	unsigned char config_socket3_local_port[2+7]	={0xF5,0x8A,0x04,0xff,0xff,0x26,0xfa,0x00,0x00};/*local port3*/
+	unsigned char config_sub_msk[4+7]				={0xF5,0x8A,0x05,0xff,0xff,0xff,0xff,0x26,0xfa,0x00,0x00};/*sub msk*/
+	unsigned char config_gw[4+7]					={0xF5,0x8A,0x06,0xff,0xff,0xff,0xff,0x26,0xfa,0x00,0x00};/*gw*/
+	unsigned char config_mac[6+7]					={0xF5,0x8A,0x07,0xff,0xff,0xff,0xff,0xff,0xff,0x26,0xfa,0x00,0x00};/*mac*/
+	unsigned char config_socket0_ip[4+7]			={0xF5,0x8A,0x08,0xff,0xff,0xff,0xff,0x26,0xfa,0x00,0x00};/*socket 0 ip*/
+	unsigned char config_socket1_ip[4+7]			={0xF5,0x8A,0x09,0xff,0xff,0xff,0xff,0x26,0xfa,0x00,0x00};/*socket 1 ip*/
+	unsigned char config_socket2_ip[4+7]			={0xF5,0x8A,0x0a,0xff,0xff,0xff,0xff,0x26,0xfa,0x00,0x00};/*socket 2 ip*/
+	unsigned char config_socket3_ip[4+7]			={0xF5,0x8A,0x0b,0xff,0xff,0xff,0xff,0x26,0xfa,0x00,0x00};/*socket 3 ip*/
+	unsigned char config_socket0_ip6[64+7]			={0xF5,0x8A,0x0c,0xff,0xff,0xff,0xff,0x26,0xfa,0x00,0x00};/*socket 0 ip6*/
+	unsigned char config_socket1_ip6[64+7]			={0xF5,0x8A,0x0d,0xff,0xff,0xff,0xff,0x26,0xfa,0x00,0x00};/*socket 1 ip6*/
+	unsigned char config_socket2_ip6[64+7]			={0xF5,0x8A,0x0e,0xff,0xff,0xff,0xff,0x26,0xfa,0x00,0x00};/*socket 2 ip6*/
+	unsigned char config_socket3_ip6[64+7]			={0xF5,0x8A,0x0f,0xff,0xff,0xff,0xff,0x26,0xfa,0x00,0x00};/*socket 3 ip6*/
+	unsigned char config_socket0_remote_port[2+7]	={0xF5,0x8A,0x10,0xff,0xff,0x26,0xfa,0x00,0x00};/*socket 0 port*/
+	unsigned char config_socket1_remote_port[2+7]	={0xF5,0x8A,0x11,0xff,0xff,0x26,0xfa,0x00,0x00};/*socket 1 port*/
+	unsigned char config_socket2_remote_port[2+7]	={0xF5,0x8A,0x12,0xff,0xff,0x26,0xfa,0x00,0x00};/*socket 2 port*/
+	unsigned char config_socket3_remote_port[2+7]	={0xF5,0x8A,0x13,0xff,0xff,0x26,0xfa,0x00,0x00};/*socket 3 port*/
+	unsigned char config_net_protol0[1+7]			={0xF5,0x8A,0x14,0xff,0x26,0xfa,0x00,0x00};/*protol0*/
+	unsigned char config_net_protol1[1+7]			={0xF5,0x8A,0x15,0xff,0x26,0xfa,0x00,0x00};/*protol1*/
+	unsigned char config_net_protol2[1+7]			={0xF5,0x8A,0x16,0xff,0x26,0xfa,0x00,0x00};/*protol2*/
+	unsigned char config_net_protol3[1+7]			={0xF5,0x8A,0x17,0xff,0x26,0xfa,0x00,0x00};/*protol3*/
+	unsigned char config_socket_mode0[1+7]			={0xF5,0x8A,0x18,0xff,0x26,0xfa,0x00,0x00};/*server mode0*/
+	unsigned char config_socket_mode1[1+7]			={0xF5,0x8A,0x19,0xff,0x26,0xfa,0x00,0x00};/*server mode1*/
+	unsigned char config_socket_mode2[1+7]			={0xF5,0x8A,0x1a,0xff,0x26,0xfa,0x00,0x00};/*server mode2*/
+	unsigned char config_socket_mode3[1+7]			={0xF5,0x8A,0x1b,0xff,0x26,0xfa,0x00,0x00};/*server mode3*/
+	unsigned char config_uart_baud0[1+7]			={0xF5,0x8A,0x1c,0xff,0x26,0xfa,0x00,0x00};/*uart baud*/
+	unsigned char config_uart_baud1[1+7]			={0xF5,0x8A,0x1d,0xff,0x26,0xfa,0x00,0x00};/*uart baud*/
+	unsigned char config_uart_baud2[1+7]			={0xF5,0x8A,0x1e,0xff,0x26,0xfa,0x00,0x00};/*uart baud*/
+	unsigned char config_uart_baud3[1+7]			={0xF5,0x8A,0x1f,0xff,0x26,0xfa,0x00,0x00};/*uart baud*/
+	unsigned char config_local_ip6[64+7]			={0xF5,0x8A,0x20,0xff,0xff,0xff,0xff,0x26,0xfa,0x00,0x00};/*local ip6*/
+	unsigned char config_tcp0[1+7]					={0xF5,0x8A,0x21,0xff,0x26,0xfa,0x00,0x00};/*protol0*/
+	unsigned char config_tcp1[1+7]					={0xF5,0x8A,0x22,0xff,0x26,0xfa,0x00,0x00};/*protol1*/
+	unsigned char config_tcp2[1+7]					={0xF5,0x8A,0x23,0xff,0x26,0xfa,0x00,0x00};/*protol2*/
+	unsigned char config_tcp3[1+7]					={0xF5,0x8A,0x24,0xff,0x26,0xfa,0x00,0x00};/*protol3*/
+	#endif
+	char *ptr=NULL;
+	int crc=0,i=0,len;
+	char *p=NULL;
+	switch(cmd)
+	{
+		case 0:
+			{
+				ptr=config_local_ip;
+				p=g_conf.local_ip;
+				ptr[3]=atoi(p);
+				while(*p!='.')
+					p++;
+				p++;
+				ptr[4]=atoi(p);
+				while(*p!='.')
+					p++;
+				p++;
+				ptr[5]=atoi(p);
+				while(*p!='.')
+					p++;
+				p++;
+				ptr[6]=atoi(p);
+				len=4;
+			}
+			break;
+		case 1:
+			{
+				if(dev==(cmd-1))
+				ptr=config_socket0_local_port;
+			}
+		case 2:
+			{
+				if(dev==(cmd-1))
+				ptr=config_socket1_local_port;
+			}
+		case 3:
+			{
+				if(dev==(cmd-1))
+				ptr=config_socket2_local_port;
+			}
+		case 4:
+			{
+				if(dev==(cmd-1))
+					ptr=config_socket3_local_port;
+				if(ptr!=NULL)
+				{
+					ptr[3]=(g_conf.local_port[cmd-1]>>8)&0xff;
+					ptr[4]=g_conf.local_port[cmd-1]&0xff;
+					len=2;
+				}				
+			}			
+			break;
+		case 5:
+			{
+				ptr=config_sub_msk;
+				p=g_conf.sub_msk;
+				ptr[3]=atoi(p);
+				while(*p!='.')
+					p++;
+				p++;
+				ptr[4]=atoi(p);
+				while(*p!='.')
+					p++;
+				p++;
+				ptr[5]=atoi(p);
+				while(*p!='.')
+					p++;
+				p++;
+				ptr[6]=atoi(p);
+				len=4;
+			}
+			break;
+		case 6:
+			{
+				ptr=config_gw;
+				p=g_conf.gw;
+				ptr[3]=atoi(p);
+				while(*p!='.')
+					p++;
+				p++;
+				ptr[4]=atoi(p);
+				while(*p!='.')
+					p++;
+				p++;
+				ptr[5]=atoi(p);
+				while(*p!='.')
+					p++;
+				p++;
+				ptr[6]=atoi(p);
+				len=4;
+			}
+			break;
+		case 7:
+			{
+				ptr=config_mac;				
+				p=g_conf.mac;
+				ptr[3]=atoi(p);
+				while(*p!='.')
+					p++;
+				p++;
+				ptr[4]=atoi(p);
+				while(*p!='.')
+					p++;
+				p++;
+				ptr[5]=atoi(p);
+				while(*p!='.')
+					p++;
+				p++;
+				ptr[6]=atoi(p);
+				while(*p!='.')
+					p++;
+				p++;
+				ptr[7]=atoi(p);
+				while(*p!='.')
+					p++;
+				p++;
+				ptr[8]=atoi(p);
+				len=6;
+			}
+			break;	
+		case 8:
+			if(dev==(cmd-8))				
+			ptr=config_socket0_ip;
+		case 9:
+			if(dev==(cmd-8))
+			ptr=config_socket1_ip;
+		case 10:
+			if(dev==(cmd-8))
+			ptr=config_socket2_ip;
+		case 11:
+			{
+				if(dev==(cmd-8))
+				ptr=config_socket3_ip;
+				if(ptr!=NULL)
+				{
+					p=g_conf.remote_ip[cmd-8];
+					ptr[3]=atoi(p);
+					while(*p!='.')
+						p++;
+					p++;
+					ptr[4]=atoi(p);
+					while(*p!='.')
+						p++;
+					p++;
+					ptr[5]=atoi(p);
+					while(*p!='.')
+						p++;
+					p++;
+					ptr[6]=atoi(p);
+					len=4;
+				}
+			}
+			break;
+		case 12:
+			if(dev==(cmd-12))
+			ptr=config_socket0_ip6;
+		case 13:
+			if(dev==(cmd-12))
+			ptr=config_socket1_ip6;
+		case 14:
+			if(dev==(cmd-12))
+			ptr=config_socket2_ip6;
+		case 15:
+			{
+				if(dev==(cmd-12))
+				ptr=config_socket3_ip6;
+				if(ptr!=NULL)
+				{
+					p=g_conf.remote_ip6[cmd-12];
+					for(i=0;i<sizeof(g_conf.remote_ip6[cmd-12]);i++)
+						ptr[3+i]=p[i];
+					len=64;
+				}
+			}
+			break;
+		case 16:
+			if(dev==(cmd-16))
+			ptr=config_socket0_remote_port;
+		case 17:
+			if(dev==(cmd-16))
+			ptr=config_socket1_remote_port;
+		case 18:
+			if(dev==(cmd-16))
+			ptr=config_socket2_remote_port;
+		case 19:
+			{
+				if(dev==(cmd-16))
+					ptr=config_socket3_remote_port;
+				if(ptr!=NULL)
+				{
+					ptr[3]=(g_conf.remote_port[cmd-16]>>8)&0xff;
+					ptr[4]=g_conf.remote_port[cmd-16]&0xff;
+					len=2;
+				}
+			}
+			break;
+		case 20:
+			if(dev==(cmd-20))
+			ptr=config_net_protol0;
+		case 21:
+			if(dev==(cmd-20))
+			ptr=config_net_protol1;
+		case 22:
+			if(dev==(cmd-20))
+			ptr=config_net_protol2;
+		case 23:
+			{
+				if(dev==(cmd-20))
+				ptr=config_net_protol3;
+				if(ptr!=NULL)
+				{
+					ptr[3]=(g_conf.config[cmd-20]&CONFIG_IPV6)?1:0;
+					len=1;
+				}
+			}
+			break;
+		case 24:
+			if(dev==(cmd-24))
+			ptr=config_socket_mode0;
+		case 25:
+			if(dev==(cmd-24))
+			ptr=config_socket_mode1;
+		case 26:
+			if(dev==(cmd-24))
+			ptr=config_socket_mode2;
+		case 27:
+			{
+				if(dev==(cmd-24))
+				ptr=config_socket_mode3;
+				if(ptr!=NULL)
+				{
+					ptr[3]=(g_conf.config[cmd-24]&CONFIG_SERVER)?1:0;
+					len=1;
+				}
+			}
+			break;
+		case 28:
+			if(dev==(cmd-28))
+			ptr=config_uart_baud0;
+		case 29:
+			if(dev==(cmd-28))
+			ptr=config_uart_baud1;
+		case 30:
+			if(dev==(cmd-28))
+			ptr=config_uart_baud2;
+		case 31:
+			{
+				if(dev==(cmd-28))
+				ptr=config_uart_baud3;
+				if(ptr!=NULL)
+				{
+					ptr[3]=g_conf.config[cmd-28]>>3;
+					len=1;
+				}
+			}
+			break;
+		case 32:
+			{
+				ptr=config_local_ip6;
+				if(ptr!=NULL)
+				{
+					p=g_conf.local_ip6;
+					for(i=0;i<sizeof(g_conf.local_ip6);i++)
+						ptr[3+i]=p[i];
+					len=64;
+				}
+			}
+			break;
+		case 33:
+			if(dev==(cmd-33))
+			ptr=config_tcp0;
+		case 34:
+			if(dev==(cmd-33))
+			ptr=config_tcp1;
+		case 35:
+			if(dev==(cmd-33))
+			ptr=config_tcp2;
+		case 36:
+			{
+				if(dev==(cmd-33))
+				ptr=config_tcp3;
+				if(ptr!=NULL)
+				{
+					ptr[3]=(g_conf.config[cmd-33]&CONFIG_TCP)?1:0;
+					len=1;
+				}
+			}
+			break;
+
+		default:
+			break;
+	}
+	if(ptr!=NULL)
+	{
+		ptr[0]=0xf5;ptr[1]=0x8b;ptr[2]=cmd;
+		ptr[len+3]=0x26;ptr[len+4]=0xfa;
+		for(i=0;i<len+5;i++)
+			crc=crc+ptr[i];
+		ptr[len+5]=(crc>>8)&0xff;
+		ptr[len+6]=(crc)&0xff;
+		*lenout=len+7;
+	}
+	return ptr;
+}
+void common_rw_config(int dev)
+{
+
+	rt_uint8_t buf[65];
+	rt_uint8_t i=0,delay=0;	
+	int data_len,crc_len,longlen=0;
+	unsigned char crc[2];
+	char ch;	
+	int lenout;
+	rt_uint8_t len=0,param;
+	enum STATE_OP state=GET_F5;
+	DBG("enter common_rw_config\r\n");
+	rt_uint8_t *ptr=(rt_uint8_t *)buf;
+	configlock();
+	while(1)
+	{
+		if(rt_device_read(common_dev[dev], 0, &ch, 1)==1)
+		{
+		if(ch==0xf5 && state==GET_F5)
+		{
+			DBG("GET_F5\n");
+			state=GET_8A_8B;
+		}
+		else if(ch==0x8a && state==GET_8A_8B)
+		{
+			DBG("GET_8A\n");
+			data_len=0;
+			longlen=0;
+			state=GET_DATA;
+		}
+		else if(ch==0x8b && state==GET_8A_8B)
+		{
+			DBG("GET_8B\n");
+			rt_device_read(common_dev[dev], 0, &ch, 1);
+			DBG("GET %d\n",ch);
+			char *tmp=send_out(dev,ch,&lenout);
+			if(tmp!=NULL)
+			{
+				int ii=0;
+				for(ii=0;ii<lenout;ii++)
+					DBG("%2x ",tmp[ii]);
+				rt_device_write(common_dev[dev], 0, (void *)tmp, lenout);
+			}
+			else
+				DBG("some error\n");
+			break;
+		}
+		else if(state==GET_DATA)
+		{	
+			DBG("GET_DATA %2x\n",ch);
+			*(ptr+data_len)=ch;
+			if(data_len==0)
+			{
+				if(ch==0x0c || ch==0x0d || ch==0x0e || ch==0x0f || ch==0x20)
+					state=GET_LEN;
+ 			}
+			else
+			{
+				if(ch==0x26&&(data_len>longlen))
+					state=GET_FA;
+ 			}
+			
+			data_len++;
+		}
+		else if(state==GET_LEN)
+		{
+			DBG("GET_LEN %2x\n",ch);
+			longlen=ch;
+			state=GET_DATA;
+		}
+		else if(ch==0xfa && state==GET_FA)
+		{
+			DBG("GET_FA\n");
+			data_len--;
+			crc_len=0;
+			state=GET_CHECSUM;
+		}
+		else if(state==GET_CHECSUM)
+		{
+			if(crc_len!=1)
+			{
+				crc[crc_len++]=ch;
+				DBG("GET_SUM %2x\n",ch);
+			}
+			else
+			{
+				crc[crc_len++]=ch;
+				DBG("GET_SUM %2x\n",ch);
+				//verify checksum
+				int verify=0xf5+0x8a+0xfa+0x26+longlen;
+				rt_kprintf("command is \n");
+				for(i=0;i<data_len;i++)
+				{
+					rt_kprintf("%2x ",ptr[i]);	
+					verify+=ptr[i];
+				}
+				rt_kprintf("crc is %2x %2x,verify is %x\n",crc[0],crc[1],verify);
+				if(verify!=(crc[0]<<8|crc[1]))
+				{
+					rt_device_write(common_dev[dev], 0, (void *)COMMAND_FAIL, strlen(COMMAND_FAIL));
+				}
+				else
+				{
+					rt_device_write(common_dev[dev], 0, (void *)COMMAND_OK, strlen(COMMAND_OK));
+					set_config(ptr,longlen,dev);					
+				}
+				state=GET_F5;
+				break;
+			}
+		}
+		else
+		{
+			state=GET_F5;			
+			break;
+		}
+	}
+		else
+			{
+				rt_thread_delay(1);
+				delay++;
+				if(delay>10)
+					break;
+			}
+	}
+	configunlock();
+	return ;
+}
+#endif
+
+static bool flag_cnn[4]={false,false,false,false};
+void all_cut()
+{
+	MAP_GPIOPinWrite(GPIO_PORTB_BASE,GPIO_PIN_4,GPIO_PIN_4);	
+	MAP_GPIOPinWrite(GPIO_PORTE_BASE,GPIO_PIN_5,0); 
+	MAP_GPIOPinWrite(GPIO_PORTK_BASE,GPIO_PIN_2,0); 
+	flag_cnn[0]=false;
+	flag_cnn[1]=false;
+	flag_cnn[2]=false;
+	flag_cnn[3]=false;
+}
+void cnn_out(int index,int level)
+{
+	
+	
+	if(phy_link)
+	{
+		if(level&&(flag_cnn[index]==false))
+			flag_cnn[index]=true;
+		else if(!level&&(flag_cnn[index]==true))
+			flag_cnn[index]=false;
+		else
+			return;
+		rt_kprintf("dev %d , level %d, phy_link %d\n",index,level,phy_link);
+		switch(index)
+		{
+			case 0:
+				if(level)
+					MAP_GPIOPinWrite(GPIO_PORTB_BASE,GPIO_PIN_4,0);
+				else
+					MAP_GPIOPinWrite(GPIO_PORTB_BASE,GPIO_PIN_4,GPIO_PIN_4);
+				break;
+			case 1:
+				if(level)
+					MAP_GPIOPinWrite(GPIO_PORTE_BASE,GPIO_PIN_5,GPIO_PIN_5);
+				else
+					MAP_GPIOPinWrite(GPIO_PORTE_BASE,GPIO_PIN_5,0);	
+				break;
+			case 2:
+				if(level)
+					MAP_GPIOPinWrite(GPIO_PORTK_BASE,GPIO_PIN_2,GPIO_PIN_2);
+				else
+					MAP_GPIOPinWrite(GPIO_PORTK_BASE,GPIO_PIN_2,0);	
+				break;
+			case 3:
+				if(level)
+				;//	MAP_GPIOPinWrite(GPIO_PORTB_BASE,GPIO_PIN_4,GPIO_PIN_4);
+				else
+				;//	MAP_GPIOPinWrite(GPIO_PORTB_BASE,GPIO_PIN_4,0);	
+				break;
+			default:
+				break;
+		}
+	}
+	else
+	{
+		MAP_GPIOPinWrite(GPIO_PORTB_BASE,GPIO_PIN_4,GPIO_PIN_4);	
+		MAP_GPIOPinWrite(GPIO_PORTE_BASE,GPIO_PIN_5,0);	
+		MAP_GPIOPinWrite(GPIO_PORTK_BASE,GPIO_PIN_2,0);	
+		flag_cnn[0]=false;
+		flag_cnn[1]=false;
+		flag_cnn[2]=false;
+		flag_cnn[3]=false;
+		//MAP_GPIOPinWrite(GPIO_PORTB_BASE,GPIO_PIN_4,0);	
+	}
+}
+int baud(int type)
+{
+	rt_kprintf("intput %d\n",type);
+	switch(type)
+	{
+		case 0:
+			return 115200;
+		case 1:
+			return 128000;
+		case 2:
+			return 256000;
+		case 3:
+			return 460800;
+		case 4:
+			return 921600;
+		case 5:
+			return 1000000;
+		case 6:
+			return 2000000;
+		case 7:
+			return 4000000;
+		case 8:
+			return 6000000;
+		}
+	return 0;
+}
+void print_config(config g)
+{
+	rt_kprintf("\n============================================================================>\n");
+	rt_kprintf("local_ip %s\n",g.local_ip);
+	rt_kprintf("local_ip6 %s\n",g.local_ip6);
+	rt_kprintf("local_port0 %d\n",g.local_port[0]);
+	rt_kprintf("local_port1 %d\n",g.local_port[1]);
+	rt_kprintf("local_port2 %d\n",g.local_port[2]);
+	rt_kprintf("local_port3 %d\n",g.local_port[3]);
+	rt_kprintf("sub_msk %s\n",g.sub_msk);
+	rt_kprintf("gw %s\n",g.gw);
+	rt_kprintf("mac %s\n",g.mac);
+	rt_kprintf("remote_ip0 %s\n",g.remote_ip[0]);
+	rt_kprintf("remote_ip1 %s\n",g.remote_ip[1]);
+	rt_kprintf("remote_ip2 %s\n",g.remote_ip[2]);
+	rt_kprintf("remote_ip3 %s\n",g.remote_ip[3]);
+	rt_kprintf("remote_ip60 %s\n",g.remote_ip6[0]);
+	rt_kprintf("remote_ip61 %s\n",g.remote_ip6[1]);
+	rt_kprintf("remote_ip62 %s\n",g.remote_ip6[2]);
+	rt_kprintf("remote_ip63 %s\n",g.remote_ip6[3]);
+	rt_kprintf("remote_port0 %d\n",g.remote_port[0]);
+	rt_kprintf("remote_port1 %d\n",g.remote_port[1]);
+	rt_kprintf("remote_port2 %d\n",g.remote_port[2]);
+	rt_kprintf("remote_port3 %d\n",g.remote_port[3]);
+	rt_kprintf("IP socket0 %s socket1 %s socket2 %s socket3 %s\n",((g.config[0]&0x01)==0)?"IPV4":"IPV6",((g.config[1]&0x01)==0)?"IPV4":"IPV6",((g.config[2]&0x01)==0)?"IPV4":"IPV6",((g.config[3]&0x01)==0)?"IPV4":"IPV6");
+	rt_kprintf("protol socket0 %s socket1 %s socket2 %s socket3 %s\n",((g.config[0]&0x02)==0x02)?"TCP":"UDP",((g.config[1]&0x02)==0x02)?"TCP":"UDP",((g.config[2]&0x02)==0x02)?"TCP":"UDP",((g.config[3]&0x02)==0x02)?"TCP":"UDP");
+	rt_kprintf("mode socket0 %s socket1 %s socket2 %s socket3 %s\n",((g.config[0]&0x04)==0x04)?"SERVER":"CLIENT",((g.config[1]&0x04)==0x04)?"SERVER":"CLIENT",((g.config[2]&0x04)==0x04)?"SERVER":"CLIENT",((g.config[3]&0x04)==0x04)?"SERVER":"CLIENT");
+	rt_kprintf("baud %d.%d.%d.%d\n",baud((g.config[0]&0xf8)>>3),baud((g.config[1]&0xf8)>>3),baud((g.config[2]&0xf8)>>3),baud((g.config[3]&0xf8)>>3));
+	rt_kprintf("\n============================================================================>\n");
+}
+int common_w_socket(int dev)
+{	
+	int len;
+	rt_uint8_t /*common_buf[2048],*/*ptr;
+	ptr=rt_malloc(2048);
+	len=rt_device_read(common_dev[dev], 0, ptr, 2048);
+	#if CONFIG_IT	
+	if(phy_link&&(len>0)&&g_socket[dev].connected)
+	{
+		int i;
+		for(i=0;i<10;i++)
+		{
+			char *tmp=rt_malloc(len);
+			rt_memcpy(tmp,ptr,len);
+			rt_data_queue_push(&g_data_queue[dev*2], tmp, len, RT_WAITING_FOREVER);	
+		}
+	}
+	
+	rt_free(ptr);
+	#else
+	if(phy_link&&(len>0)&&g_socket[dev].connected)
+		rt_data_queue_push(&g_data_queue[dev*2], ptr, len, RT_WAITING_FOREVER);	
+	else
+		rt_free(ptr);
+	#endif
+	return 0;
+}
+static rt_err_t common_rx_ind(rt_device_t dev, rt_size_t size)
+{
+    /* release semaphore to let finsh thread rx data */
+	//DBG("dev %d common_rx_ind %d\r\n",which_common_dev(common_dev,dev),size);
+    rt_sem_release(&(rx_sem[which_common_dev(common_dev,dev)]));
+    return RT_EOK;
+}
+
+void common_w(void* parameter)
+{
+	int dev=((int)parameter)/2;
+	static int flag[4]={0,0,0,0};
+	DBG("common_w %d Enter\r\n",dev);
+	while (1)
+	{
+		/* wait receive */
+		if (rt_sem_take(&(rx_sem[dev]), RT_WAITING_FOREVER) != RT_EOK) continue;
+		#if CONFIG_BIN
+		//DBG("to read in_low %d\r\n",ind_low(dev));
+		if(ind[dev])
+		{	
+			//DBG("dev %d in socket data flag %d\n",dev,flag);
+			if(flag[dev]==1)
+			{
+				print_config(g_conf);
+				flag[dev]=0;	
+				void *ptr1=(void *)&g_confb;
+				void *ptr2=(void *)&g_conf;
+				if(rt_memcmp(ptr1,ptr2,sizeof(config))!=0)
+				{
+					#if CONFIG_IT					
+					common_w_socket(dev);
+					times=0;
+					#endif
+					print_config(g_conf);
+				}
+			}
+			
+			/*socket data transfer,use dma*/
+			#if !CONFIG_IT
+			common_w_socket(dev);
+			#else
+			char cha;
+			while(rt_device_read(common_dev[dev], &cha, &cha, 1)==1);
+			#endif
+		}
+		else
+		{
+			DBG("dev %d in config data flag %d\n",dev,flag[dev]);
+			if(flag[dev]==0)
+			{
+				flag[dev]=1;
+				void *ptr1=(void *)&g_confb;
+				void *ptr2=(void *)&g_conf;
+				rt_memcpy(ptr1,ptr2,sizeof(config));
+			}
+			common_rw_config(dev);
+			
+		}
+		#else
+		common_w_socket(dev);
+		#endif
+	}
+}
+void common_w_usb(void* parameter)
+{
+	int dev=((int)parameter)/2;
+	rt_kprintf("common_w_usb %d\n",dev);
+	while(1)
+	{
+		if (rt_sem_take(&(rx_sem[dev]), RT_WAITING_FOREVER) != RT_EOK) continue;
+		_usb_read(dev);
+	}
+	
+}
+
+static void common_r(void* parameter)
+{
+    rt_size_t data_size;
+    const void *last_data_ptr;
+	void *data_ptr;
+	int dev=(int)parameter;
+	rt_err_t r;
+	while(1)
+	{
+		r=rt_data_queue_pop(&g_data_queue[dev], &last_data_ptr, &data_size, RT_WAITING_FOREVER);
+		//rt_data_queue_pop(&(g_data_queue[dev]), &last_data_ptr, &data_size, 0);
+       // if (rt_data_queue_peak(&(g_data_queue[dev]), &data_ptr, &data_size) == RT_EOK)
+       // {
+			if(r==RT_EOK && data_size!=0 && last_data_ptr)
+			{		
+				//if(dev==1)
+				{
+					#if CONFIG_IT
+					if(times<=10){
+					#endif
+					//dillon rt_device_write(common_dev[(dev-1)/2], 0, last_data_ptr, data_size);
+					//rt_kprintf("write index %d,%d\n",dev,data_size);
+					_usb_write(dev,last_data_ptr,data_size);
+					#if CONFIG_IT
+					times++;}
+					#endif
+				}
+				//else
+					//rt_data_queue_push(&g_data_queue[dev-1], last_data_ptr, data_size, RT_WAITING_FOREVER);
+				//if(dev==1)
+				rt_free(last_data_ptr);
+			}
+        //}
+		//else
+			//rt_thread_delay(1);
+		//if(last_data_ptr)
+		//	rt_free(last_data_ptr);
+	}
+}
+
+/*init common1,2,3,4 for 4 socket*/
+int common_init(int dev)//0 uart , 1 parallel bus, 2 usb
+{
+	/*init common device*/
+	rt_err_t result;
+	rt_uint8_t common[10];
+	int i,max_devices=4;
+	/*read config data from internal flash*/
+	MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOE);
+	MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOK);
+	MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOD);
+	MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);
+
+	MAP_SysCtlDelay(1);
+	//config select
+	MAP_GPIOIntDisable(GPIO_PORTD_BASE, GPIO_PIN_2);
+	MAP_GPIOPinTypeGPIOInput(GPIO_PORTD_BASE, GPIO_PIN_2);//ind0
+	MAP_GPIOIntTypeSet(GPIO_PORTD_BASE, GPIO_PIN_2, GPIO_BOTH_EDGES);
+	MAP_IntEnable(INT_GPIOD);
+	MAP_GPIOIntEnable(GPIO_PORTD_BASE, GPIO_PIN_2);
+	int ui32Status = MAP_GPIOIntStatus(GPIO_PORTD_BASE, true);
+	MAP_GPIOIntClear(GPIO_PORTD_BASE, ui32Status);
+	//connect ind
+	MAP_GPIOPinTypeGPIOOutput(GPIO_PORTE_BASE, GPIO_PIN_5);//CNN1
+	MAP_GPIOPinTypeGPIOOutput(GPIO_PORTK_BASE, GPIO_PIN_2);//CNN2
+	MAP_GPIOPinTypeGPIOOutput(GPIO_PORTK_BASE, GPIO_PIN_3);//CNN3
+	MAP_GPIOPinTypeGPIOOutput(GPIO_PORTB_BASE, GPIO_PIN_4);//CNN4
+	MAP_GPIOPinWrite(GPIO_PORTB_BASE,GPIO_PIN_4,GPIO_PIN_4);	
+	MAP_GPIOPinWrite(GPIO_PORTE_BASE,GPIO_PIN_5,0);	
+	MAP_GPIOPinWrite(GPIO_PORTK_BASE,GPIO_PIN_2,0);	
+	default_config();
+	memset(config_local_ip,0,11);config_local_ip[11]='\0';
+	memset(config_sub_msk,0,11);config_local_ip[11]='\0';
+	memset(config_gw,0,11);config_local_ip[11]='\0';
+	memset(config_socket3_ip,0,11);config_local_ip[11]='\0';
+	memset(config_socket0_ip,0,11);config_local_ip[11]='\0';
+	memset(config_socket1_ip,0,11);config_local_ip[11]='\0';
+	memset(config_socket2_ip,0,11);config_local_ip[11]='\0';
+	memset(config_socket0_local_port,0,9);config_local_ip[11]='\0';
+	memset(config_socket1_local_port,0,9);config_local_ip[11]='\0';
+	memset(config_socket2_local_port,0,9);config_local_ip[11]='\0';
+	memset(config_socket3_local_port,0,9);config_local_ip[11]='\0';
+	memset(config_socket0_remote_port,0,9);config_local_ip[11]='\0';
+	memset(config_socket1_remote_port,0,9);config_local_ip[11]='\0';
+	memset(config_socket2_remote_port,0,9);config_local_ip[11]='\0';
+	memset(config_socket3_remote_port,0,9);config_local_ip[11]='\0';
+	memset(config_mac,0,13);config_local_ip[11]='\0';
+	memset(config_socket0_ip6,0,71);config_local_ip[11]='\0';
+	memset(config_socket1_ip6,0,71);config_local_ip[11]='\0';
+	memset(config_socket2_ip6,0,71);config_local_ip[11]='\0';
+	memset(config_socket3_ip6,0,71);config_local_ip[11]='\0';
+	memset(config_local_ip6,0,71);config_local_ip6[71]='\0';
+	memset(config_net_protol0,0,8);config_net_protol0[8]='\0';
+	memset(config_net_protol1,0,8);config_net_protol1[8]='\0';
+	memset(config_net_protol2,0,8);config_net_protol2[8]='\0';
+	memset(config_net_protol3,0,8);config_net_protol3[8]='\0';
+	memset(config_socket_mode0,0,8);config_socket_mode0[8]='\0';
+	memset(config_socket_mode1,0,8);config_socket_mode1[8]='\0';
+	memset(config_socket_mode2,0,8);config_socket_mode2[8]='\0';
+	memset(config_socket_mode3,0,8);config_socket_mode3[8]='\0';
+	memset(config_uart_baud0,0,8);config_uart_baud0[8]='\0';
+	memset(config_uart_baud1,0,8);config_uart_baud1[8]='\0';
+	memset(config_uart_baud2,0,8);config_uart_baud2[8]='\0';
+	memset(config_uart_baud3,0,8);config_uart_baud3[8]='\0';
+	memset(config_tcp0,0,8);config_tcp0[8]='\0';
+	memset(config_tcp1,0,8);config_tcp1[8]='\0';
+	memset(config_tcp2,0,8);config_tcp2[8]='\0';
+	memset(config_tcp3,0,8);config_tcp3[8]='\0';
+	rt_mutex_init(&mconfigutex, "config_mutex", RT_IPC_FLAG_FIFO);
+/*
+	for(i=3;i<67;i++)
+	{
+		config_socket0_ip6[i]=0xff;
+		config_socket1_ip6[i]=0xff;
+		config_socket2_ip6[i]=0xff;
+		config_socket3_ip6[i]=0xff;
+		config_local_ip6[i]=0xff;
+	}
+	config_socket0_ip6[67]=0x26;
+	config_socket1_ip6[67]=0x26;
+	config_socket2_ip6[67]=0x26;
+	config_socket3_ip6[67]=0x26;
+	config_local_ip6[67]=0x26;
+	config_socket0_ip6[68]=0xfa;
+	config_socket1_ip6[68]=0xfa;
+	config_socket2_ip6[68]=0xfa;
+	config_socket3_ip6[68]=0xfa;
+	config_local_ip6[68]=0xfa;
+*/
+	if(dev==DEV_USB)
+		max_devices=5;
+	for(i=0;i<max_devices;i++)
+	{
+		//config sem
+		rt_sprintf(common,"common_%d_rx",i);
+		rt_sem_init(&(rx_sem[i]), common, 0, 0);
+		rt_sprintf(common,"usb_%d_rx",i);
+		rt_sem_init(&(usbrx_sem[i]), common, 0, 0);
+		if(dev==DEV_UART)
+		{
+			if(i==1)
+				rt_sprintf(common,"uart%d",4);
+			else
+				rt_sprintf(common,"uart%d",i);
+		
+			DBG("To open ==>%s\n",common);
+			//open uart ,parallel ,usb
+			common_dev[i] = rt_device_find(common);
+			if (common_dev[i] == RT_NULL)
+			{
+				DBG("app_common: can not find device: %s\n",common);
+				return 0;
+			}
+			if (rt_device_open(common_dev[i], RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_INT_RX | RT_DEVICE_FLAG_INT_TX) == RT_EOK)
+			{
+				//create common_w,r thread to read data from socket write to uart,parallel,usb
+				//or read from uart,parallel,usb write to socket
+				rt_sprintf(common,"common_wx%d",i);
+				tid_common_w[i] = rt_thread_create(common,common_w, (void *)(i*2),4096, 20, 10);
+				rt_sprintf(common,"common_rx%d",i);
+				tid_common_r[i] = rt_thread_create(common,common_r, (void *)(i*2+1),2048, 20, 10);
+
+				rt_device_set_rx_indicate(common_dev[i], common_rx_ind);
+
+				if(tid_common_w[i]!=RT_NULL)
+					rt_thread_startup(tid_common_w[i]);			
+				if(tid_common_r[i]!=RT_NULL)
+					rt_thread_startup(tid_common_r[i]);
+			}
+		}
+		else if(dev==DEV_BUS)
+		{
+
+		}
+		else
+		{
+			//init usbbulk,read data from usb,and transfer data to 4 socket thread by 4 ctl line
+			//create 4 common_r thread read data from 4 socket thread,and put data to usb,control 4 ind line
+			if(i==0)
+			_usb_init();
+			rt_kprintf("uub %d\n",i);
+			rt_sprintf(common,"common_wx%d",i);
+			tid_common_w[i] = rt_thread_create(common,common_w_usb, (void *)(i*2),4096, 20, 10);	
+			if(tid_common_w[i]!=RT_NULL)
+				rt_thread_startup(tid_common_w[i]);	
+			if(i!=4){
+			rt_sprintf(common,"common_rx%d",i);
+			tid_common_r[i] = rt_thread_create(common,common_r, (void *)(i*2+1),2048, 20, 10);
+				
+			if(tid_common_r[i]!=RT_NULL)
+				rt_thread_startup(tid_common_r[i]);
+				}
+		}
+	}
+	print_config(g_conf);
+	//rt_thread_delay(300);	
+	for(i=0;i<4;i++)
+	{
+		g_chang[i].cs=g_chang[i].lip6c=g_chang[i].lpc=g_chang[i].mode=g_chang[i].protol=g_chang[i].rip4c=g_chang[i].rip6c=g_chang[i].rpc=0;
+		socket_thread_start(i);
+	}
+	//rt_thread_delay(100);
+	//list_mem1();	
+	//list_tcps1();
+	//list_thread();
+	
+	DBG("common_init ok\n");
+	//list_mem1();	
+	return 1;
+}
+#endif
diff --git a/bsp/tm4c129x/applications/con_socket.c b/bsp/tm4c129x/applications/con_socket.c
new file mode 100755
index 0000000..ca4908c
--- /dev/null
+++ b/bsp/tm4c129x/applications/con_socket.c
@@ -0,0 +1,1025 @@
+#include "con_socket.h"
+#include <rtdevice.h>
+#include <lwip/netdb.h>
+#include <lwip/sockets.h>
+
+/*client use socket,server use netconn*/
+#define BUF_SIZE 2048
+rt_thread_t tid_w[4]={RT_NULL,RT_NULL,RT_NULL,RT_NULL},tid_r[4]={RT_NULL,RT_NULL,RT_NULL,RT_NULL};
+extern struct rt_semaphore fifo_sem;
+struct rt_mutex mutex[4];
+extern bool ind[4];
+bool socket_config(int dev);
+
+bool is_right(char config,char flag)
+{
+	if((config&flag)==flag)
+		return true;
+	else
+		return false;
+}
+void lock(int i)
+{
+    rt_err_t result;
+
+    result = rt_mutex_take(&mutex[i], RT_WAITING_FOREVER);
+    if (result != RT_EOK)
+    {
+        RT_ASSERT(0);
+    }
+}
+void unlock(int i)
+{
+    rt_mutex_release(&mutex[i]);
+}
+#if 0
+void socket_ip6_w(void *paramter)
+{
+	int dev=(int)paramter;
+	rt_size_t data_size;
+	const void *last_data_ptr;
+	struct timeval tv;
+	fd_set myset;
+	int status;
+	tv.tv_sec = 0; 
+    tv.tv_usec = 10000; 
+	rt_kprintf("socket_ip6_w==> %d , %s mode, %s , %s . Thread Enter\r\n",dev,is_right(g_conf.config[dev],CONFIG_SERVER)?"Server":"Client",is_right(g_conf.config[dev],CONFIG_IPV6)?"IPV6":"IPV4",is_right(g_conf.config[dev],CONFIG_TCP)?"TCP":"UDP");
+	while(1)
+	{
+		if(!g_ip6[dev].connected)
+		{
+			rt_thread_delay(10);
+			continue;
+		}
+		cnn_out(dev,1);
+		FD_ZERO(&myset);
+		int sock;
+		if(is_right(g_conf.config[dev],CONFIG_SERVER))
+        	sock=g_ip6[dev].clientfd;
+		else
+			sock=g_ip6[dev].sockfd;
+		FD_SET(sock, &myset);
+		if(select(sock+1,NULL, &myset,  NULL, &tv) > 0) 
+		{ 
+			rt_data_queue_pop(&g_data_queue[dev*2], &last_data_ptr, &data_size, 0);
+			if(data_size>0)
+			{
+				lock(dev);
+				if(is_right(g_conf.config[dev],CONFIG_TCP))
+				{
+					status=send(sock, last_data_ptr, data_size, 0);				
+				}
+				else
+				{
+					if(is_right(g_conf.config[dev],CONFIG_SERVER))
+						status=sendto(g_ip6[dev].sockfd, last_data_ptr, data_size, 0, (struct sockaddr *)&g_ip6[dev].client_addr6, sizeof(g_ip6[dev].client_addr6));
+					else
+						status=sendto(g_ip6[dev].sockfd, last_data_ptr, data_size, 0, (struct sockaddr *)&g_ip6[dev].server_addr6, sizeof(g_ip6[dev].server_addr6));
+				}
+				unlock(dev);
+				if( status< 0)
+				{
+					rt_kprintf("Thread ip6_w%d send error\n",dev,errno);
+					if(is_right(g_conf.config[dev],CONFIG_TCP))
+					{
+						rt_kprintf("Thread ip6_w%d send error %d\n",dev,errno);
+						//g_ip6[dev].connected=false;
+						cnn_out(dev,0);
+					}
+				}
+			}
+		}
+	}
+}
+void socket_ip6_r(void *paramter)
+{
+	int dev=(int)paramter;
+	struct sockaddr_in6 server_addr6;	
+	int status;
+	fd_set myset; 
+  	struct timeval tv; 
+  	socklen_t lon; 
+	int valopt,ret; 
+	struct sockaddr_in6 client_addr6;
+	tv.tv_sec = 0; 
+    tv.tv_usec = 10000; 
+	rt_kprintf("socket_ip6_r==> %d , %s mode, %s , %s . Thread Enter\r\n",dev,is_right(g_conf.config[dev],CONFIG_SERVER)?"Server":"Client",is_right(g_conf.config[dev],CONFIG_IPV6)?"IPV6":"IPV4",is_right(g_conf.config[dev],CONFIG_TCP)?"TCP":"UDP");
+	while(1)
+	{
+		if(g_ip6[dev].connected==false)
+		{
+			if(is_right(g_conf.config[dev],CONFIG_SERVER))
+			{				
+				rt_kprintf("socket_ip6_r %d to accept %d\n",dev,g_ip6[dev].sockfd);
+				rt_uint32_t  sin_size = sizeof(struct sockaddr_in6);
+				FD_ZERO(&myset);
+		        FD_SET(g_ip4[dev].sockfd, &myset);
+		        if(select(g_ip6[dev].sockfd+1, &myset, 0, 0, &tv) > 0 )
+		        {
+					g_ip6[dev].clientfd = accept(g_ip6[dev].sockfd, (struct sockaddr *)&client_addr6, &sin_size);
+					if(g_ip6[dev].clientfd!=-1)
+					{
+						rt_kprintf("socket_ip6_r %d I got a connection from (IP:%s, PORT:%d\n) fd %d\n", dev,inet6_ntoa(client_addr6.sin6_addr), ntohs(client_addr6.sin6_port),g_ip6[dev].clientfd);
+						g_ip6[dev].connected=true;
+						cnn_out(dev,1);
+						char a=1;
+						setsockopt(g_ip6[dev].clientfd, SOL_SOCKET, SO_KEEPALIVE, &a, sizeof(char));										
+					}
+		        }
+			}
+			else
+			{
+				//rt_kprintf("to connect ipv6\n");
+				status = connect(g_ip6[dev].sockfd, (struct sockaddr *)&g_ip6[dev].server_addr6, sizeof(g_ip6[dev].server_addr6));
+				if(status==0)
+				{
+					g_ip6[dev].connected=true;
+					cnn_out(dev,1);
+					int imode=0;
+					ioctlsocket(g_ip6[dev].sockfd, FIONBIO, &imode);
+				}
+				else if(errno==EINPROGRESS)
+				{
+					
+			        FD_ZERO(&myset); 
+			        FD_SET(g_ip6[dev].sockfd, &myset);
+			        if(select(g_ip6[dev].sockfd+1, NULL, &myset, NULL, &tv) > 0) 
+					{ 
+					   if(FD_ISSET(g_ip6[dev].sockfd,&myset))
+					   {
+				           lon = sizeof(int); 
+				           getsockopt(g_ip6[dev].sockfd, SOL_SOCKET, SO_ERROR, (void*)(&valopt), &lon); 
+				           if(!valopt) 
+						   { 
+				              rt_kprintf("OK Connection is done\n"); 
+							  g_ip6[dev].connected=true;
+							  cnn_out(dev,1);
+							  int imode=0;
+							  ioctlsocket(g_ip6[dev].sockfd, FIONBIO, &imode);
+							 continue;           
+				           }
+					   	}
+			        }
+				}
+				lock(dev);
+				closesocket(g_ip6[dev].sockfd);
+				g_ip6[dev].sockfd= socket(PF_INET6, SOCK_STREAM, 0);		
+				unlock(dev);
+				int imode = 1;
+				setsockopt(g_ip6[dev].sockfd,SOL_SOCKET,SO_KEEPALIVE,&imode,sizeof(imode));
+				ioctlsocket(g_ip6[dev].sockfd, FIONBIO, &imode);
+				
+			}			
+		}
+		if(g_ip6[dev].connected==false)
+		{
+			rt_thread_delay(10);			
+			continue;
+		}
+		//if(need_reconfig(dev))
+		//{
+			
+		//}
+		cnn_out(dev,1);
+		socklen_t clientlen = sizeof(g_ip6[dev].server_addr6);
+		FD_ZERO(&myset); 
+		int sock;
+		if(is_right(g_conf.config[dev],CONFIG_SERVER))
+        	sock=g_ip6[dev].clientfd;
+		else
+			sock=g_ip6[dev].sockfd;
+		FD_SET(sock, &myset);
+        if(select(sock+1, &myset, NULL, NULL, &tv) > 0) 
+		{ 
+			if(is_right(g_conf.config[dev],CONFIG_TCP))
+			{
+				status=recv(sock, g_ip6[dev].recv_data, BUF_SIZE, 0);	
+				if(status>0)
+				{
+					if(ind[dev])
+					rt_data_queue_push(&g_data_queue[dev*2+1], g_ip6[dev].recv_data, status, RT_WAITING_FOREVER);
+				}
+				else
+				{
+					rt_kprintf("Thread ip6_r_%d recv error,connection lost\n",dev);
+					if(is_right(g_conf.config[dev],CONFIG_SERVER))
+					{
+						
+							rt_kprintf("Thread ip6_r%d recv error %d\n",dev,errno);	
+							lock(dev);
+							closesocket(g_ip6[dev].clientfd);
+							unlock(dev);
+							g_ip6[dev].connected=false;
+							cnn_out(dev,0);
+					}
+					else
+					{
+						
+							rt_kprintf("Thread ip6_r%d recv error %d\n",dev,errno);	
+							lock(dev);
+							closesocket(g_ip6[dev].sockfd);
+							unlock(dev);
+							g_ip6[dev].sockfd= socket(PF_INET6, SOCK_STREAM, 0);						
+							int imode = 1;
+							setsockopt(g_ip6[dev].sockfd,SOL_SOCKET,SO_KEEPALIVE,&imode,sizeof(imode));
+							ioctlsocket(g_ip6[dev].sockfd, FIONBIO, &imode);
+							g_ip6[dev].connected=false;
+							cnn_out(dev,0);
+					}
+				}
+
+			}
+			else
+			{	
+				status=recvfrom(g_ip6[dev].sockfd, g_ip6[dev].recv_data, BUF_SIZE, 0, (struct sockaddr *)&g_ip6[dev].server_addr6, &clientlen);
+				//rt_kprintf("socket_ip6_r status %d\n",status);
+				if(status>0)
+				{
+					if(ind[dev])
+					rt_data_queue_push(&g_data_queue[dev*2+1], g_ip6[dev].recv_data, status, RT_WAITING_FOREVER);	
+				}
+				else
+				{
+					rt_kprintf("Thread ip6_r_%d Recvfrom error,connection lost\n",dev);
+				}
+			}	
+        }
+	}
+	rt_kprintf("socket_ip6_r close\n");
+}
+
+bool socket_ip6(int dev)
+{	
+	/*create socket*/
+	if(is_right(g_conf.config[dev],CONFIG_TCP))
+		g_ip6[dev].sockfd= socket(PF_INET6, SOCK_STREAM, 0);
+	else
+		g_ip6[dev].sockfd= socket(PF_INET6, SOCK_DGRAM, 0);
+	if(g_ip6[dev].sockfd == -1)
+	{
+		rt_kprintf("Socket error\n");
+		return false;
+	}
+	int imode = 1;
+    setsockopt(g_ip6[dev].sockfd,SOL_SOCKET,SO_KEEPALIVE,&imode,sizeof(imode));	   
+	/*init sockaddr_in6 */
+	if(is_right(g_conf.config[dev],CONFIG_SERVER))
+	{//server mode
+		g_ip6[dev].server_addr6.sin6_family = AF_INET6;
+		memcpy(g_ip6[dev].server_addr6.sin6_addr.s6_addr, IP6_ADDR_ANY, 16);
+		g_ip6[dev].server_addr6.sin6_port = htons(g_conf.local_port[dev]);
+		if(bind(g_ip6[dev].sockfd, (struct sockaddr *)&g_ip6[dev].server_addr6, sizeof(struct sockaddr)) == -1)
+		{
+			rt_kprintf("Bind error\n");
+			lock(dev);
+			closesocket(g_ip6[dev].sockfd);
+			unlock(dev);
+			return false;
+		}
+		if(is_right(g_conf.config[dev],CONFIG_TCP))
+		{
+			rt_kprintf("socket_ip6 %d to listen %d\n",dev,g_ip6[dev].sockfd);
+			if(listen(g_ip6[dev].sockfd, 1) == -1)
+			{
+				rt_kprintf("Listen error\n");
+				lock(dev);
+				closesocket(g_ip6[dev].sockfd);
+				unlock(dev);
+				return false;
+			}
+		}
+		else
+		{
+			memset(&g_ip6[dev].client_addr6, 0, sizeof(g_ip6[dev].client_addr6));
+			g_ip6[dev].client_addr6.sin6_family = AF_INET6;
+			g_ip6[dev].client_addr6.sin6_port = htons(g_conf.remote_port[dev]);
+			if(inet_pton(AF_INET6, (char *)g_conf.remote_ip6[dev], &g_ip6[dev].client_addr6.sin6_addr.s6_addr) != 1)
+			{
+				rt_kprintf("inet_pton() error\n");
+				lock(dev);
+				closesocket(g_ip6[dev].sockfd);
+				unlock(dev);
+				return false;
+			}
+		}
+	}
+	else
+	{//client mode
+		memset(&g_ip6[dev].server_addr6, 0, sizeof(g_ip6[dev].server_addr6));
+		g_ip6[dev].server_addr6.sin6_family = AF_INET6;
+		g_ip6[dev].server_addr6.sin6_port = htons(g_conf.remote_port[dev]);
+		if(inet_pton(AF_INET6, g_conf.remote_ip6[dev], &g_ip6[dev].server_addr6.sin6_addr.s6_addr) != 1)
+		{
+			rt_kprintf("inet_pton() error\n");
+			lock(dev);
+			closesocket(g_ip6[dev].sockfd);
+			unlock(dev);
+			return false;
+		}
+		if(!is_right(g_conf.config[dev],CONFIG_TCP))
+		{
+			g_ip6[dev].client_addr6.sin6_family = AF_INET6;
+			memcpy(g_ip6[dev].client_addr6.sin6_addr.s6_addr, IP6_ADDR_ANY, 16);
+			g_ip6[dev].client_addr6.sin6_port = htons(g_conf.local_port[dev]);
+			if(bind(g_ip6[dev].sockfd, (struct sockaddr *)&g_ip6[dev].client_addr6, sizeof(struct sockaddr)) == -1)
+			{
+				rt_kprintf("Bind error\n");
+				lock(dev);
+				closesocket(g_ip6[dev].sockfd);
+				unlock(dev);
+				return false;
+			}
+		}
+		else
+		{
+			ioctlsocket(g_ip6[dev].sockfd, FIONBIO, &imode);
+		}
+	}
+	/*mall receive buffer*/		
+	g_ip6[dev].recv_data = rt_malloc(BUF_SIZE);
+	if(g_ip6[dev].recv_data == RT_NULL)
+	{
+		rt_kprintf(" ip6 %d No memory\n",dev);
+		lock(dev);
+		closesocket(g_ip6[dev].sockfd);
+		unlock(dev);
+		return false;
+	}
+	if(is_right(g_conf.config[dev],CONFIG_TCP))
+	{
+		g_ip6[dev].connected=false;
+		cnn_out(dev,0);
+	}
+	else
+	{
+		g_ip6[dev].connected=true;	
+		cnn_out(dev,1);
+	}
+	return true;
+}
+#endif
+void socket_w(void *paramter)
+{
+	int dev=(int)paramter;
+	rt_size_t data_size;
+	const void *last_data_ptr;
+	struct timeval tv;
+	fd_set myset;
+	int status;
+	tv.tv_sec = 0; 
+    tv.tv_usec = 10000; 
+	rt_kprintf("socket_ip4_w==> %d , %s mode, %s , %s . Thread Enter\r\n",dev,is_right(g_conf.config[dev],CONFIG_SERVER)?"Server":"Client",is_right(g_conf.config[dev],CONFIG_IPV6)?"IPV6":"IPV4",is_right(g_conf.config[dev],CONFIG_TCP)?"TCP":"UDP");
+	while(1)
+	{
+		rt_data_queue_pop(&g_data_queue[dev*2], &last_data_ptr, &data_size, RT_WAITING_FOREVER);
+		if(!g_socket[dev].connected)
+		{
+			rt_thread_delay(10);
+			rt_free(last_data_ptr);
+			continue;
+		}
+		cnn_out(dev,1);	
+		
+		FD_ZERO(&myset);
+		int sock;
+		if(is_right(g_conf.config[dev],CONFIG_SERVER)&&is_right(g_conf.config[dev],CONFIG_TCP))
+        	sock=g_socket[dev].clientfd;
+		else
+			sock=g_socket[dev].sockfd;
+		if(sock!=-1&&g_socket[dev].connected)
+		{		
+		FD_SET(sock, &myset);
+		if(select(sock+1,NULL, &myset,  NULL, &tv) > 0) 
+		{ 		
+			if(data_size>0)
+			{
+				lock(dev);
+				if(is_right(g_conf.config[dev],CONFIG_TCP))
+				{
+					status=send(sock, last_data_ptr, data_size, 0);
+				
+				}
+				else
+				{
+					if(is_right(g_conf.config[dev],CONFIG_SERVER))
+					{
+						if(is_right(g_conf.config[dev],CONFIG_IPV6))
+							status=sendto(g_socket[dev].sockfd, last_data_ptr, data_size, 0, (struct sockaddr *)&g_socket[dev].client_addr6, sizeof(g_socket[dev].client_addr6));
+						else
+							status=sendto(g_socket[dev].sockfd, last_data_ptr, data_size, 0, (struct sockaddr *)&g_socket[dev].client_addr, sizeof(g_socket[dev].client_addr));
+					}
+					else
+					{
+						if(is_right(g_conf.config[dev],CONFIG_IPV6))
+							status=sendto(g_socket[dev].sockfd, last_data_ptr, data_size, 0, (struct sockaddr *)&g_socket[dev].server_addr6, sizeof(g_socket[dev].server_addr6));
+						else
+							status=sendto(g_socket[dev].sockfd, last_data_ptr, data_size, 0, (struct sockaddr *)&g_socket[dev].server_addr, sizeof(g_socket[dev].server_addr));
+					}
+				}
+				unlock(dev);
+				if( status< 0)
+				{
+					if(is_right(g_conf.config[dev],CONFIG_TCP))
+					{
+						rt_kprintf("Thread socket_w%d send error %d\n",dev,errno);	
+						//cnn_out(dev,0);
+						//g_socket[dev].connected=false;
+					}//EINPROGRESS
+				} 
+			}
+		}
+		
+				
+			}
+		rt_free(last_data_ptr);
+	}
+	rt_kprintf("socket_ip_w %d close\n",dev);
+}
+void socket_r(void *paramter)
+{
+	int dev=(int)paramter;
+	int status;
+	fd_set myset; 
+  	struct timeval tv; 
+  	socklen_t lon; 
+	int valopt,ret; 
+	struct sockaddr_in client_addr;
+	struct sockaddr_in6 client_addr6;
+	tv.tv_sec = 0; 
+    tv.tv_usec = 10000; 
+	rt_kprintf("socket_ip4_r==> %d , %s mode, %s , %s . Thread Enter\r\n",dev,is_right(g_conf.config[dev],CONFIG_SERVER)?"Server":"Client",is_right(g_conf.config[dev],CONFIG_IPV6)?"IPV6":"IPV4",is_right(g_conf.config[dev],CONFIG_TCP)?"TCP":"UDP");
+	while(1)
+	{
+		if(need_reconfig(dev))
+		{
+			g_socket[dev].connected=false;			
+			lock(dev);
+			closesocket(g_socket[dev].sockfd);
+			closesocket(g_socket[dev].clientfd);
+			g_socket[dev].sockfd=-1;
+			g_socket[dev].clientfd=-1;
+			unlock(dev);
+			socket_config(dev);
+		}
+		if(g_socket[dev].connected==false)
+		{
+			if(is_right(g_conf.config[dev],CONFIG_SERVER))
+			{
+				rt_uint32_t  sin_size;
+				if(is_right(g_conf.config[dev],CONFIG_IPV6))
+					sin_size=sizeof(struct sockaddr_in6);
+				else
+					sin_size=sizeof(struct sockaddr_in);
+				FD_ZERO(&myset);
+		        FD_SET(g_socket[dev].sockfd, &myset);
+		        if(select(g_socket[dev].sockfd+1, &myset, 0, 0, &tv) > 0 )
+		        {
+		        	if(is_right(g_conf.config[dev],CONFIG_IPV6))
+						g_socket[dev].clientfd = accept(g_socket[dev].sockfd, (struct sockaddr *)&client_addr6, &sin_size);
+					else
+						g_socket[dev].clientfd = accept(g_socket[dev].sockfd, (struct sockaddr *)&client_addr, &sin_size);
+					if(g_socket[dev].clientfd!=-1)
+					{
+						if(is_right(g_conf.config[dev],CONFIG_IPV6))
+							rt_kprintf("socket_ip6_r %d I got a connection from (IP:%s, PORT:%d\n) fd %d\n", dev,inet6_ntoa(client_addr6.sin6_addr), ntohs(client_addr6.sin6_port),g_socket[dev].clientfd);								
+						else
+							rt_kprintf("socket_ip4_r %d I got a connection from (IP:%s, PORT:%d\n) fd %d\n", dev,inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port),g_socket[dev].clientfd);
+						g_socket[dev].connected=true;
+						cnn_out(dev,1);
+						char a=1;
+						setsockopt(g_socket[dev].clientfd, SOL_SOCKET, SO_KEEPALIVE, &a, sizeof(char));
+					}
+				}				
+			}
+			else
+			{
+				if(is_right(g_conf.config[dev],CONFIG_IPV6))
+					status = connect(g_socket[dev].sockfd, (struct sockaddr *)&g_socket[dev].server_addr6, sizeof(g_socket[dev].server_addr6));
+				else					
+					status = connect(g_socket[dev].sockfd, (struct sockaddr *)&g_socket[dev].server_addr, sizeof(g_socket[dev].server_addr));
+				if(status==0)
+				{
+					g_socket[dev].connected=true;
+					cnn_out(dev,1);
+					int imode=0;
+					ioctlsocket(g_socket[dev].sockfd, FIONBIO, &imode);
+					continue;
+				}
+				else if(errno==EINPROGRESS)
+				{
+					
+			        FD_ZERO(&myset); 
+			        FD_SET(g_socket[dev].sockfd, &myset);
+			        if(select(g_socket[dev].sockfd+1, NULL, &myset, NULL, &tv) > 0) 
+					{ 
+					   if(FD_ISSET(g_socket[dev].sockfd,&myset))
+					   {
+				           lon = sizeof(int); 
+				           getsockopt(g_socket[dev].sockfd, SOL_SOCKET, SO_ERROR, (void*)(&valopt), &lon); 
+				           if(!valopt) 
+						   { 
+				              rt_kprintf("OK Connection %d is done\n",dev); 
+							  g_socket[dev].connected=true;
+							  cnn_out(dev,1);
+							  int imode=0;
+							  ioctlsocket(g_socket[dev].sockfd, FIONBIO, &imode);
+							 continue;           
+				           }
+					   	}
+			        }
+				}
+				lock(dev);
+				closesocket(g_socket[dev].sockfd);
+				g_socket[dev].sockfd=-1;
+				unlock(dev);
+				if(is_right(g_conf.config[dev],CONFIG_IPV6))
+					g_socket[dev].sockfd= socket(PF_INET6, SOCK_STREAM, 0);		
+				else
+					g_socket[dev].sockfd= socket(PF_INET, SOCK_STREAM, 0);					
+				int imode = 1;
+				setsockopt(g_socket[dev].sockfd,SOL_SOCKET,SO_KEEPALIVE,&imode,sizeof(imode));
+				ioctlsocket(g_socket[dev].sockfd, FIONBIO, &imode);				
+			}			
+		}
+		if(g_socket[dev].connected==false)
+		{
+			rt_thread_delay(1);			
+			continue;
+		}
+		
+		cnn_out(dev,1);
+		socklen_t clientlen;
+		if(is_right(g_conf.config[dev],CONFIG_IPV6))
+			clientlen = sizeof(g_socket[dev].server_addr6);
+		else
+			clientlen = sizeof(g_socket[dev].server_addr);
+		FD_ZERO(&myset); 
+		int sock;
+		if(is_right(g_conf.config[dev],CONFIG_SERVER)&&is_right(g_conf.config[dev],CONFIG_TCP))
+        	sock=g_socket[dev].clientfd;
+		else
+			sock=g_socket[dev].sockfd;
+		FD_SET(sock, &myset);
+        if(select(sock+1, &myset, NULL, NULL, &tv) > 0) 
+		{ 
+			lock(dev);			
+			g_socket[dev].recv_data=rt_malloc(BUF_SIZE);
+			if(g_socket[dev].recv_data==NULL)
+			{
+				rt_kprintf("malloc recv_data failed\n");
+				//rt_thread_delay(10);
+				unlock(dev);
+				continue;
+			}
+			if(is_right(g_conf.config[dev],CONFIG_TCP))
+			{
+				status=recv(sock, g_socket[dev].recv_data, BUF_SIZE, 0);					
+				unlock(dev);
+				if(status>0)
+				{				
+					//rt_kprintf("get %d %d\n",status,ind[dev]);
+					if(ind[dev])
+					{
+						rt_data_queue_push(&g_data_queue[dev*2+1], g_socket[dev].recv_data, status, RT_WAITING_FOREVER);
+					}
+					else
+						rt_free(g_socket[dev].recv_data);
+				}
+				else
+				{
+					rt_free(g_socket[dev].recv_data);
+					rt_kprintf("Thread ip4_r_%d recv error,connection lost %d %d\n",dev,status,errno);
+					if(is_right(g_conf.config[dev],CONFIG_SERVER))
+					{
+						rt_kprintf("Thread ip4_r%d recv error %d\n",dev,errno);	
+						lock(dev);
+						closesocket(g_socket[dev].clientfd);
+						g_socket[dev].clientfd=-1;
+						unlock(dev);
+						g_socket[dev].connected=false;
+						cnn_out(dev,0);
+					}
+					else
+					{
+						rt_kprintf("Thread ip4_r%d recv error %d\n",dev,errno);	
+						lock(dev);
+						closesocket(g_socket[dev].sockfd);
+						g_socket[dev].sockfd=-1;
+						if(is_right(g_conf.config[dev],CONFIG_IPV6))
+							g_socket[dev].sockfd= socket(PF_INET6, SOCK_STREAM, 0);		
+						else
+							g_socket[dev].sockfd= socket(PF_INET, SOCK_STREAM, 0);
+						unlock(dev);
+						int imode = 1;
+						setsockopt(g_socket[dev].sockfd,SOL_SOCKET,SO_KEEPALIVE,&imode,sizeof(imode));
+						ioctlsocket(g_socket[dev].sockfd, FIONBIO, &imode);
+						g_socket[dev].connected=false;
+						cnn_out(dev,0);
+					}
+					
+				}
+
+			}
+			else
+			{
+				#if 1
+				if(is_right(g_conf.config[dev],CONFIG_SERVER))
+				{
+					if(is_right(g_conf.config[dev],CONFIG_IPV6))
+						status=recvfrom(g_socket[dev].sockfd, g_socket[dev].recv_data, BUF_SIZE, 0, (struct sockaddr *)&g_socket[dev].server_addr6, &clientlen);
+					else
+						status=recvfrom(g_socket[dev].sockfd, g_socket[dev].recv_data, BUF_SIZE, 0, (struct sockaddr *)&g_socket[dev].server_addr, &clientlen);
+				}
+				else
+				{
+					if(is_right(g_conf.config[dev],CONFIG_IPV6))
+						status=recvfrom(g_socket[dev].sockfd, g_socket[dev].recv_data, BUF_SIZE, 0, (struct sockaddr *)&g_socket[dev].client_addr6, &clientlen);
+					else
+						status=recvfrom(g_socket[dev].sockfd, g_socket[dev].recv_data, BUF_SIZE, 0, (struct sockaddr *)&g_socket[dev].client_addr, &clientlen);
+				}
+				unlock(dev);
+				#else
+				if(is_right(g_conf.config[dev],CONFIG_IPV6))
+					status=recvfrom(g_socket[dev].sockfd, g_socket[dev].recv_data, BUF_SIZE, 0, (struct sockaddr *)&g_socket[dev].server_addr6, &clientlen);
+				else						
+					status=recvfrom(g_socket[dev].sockfd, g_socket[dev].recv_data, BUF_SIZE, 0, (struct sockaddr *)&g_socket[dev].server_addr, &clientlen);
+				#endif
+				if(status>0)
+				{		
+					if(ind[dev])
+					rt_data_queue_push(&g_data_queue[dev*2+1], g_socket[dev].recv_data, status, RT_WAITING_FOREVER);
+					else
+						rt_free(g_socket[dev].recv_data);
+				}
+				else
+				{
+					rt_kprintf("Thread socket_r_%d Recvfrom error,connection lost\n",dev);
+				}
+			}
+		}
+		
+	}
+}
+void test_select_connect()
+{
+	struct sockaddr_in server_addr;
+	fd_set myset; 
+  	struct timeval tv; 
+  	socklen_t lon; 
+	int res=-1, valopt,sockfd,ret; 
+	int imode = 1;  
+	memset(&server_addr, 0, sizeof(server_addr));
+	server_addr.sin_family = AF_INET;
+	server_addr.sin_port = htons(1234);
+	server_addr.sin_addr.s_addr=inet_addr("192.168.1.6");
+	rt_memset(&(server_addr.sin_zero),0, sizeof(server_addr.sin_zero));
+	rt_thread_delay(300);
+	//list_mem1();
+	//list_tcps1();
+	//list_thread();
+	//EINPROGRESS
+			
+	do
+	{	
+		sockfd= socket(PF_INET, SOCK_STREAM, 0);
+	    setsockopt(sockfd,SOL_SOCKET,SO_KEEPALIVE,&imode,sizeof(imode));
+	    ioctlsocket(sockfd, FIONBIO, &imode);
+	    ret=connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr));
+		rt_kprintf("verify ret\n");
+		if(ret==0)
+			break;
+		else if(errno==EINPROGRESS)
+		{
+			tv.tv_sec = 0; 
+	        tv.tv_usec = 10000; 
+	        FD_ZERO(&myset); 
+	        FD_SET(sockfd, &myset);
+	        if(select(sockfd+1, NULL, &myset, NULL, &tv) > 0) 
+			{ 
+			   if(FD_ISSET(sockfd,&myset))
+			   {
+		           lon = sizeof(int); 
+		           getsockopt(sockfd, SOL_SOCKET, SO_ERROR, (void*)(&valopt), &lon); 
+		           if(!valopt) 
+				   { 
+		              rt_kprintf("OK Connection is done\n"); 
+					  break;		           
+		           }
+				   else
+		           {
+		           	  //rt_kprintf("Error in connection() %d\n", valopt); 
+					  closesocket(sockfd);
+		           }
+			   	   
+			   }
+			   closesocket(sockfd);
+	        } 
+	        else
+			{  
+			   closesocket(sockfd);
+	        }			
+		}
+		else
+		{
+			 rt_kprintf("Error connecting %d\n", errno); 
+			 closesocket(sockfd);
+		}
+	}
+	while(1);
+	rt_thread_delay(10);
+	//list_mem1();
+//	list_tcps1();
+	//list_thread();
+	imode=0;
+	ioctlsocket(sockfd, FIONBIO, &imode); 
+	send(sockfd,"1234",sizeof("1234"),0);
+	closesocket(sockfd);
+	rt_thread_delay(10);
+	//list_mem1();
+	//list_tcps1();
+	//list_thread();
+}
+void test_select_accept()
+{
+	struct sockaddr_in server_addr;
+	fd_set myset; 
+  	struct timeval tv; 
+  	socklen_t lon; 
+	int res=-1, valopt,sockfd,ret,clientfd; 
+	struct sockaddr_in client_addr;
+	int imode = 1;  
+	memset(&server_addr, 0, sizeof(server_addr));
+	server_addr.sin_family = AF_INET;
+	server_addr.sin_port = htons(1234);
+	server_addr.sin_addr.s_addr=INADDR_ANY;
+	rt_memset(&(server_addr.sin_zero),0, sizeof(server_addr.sin_zero));
+	rt_thread_delay(200);
+	//list_mem1();
+	//list_tcps1();
+	//list_thread();
+	//EINPROGRESS
+	sockfd= socket(PF_INET, SOCK_STREAM, 0);
+    setsockopt(sockfd,SOL_SOCKET,SO_KEEPALIVE,&imode,sizeof(imode));
+    ioctlsocket(sockfd, FIONBIO, &imode);
+	if(bind(sockfd, (struct sockaddr *)&server_addr, sizeof(struct sockaddr)) == -1)
+	{
+		rt_kprintf("Bind error\n");
+		closesocket(sockfd);
+		return ;
+	}
+	if(listen(sockfd, 1) == -1)
+	{
+		rt_kprintf("Listen error\n");
+		closesocket(sockfd);
+		return ;
+	}
+	do
+	{	
+		tv.tv_sec = 0; 
+	    tv.tv_usec = 1000; 
+		FD_ZERO(&myset);
+        FD_SET(sockfd, &myset);
+        if(lwip_select(sockfd+1, &myset, 0, 0, &tv) == 0 )
+        {
+			rt_kprintf("Time out Server select\n");
+			continue;
+		}
+	    rt_uint32_t  sin_size = sizeof(struct sockaddr_in);
+		clientfd = accept(sockfd, (struct sockaddr *)&client_addr, &sin_size);
+		rt_kprintf("clientfd %d\n",clientfd);
+		break;
+	}while(1);
+	rt_thread_delay(10);
+	//list_mem1();
+	//list_tcps1();
+	//list_thread();
+	imode=0;
+	ioctlsocket(clientfd, FIONBIO, &imode); 
+	send(clientfd,"1234",sizeof("1234"),0);
+	closesocket(clientfd);
+	closesocket(sockfd);
+	rt_thread_delay(10);
+	//list_mem1();
+	//list_tcps1();
+	//list_thread();
+}
+
+bool socket_config(int dev)
+{	
+	/*create socket*/
+	if(is_right(g_conf.config[dev],CONFIG_TCP))
+	{
+		if(is_right(g_conf.config[dev],CONFIG_IPV6))
+			g_socket[dev].sockfd= socket(PF_INET6, SOCK_STREAM, 0);
+		else
+			g_socket[dev].sockfd= socket(PF_INET, SOCK_STREAM, 0);
+	}
+	else
+	{
+		if(is_right(g_conf.config[dev],CONFIG_IPV6))
+			g_socket[dev].sockfd= socket(PF_INET6, SOCK_DGRAM, 0);
+		else
+			g_socket[dev].sockfd= socket(PF_INET, SOCK_DGRAM, 0);
+	}
+
+	if(g_socket[dev].sockfd == -1)
+	{
+		rt_kprintf("Socket error\n");
+		return false;
+	}
+	int imode = 1;
+    setsockopt(g_socket[dev].sockfd,SOL_SOCKET,SO_KEEPALIVE,&imode,sizeof(imode));	  
+	setsockopt(g_socket[dev].sockfd, SOL_SOCKET, SO_REUSEADDR, &imode, sizeof(imode) );
+	/*init sockaddr_in */
+	if(is_right(g_conf.config[dev],CONFIG_SERVER))
+	{//server mode
+		if(is_right(g_conf.config[dev],CONFIG_IPV6))
+		{
+			g_socket[dev].server_addr6.sin6_family = AF_INET6;
+			memcpy(g_socket[dev].server_addr6.sin6_addr.s6_addr, IP6_ADDR_ANY, 16);
+			g_socket[dev].server_addr6.sin6_port = htons(g_conf.local_port[dev]);
+			if(bind(g_socket[dev].sockfd, (struct sockaddr *)&g_socket[dev].server_addr6, sizeof(struct sockaddr)) == -1)
+			{
+				rt_kprintf("Server Bind error\n");
+				lock(dev);
+				closesocket(g_socket[dev].sockfd);
+				unlock(dev);
+				return false;
+			}
+			if(is_right(g_conf.config[dev],CONFIG_TCP))
+			{
+				rt_kprintf("socket %d to listen %d\n",dev,g_socket[dev].sockfd);
+				if(listen(g_socket[dev].sockfd, 1) == -1)
+				{
+					rt_kprintf("Listen error\n");
+					lock(dev);
+					closesocket(g_socket[dev].sockfd);
+					unlock(dev);
+					return false;
+				}
+			}
+			else
+			{
+				memset(&g_socket[dev].client_addr6, 0, sizeof(g_socket[dev].client_addr6));
+				g_socket[dev].client_addr6.sin6_family = AF_INET6;
+				g_socket[dev].client_addr6.sin6_port = htons(g_conf.remote_port[dev]);
+				if(inet_pton(AF_INET6, (char *)g_conf.remote_ip6[dev], &g_socket[dev].client_addr6.sin6_addr.s6_addr) != 1)
+				{
+					rt_kprintf("inet_pton() error\n");
+					lock(dev);
+					closesocket(g_socket[dev].sockfd);
+					unlock(dev);
+					return false;
+				}
+			}
+
+		}
+		else
+		{
+			g_socket[dev].server_addr.sin_family = AF_INET;
+			g_socket[dev].server_addr.sin_addr.s_addr = INADDR_ANY;
+			g_socket[dev].server_addr.sin_port = htons(g_conf.local_port[dev]);
+			rt_memset(&(g_socket[dev].server_addr.sin_zero),0, sizeof(g_socket[dev].server_addr.sin_zero));
+			if(bind(g_socket[dev].sockfd, (struct sockaddr *)&g_socket[dev].server_addr, sizeof(struct sockaddr)) == -1)
+			{
+				rt_kprintf("Server Bind %d error\n",g_conf.local_port[dev]);
+				lock(dev);
+				closesocket(g_socket[dev].sockfd);
+				unlock(dev);
+				return false;
+			}
+			if(is_right(g_conf.config[dev],CONFIG_TCP))
+			{
+				rt_kprintf("to listen %d\n",g_socket[dev].sockfd);
+				if(listen(g_socket[dev].sockfd, 1) == -1)
+				{
+					rt_kprintf("Listen error\n");
+					lock(dev);
+					closesocket(g_socket[dev].sockfd);
+					unlock(dev);
+					return false;
+				}
+			}
+			else
+			{
+				memset(&g_socket[dev].client_addr, 0, sizeof(g_socket[dev].client_addr));
+				g_socket[dev].client_addr.sin_family = AF_INET;
+				g_socket[dev].client_addr.sin_port = htons(g_conf.remote_port[dev]);
+				rt_memset(&(g_socket[dev].client_addr.sin_zero),0, sizeof(g_socket[dev].client_addr.sin_zero));
+				g_socket[dev].client_addr.sin_addr.s_addr=inet_addr(g_conf.remote_ip[dev]);
+			}
+		}
+		
+	}
+	else
+	{//client mode
+		if(is_right(g_conf.config[dev],CONFIG_IPV6))
+		{
+			memset(&g_socket[dev].server_addr6, 0, sizeof(g_socket[dev].server_addr6));
+			g_socket[dev].server_addr6.sin6_family = AF_INET6;
+			g_socket[dev].server_addr6.sin6_port = htons(g_conf.remote_port[dev]);
+			if(inet_pton(AF_INET6, g_conf.remote_ip6[dev], &g_socket[dev].server_addr6.sin6_addr.s6_addr) != 1)
+			{
+				rt_kprintf("inet_pton() error\n");
+				lock(dev);
+				closesocket(g_socket[dev].sockfd);
+				unlock(dev);
+				return false;
+			}
+			if(!is_right(g_conf.config[dev],CONFIG_TCP))
+			{
+				g_socket[dev].client_addr6.sin6_family = AF_INET6;
+				memcpy(g_socket[dev].client_addr6.sin6_addr.s6_addr, IP6_ADDR_ANY, 16);
+				g_socket[dev].client_addr6.sin6_port = htons(g_conf.local_port[dev]);
+				if(bind(g_socket[dev].sockfd, (struct sockaddr *)&g_socket[dev].client_addr6, sizeof(struct sockaddr)) == -1)
+				{
+					rt_kprintf("Client Bind %d error\n",g_conf.local_port[dev]);
+					lock(dev);
+					closesocket(g_socket[dev].sockfd);
+					unlock(dev);
+					return false;
+				}
+			}
+			else
+				ioctlsocket(g_socket[dev].sockfd, FIONBIO, &imode);
+		}
+		else
+		{
+			memset(&g_socket[dev].server_addr, 0, sizeof(g_socket[dev].server_addr));
+			g_socket[dev].server_addr.sin_family = AF_INET;
+			g_socket[dev].server_addr.sin_port = htons(g_conf.remote_port[dev]);
+			rt_memset(&(g_socket[dev].server_addr.sin_zero),0, sizeof(g_socket[dev].server_addr.sin_zero));
+			g_socket[dev].server_addr.sin_addr.s_addr=inet_addr(g_conf.remote_ip[dev]);
+			rt_kprintf("to connect %s,port %d\n",g_conf.remote_ip[dev],g_conf.remote_port[dev]);
+			if(!is_right(g_conf.config[dev],CONFIG_TCP))
+			{
+				g_socket[dev].client_addr.sin_family = AF_INET;
+				g_socket[dev].client_addr.sin_addr.s_addr = INADDR_ANY;
+				g_socket[dev].client_addr.sin_port = htons(g_conf.local_port[dev]);
+				rt_memset(&(g_socket[dev].client_addr.sin_zero),0, sizeof(g_socket[dev].client_addr.sin_zero));
+				if(bind(g_socket[dev].sockfd, (struct sockaddr *)&g_socket[dev].client_addr, sizeof(struct sockaddr)) == -1)
+				{
+					rt_kprintf("Client Bind %d error\n",g_conf.local_port[dev]);
+					lock(dev);
+					closesocket(g_socket[dev].sockfd);
+					unlock(dev);
+					return false;
+				}
+			}
+			else
+			 ioctlsocket(g_socket[dev].sockfd, FIONBIO, &imode);
+		}
+	}
+	/*mall receive buffer*/
+	/*g_socket[dev].recv_data = rt_malloc(BUF_SIZE);
+	if(g_socket[dev].recv_data == RT_NULL)
+	{
+		rt_kprintf(" socket %d No memory\n",dev);
+		lock(dev);
+		closesocket(g_socket[dev].sockfd);
+		unlock(dev);
+		return false;
+	}*/
+	if(is_right(g_conf.config[dev],CONFIG_TCP))
+	{
+		g_socket[dev].connected=false;
+		cnn_out(dev,0);
+	}
+	else
+	{
+		g_socket[dev].connected=true;	
+		cnn_out(dev,1);
+	}
+	return true;
+}
+
+/*init socket 1,2,3,4*/
+void socket_thread_start(int i)
+{
+	rt_uint8_t *thread_string;	
+	thread_string=(rt_uint8_t *)rt_malloc(20*sizeof(rt_uint8_t));
+	rt_memset(thread_string,'\0',20);
+	rt_kprintf("%s Socket==> %d , %s mode, %s , %s . Thread Enter\r\n","Create",i,is_right(g_conf.config[i],CONFIG_SERVER)?"Server":"Client",is_right(g_conf.config[i],CONFIG_IPV6)?"IPV6":"IPV4",is_right(g_conf.config[i],CONFIG_TCP)?"TCP":"UDP");
+	if(tid_w[i]==RT_NULL && tid_r[i]==RT_NULL)
+	{
+		rt_sprintf(thread_string,"socket_%d_mu",i);
+		rt_mutex_init(&mutex[i], thread_string, RT_IPC_FLAG_FIFO);
+		g_socket[i].connected=false;
+		if(socket_config(i))
+		{
+			rt_sprintf(thread_string,"%d%d%c%c_w",i,is_right(g_conf.config[i],CONFIG_IPV6)?6:4,is_right(g_conf.config[i],CONFIG_TCP)?'T':'U',is_right(g_conf.config[i],CONFIG_SERVER)?'S':'C');
+			tid_w[i] = rt_thread_create(thread_string,socket_w, (void *)i,2048, 20, 10);
+			rt_sprintf(thread_string,"%d%d%c%c_r",i,is_right(g_conf.config[i],CONFIG_IPV6)?6:4,is_right(g_conf.config[i],CONFIG_TCP)?'T':'U',is_right(g_conf.config[i],CONFIG_SERVER)?'S':'C');
+			tid_r[i] = rt_thread_create(thread_string,socket_r, (void *)i,2048, 20, 10);
+		}		
+		if (tid_w[i] != RT_NULL)
+			rt_thread_startup(tid_w[i]);
+		if (tid_r[i] != RT_NULL)
+			rt_thread_startup(tid_r[i]);		
+	}
+	rt_free(thread_string);
+}
+#ifdef RT_USING_FINSH
+#include <finsh.h>
+FINSH_FUNCTION_EXPORT(socket_thread_start, ctl socket);
+#endif
diff --git a/bsp/tm4c129x/applications/con_socket.h b/bsp/tm4c129x/applications/con_socket.h
new file mode 100755
index 0000000..e3deb2d
--- /dev/null
+++ b/bsp/tm4c129x/applications/con_socket.h
@@ -0,0 +1,73 @@
+#ifndef CON_SOCKET_H
+#define CON_SOCKET_H
+#include <rtthread.h>
+#include <board.h>
+#include <components.h>
+#include <rtdevice.h>
+#include <lwip/netdb.h>
+#include <lwip/sockets.h>
+
+typedef struct {
+	rt_uint8_t local_ip[16];
+	rt_uint8_t local_ip6[64];
+	rt_uint16_t local_port[4];
+	rt_uint8_t sub_msk[16];
+	rt_uint8_t gw[16];
+	rt_uint8_t mac[64];
+	rt_uint8_t remote_ip[4][16];
+	rt_uint8_t remote_ip6[4][64];
+	rt_uint16_t remote_port[4];
+	rt_uint8_t config[4];//bit0 ipv4 or ipv6 	,bit1 tcp or udp , bit2 server or client ,bit 3 to bit 7 uart baud
+}config,*pconfig;
+typedef struct {
+	rt_uint8_t lip6c;	//local ip6 addr changed
+	rt_uint8_t rip4c;	//remote ip4 addr changed
+	rt_uint8_t rip6c;	//remote ip6 addr changed
+	rt_uint8_t lpc;		//local port changed
+	rt_uint8_t rpc;		//remote port changed
+	rt_uint8_t protol;  //ipv4 or ipv6 changed
+	rt_uint8_t mode;    //tcp or udp changed
+	rt_uint8_t cs;		//client or server
+}change;
+change g_chang[4];
+config g_conf,g_confb;
+#define CONFIG_IPV6 			0x01
+#define CONFIG_TCP 				0x02
+#define CONFIG_SERVER 			0x04
+#define CONFIG_BAUD_115200 		0x08
+#define CONFIG_BAUD_460800 		0x10
+#define CONFIG_BAUD_921600 		0x20
+#define CONFIG_BAUD_2000000 	0x40
+#define CONFIG_BAUD_4000000 	0x80
+#define CONFIG_BAUD_6000000 	0x88
+#define DEV_UART 0
+#define DEV_BUS 1
+#define DEV_USB 2
+
+
+void socket_init();
+struct rt_data_queue *g_data_queue;
+typedef struct socket_type
+{
+	struct sockaddr_in6 server_addr6;
+	struct sockaddr_in6 client_addr6;
+	struct sockaddr_in server_addr;
+	struct sockaddr_in client_addr;
+	int sockfd;
+	int clientfd;
+	char *recv_data;
+	bool connected;
+}socket_t,*psocket_t;
+
+socket_t g_socket[4];
+void cnn_out(int index,int level);
+void socket_ctl(bool open,int i);
+
+//void socket_send(int index,rt_uint8_t *data,int len);
+#define debug 1
+#if debug
+#define DBG rt_kprintf
+#else
+#define DBG 
+#endif
+#endif
diff --git a/bsp/tm4c129x/applications/con_usb.c b/bsp/tm4c129x/applications/con_usb.c
new file mode 100755
index 0000000..a139293
--- /dev/null
+++ b/bsp/tm4c129x/applications/con_usb.c
@@ -0,0 +1,297 @@
+#include <rthw.h>
+#include <rtthread.h>
+#include <rtdevice.h>
+#include "con_socket.h"
+
+#include "board.h"
+//#include <components.h>
+
+#include "inc/hw_memmap.h"
+#include "driverlib/sysctl.h"
+#include "driverlib/gpio.h"
+#include "driverlib/uart.h"
+#include "driverlib/pin_map.h"
+#include "driverlib/interrupt.h"
+#include "driverlib/rom_map.h"
+#include "usblib/usblib.h"
+#include "usblib/usbcdc.h"
+#include "usblib/usb-ids.h"
+#include "usblib/device/usbdevice.h"
+#include "usblib/device/usbdcomp.h"
+#include "usblib/device/usbdbulk.h"
+
+#include "usb_comp_bulk_structs.h"
+extern bool phy_link;
+int usb_1=0;
+static struct rt_device_usb _hw_usb;
+unsigned char *buf;
+uint32_t len;
+uint8_t g_pucDescriptorData[DESCRIPTOR_DATA_SIZE];
+extern uint8_t g_ppui8USBRxBuffer[NUM_BULK_DEVICES][UART_BUFFER_SIZE];
+extern uint8_t g_ppcUSBTxBuffer[NUM_BULK_DEVICES][UART_BUFFER_SIZE_TX];
+extern struct rt_semaphore rx_sem[4];
+extern struct rt_semaphore usbrx_sem[4];
+uint32_t send_len;
+rt_size_t _usb_init()
+{
+
+	int i=0;
+	PinoutSet(false, true); 
+	for(i=0;i<NUM_BULK_DEVICES;i++)
+	{
+	   USBBufferInit(&g_sTxBuffer[i]);
+	   USBBufferInit(&g_sRxBuffer[i]);
+	
+	   g_sCompDevice.psDevices[i].pvInstance = USBDBulkCompositeInit(0, &g_psBULKDevice[i], &g_psCompEntries[i]);
+	}
+   USBDCompositeInit(0, &g_sCompDevice, DESCRIPTOR_DATA_SIZE,g_pucDescriptorData);
+
+    return 0;
+}
+int which_usb_device(tUSBDBulkDevice *psDevice)
+{
+	int i=0;
+	for(i=0;i<NUM_BULK_DEVICES;i++)
+		if(psDevice==&(g_psBULKDevice[i]))
+			break;
+
+	return i;
+}
+uint32_t
+TxHandlerBulk(void *pvCBData, uint32_t ui32Event, uint32_t ui32MsgValue,
+          void *pvMsgData)
+{
+    //
+    // We are not required to do anything in response to any transmit event
+    // in this example. All we do is update our transmit counter.
+    //
+    if(ui32Event == USB_EVENT_TX_COMPLETE)
+    {
+        //g_ui32TxCount += ui32MsgValue;
+         int index=which_usb_device((tUSBDBulkDevice *)pvCBData);
+		//rt_kprintf("packet sent %d,length %d\n",index,ui32MsgValue);
+		send_len=ui32MsgValue;
+		rt_sem_release(&(usbrx_sem[index]));
+    }
+    return(0);
+}
+
+uint32_t
+RxHandlerBulk(void *pvCBData, uint32_t ui32Event, uint32_t ui32MsgValue,
+          void *pvMsgData)
+{
+    //
+    // Which event are we being sent?
+    //
+    
+	 unsigned char *tmpbuf;
+     tUSBDBulkDevice *psDevice;
+     psDevice = (tUSBDBulkDevice *)pvCBData;
+	 int index=which_usb_device(psDevice);
+    switch(ui32Event)
+    {
+        //
+        // We are connected to a host and communication is now possible.
+        //
+        case USB_EVENT_CONNECTED:
+        {
+            //
+            // Flush our buffers.
+            //
+            USBBufferFlush(&g_sTxBuffer[index]);
+            USBBufferFlush(&g_sRxBuffer[index]);
+			rt_kprintf("usb connect %d\n",index);
+			if(index==1)
+				usb_1=1;
+            break;
+        }
+
+        //
+        // The host has disconnected.
+        //
+        case USB_EVENT_DISCONNECTED:
+        {
+			rt_kprintf("usb disconnect %d\n",index);
+			if(index==1)
+				usb_1=0;
+            break;
+        }
+
+        //
+        // A new packet has been received.
+        //
+        case USB_EVENT_RX_AVAILABLE:
+        {
+			#if 0
+			tmpbuf=rt_malloc(64);
+			int bytes=USBBufferRead(&g_sRxBuffer[index],tmpbuf,64);
+			if(index!=0)
+			{
+				rt_kprintf("read index %d ,bytes %d\n",index,bytes);
+				//USBBufferWrite(&g_sTxBuffer[index],tmpbuf,bytes);		
+				if(phy_link&&(bytes>0)&&g_socket[index-1].connected)
+					rt_data_queue_push(&g_data_queue[(index-1)*2], tmpbuf, bytes, RT_WAITING_FOREVER);	
+				else
+					rt_free(tmpbuf);
+			}
+			else
+			{
+				USBBufferWrite(&g_sTxBuffer[index],tmpbuf,bytes);
+				rt_free(tmpbuf);
+			}
+			#endif
+			rt_sem_release(&(rx_sem[index]));
+			//rt_kprintf("release %d\n",index);
+            return 0;
+        }
+
+        //
+        // Ignore SUSPEND and RESUME for now.
+        //
+        case USB_EVENT_SUSPEND:
+        case USB_EVENT_RESUME:
+            break;
+
+        //
+        // Ignore all other events and return 0.
+        //
+        default:
+            break;
+    }
+
+    return(0);
+}
+
+int _usb_read(int index)
+{   
+    //return USBBufferRead(&g_sRxBuffer[index],buffer,size);
+   
+		//rt_kprintf("get sem %d\n",index);
+		unsigned char *tmpbuf=rt_malloc(64);
+		int bytes=USBBufferRead(&g_sRxBuffer[index],tmpbuf,64);
+		if(bytes!=0&&usb_1==1)
+		{
+			if(index!=0)
+			{
+			//	rt_kprintf("read index %d ,bytes %d\n",index,bytes);
+				//USBBufferWrite(&g_sTxBuffer[index],tmpbuf,bytes); 	
+				if(phy_link&&(bytes>0)&&g_socket[index-1].connected)
+					rt_data_queue_push(&g_data_queue[(index-1)*2], tmpbuf, bytes, RT_WAITING_FOREVER);	
+				else
+					rt_free(tmpbuf);
+			}
+			else
+			{
+				USBBufferWrite(&g_sTxBuffer[index],tmpbuf,bytes);
+				rt_free(tmpbuf);
+			}
+		}
+		else
+			rt_free(tmpbuf);
+
+	
+}
+static void _delay_us(uint32_t us)
+{
+    volatile uint32_t len;
+    for (; us > 0; us --)
+        for (len = 0; len < 20; len++ );
+}
+
+int _usb_write(int index, void *buffer, int size)
+{
+	int len=0,len_out=0,tmp_size=size,size64=64,send_size=0,addr=0;
+	//rt_kprintf("_usb_write index %d,size %d\n",index,size);
+	//send_size=USBBufferWrite(&g_sTxBuffer[index],buffer,size);
+	//rt_sem_take(&(usbrx_sem[index]), RT_WAITING_FOREVER);
+	//rt_kprintf("_usb_write %d %d %d\n",size,send_size,send_len);
+	//return 0;
+	//len_out=USBBufferSpaceAvailable(&g_sTxBuffer[index]);
+	//rt_kprintf("===>%d %d\n",size,len_out);
+	if(index==3)
+		index=2;
+	else if(index==5)
+		index=3;
+	else if(index==7)
+		index=4;
+	while(tmp_size!=0)
+	{
+		len_out=USBBufferSpaceAvailable(&g_sTxBuffer[index]);
+		if(len_out==0)
+		{
+			//rt_thread_delay(1);
+			_delay_us(1);
+		}
+		else
+		{
+			if(tmp_size>len_out)
+				send_size=len_out;
+			else
+				send_size=tmp_size;
+			USBBufferWrite(&g_sTxBuffer[index],buffer+addr,send_size);
+			//rt_sem_take(&(usbrx_sem[index]), RT_WAITING_FOREVER);
+			addr=addr+send_size;
+			tmp_size=tmp_size-send_size;
+			//rt_kprintf("tmp_size %d,send_size %d\n",tmp_size,send_size);
+		}
+	}
+	//rt_kprintf("<===\n");
+	return 0;
+	int loop=size/64;
+	int last_bytes=size%64;
+	//rt_kprintf("_usb_write %d loop %d ,last_bytes %d\n",size,loop,last_bytes);
+	int i;
+	for(i=0;i<loop;i++)
+	{
+		USBBufferWrite(&g_sTxBuffer[index],buffer+i*64,64);
+		rt_sem_take(&(usbrx_sem[index]), RT_WAITING_FOREVER);
+		//rt_kprintf("64 len_out %d\n",send_len);
+	}
+	if(last_bytes!=0)
+	{
+		USBBufferWrite(&g_sTxBuffer[index],buffer+i*64,last_bytes);
+		rt_sem_take(&(usbrx_sem[index]), RT_WAITING_FOREVER);
+		//rt_kprintf("len_out %d\n",send_len);
+	}
+		return 0;
+	while(tmp_size!=0)
+	{
+		len_out=USBBufferWrite(&g_sTxBuffer[index],buffer+len,size64);
+		if(rt_sem_take(&(usbrx_sem[index]), RT_WAITING_FOREVER) != RT_EOK) continue;
+		if(send_len!=64)
+		{
+			rt_kprintf("len_out %d\n",send_len);
+			break;
+		}
+		if(tmp_size>64)
+			tmp_size=tmp_size-64;
+		else
+			size64=tmp_size;
+		
+		len=len+size64;
+	}
+	return 0;
+	while(1)
+	{
+	    len_out=USBBufferWrite(&g_sTxBuffer[index],buffer+len,tmp_size);
+		/*if(len_out==0)
+		{
+			_delay_us(1);
+			continue;
+		}*/
+		
+		if(rt_sem_take(&(usbrx_sem[index]), RT_WAITING_FOREVER) != RT_EOK) continue;
+		if(len_out!=tmp_size)
+		{
+			//rt_kprintf("len_out %d , tmp_size %d\n",len_out,tmp_size);
+			len=len+len_out;
+			tmp_size=tmp_size-len_out;			
+		}
+		else
+			break;
+		
+	}
+
+	return 0;
+}
+
diff --git a/bsp/tm4c129x/applications/drv_usb.h b/bsp/tm4c129x/applications/drv_usb.h
new file mode 100755
index 0000000..969b969
--- /dev/null
+++ b/bsp/tm4c129x/applications/drv_usb.h
@@ -0,0 +1,25 @@
+#ifndef DRV_USB_H__
+#define DRV_USB_H__
+
+#include <rtthread.h>
+#include <rtdevice.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* pin device and operations for RT-Thread */
+struct rt_device_usb
+{
+    struct rt_device parent;
+};
+
+int rt_device_usb_register(const char *name);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/bsp/tm4c129x/applications/net_utils.c b/bsp/tm4c129x/applications/net_utils.c
new file mode 100755
index 0000000..2e767e7
--- /dev/null
+++ b/bsp/tm4c129x/applications/net_utils.c
@@ -0,0 +1,323 @@
+/*
+ * netutils: ping implementation
+ */
+
+#include "lwip/opt.h"
+
+#include "lwip/mem.h"
+#include "lwip/icmp.h"
+#include "lwip/netif.h"
+#include "lwip/sys.h"
+#include "lwip/sockets.h"
+#include "lwip/inet.h"
+#include "lwip/inet_chksum.h"
+#include "lwip/ip.h"
+
+/**
+ * PING_DEBUG: Enable debugging for PING.
+ */
+#ifndef PING_DEBUG
+#define PING_DEBUG     LWIP_DBG_ON
+#endif
+
+/** ping receive timeout - in milliseconds */
+#define PING_RCV_TIMEO 1000
+/** ping delay - in milliseconds */
+#define PING_DELAY     100
+
+/** ping identifier - must fit on a u16_t */
+#ifndef PING_ID
+#define PING_ID        0xAFAF
+#endif
+
+/** ping additional data size to include in the packet */
+#ifndef PING_DATA_SIZE
+#define PING_DATA_SIZE 32
+#endif
+#define IPV6_PING 0
+/* ping variables */
+static u16_t ping_seq_num;
+struct _ip_addr
+{
+    rt_uint8_t addr0, addr1, addr2, addr3;
+};
+/** Prepare a echo ICMP request */
+
+static void ping_prepare_echo6( struct icmp6_echo_hdr *iecho, u16_t len)
+{
+	size_t i;
+	size_t data_len = len - sizeof(struct icmp6_echo_hdr);
+	iecho->type=ICMP6_TYPE_EREQ;
+	iecho->code=0;	
+	iecho->chksum = 0;
+	iecho->id	  = PING_ID;
+	iecho->seqno  = htons(++ping_seq_num);
+
+	/* fill the additional data buffer with some data */
+	for(i = 0; i < data_len; i++)
+	{
+		((char*)iecho)[sizeof(struct icmp6_echo_hdr) + i] = (char)i;
+	}
+	/*remove chksum ,tm4c129x can hw set chksum*/
+	//iecho->chksum = inet_chksum(iecho, len);
+}
+
+
+static void ping_prepare_echo( struct icmp_echo_hdr *iecho, u16_t len)
+{
+    size_t i;
+    size_t data_len = len - sizeof(struct icmp_echo_hdr);	
+    ICMPH_TYPE_SET(iecho, ICMP_ECHO);
+    ICMPH_CODE_SET(iecho, 0);	
+    iecho->chksum = 0;
+    iecho->id     = PING_ID;
+    iecho->seqno  = htons(++ping_seq_num);
+
+    /* fill the additional data buffer with some data */
+    for(i = 0; i < data_len; i++)
+    {
+        ((char*)iecho)[sizeof(struct icmp_echo_hdr) + i] = (char)i;
+    }
+	/*remove chksum ,tm4c129x can hw set chksum*/
+    //iecho->chksum = inet_chksum(iecho, len);
+}
+
+/* Ping using the socket ip */
+static err_t ping_send6(int s, struct ip6_addr *addr, int size)
+{
+	int err;
+	struct sockaddr_in6 to;
+	struct icmp6_echo_hdr *iecho;
+	size_t ping_size = sizeof(struct icmp6_echo_hdr) + size;
+	
+	LWIP_ASSERT("ping_size is too big", ping_size <= 0xffff);
+
+	iecho = rt_malloc(ping_size);
+	if (iecho == RT_NULL)
+	{
+		return ERR_MEM;
+	}
+
+	ping_prepare_echo6(iecho, (u16_t)ping_size);
+	
+	to.sin6_len = sizeof(to);
+	to.sin6_family = AF_INET6;
+	to.sin6_flowinfo = 0;
+	memcpy((void *)to.sin6_addr.s6_addr,(unsigned char *)(addr->addr),16);	
+	
+
+	err = lwip_sendto(s, iecho, ping_size, 0, (struct sockaddr*)&to, sizeof(to));
+	rt_free(iecho);
+
+	return (err ? ERR_OK : ERR_VAL);
+}
+
+static err_t ping_send(int s, struct ip_addr *addr, int size)
+{
+    int err;
+	struct sockaddr_in to;
+    struct icmp_echo_hdr *iecho;
+	size_t ping_size = sizeof(struct icmp_echo_hdr) + size;
+    
+    LWIP_ASSERT("ping_size is too big", ping_size <= 0xffff);
+
+    iecho = rt_malloc(ping_size);
+    if (iecho == RT_NULL)
+    {
+        return ERR_MEM;
+    }
+
+    ping_prepare_echo(iecho, (u16_t)ping_size);
+	
+    to.sin_len = sizeof(to);
+    to.sin_family = AF_INET;
+	to.sin_addr.s_addr = addr->addr;
+    
+
+    err = lwip_sendto(s, iecho, ping_size, 0, (struct sockaddr*)&to, sizeof(to));
+    rt_free(iecho);
+
+    return (err ? ERR_OK : ERR_VAL);
+}
+static int ping_recv6(int s)
+{
+    char buf[64];
+    int fromlen, len;
+    struct sockaddr_in6 from;	
+    struct ip6_hdr *iphdr;
+    struct icmp6_echo_hdr *iecho;
+	struct ip6_addr *addr;
+	
+    while((len = lwip_recvfrom(s, buf, sizeof(buf), 0, (struct sockaddr*)&from, (socklen_t*)&fromlen)) > 0)
+    {
+        if (len >= (sizeof(struct ip6_hdr)+sizeof(struct icmp6_echo_hdr)))
+        {
+			addr = (struct ip6_addr *)&(from.sin6_addr.s6_addr); 
+            iphdr = (struct ip6_hdr *)buf;
+            iecho = (struct icmp6_echo_hdr *)(buf+(IP6H_PLEN(iphdr)));
+            if ((iecho->id == PING_ID) && (iecho->seqno == htons(ping_seq_num)))
+            {
+            	rt_kprintf("ping: recv %4x:%4x:%4x:%4x:%4x:%4x:%4x:%4x\n",
+                    IP6_ADDR_BLOCK1(addr),
+                    IP6_ADDR_BLOCK2(addr),
+                    IP6_ADDR_BLOCK3(addr),
+                    IP6_ADDR_BLOCK4(addr),
+                    IP6_ADDR_BLOCK5(addr),
+                    IP6_ADDR_BLOCK6(addr),
+                    IP6_ADDR_BLOCK7(addr),
+                    IP6_ADDR_BLOCK8(addr));
+                return 0;
+            }
+            else
+            {
+                rt_kprintf("ping: drop\n");
+            }
+        }
+    }
+
+    if (len <= 0)
+    {
+        rt_kprintf("ping: timeout\n");
+    }
+	return -1;
+}
+
+static int ping_recv(int s)
+{
+    char buf[64];
+    int fromlen, len;
+    struct ip_hdr *iphdr;
+    struct icmp_echo_hdr *iecho;
+	struct sockaddr_in from;
+    struct _ip_addr *addr;
+	
+    while((len = lwip_recvfrom(s, buf, sizeof(buf), 0, (struct sockaddr*)&from, (socklen_t*)&fromlen)) > 0)
+    {
+		if (len >= (sizeof(struct ip_hdr)+sizeof(struct icmp_echo_hdr)))
+        {
+            addr = (struct _ip_addr *)&(from.sin_addr);			
+            rt_kprintf("ping: recv %d.%d.%d.%d\n", addr->addr0, addr->addr1, addr->addr2, addr->addr3);
+            iphdr = (struct ip_hdr *)buf;
+            iecho = (struct icmp_echo_hdr *)(buf+(IPH_HL(iphdr) * 4));
+            if ((iecho->id == PING_ID) && (iecho->seqno == htons(ping_seq_num)))
+            {
+                return 0;
+            }
+            else
+            {
+                rt_kprintf("ping: drop\n");
+            }
+        }
+    }
+
+    if (len <= 0)
+    {
+        rt_kprintf("ping: timeout\n");
+    }
+	return -1;
+}
+
+rt_err_t ping_test6(char* target, rt_uint32_t time, rt_size_t size)
+{
+    int s;
+	int result=-1;
+    int timeout = PING_RCV_TIMEO;
+    struct ip6_addr ping_target;
+    rt_uint32_t send_time;
+	char *addr;
+    send_time = 0;
+
+    if(size == 0)
+        size = PING_DATA_SIZE;
+	memset(&ping_target, 0, sizeof(ping_target));
+	//ping_target.sin6_family = AF_INET6;
+	if(inet_pton(AF_INET6, target, (struct ip6_addr*)&ping_target) != 1)
+	{
+		rt_kprintf("inet_pton() error\n");
+		return result;
+	}	
+	addr = target;
+	if ((s = lwip_socket(AF_INET6, SOCK_RAW, IP6_NEXTH_ICMP6)) < 0)
+    {
+        rt_kprintf("create socket failled\n");
+        return -RT_ERROR;
+    }
+    
+
+    lwip_setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));
+
+    while (1)
+    {
+        if (ping_send6(s, &ping_target, size) == ERR_OK)
+        {
+			rt_kprintf("ping: send %s\n", addr);
+            result=ping_recv6(s);
+        }
+        else
+        {
+			rt_kprintf("ping: send %s error\n", addr);
+        }
+
+        send_time ++;
+        if (send_time >= time || result==0) break; /* send ping times reached, stop */
+
+        rt_thread_delay(PING_DELAY); /* take a delay */
+    }
+
+    lwip_close(s);
+	
+    return result;
+}
+rt_err_t ping_test(char* target, rt_uint32_t time, rt_size_t size)
+{
+    int s;
+	int result=-1;
+    int timeout = PING_RCV_TIMEO;
+    struct ip_addr ping_target;
+    rt_uint32_t send_time;
+    struct _ip_addr
+    {
+        rt_uint8_t addr0, addr1, addr2, addr3;
+    } *addr;
+    send_time = 0;
+
+    if(size == 0)
+        size = PING_DATA_SIZE;
+    if (inet_aton(target, (struct in_addr*)&ping_target) == 0) return -RT_ERROR;
+    addr = (struct _ip_addr*)&ping_target;
+	if ((s = lwip_socket(AF_INET, SOCK_RAW, IP_PROTO_ICMP)) < 0)
+    {
+        rt_kprintf("create socket failled\n");
+        return -RT_ERROR;
+    }
+    
+
+    lwip_setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));
+
+    while (1)
+    {
+        if (ping_send(s, &ping_target, size) == ERR_OK)
+        {
+            rt_kprintf("ping: send %d.%d.%d.%d\n", addr->addr0, addr->addr1, addr->addr2, addr->addr3);
+            result=ping_recv(s);
+        }
+        else
+        {
+            rt_kprintf("ping: send %d.%d.%d.%d - error\n", addr->addr0, addr->addr1, addr->addr2, addr->addr3);
+        }
+
+        send_time ++;
+        if (send_time >= time || result==0) break; /* send ping times reached, stop */
+
+        rt_thread_delay(PING_DELAY); /* take a delay */
+    }
+
+    lwip_close(s);
+	rt_kprintf("ping return %d\n",result);
+    return result;
+}
+#ifdef RT_USING_FINSH
+#include <finsh.h>
+FINSH_FUNCTION_EXPORT(ping_test, ping ipv4 network host);
+FINSH_FUNCTION_EXPORT(ping_test6, ping ipv6 network host);
+#endif
diff --git a/bsp/tm4c129x/applications/usb_comp_bulk_structs.c b/bsp/tm4c129x/applications/usb_comp_bulk_structs.c
new file mode 100755
index 0000000..8436b8e
--- /dev/null
+++ b/bsp/tm4c129x/applications/usb_comp_bulk_structs.c
@@ -0,0 +1,396 @@
+//*****************************************************************************
+//
+// usb_serial_structs.c - Data structures defining this CDC USB device.
+//
+// Copyright (c) 2009-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the EK-TM4C1294XL Firmware Package.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "inc/hw_types.h"
+#include "driverlib/usb.h"
+#include "usblib/usblib.h"
+#include "usblib/usbcdc.h"
+#include "usblib/usb-ids.h"
+#include "usblib/device/usbdevice.h"
+#include "usblib/device/usbdbulk.h"
+#include "usblib/device/usbdcomp.h"
+#include "usb_comp_bulk_structs.h"
+
+//*****************************************************************************
+//
+// The languages supported by this device.
+//
+//*****************************************************************************
+const uint8_t g_pui8LangDescriptor[] =
+{
+    4,
+    USB_DTYPE_STRING,
+    USBShort(USB_LANG_EN_US)
+};
+
+//*****************************************************************************
+//
+// The manufacturer string.
+//
+//*****************************************************************************
+const uint8_t g_pui8ManufacturerString[] =
+{
+    (17 + 1) * 2,
+    USB_DTYPE_STRING,
+    'T', 0, 'e', 0, 'x', 0, 'a', 0, 's', 0, ' ', 0, 'I', 0, 'n', 0, 's', 0,
+    't', 0, 'r', 0, 'u', 0, 'm', 0, 'e', 0, 'n', 0, 't', 0, 's', 0,
+};
+
+//*****************************************************************************
+//
+// The product string.
+//
+//*****************************************************************************
+const uint8_t g_pui8ProductString[] =
+{
+    2 + (16 * 2),
+    USB_DTYPE_STRING,
+    'T', 0, 'M', 0, '4', 0, 'C', 0, '1', 0, '2', 0, '9', 0, ' ', 0,
+    'U', 0, 'S', 0, 'B', 0, ' ', 0, 'P', 0, 'o', 0, 'r', 0, 't', 0
+};
+
+//*****************************************************************************
+//
+// The serial number string.
+//
+//*****************************************************************************
+const uint8_t g_pui8SerialNumberString[] =
+{
+    2 + (8 * 2),
+    USB_DTYPE_STRING,
+    '1', 0, '2', 0, '3', 0, '4', 0, '5', 0, '6', 0, '7', 0, '8', 0
+};
+
+//*****************************************************************************
+//
+// The control interface description string.
+//
+//*****************************************************************************
+const uint8_t g_pui8ControlInterfaceString[] =
+{
+    2 + (21 * 2),
+    USB_DTYPE_STRING,
+    'A', 0, 'C', 0, 'M', 0, ' ', 0, 'C', 0, 'o', 0, 'n', 0, 't', 0,
+    'r', 0, 'o', 0, 'l', 0, ' ', 0, 'I', 0, 'n', 0, 't', 0, 'e', 0,
+    'r', 0, 'f', 0, 'a', 0, 'c', 0, 'e', 0
+};
+
+//*****************************************************************************
+//
+// The configuration description string.
+//
+//*****************************************************************************
+const uint8_t g_pui8ConfigString[] =
+{
+    2 + (26 * 2),
+    USB_DTYPE_STRING,
+    'S', 0, 'e', 0, 'l', 0, 'f', 0, ' ', 0, 'P', 0, 'o', 0, 'w', 0,
+    'e', 0, 'r', 0, 'e', 0, 'd', 0, ' ', 0, 'C', 0, 'o', 0, 'n', 0,
+    'f', 0, 'i', 0, 'g', 0, 'u', 0, 'r', 0, 'a', 0, 't', 0, 'i', 0,
+    'o', 0, 'n', 0
+};
+
+//*****************************************************************************
+//
+// The descriptor string table.
+//
+//*****************************************************************************
+const uint8_t * const g_pui8StringDescriptors[] =
+{
+    g_pui8LangDescriptor,
+    g_pui8ManufacturerString,
+    g_pui8ProductString,
+    g_pui8SerialNumberString,
+    g_pui8ControlInterfaceString,
+    g_pui8ConfigString
+};
+
+#define NUM_STRING_DESCRIPTORS (sizeof(g_pui8StringDescriptors) /             \
+                                sizeof(uint8_t *))
+
+//*****************************************************************************
+//
+// The CDC device initialization and customization structures. In this case,
+// we are using USBBuffers between the CDC device class driver and the
+// application code. The function pointers and callback data values are set
+// to insert a buffer in each of the data channels, transmit and receive.
+//
+// With the buffer in place, the CDC channel callback is set to the relevant
+// channel function and the callback data is set to point to the channel
+// instance data. The buffer, in turn, has its callback set to the application
+// function and the callback data set to our CDC instance structure.
+//
+//*****************************************************************************
+tUSBDBulkDevice g_psBULKDevice[NUM_BULK_DEVICES] =
+{
+    {
+	    USB_VID_TI_1CBE,
+	    USB_PID_BULK,
+	    500,
+	    USB_CONF_ATTR_SELF_PWR,
+	    USBBufferEventCallback,
+	    (void *)&g_sRxBuffer[0],
+	    USBBufferEventCallback,
+	    (void *)&g_sTxBuffer[0],
+	    g_pui8StringDescriptors,
+	    NUM_STRING_DESCRIPTORS
+	},
+    {
+	    USB_VID_TI_1CBE,
+	    USB_PID_BULK,
+	    500,
+	    USB_CONF_ATTR_SELF_PWR,
+	    USBBufferEventCallback,
+	    (void *)&g_sRxBuffer[1],
+	    USBBufferEventCallback,
+	    (void *)&g_sTxBuffer[1],
+	    g_pui8StringDescriptors,
+	    NUM_STRING_DESCRIPTORS
+	},	
+	{
+		USB_VID_TI_1CBE,
+		USB_PID_BULK,
+		500,
+		USB_CONF_ATTR_SELF_PWR,
+		USBBufferEventCallback,
+		(void *)&g_sRxBuffer[2],
+		USBBufferEventCallback,
+		(void *)&g_sTxBuffer[2],
+		g_pui8StringDescriptors,
+		NUM_STRING_DESCRIPTORS
+	},
+	{
+		USB_VID_TI_1CBE,
+		USB_PID_BULK,
+		500,
+		USB_CONF_ATTR_SELF_PWR,
+		USBBufferEventCallback,
+		(void *)&g_sRxBuffer[3],
+		USBBufferEventCallback,
+		(void *)&g_sTxBuffer[3],
+		g_pui8StringDescriptors,
+		NUM_STRING_DESCRIPTORS
+	},
+	{
+		USB_VID_TI_1CBE,
+		USB_PID_BULK,
+		500,
+		USB_CONF_ATTR_SELF_PWR,
+		USBBufferEventCallback,
+		(void *)&g_sRxBuffer[4],
+		USBBufferEventCallback,
+		(void *)&g_sTxBuffer[4],
+		g_pui8StringDescriptors,
+		NUM_STRING_DESCRIPTORS
+	}
+};
+
+//*****************************************************************************
+//
+// Receive buffer (from the USB perspective).
+//
+//*****************************************************************************
+uint8_t g_ppui8USBRxBuffer[NUM_BULK_DEVICES][UART_BUFFER_SIZE];
+uint8_t g_ppui8RxBufferWorkspace[NUM_BULK_DEVICES][USB_BUFFER_WORKSPACE_SIZE];
+const tUSBBuffer g_sRxBuffer[NUM_BULK_DEVICES] =
+{
+    {
+        false,                          // This is a receive buffer.
+        RxHandlerBulk,                  // pfnCallback
+        (void *)&g_psBULKDevice[0],      // Callback data is our device pointer.
+        USBDBulkPacketRead,              // pfnTransfer
+        USBDBulkRxPacketAvailable,       // pfnAvailable
+        (void *)&g_psBULKDevice[0],      // pvHandle
+        g_ppui8USBRxBuffer[0],          // pcBuffer
+        UART_BUFFER_SIZE,               // ulBufferSize
+        g_ppui8RxBufferWorkspace[0]     // pvWorkspace
+    },
+    {
+        false,                          // This is a receive buffer.
+        RxHandlerBulk,                   // pfnCallback
+        (void *)&g_psBULKDevice[1],      // Callback data is our device pointer.
+        USBDBulkPacketRead,              // pfnTransfer
+        USBDBulkRxPacketAvailable,       // pfnAvailable
+        (void *)&g_psBULKDevice[1],      // pvHandle
+        g_ppui8USBRxBuffer[1],          // pcBuffer
+        UART_BUFFER_SIZE,               // ulBufferSize
+        g_ppui8RxBufferWorkspace[1]     // pvWorkspace
+    },
+    {
+        false,                          // This is a receive buffer.
+        RxHandlerBulk,                   // pfnCallback
+        (void *)&g_psBULKDevice[2],      // Callback data is our device pointer.
+        USBDBulkPacketRead,              // pfnTransfer
+        USBDBulkRxPacketAvailable,       // pfnAvailable
+        (void *)&g_psBULKDevice[2],      // pvHandle
+        g_ppui8USBRxBuffer[2],          // pcBuffer
+        UART_BUFFER_SIZE,               // ulBufferSize
+        g_ppui8RxBufferWorkspace[2]     // pvWorkspace
+    },
+    {
+        false,                          // This is a receive buffer.
+        RxHandlerBulk,                   // pfnCallback
+        (void *)&g_psBULKDevice[3],      // Callback data is our device pointer.
+        USBDBulkPacketRead,              // pfnTransfer
+        USBDBulkRxPacketAvailable,       // pfnAvailable
+        (void *)&g_psBULKDevice[3],      // pvHandle
+        g_ppui8USBRxBuffer[3],          // pcBuffer
+        UART_BUFFER_SIZE,               // ulBufferSize
+        g_ppui8RxBufferWorkspace[3]     // pvWorkspace
+    },
+    {
+        false,                          // This is a receive buffer.
+        RxHandlerBulk,                   // pfnCallback
+        (void *)&g_psBULKDevice[4],      // Callback data is our device pointer.
+        USBDBulkPacketRead,              // pfnTransfer
+        USBDBulkRxPacketAvailable,       // pfnAvailable
+        (void *)&g_psBULKDevice[4],      // pvHandle
+        g_ppui8USBRxBuffer[4],          // pcBuffer
+        UART_BUFFER_SIZE,               // ulBufferSize
+        g_ppui8RxBufferWorkspace[4]     // pvWorkspace
+    }
+};
+
+//*****************************************************************************
+//
+// Transmit buffer (from the USB perspective).
+//
+//*****************************************************************************
+uint8_t g_ppcUSBTxBuffer[NUM_BULK_DEVICES][UART_BUFFER_SIZE_TX];
+uint8_t g_ppucTxBufferWorkspace[NUM_BULK_DEVICES][USB_BUFFER_WORKSPACE_SIZE];
+const tUSBBuffer g_sTxBuffer[NUM_BULK_DEVICES] =
+{
+    {
+        true,                           // This is a transmit buffer.
+        TxHandlerBulk,                      // pfnCallback
+        (void *)&g_psBULKDevice[0],      // Callback data is our device pointer.
+        USBDBulkPacketWrite,             // pfnTransfer
+        USBDBulkTxPacketAvailable,       // pfnAvailable
+        (void *)&g_psBULKDevice[0],      // pvHandle
+        g_ppcUSBTxBuffer[0],            // pcBuffer
+        UART_BUFFER_SIZE_TX,               // ulBufferSize
+        g_ppucTxBufferWorkspace[0]      // pvWorkspace
+    },
+    {
+        true,                           // This is a transmit buffer.
+        TxHandlerBulk,                   // pfnCallback
+        (void *)&g_psBULKDevice[1],      // Callback data is our device pointer.
+        USBDBulkPacketWrite,             // pfnTransfer
+        USBDBulkTxPacketAvailable,       // pfnAvailable
+        (void *)&g_psBULKDevice[1],      // pvHandle
+        g_ppcUSBTxBuffer[1],            // pcBuffer
+        UART_BUFFER_SIZE_TX,               // ulBufferSize
+        g_ppucTxBufferWorkspace[1]      // pvWorkspace
+    },
+    {
+        true,                           // This is a transmit buffer.
+        TxHandlerBulk,                      // pfnCallback
+        (void *)&g_psBULKDevice[2],      // Callback data is our device pointer.
+        USBDBulkPacketWrite,             // pfnTransfer
+        USBDBulkTxPacketAvailable,       // pfnAvailable
+        (void *)&g_psBULKDevice[2],      // pvHandle
+        g_ppcUSBTxBuffer[2],            // pcBuffer
+        UART_BUFFER_SIZE_TX,               // ulBufferSize
+        g_ppucTxBufferWorkspace[2]      // pvWorkspace
+    },
+    {
+        true,                           // This is a transmit buffer.
+        TxHandlerBulk,                      // pfnCallback
+        (void *)&g_psBULKDevice[3],      // Callback data is our device pointer.
+        USBDBulkPacketWrite,             // pfnTransfer
+        USBDBulkTxPacketAvailable,       // pfnAvailable
+        (void *)&g_psBULKDevice[3],      // pvHandle
+        g_ppcUSBTxBuffer[3],            // pcBuffer
+        UART_BUFFER_SIZE_TX,               // ulBufferSize
+        g_ppucTxBufferWorkspace[3]      // pvWorkspace
+    },
+    {
+        true,                           // This is a transmit buffer.
+        TxHandlerBulk,                      // pfnCallback
+        (void *)&g_psBULKDevice[4],      // Callback data is our device pointer.
+        USBDBulkPacketWrite,             // pfnTransfer
+        USBDBulkTxPacketAvailable,       // pfnAvailable
+        (void *)&g_psBULKDevice[4],      // pvHandle
+        g_ppcUSBTxBuffer[4],            // pcBuffer
+        UART_BUFFER_SIZE_TX,               // ulBufferSize
+        g_ppucTxBufferWorkspace[4]      // pvWorkspace
+    }
+};
+
+//****************************************************************************
+//
+// The memory allocated to hold the composite descriptor that is created by
+// the call to USBDCompositeInit().
+//
+//****************************************************************************
+uint8_t g_pui8DescriptorData[DESCRIPTOR_DATA_SIZE];
+
+tCompositeEntry g_psCompEntries[NUM_BULK_DEVICES];
+
+//****************************************************************************
+//
+// Allocate the Device Data for the top level composite device class.
+//
+//****************************************************************************
+tUSBDCompositeDevice g_sCompDevice =
+{
+    //
+    // Stellaris VID.
+    //
+    USB_VID_TI_1CBE,
+
+    //
+    // Stellaris PID for composite serial device.
+    //
+    /*USB_PID_COMP_SERIAL,*/USB_PID_BULK,
+
+    //
+    // This is in 2mA increments so 500mA.
+    //
+    250,
+
+    //
+    // Bus powered device.
+    //
+    USB_CONF_ATTR_BUS_PWR,
+
+    //
+    // There is no need for a default composite event handler.
+    //
+    0,
+
+    //
+    // The string table.
+    //
+    g_pui8StringDescriptors,
+    NUM_STRING_DESCRIPTORS,
+
+    //
+    // The Composite device array.
+    //
+    NUM_BULK_DEVICES,
+    g_psCompEntries
+};
diff --git a/bsp/tm4c129x/applications/usb_comp_bulk_structs.h b/bsp/tm4c129x/applications/usb_comp_bulk_structs.h
new file mode 100755
index 0000000..c1542d7
--- /dev/null
+++ b/bsp/tm4c129x/applications/usb_comp_bulk_structs.h
@@ -0,0 +1,64 @@
+//*****************************************************************************
+//
+// usb_serial_structs.h - Data structures defining this USB CDC device.
+//
+// Copyright (c) 2009-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the EK-TM4C1294XL Firmware Package.
+//
+//*****************************************************************************
+
+#ifndef __USB_SERIAL_STRUCTS_H__
+#define __USB_SERIAL_STRUCTS_H__
+
+//*****************************************************************************
+//
+// The size of the transmit and receive buffers used for the redirected UART.
+// This number should be a power of 2 for best performance.  256 is chosen
+// pretty much at random though the buffer should be at least twice the size of
+// a maximum-sized USB packet.
+//
+//*****************************************************************************
+#define UART_BUFFER_SIZE        4096
+#define UART_BUFFER_SIZE_TX     1024
+
+#define NUM_BULK_DEVICES      5
+#define DESCRIPTOR_DATA_SIZE    (COMPOSITE_DBULK_SIZE*NUM_BULK_DEVICES)
+
+extern uint32_t RxHandlerBulk(void *pvCBData, uint32_t ui32Event,
+                              uint32_t ui32MsgValue, void *pvMsgData);
+extern uint32_t RxHandlerCmd(void *pvCBData, uint32_t ui32Event,
+                             uint32_t ui32MsgValue, void *pvMsgData);
+extern uint32_t TxHandlerBulk(void *pvlCBData, uint32_t ui32Event,
+                              uint32_t ui32MsgValue, void *pvMsgData);
+extern uint32_t TxHandlerCmd(void *pvlCBData, uint32_t ui32Event,
+                             uint32_t ui32MsgValue, void *pvMsgData);
+
+extern uint32_t ControlHandler(void *pvCBData, uint32_t ui32Event,
+                               uint32_t ui32MsgValue, void *pvMsgData);
+extern uint32_t EventHandler(void *pvCBData, uint32_t ui32Event,
+                             uint32_t ui32MsgData, void *pvMsgData);
+extern const tUSBBuffer g_sTxBuffer[NUM_BULK_DEVICES];
+extern const tUSBBuffer g_sRxBuffer[NUM_BULK_DEVICES];
+extern tUSBDBulkDevice g_psBULKDevice[NUM_BULK_DEVICES];
+extern uint8_t g_pui8USBTxBuffer[];
+extern uint8_t g_pui8USBRxBuffer[];
+extern tCompositeEntry g_psCompEntries[NUM_BULK_DEVICES];
+extern tUSBDCompositeDevice g_sCompDevice;
+extern uint8_t g_pui8DescriptorData[DESCRIPTOR_DATA_SIZE];
+
+#endif // __USB_SERIAL_STRUCTS_H__
diff --git a/bsp/tm4c129x/checkin.sh b/bsp/tm4c129x/checkin.sh
new file mode 100755
index 0000000..f6bc314
--- /dev/null
+++ b/bsp/tm4c129x/checkin.sh
@@ -0,0 +1,4 @@
+#! /bin/bash -e
+
+git commit -am "$1"
+git push origin ccoldman_tm4c129x
diff --git a/bsp/tm4c129x/drivers/drv_eth.c b/bsp/tm4c129x/drivers/drv_eth.c
index 9d68a5d..81367a4 100644
--- a/bsp/tm4c129x/drivers/drv_eth.c
+++ b/bsp/tm4c129x/drivers/drv_eth.c
@@ -67,8 +67,11 @@
 #include <lwip/snmp.h>
 #include "lwip/tcpip.h"
 #include "netif/etharp.h"
+#ifndef RT_USING_LWIP_HEAD
 #include "netif/ppp_oe.h"
-
+#else
+#include "netif/ppp/pppoe.h"
+#endif
 
 /**
  * Sanity Check:  This interface driver will NOT work if the following defines
@@ -146,8 +149,6 @@ extern void lwIPHostGetTime(u32_t *time_s, u32_t *time_ns);
 #include "lwipopts.h"
 #include "drv_eth.h"
 
-#include <components.h>
-
 /**
  * A structure used to keep track of driver state and error counts.
  */
@@ -490,7 +491,6 @@ tivaif_check_pbuf(struct pbuf *p)
                     tivaif_trace_pbuf("Copied:", pBuf);
 #endif
                     DRIVER_STATS_INC(TXCopyCount);
-
                     /* Reduce the reference count on the original pbuf since
                      * we're not going to hold on to it after returning from
                      * tivaif_transmit.  Note that we already bumped
@@ -871,6 +871,7 @@ tivaif_receive(net_device_t dev)
                       /* drop the packet */
                       LWIP_DEBUGF(NETIF_DEBUG, ("tivaif_input: input error\n"));
                       pbuf_free(pBuf);
+					  
 
                       /* Adjust the link statistics */
                       LINK_STATS_INC(link.memerr);
@@ -907,7 +908,7 @@ tivaif_receive(net_device_t dev)
       }
       else
       {
-          LWIP_DEBUGF(NETIF_DEBUG, ("tivaif_receive: pbuf_alloc error\n"));
+          LWIP_DEBUGF(NETIF_DEBUG, ("tivaif_receive: pbuf_alloc error %d\n",PBUF_POOL_BUFSIZE));
 
           pDescList->pDescriptors[pDescList->ui32Read].Desc.pvBuffer1 = 0;
 
@@ -940,6 +941,7 @@ tivaif_receive(net_device_t dev)
  * transmitter.
  *
  */
+ extern bool phy_link;
 void
 tivaif_process_phy_interrupt(net_device_t dev)
 {
@@ -971,6 +973,7 @@ tivaif_process_phy_interrupt(net_device_t dev)
 #else
             //tcpip_callback((tcpip_callback_fn)netif_set_link_up, psNetif);
 			eth_device_linkchange(&(dev->parent), RT_TRUE);
+			phy_link=true;
 #endif
 
             /* In this case we drop through since we may need to reconfigure
@@ -985,6 +988,8 @@ tivaif_process_phy_interrupt(net_device_t dev)
 #else
             //tcpip_callback((tcpip_callback_fn)netif_set_link_down, psNetif);
 			eth_device_linkchange(&(dev->parent), RT_FALSE);
+			phy_link=false;
+			all_cut();
 #endif
         }
     }
@@ -1376,11 +1381,11 @@ static struct pbuf* eth_dev_rx(rt_device_t dev)
 	rt_uint32_t temp =0;
 	net_device_t net_dev = (net_device_t)dev;
 	result = rt_mb_recv(net_dev->rx_pbuf_mb, &temp, RT_WAITING_NO);
-	
+
 	return (result == RT_EOK)? (struct pbuf*)temp : RT_NULL;
 }
 
-int rt_hw_tiva_eth_init(void)
+rt_err_t rt_hw_tiva_eth_init(void)
 {
 	rt_err_t result;
 
@@ -1400,7 +1405,7 @@ int rt_hw_tiva_eth_init(void)
 	
 	result = rt_mb_init(&eth_rx_pbuf_mb, "epbuf",
                         &rx_pbuf_mb_pool[0], sizeof(rx_pbuf_mb_pool)/4,
-                        RT_IPC_FLAG_FIFO);
+                        RT_IPC_FLAG_PRIO);
 	RT_ASSERT(result == RT_EOK);
 	eth_dev->rx_pbuf_mb = &eth_rx_pbuf_mb;
 	
@@ -1408,11 +1413,6 @@ int rt_hw_tiva_eth_init(void)
 	result = eth_device_init(&(eth_dev->parent), "e0");
 	return result;
 }
-// eth_device_init using malloc
-// We use INIT_COMPONENT_EXPORT insted of INIT_BOARD_EXPORT
-INIT_COMPONENT_EXPORT(rt_hw_tiva_eth_init);
-
-
 #if 0
 #ifdef RT_USING_FINSH
 #include "finsh.h"
diff --git a/bsp/tm4c129x/drivers/drv_eth.h b/bsp/tm4c129x/drivers/drv_eth.h
index 5443140..5f27139 100644
--- a/bsp/tm4c129x/drivers/drv_eth.h
+++ b/bsp/tm4c129x/drivers/drv_eth.h
@@ -15,6 +15,6 @@
 #ifndef __TIVA_ETH_H__
 #define __TIVA_ETH_H__
 
-int rt_hw_tiva_eth_init(void);
+rt_err_t rt_hw_tiva_eth_init(void);
 
 #endif
diff --git a/bsp/tm4c129x/drivers/drv_uart.c b/bsp/tm4c129x/drivers/drv_uart.c
index 7365278..9fc9f7e 100644
--- a/bsp/tm4c129x/drivers/drv_uart.c
+++ b/bsp/tm4c129x/drivers/drv_uart.c
@@ -18,7 +18,7 @@
 #include <rtdevice.h>
 
 #include "board.h"
-#include <components.h>
+//#include <components.h>
 
 #include "inc/hw_memmap.h"
 #include "driverlib/sysctl.h"
@@ -95,7 +95,7 @@ static rt_err_t hw_configure(struct rt_serial_device *serial, struct serial_conf
 	// Initialize UART0 peripheral with given to corresponding parameter
     MAP_UARTConfigSetExpClk(uart->hw_base, SysClock, cfg->baud_rate, config);
 	MAP_UARTFIFOEnable(uart->hw_base);
-
+//rt_kprintf("set uart baud %d\r\n",cfg->baud_rate);
 	// Enable the UART.
 	MAP_UARTEnable(uart->hw_base);
     return RT_EOK;
@@ -111,11 +111,11 @@ static rt_err_t hw_control(struct rt_serial_device *serial, int cmd, void *arg)
     {
     case RT_DEVICE_CTRL_CLR_INT:
         /* disable rx irq */
-        MAP_UARTIntDisable(uart->hw_base, UART_INT_RX | UART_INT_RT);
+        MAP_UARTIntDisable(uart->hw_base, UART_INT_RX | UART_INT_RT |UART_INT_TX);
         break;
     case RT_DEVICE_CTRL_SET_INT:
         /* enable rx irq */
-        MAP_UARTIntEnable(uart->hw_base, UART_INT_RX | UART_INT_RT);
+        MAP_UARTIntEnable(uart->hw_base, UART_INT_RX | UART_INT_RT |UART_INT_TX);
         break;
     }
 
@@ -135,9 +135,9 @@ static int hw_putc(struct rt_serial_device *serial, char c)
 static int hw_getc(struct rt_serial_device *serial)
 {
 	hw_uart_t* uart;
-    RT_ASSERT(serial != RT_NULL);
-    uart = mUartGetHwPtr(serial);
-	
+	RT_ASSERT(serial != RT_NULL);
+	uart = mUartGetHwPtr(serial);
+
 	return MAP_UARTCharGetNonBlocking(uart->hw_base);
 }
 
@@ -174,50 +174,343 @@ void UART0_IRQHandler(void)
         MAP_UARTIntClear(uart->hw_base, intsrc);
         rt_hw_serial_isr(&serial0, RT_SERIAL_EVENT_RX_IND);
     }
-		
+	if (intsrc & (UART_INT_TX))
+    {
+        MAP_UARTIntClear(uart->hw_base, intsrc);
+        rt_hw_serial_isr(&serial0, RT_SERIAL_EVENT_TX_DONE);
+    }	
     /* leave interrupt */
     rt_interrupt_leave();
 }
 #endif
+#if defined(RT_USING_UART1)
+/* UART0 device driver structure */
+struct rt_serial_device serial1;
+hw_uart_t uart1 =
+{
+    UART1_BASE,
+};
 
-int rt_hw_uart_init(void)
+void UART1_IRQHandler(void)
 {
-    hw_uart_t* uart;
-    struct serial_configure config;
+	uint32_t intsrc;
+    hw_uart_t *uart = &uart1;
+
+    /* enter interrupt */
+    rt_interrupt_enter();
+
+    /* Determine the interrupt source */
+    intsrc = MAP_UARTIntStatus(uart->hw_base, true);
+
+    // Receive Data Available or Character time-out
+    if (intsrc & (UART_INT_RX | UART_INT_RT))
+    {
+        MAP_UARTIntClear(uart->hw_base, intsrc);
+        rt_hw_serial_isr(&serial1, RT_SERIAL_EVENT_RX_IND);
+    }
+	if (intsrc & (UART_INT_TX))
+    {
+        MAP_UARTIntClear(uart->hw_base, intsrc);
+        rt_hw_serial_isr(&serial1, RT_SERIAL_EVENT_TX_DONE);
+    }		
+    /* leave interrupt */
+    rt_interrupt_leave();
+}
+#endif
+#if defined(RT_USING_UART2)
+/* UART0 device driver structure */
+struct rt_serial_device serial2;
+hw_uart_t uart2 =
+{
+    UART2_BASE,
+};
+
+void UART2_IRQHandler(void)
+{
+	uint32_t intsrc;
+    hw_uart_t *uart = &uart2;
+
+    /* enter interrupt */
+    rt_interrupt_enter();
+
+    /* Determine the interrupt source */
+    intsrc = MAP_UARTIntStatus(uart->hw_base, true);
+
+    // Receive Data Available or Character time-out
+    if (intsrc & (UART_INT_RX | UART_INT_RT))
+    {
+        MAP_UARTIntClear(uart->hw_base, intsrc);
+        rt_hw_serial_isr(&serial2, RT_SERIAL_EVENT_RX_IND);
+    }
+	if (intsrc & (UART_INT_TX))
+    {
+        MAP_UARTIntClear(uart->hw_base, intsrc);
+        rt_hw_serial_isr(&serial2, RT_SERIAL_EVENT_TX_DONE);
+    }		
+    /* leave interrupt */
+    rt_interrupt_leave();
+}
+#endif
+#if defined(RT_USING_UART3)
+/* UART0 device driver structure */
+struct rt_serial_device serial3;
+hw_uart_t uart3 =
+{
+    UART3_BASE,
+};
+
+void UART3_IRQHandler(void)
+{
+	uint32_t intsrc;
+    hw_uart_t *uart = &uart3;
+
+    /* enter interrupt */
+    rt_interrupt_enter();
+
+    /* Determine the interrupt source */
+    intsrc = MAP_UARTIntStatus(uart->hw_base, true);
+
+    // Receive Data Available or Character time-out
+    if (intsrc & (UART_INT_RX | UART_INT_RT))
+    {
+        MAP_UARTIntClear(uart->hw_base, intsrc);
+        rt_hw_serial_isr(&serial3, RT_SERIAL_EVENT_RX_IND);
+    }
+	if (intsrc & (UART_INT_TX))
+    {
+        MAP_UARTIntClear(uart->hw_base, intsrc);
+        rt_hw_serial_isr(&serial3, RT_SERIAL_EVENT_TX_DONE);
+    }		
+    /* leave interrupt */
+    rt_interrupt_leave();
+}
+#endif
+#if defined(RT_USING_UART4)
+/* UART0 device driver structure */
+struct rt_serial_device serial4;
+hw_uart_t uart4 =
+{
+    UART4_BASE,
+};
+
+void UART4_IRQHandler(void)
+{
+	uint32_t intsrc;
+    hw_uart_t *uart = &uart4;
+
+    /* enter interrupt */
+    rt_interrupt_enter();
+
+    /* Determine the interrupt source */
+    intsrc = MAP_UARTIntStatus(uart->hw_base, true);
+
+    // Receive Data Available or Character time-out
+    if (intsrc & (UART_INT_RX | UART_INT_RT))
+    {
+        MAP_UARTIntClear(uart->hw_base, intsrc);
+        rt_hw_serial_isr(&serial4, RT_SERIAL_EVENT_RX_IND);
+    }
+	if (intsrc & (UART_INT_TX))
+    {
+        MAP_UARTIntClear(uart->hw_base, intsrc);
+        rt_hw_serial_isr(&serial4, RT_SERIAL_EVENT_TX_DONE);
+    }		
+    /* leave interrupt */
+    rt_interrupt_leave();
+}
+#endif
+#if defined(RT_USING_UART6)
+/* UART0 device driver structure */
+struct rt_serial_device serial6;
+hw_uart_t uart6 =
+{
+    UART6_BASE,
+};
+
+void UART6_IRQHandler(void)
+{
+	uint32_t intsrc;
+    hw_uart_t *uart = &uart6;
+
+    /* enter interrupt */
+    rt_interrupt_enter();
+
+    /* Determine the interrupt source */
+    intsrc = MAP_UARTIntStatus(uart->hw_base, true);
+
+    // Receive Data Available or Character time-out
+    if (intsrc & (UART_INT_RX | UART_INT_RT))
+    {
+        MAP_UARTIntClear(uart->hw_base, intsrc);
+        rt_hw_serial_isr(&serial6, RT_SERIAL_EVENT_RX_IND);
+    }
+	if (intsrc & (UART_INT_TX))
+    {
+        MAP_UARTIntClear(uart->hw_base, intsrc);
+        rt_hw_serial_isr(&serial6, RT_SERIAL_EVENT_TX_DONE);
+    }		
+    /* leave interrupt */
+    rt_interrupt_leave();
+}
+#endif
+
+int rt_hw_uart_init(int use_uart)
+{
+	hw_uart_t* uart;
+	struct serial_configure config;
+
+	config.baud_rate = BAUD_RATE_115200;
+	config.bit_order = BIT_ORDER_LSB;
+	config.data_bits = DATA_BITS_8;
+	config.parity    = PARITY_NONE;
+	config.stop_bits = STOP_BITS_1;
+	config.invert    = NRZ_NORMAL;
+	config.bufsz     = RT_SERIAL_RB_BUFSZ;
 
-    config.baud_rate = BAUD_RATE_115200;
-    config.bit_order = BIT_ORDER_LSB;
-    config.data_bits = DATA_BITS_8;
-    config.parity    = PARITY_NONE;
-    config.stop_bits = STOP_BITS_1;
-    config.invert    = NRZ_NORMAL;
-    config.bufsz     = RT_SERIAL_RB_BUFSZ;
-	
 #ifdef RT_USING_UART0
-    uart = &uart0;
-    serial0.ops    = &hw_uart_ops;
-    serial0.config = config;
+	uart = &uart0;
+	serial0.ops    = &hw_uart_ops;
+	serial0.config = config;
 
-    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
-    MAP_GPIOPinConfigure(GPIO_PA0_U0RX);
-    MAP_GPIOPinConfigure(GPIO_PA1_U0TX);
-	
-    MAP_GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);
-    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);
+	MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
+	MAP_GPIOPinConfigure(GPIO_PA0_U0RX);
+	MAP_GPIOPinConfigure(GPIO_PA1_U0TX);
 
-    /* preemption = 1, sub-priority = 1 */
-    //IntPrioritySet(INT_UART0, ((0x01 << 5) | 0x01));
+	MAP_GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);
+	MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);
 
-    /* Enable Interrupt for UART channel */
-	  UARTIntRegister(uart->hw_base, UART0_IRQHandler);
-	  MAP_IntEnable(INT_UART0);
-	  MAP_UARTEnable(uart->hw_base);
+	/* preemption = 1, sub-priority = 1 */
+	//IntPrioritySet(INT_UART0, ((0x01 << 5) | 0x01));
 
-    /* register UART0 device */
-    rt_hw_serial_register(&serial0, "uart0",
-                          RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX,
-                          uart);
+	/* Enable Interrupt for UART channel */
+	UARTIntRegister(uart->hw_base, UART0_IRQHandler);
+	MAP_IntEnable(INT_UART0);
+	MAP_UARTEnable(uart->hw_base);
+	/* register UART0 device */
+	rt_hw_serial_register(&serial0, "uart0",RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX| RT_DEVICE_FLAG_INT_TX,uart);
 #endif
+	if(use_uart){
+#ifdef RT_USING_UART1
+	uart = &uart1;
+	serial1.ops	 = &hw_uart_ops;
+	serial1.config = config;
+
+	MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);
+	MAP_GPIOPinConfigure(GPIO_PB0_U1RX);
+	MAP_GPIOPinConfigure(GPIO_PB1_U1TX);
+
+	MAP_GPIOPinTypeUART(GPIO_PORTB_BASE, GPIO_PIN_0 | GPIO_PIN_1);
+	MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART1);
+
+	/* preemption = 1, sub-priority = 1 */
+	//IntPrioritySet(INT_UART0, ((0x01 << 5) | 0x01));
+
+	/* Enable Interrupt for UART channel */
+	UARTIntRegister(uart->hw_base, UART1_IRQHandler);
+	MAP_IntEnable(INT_UART1);
+	MAP_UARTEnable(uart->hw_base);
+	MAP_IntPrioritySet(INT_UART1, 0);
+
+	/* register UART0 device */
+	rt_hw_serial_register(&serial1, "uart1",RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX| RT_DEVICE_FLAG_INT_TX,uart);
+#endif
+#ifdef RT_USING_UART2
+	uart = &uart2;
+	serial2.ops	 = &hw_uart_ops;
+	serial2.config = config;
+
+	MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOD);
+	MAP_GPIOPinConfigure(GPIO_PD4_U2RX);
+	MAP_GPIOPinConfigure(GPIO_PD5_U2TX);
+
+	MAP_GPIOPinTypeUART(GPIO_PORTD_BASE, GPIO_PIN_4 | GPIO_PIN_5);
+	MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART2);
+
+	/* preemption = 1, sub-priority = 1 */
+	//IntPrioritySet(INT_UART0, ((0x01 << 5) | 0x01));
+
+	/* Enable Interrupt for UART channel */
+	UARTIntRegister(uart->hw_base, UART2_IRQHandler);
+	MAP_IntEnable(INT_UART2);
+	MAP_UARTEnable(uart->hw_base);
+	MAP_IntPrioritySet(INT_UART2, 0);
+
+	/* register UART0 device */
+	rt_hw_serial_register(&serial2, "uart2",RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX| RT_DEVICE_FLAG_INT_TX,uart);
+#endif
+#ifdef RT_USING_UART3
+	uart = &uart3;
+	serial3.ops	 = &hw_uart_ops;
+	serial3.config = config;
+
+	MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
+	MAP_GPIOPinConfigure(GPIO_PA4_U3RX);
+	MAP_GPIOPinConfigure(GPIO_PA5_U3TX);
+
+	MAP_GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_4 | GPIO_PIN_5);
+	MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART3);
+
+	/* preemption = 1, sub-priority = 1 */
+	//IntPrioritySet(INT_UART0, ((0x01 << 5) | 0x01));
+
+	/* Enable Interrupt for UART channel */
+	UARTIntRegister(uart->hw_base, UART3_IRQHandler);
+	MAP_IntEnable(INT_UART3);
+	MAP_UARTEnable(uart->hw_base);
+	MAP_IntPrioritySet(INT_UART3, 0);
+
+	/* register UART0 device */
+	rt_hw_serial_register(&serial3, "uart3",RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX| RT_DEVICE_FLAG_INT_TX,uart);
+#endif
+#ifdef RT_USING_UART4
+	uart = &uart4;
+	serial4.ops	 = &hw_uart_ops;
+	serial4.config = config;
+
+	MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
+	MAP_GPIOPinConfigure(GPIO_PA2_U4RX);
+	MAP_GPIOPinConfigure(GPIO_PA3_U4TX);
+
+	MAP_GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_2 | GPIO_PIN_3);
+	MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART4);
+
+	/* preemption = 1, sub-priority = 1 */
+	//IntPrioritySet(INT_UART0, ((0x01 << 5) | 0x01));
+
+	/* Enable Interrupt for UART channel */
+	UARTIntRegister(uart->hw_base, UART4_IRQHandler);
+	MAP_IntEnable(INT_UART4);
+	MAP_UARTEnable(uart->hw_base);
+	MAP_IntPrioritySet(INT_UART4, 0);
+
+	/* register UART0 device */
+	rt_hw_serial_register(&serial4, "uart4",RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX| RT_DEVICE_FLAG_INT_TX,uart);
+#endif
+#ifdef RT_USING_UART6
+		uart = &uart6;
+		serial6.ops  = &hw_uart_ops;
+		serial6.config = config;
+	
+		MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOP);
+		MAP_GPIOPinConfigure(GPIO_PP0_U6RX);
+		MAP_GPIOPinConfigure(GPIO_PP1_U6TX);
+	
+		MAP_GPIOPinTypeUART(GPIO_PORTP_BASE, GPIO_PIN_0 | GPIO_PIN_1);
+		MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART6);
+	
+		/* preemption = 1, sub-priority = 1 */
+		//IntPrioritySet(INT_UART0, ((0x01 << 5) | 0x01));
+	
+		/* Enable Interrupt for UART channel */
+		UARTIntRegister(uart->hw_base, UART6_IRQHandler);
+		MAP_IntEnable(INT_UART6);
+		MAP_UARTEnable(uart->hw_base);
+		MAP_IntPrioritySet(INT_UART6, 0);
+		/* register UART0 device */
+		rt_hw_serial_register(&serial6, "uart6",RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX| RT_DEVICE_FLAG_INT_TX,uart);
+#endif
+
+	}
 	return 0;
 }
-INIT_BOARD_EXPORT(rt_hw_uart_init);
+//INIT_BOARD_EXPORT(rt_hw_uart_init);
diff --git a/bsp/tm4c129x/drivers/drv_uart.h b/bsp/tm4c129x/drivers/drv_uart.h
index 312c6da..89300ee 100644
--- a/bsp/tm4c129x/drivers/drv_uart.h
+++ b/bsp/tm4c129x/drivers/drv_uart.h
@@ -15,6 +15,6 @@
 #ifndef __UART_H__
 #define __UART_H__
 
-void rt_hw_uart_init(void);
+void rt_hw_uart_init(int use_uart);
 
 #endif
diff --git a/bsp/tm4c129x/drivers/led.c b/bsp/tm4c129x/drivers/led.c
new file mode 100755
index 0000000..f755c6c
--- /dev/null
+++ b/bsp/tm4c129x/drivers/led.c
@@ -0,0 +1,54 @@
+/*
+ * File      : led.c
+ * This file is part of RT-Thread RTOS
+ * COPYRIGHT (C) 2006-2013, RT-Thread Development Team
+ *
+ * The license and distribution terms for this file may be
+ * found in the file LICENSE in this distribution or at
+ * http://www.rt-thread.org/license/LICENSE
+ *
+ * Change Logs:
+ * Date           Author       Notes
+ * 2013-11-15     bright       the first version
+ */
+
+#include "led.h"
+/* RT_USING_COMPONENTS_INIT */
+#ifdef  RT_USING_COMPONENTS_INIT
+#include <components.h>
+#endif
+#include "board.h"
+
+#include "inc/hw_memmap.h"
+#include "driverlib/sysctl.h"
+#include "driverlib/gpio.h"
+#include "driverlib/uart.h"
+#include "driverlib/pin_map.h"
+#include "driverlib/interrupt.h"
+#include "driverlib/rom_map.h"
+
+void rt_hw_led_on(){
+	MAP_GPIOPinWrite(GPIO_PORTN_BASE, GPIO_PIN_0|GPIO_PIN_1, GPIO_PIN_0|GPIO_PIN_1);
+}
+
+void rt_hw_led_off(){
+	MAP_GPIOPinWrite(GPIO_PORTN_BASE, GPIO_PIN_0|GPIO_PIN_1, 0);
+}
+
+/*
+LED_GREEN: PC8
+LED_RED  : PC9
+*/
+
+/* Initial led gpio pin  */
+int rt_hw_led_init(void)
+{
+    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPION);
+    MAP_SysCtlDelay(1);
+    MAP_GPIOPinTypeGPIOOutput(GPIO_PORTN_BASE, GPIO_PIN_1);
+    MAP_GPIOPinTypeGPIOOutput(GPIO_PORTN_BASE, GPIO_PIN_0);
+    return 0;
+}
+
+/* Initial components for device */
+INIT_DEVICE_EXPORT(rt_hw_led_init);
diff --git a/bsp/tm4c129x/drivers/led.h b/bsp/tm4c129x/drivers/led.h
new file mode 100755
index 0000000..a418b41
--- /dev/null
+++ b/bsp/tm4c129x/drivers/led.h
@@ -0,0 +1,26 @@
+/*
+ * File      : led.h
+ * This file is part of RT-Thread RTOS
+ * COPYRIGHT (C) 2009, RT-Thread Development Team
+ *
+ * The license and distribution terms for this file may be
+ * found in the file LICENSE in this distribution or at
+ * http://www.rt-thread.org/license/LICENSE
+ *
+ * Change Logs:
+ * Date           Author       Notes
+ * 2013-13-05     bright       the first version
+ */
+
+#ifndef __LED_H__
+#define __LED_H__
+
+#include <rthw.h>
+#include <rtthread.h>
+
+int rt_hw_led_init(void);
+void rt_hw_led_on();
+void rt_hw_led_off();
+
+
+#endif
diff --git a/bsp/tm4c129x/drivers/pinout.c b/bsp/tm4c129x/drivers/pinout.c
new file mode 100755
index 0000000..a2cf417
--- /dev/null
+++ b/bsp/tm4c129x/drivers/pinout.c
@@ -0,0 +1,301 @@
+//*****************************************************************************
+//
+// pinout.c - Function to configure the device pins on the EK-TM4C1294XL.
+//
+// Copyright (c) 2013-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the EK-TM4C1294XL Firmware Package.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "inc/hw_gpio.h"
+#include "inc/hw_memmap.h"
+#include "inc/hw_types.h"
+#include "driverlib/gpio.h"
+#include "driverlib/pin_map.h"
+#include "driverlib/rom.h"
+#include "driverlib/rom_map.h"
+#include "driverlib/sysctl.h"
+#include "pinout.h"
+
+//*****************************************************************************
+//
+//! \addtogroup pinout_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! Configures the device pins for the standard usages on the EK-TM4C1294XL.
+//!
+//! \param bEthernet is a boolean used to determine function of Ethernet pins.
+//! If true Ethernet pins are  configured as Ethernet LEDs.  If false GPIO are
+//! available for application use.
+//! \param bUSB is a boolean used to determine function of USB pins. If true USB
+//! pins are configured for USB use.  If false then USB pins are available for
+//! application use as GPIO.
+//!
+//! This function enables the GPIO modules and configures the device pins for
+//! the default, standard usages on the EK-TM4C1294XL.  Applications that
+//! require alternate configurations of the device pins can either not call
+//! this function and take full responsibility for configuring all the device
+//! pins, or can reconfigure the required device pins after calling this
+//! function.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+PinoutSet(bool bEthernet, bool bUSB)
+{
+    //
+    // Enable all the GPIO peripherals.
+    //
+    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
+    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);
+    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOC);
+    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOD);
+    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOE);
+    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);
+    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOG);
+    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOH);
+    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOJ);
+    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOK);
+    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOL);
+    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOM);
+    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPION);
+    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOP);
+    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOQ);
+
+    //
+    // PA0-1 are used for UART0.
+    //
+    MAP_GPIOPinConfigure(GPIO_PA0_U0RX);
+    MAP_GPIOPinConfigure(GPIO_PA1_U0TX);
+    MAP_GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);
+
+    //
+    // PB0-1/PD6/PL6-7 are used for USB.
+    // PQ4 can be used as a power fault detect on this board but it is not
+    // the hardware peripheral power fault input pin.
+    //
+    if(bUSB)
+    {
+        HWREG(GPIO_PORTD_BASE + GPIO_O_LOCK) = GPIO_LOCK_KEY;
+        HWREG(GPIO_PORTD_BASE + GPIO_O_CR) = 0xff;
+        MAP_GPIOPinConfigure(GPIO_PD6_USB0EPEN);
+        MAP_GPIOPinTypeUSBAnalog(GPIO_PORTB_BASE, GPIO_PIN_0 | GPIO_PIN_1);
+        MAP_GPIOPinTypeUSBDigital(GPIO_PORTD_BASE, GPIO_PIN_6);
+        MAP_GPIOPinTypeUSBAnalog(GPIO_PORTL_BASE, GPIO_PIN_6 | GPIO_PIN_7);
+        MAP_GPIOPinTypeGPIOInput(GPIO_PORTQ_BASE, GPIO_PIN_4);
+    }
+    else
+    {
+        //
+        // Keep the default config for most pins used by USB.
+        // Add a pull down to PD6 to turn off the TPS2052 switch
+        //
+        MAP_GPIOPinTypeGPIOInput(GPIO_PORTD_BASE, GPIO_PIN_6);
+        MAP_GPIOPadConfigSet(GPIO_PORTD_BASE, GPIO_PIN_6, GPIO_STRENGTH_2MA,
+                             GPIO_PIN_TYPE_STD_WPD);
+
+    }
+
+    //
+    // PF0/PF4 are used for Ethernet LEDs.
+    //
+    if(bEthernet)
+    {
+        //
+        // this app wants to configure for ethernet LED function.
+        //
+        MAP_GPIOPinConfigure(GPIO_PF0_EN0LED0);
+        MAP_GPIOPinConfigure(GPIO_PF4_EN0LED1);
+
+        GPIOPinTypeEthernetLED(GPIO_PORTF_BASE, GPIO_PIN_0 | GPIO_PIN_4);
+
+    }
+    else
+    {
+
+        //
+        // This app does not want Ethernet LED function so configure as
+        // standard outputs for LED driving.
+        //
+        MAP_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_0 | GPIO_PIN_4);
+
+        //
+        // Default the LEDs to OFF.
+        //
+        MAP_GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_0 | GPIO_PIN_4, 0);
+        MAP_GPIOPadConfigSet(GPIO_PORTF_BASE, GPIO_PIN_0 | GPIO_PIN_4,
+                             GPIO_STRENGTH_12MA, GPIO_PIN_TYPE_STD);
+
+
+    }
+
+    //
+    // PJ0 and J1 are used for user buttons
+    //
+    MAP_GPIOPinTypeGPIOInput(GPIO_PORTJ_BASE, GPIO_PIN_0 | GPIO_PIN_1);
+    MAP_GPIOPinWrite(GPIO_PORTJ_BASE, GPIO_PIN_0 | GPIO_PIN_1, 0);
+
+    //
+    // PN0 and PN1 are used for USER LEDs.
+    //
+    MAP_GPIOPinTypeGPIOOutput(GPIO_PORTN_BASE, GPIO_PIN_0 | GPIO_PIN_1);
+    MAP_GPIOPadConfigSet(GPIO_PORTN_BASE, GPIO_PIN_0 | GPIO_PIN_1,
+                             GPIO_STRENGTH_12MA, GPIO_PIN_TYPE_STD);
+
+    //
+    // Default the LEDs to OFF.
+    //
+    MAP_GPIOPinWrite(GPIO_PORTN_BASE, GPIO_PIN_0 | GPIO_PIN_1, 0);
+}
+
+//*****************************************************************************
+//
+//! This function writes a state to the LED bank.
+//!
+//! \param ui32LEDMask is a bit mask for which GPIO should be changed by this
+//! call.
+//! \param ui32LEDValue is the new value to be applied to the LEDs after the
+//! ui32LEDMask is applied.
+//!
+//! The first parameter acts as a mask.  Only bits in the mask that are set
+//! will correspond to LEDs that may change.  LEDs with a mask that is not set
+//! will not change. This works the same as GPIOPinWrite. After applying the
+//! mask the setting for each unmasked LED is written to the corresponding
+//! LED port pin via GPIOPinWrite.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+LEDWrite(uint32_t ui32LEDMask, uint32_t ui32LEDValue)
+{
+
+    //
+    // Check the mask and set or clear the LED as directed.
+    //
+    if(ui32LEDMask & CLP_D1)
+    {
+        if(ui32LEDValue & CLP_D1)
+        {
+            GPIOPinWrite(CLP_D1_PORT, CLP_D1_PIN, CLP_D1_PIN);
+        }
+        else
+        {
+            GPIOPinWrite(CLP_D1_PORT, CLP_D1_PIN, 0);
+        }
+    }
+
+    if(ui32LEDMask & CLP_D2)
+    {
+        if(ui32LEDValue & CLP_D2)
+        {
+            GPIOPinWrite(CLP_D2_PORT, CLP_D2_PIN, CLP_D2_PIN);
+        }
+        else
+        {
+            GPIOPinWrite(CLP_D2_PORT, CLP_D2_PIN, 0);
+        }
+    }
+
+    if(ui32LEDMask & CLP_D3)
+    {
+        if(ui32LEDValue & CLP_D3)
+        {
+            GPIOPinWrite(CLP_D3_PORT, CLP_D3_PIN, CLP_D3_PIN);
+        }
+        else
+        {
+            GPIOPinWrite(CLP_D3_PORT, CLP_D3_PIN, 0);
+        }
+    }
+
+    if(ui32LEDMask & CLP_D4)
+    {
+        if(ui32LEDValue & CLP_D4)
+        {
+            GPIOPinWrite(CLP_D4_PORT, CLP_D4_PIN, CLP_D4_PIN);
+        }
+        else
+        {
+            GPIOPinWrite(CLP_D4_PORT, CLP_D4_PIN, 0);
+        }
+    }
+}
+
+//*****************************************************************************
+//
+//! This function reads the state to the LED bank.
+//!
+//! \param pui32LEDValue is a pointer to where the LED value will be stored.
+//!
+//! This function reads the state of the CLP LEDs and stores that state
+//! information into the variable pointed to by pui32LEDValue.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void LEDRead(uint32_t *pui32LEDValue)
+{
+    *pui32LEDValue = 0;
+
+    //
+    // Read the pin state and set the variable bit if needed.
+    //
+    if(GPIOPinRead(CLP_D4_PORT, CLP_D4_PIN))
+    {
+        *pui32LEDValue |= CLP_D4;
+    }
+
+    //
+    // Read the pin state and set the variable bit if needed.
+    //
+    if(GPIOPinRead(CLP_D3_PORT, CLP_D3_PIN))
+    {
+        *pui32LEDValue |= CLP_D3;
+    }
+
+    //
+    // Read the pin state and set the variable bit if needed.
+    //
+    if(GPIOPinRead(CLP_D2_PORT, CLP_D2_PIN))
+    {
+        *pui32LEDValue |= CLP_D2;
+    }
+
+    //
+    // Read the pin state and set the variable bit if needed.
+    //
+    if(GPIOPinRead(CLP_D1_PORT, CLP_D1_PIN))
+    {
+        *pui32LEDValue |= CLP_D1;
+    }
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
diff --git a/bsp/tm4c129x/drivers/pinout.h b/bsp/tm4c129x/drivers/pinout.h
new file mode 100755
index 0000000..a5bb234
--- /dev/null
+++ b/bsp/tm4c129x/drivers/pinout.h
@@ -0,0 +1,80 @@
+//*****************************************************************************
+//
+// pinout.h - Prototype for the function to configure the device pins on the
+//            EK-TM4C1294XL.
+//
+// Copyright (c) 2013-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the EK-TM4C1294XL Firmware Package.
+//
+//*****************************************************************************
+
+#ifndef __DRIVERS_PINOUT_H__
+#define __DRIVERS_PINOUT_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+//*****************************************************************************
+//
+// Define Board LED's
+//
+//*****************************************************************************
+#define CLP_D1              1
+#define CLP_D2              2
+#define CLP_D3              4
+#define CLP_D4              8
+
+#define CLP_D1_PORT         GPIO_PORTN_BASE
+#define CLP_D1_PIN          GPIO_PIN_1
+
+#define CLP_D2_PORT         GPIO_PORTN_BASE
+#define CLP_D2_PIN          GPIO_PIN_0
+
+#define CLP_D3_PORT         GPIO_PORTF_BASE
+#define CLP_D3_PIN          GPIO_PIN_4
+
+#define CLP_D4_PORT         GPIO_PORTF_BASE
+#define CLP_D4_PIN          GPIO_PIN_0
+
+//*****************************************************************************
+//
+// Prototypes.
+//
+//*****************************************************************************
+extern void PinoutSet(bool bEthernet, bool bUSB);
+extern void LEDWrite(uint32_t ui32LEDMask, uint32_t ui32LEDValue);
+extern void LEDRead(uint32_t *pui32LEDValue);
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __DRIVERS_PINOUT_H__
diff --git a/bsp/tm4c129x/ipv6_client.py b/bsp/tm4c129x/ipv6_client.py
new file mode 100755
index 0000000..010c79f
--- /dev/null
+++ b/bsp/tm4c129x/ipv6_client.py
@@ -0,0 +1,76 @@
+import socket, sys
+import time
+
+class MiniClient:
+    h = ''
+    p = ''
+    m = ''
+    c = int(0)
+    d = int(0)
+    
+    def __init__(self, host, port, mode):
+        self.h = host
+        self.p = int(port)
+        self.m = mode
+    def tcpC4(self):
+        tcpT4Client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+        print "Done........"
+        tcpT4Client.connect((self.h, self.p))
+        print "TCP IPv4 TCP mode connecting..."
+        while True:
+            #time.sleep(1)
+            tcpT4Client.send('sdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgfSDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgsdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgfSDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgsdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgfSDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgsdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgfSDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgsdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgfSDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgsdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgfSDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgsdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgfSDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhg')
+            buf = tcpT4Client.recv(1024)
+            print "Receive  ", buf
+            self.c = self.c + len(buf)
+            self.d = self.d + len('sdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgfSDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgsdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgfSDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgsdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgfSDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgsdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgfSDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgsdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgfSDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgsdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgfSDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgsdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgfSDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhgfhgf123456789ssdadsadfASDSDAFSDFASFDASDFJHKLSAJDFLKJASLKDJFLKSAJDFLJSALKFasdfsafdsfdasfdJKLASDJLFgfjfjhgjhgjhgjghgfhg')
+            print "Received length = ", self.c, ",Sent length = ", self.d, " "
+
+    def udpC4(self):
+        udpT4Client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
+        print "UDP TCP IPv4 Mode connecting..."
+        while True:
+            udpT4Client.sendto("hello", (self.h, self.p))
+            udpT4Data, udpT6ServerInfo = udpT4Client.recvfrom(1024)
+            #print "Receive  ", udpT4Data
+            self.c = self.c + len(udpT4Data)
+            #time.sleep(0.0001)
+            self.d = self.d + len("hello")
+            print "Received length = ", self.c, "Sent length = ", self.d+5
+                
+    def tcpC6(self):
+        tcpT4Client = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)
+        print "Done........"
+        tcpT4Client.connect((self.h, self.p))
+        print "TCP IPv6 TCP mode connecting..."
+        while True:
+            tcpT4Client.send('hello')
+            self.d = self.d + len('hello')
+            buf = tcpT4Client.recv(1024)
+            print "Receive  ", buf
+            self.c = self.c + len(buf)
+            print "Received length = ", self.c, "Sent length = ", self.d
+        
+    def udpC6(self):
+        udpU6Client = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)
+        udpU6Client.bind(('fe80::5867:8730:e9e6:d5c5%11', self.p))
+        print "UDP TCP IPv6 Mode connecting..."
+        while True:
+            udpT4Data, udpT6ServerInfo = udpU6Client.recvfrom(1024)			
+            udpU6Client.sendto("hello", (self.h, self.p))
+            self.d = self.d + len('hello')
+            #time.sleep(0.0001)
+            print "Receive  ", udpT4Data
+            self.c = self.c + len(udpT4Data)
+            print "Received length = ", self.c, "Sent length = ", self.d
+            
+if __name__ == "__main__":
+    x = MiniClient(sys.argv[1], sys.argv[2], sys.argv[3])
+    if x.m == 't4':
+        x.tcpC4()
+    elif x.m == 't6':
+        x.tcpC6()
+    elif x.m == 'u4':
+        x.udpC4()
+    else:
+        x.udpC6()
diff --git a/bsp/tm4c129x/ipv6_server.py b/bsp/tm4c129x/ipv6_server.py
new file mode 100755
index 0000000..c51fafb
--- /dev/null
+++ b/bsp/tm4c129x/ipv6_server.py
@@ -0,0 +1,82 @@
+import socket, sys
+import time
+class MiniServer:
+    h = ''
+    p = ''
+    m = ''
+    c = int(0)
+    d = int(0)
+    def __init__(self, host, port, mode):
+        self.h = host
+        self.p = int(port)
+        self.m = mode
+    def serverT4(self):
+        tcpT4Server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+        print "Server Socket Created......."
+        tcpT4Server.bind((self.h, self.p))
+        print "Wating for connecting......."
+        tcpT4Server.listen(5)
+        while True:
+            clientSock, clientaddr = tcpT4Server.accept()
+            print "Connected from: ", clientSock.getpeername()             
+            while True:
+                clientSock.send('Congratulations........')
+                buf = clientSock.recv(1024)
+                self.c = self.c + len(buf)
+                self.d = self.d + len('Congratulations........')
+                print "Received length = ", self.c, ",Sent length = ", self.d
+               #clientSock.close()
+    
+    def udpT4(self):
+        udpT4Server = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
+        print "UDP TCP IPv4 Mode Start....."
+        udpT4Server.bind((self.h, self.p))
+        print "UDP Server Start"
+        while True:
+            udpT4Server.sendto('Congratulations........',('192.168.1.32', self.p))
+            udpT4Data, udpT4ServerInfo = udpT4Server.recvfrom(1024)
+            print "Receive from ", udpT4ServerInfo, " and The Data send from The Client is :", udpT4Data
+            self.c = self.c + len(udpT4Data)
+            self.d = self.d + len('Congratulations........')
+            print "Received length = ", self.c, ",Sent length = ", self.d
+
+    def serverT6(self):
+        tcpT6Server = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)
+        print "Server Socket Created......."
+        tcpT6Server.bind((self.h, self.p))
+        print "Wating for connecting......."
+        tcpT6Server.listen(5)
+        while True:
+            clientSock, clientaddr = tcpT6Server.accept()
+            print "Connected from: ", clientSock.getpeername() 
+            while True:
+			clientSock.send('Congratulations........')
+			buf = clientSock.recv(1024)
+			self.c = self.c + len(buf)
+			self.d = self.d + len('Congratulations........')
+			print "Received length = ", self.c, ",Sent length = ", self.d
+            #clientSock.close()
+    def udpT6(self):
+        udpT6Server = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)
+        print "UDP IPv6 Mode Start....."
+        udpT6Server.bind((self.h, self.p))
+        print "UDP Server Start"
+        while True:
+            udpT6Server.sendto('Congratulations........',('fe80::1', 261))
+            udpT4Data, udpT6ServerInfo = udpT6Server.recvfrom(1024)
+            print "Receive from ", udpT6ServerInfo, " and The Data send from The Client is :", udpT4Data
+            self.c = self.c + len(udpT4Data)
+            #time.sleep(0.001)
+            self.d = self.d + len('Congratulations........')
+            print "Received length = ", self.c, ",Sent length = ", self.d
+
+if __name__ == "__main__":
+    x = MiniServer(sys.argv[1], sys.argv[2], sys.argv[3])
+    if x.m == 't4':
+        x.serverT4()
+    elif x.m == 't6':
+        x.serverT6()
+    elif x.m == 'u4':
+        x.udpT4()
+    else:
+        x.udpT6()
diff --git a/bsp/tm4c129x/libraries/SConscript b/bsp/tm4c129x/libraries/SConscript
index 8b48a34..2ded3d7 100644
--- a/bsp/tm4c129x/libraries/SConscript
+++ b/bsp/tm4c129x/libraries/SConscript
@@ -5,6 +5,8 @@ from building import *
 # The set of source files associated with this SConscript file.
 cwd     = GetCurrentDir()
 src = Glob('driverlib/*.c')
+src += Glob('usblib/*.c')
+src += Glob('usblib/device/*.c')
 SrcRemove(src, 'onewire.c')
 
 # add for startup script 
@@ -14,8 +16,10 @@ elif rtconfig.CROSS_TOOL == 'keil':
 	src += ['startup/startup_rvmdk.S']
 elif rtconfig.CROSS_TOOL == 'iar':
 	src += ['startup/startup_ewarm.c']
+elif rtconfig.CROSS_TOOL == 'ccs':
+	src += ['startup/startup_ccs.c']
 
-CPPPATH = [cwd, cwd + '/inc', cwd + '/driverlib']
+CPPPATH = [cwd, cwd + '/inc', cwd + '/driverlib', cwd + '/usblib', cwd + '/usblib/device']
 
 CPPDEFINES = [rtconfig.PART_TYPE]
 if rtconfig.CROSS_TOOL == 'gcc':
diff --git a/bsp/tm4c129x/libraries/inc/tm4c129xnczad.h b/bsp/tm4c129x/libraries/inc/tm4c129xnczad.h
new file mode 100755
index 0000000..cb5d91d
--- /dev/null
+++ b/bsp/tm4c129x/libraries/inc/tm4c129xnczad.h
@@ -0,0 +1,17263 @@
+//*****************************************************************************
+//
+// tm4c129xnczad.h - TM4C129XNCZAD Register Definitions
+//
+// Copyright (c) 2013-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+//   Redistribution and use in source and binary forms, with or without
+//   modification, are permitted provided that the following conditions
+//   are met:
+// 
+//   Redistributions of source code must retain the above copyright
+//   notice, this list of conditions and the following disclaimer.
+// 
+//   Redistributions in binary form must reproduce the above copyright
+//   notice, this list of conditions and the following disclaimer in the
+//   documentation and/or other materials provided with the  
+//   distribution.
+// 
+//   Neither the name of Texas Instruments Incorporated nor the names of
+//   its contributors may be used to endorse or promote products derived
+//   from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __TM4C129XNCZAD_H__
+#define __TM4C129XNCZAD_H__
+
+//*****************************************************************************
+//
+// Interrupt assignments
+//
+//*****************************************************************************
+#define INT_GPIOA               16          // GPIO Port A
+#define INT_GPIOB               17          // GPIO Port B
+#define INT_GPIOC               18          // GPIO Port C
+#define INT_GPIOD               19          // GPIO Port D
+#define INT_GPIOE               20          // GPIO Port E
+#define INT_UART0               21          // UART0
+#define INT_UART1               22          // UART1
+#define INT_SSI0                23          // SSI0
+#define INT_I2C0                24          // I2C0
+#define INT_PWM0_FAULT          25          // PWM Fault
+#define INT_PWM0_0              26          // PWM Generator 0
+#define INT_PWM0_1              27          // PWM Generator 1
+#define INT_PWM0_2              28          // PWM Generator 2
+#define INT_QEI0                29          // QEI0
+#define INT_ADC0SS0             30          // ADC0 Sequence 0
+#define INT_ADC0SS1             31          // ADC0 Sequence 1
+#define INT_ADC0SS2             32          // ADC0 Sequence 2
+#define INT_ADC0SS3             33          // ADC0 Sequence 3
+#define INT_WATCHDOG            34          // Watchdog Timers 0 and 1
+#define INT_TIMER0A             35          // 16/32-Bit Timer 0A
+#define INT_TIMER0B             36          // 16/32-Bit Timer 0B
+#define INT_TIMER1A             37          // 16/32-Bit Timer 1A
+#define INT_TIMER1B             38          // 16/32-Bit Timer 1B
+#define INT_TIMER2A             39          // 16/32-Bit Timer 2A
+#define INT_TIMER2B             40          // 16/32-Bit Timer 2B
+#define INT_COMP0               41          // Analog Comparator 0
+#define INT_COMP1               42          // Analog Comparator 1
+#define INT_COMP2               43          // Analog Comparator 2
+#define INT_SYSCTL              44          // System Control
+#define INT_FLASH               45          // Flash Memory Control
+#define INT_GPIOF               46          // GPIO Port F
+#define INT_GPIOG               47          // GPIO Port G
+#define INT_GPIOH               48          // GPIO Port H
+#define INT_UART2               49          // UART2
+#define INT_SSI1                50          // SSI1
+#define INT_TIMER3A             51          // 16/32-Bit Timer 3A
+#define INT_TIMER3B             52          // 16/32-Bit Timer 3B
+#define INT_I2C1                53          // I2C1
+#define INT_CAN0                54          // CAN 0
+#define INT_CAN1                55          // CAN1
+#define INT_EMAC0               56          // Ethernet MAC
+#define INT_HIBERNATE           57          // HIB
+#define INT_USB0                58          // USB MAC
+#define INT_PWM0_3              59          // PWM Generator 3
+#define INT_UDMA                60          // uDMA 0 Software
+#define INT_UDMAERR             61          // uDMA 0 Error
+#define INT_ADC1SS0             62          // ADC1 Sequence 0
+#define INT_ADC1SS1             63          // ADC1 Sequence 1
+#define INT_ADC1SS2             64          // ADC1 Sequence 2
+#define INT_ADC1SS3             65          // ADC1 Sequence 3
+#define INT_EPI0                66          // EPI 0
+#define INT_GPIOJ               67          // GPIO Port J
+#define INT_GPIOK               68          // GPIO Port K
+#define INT_GPIOL               69          // GPIO Port L
+#define INT_SSI2                70          // SSI 2
+#define INT_SSI3                71          // SSI 3
+#define INT_UART3               72          // UART 3
+#define INT_UART4               73          // UART 4
+#define INT_UART5               74          // UART 5
+#define INT_UART6               75          // UART 6
+#define INT_UART7               76          // UART 7
+#define INT_I2C2                77          // I2C 2
+#define INT_I2C3                78          // I2C 3
+#define INT_TIMER4A             79          // Timer 4A
+#define INT_TIMER4B             80          // Timer 4B
+#define INT_TIMER5A             81          // Timer 5A
+#define INT_TIMER5B             82          // Timer 5B
+#define INT_SYSEXC              83          // Floating-Point Exception
+                                            // (imprecise)
+#define INT_I2C4                86          // I2C 4
+#define INT_I2C5                87          // I2C 5
+#define INT_GPIOM               88          // GPIO Port M
+#define INT_GPION               89          // GPIO Port N
+#define INT_TAMPER0             91          // Tamper
+#define INT_GPIOP0              92          // GPIO Port P (Summary or P0)
+#define INT_GPIOP1              93          // GPIO Port P1
+#define INT_GPIOP2              94          // GPIO Port P2
+#define INT_GPIOP3              95          // GPIO Port P3
+#define INT_GPIOP4              96          // GPIO Port P4
+#define INT_GPIOP5              97          // GPIO Port P5
+#define INT_GPIOP6              98          // GPIO Port P6
+#define INT_GPIOP7              99          // GPIO Port P7
+#define INT_GPIOQ0              100         // GPIO Port Q (Summary or Q0)
+#define INT_GPIOQ1              101         // GPIO Port Q1
+#define INT_GPIOQ2              102         // GPIO Port Q2
+#define INT_GPIOQ3              103         // GPIO Port Q3
+#define INT_GPIOQ4              104         // GPIO Port Q4
+#define INT_GPIOQ5              105         // GPIO Port Q5
+#define INT_GPIOQ6              106         // GPIO Port Q6
+#define INT_GPIOQ7              107         // GPIO Port Q7
+#define INT_GPIOR               108         // GPIO Port R
+#define INT_GPIOS               109         // GPIO Port S
+#define INT_SHA0                110         // SHA/MD5
+#define INT_AES0                111         // AES
+#define INT_DES0                112         // DES
+#define INT_LCD0                113         // LCD
+#define INT_TIMER6A             114         // 16/32-Bit Timer 6A
+#define INT_TIMER6B             115         // 16/32-Bit Timer 6B
+#define INT_TIMER7A             116         // 16/32-Bit Timer 7A
+#define INT_TIMER7B             117         // 16/32-Bit Timer 7B
+#define INT_I2C6                118         // I2C 6
+#define INT_I2C7                119         // I2C 7
+#define INT_ONEWIRE0            121         // 1-Wire
+#define INT_I2C8                125         // I2C 8
+#define INT_I2C9                126         // I2C 9
+#define INT_GPIOT               127         // GPIO T
+
+//*****************************************************************************
+//
+// Watchdog Timer registers (WATCHDOG0)
+//
+//*****************************************************************************
+#define WATCHDOG0_LOAD_R        (*((volatile uint32_t *)0x40000000))
+#define WATCHDOG0_VALUE_R       (*((volatile uint32_t *)0x40000004))
+#define WATCHDOG0_CTL_R         (*((volatile uint32_t *)0x40000008))
+#define WATCHDOG0_ICR_R         (*((volatile uint32_t *)0x4000000C))
+#define WATCHDOG0_RIS_R         (*((volatile uint32_t *)0x40000010))
+#define WATCHDOG0_MIS_R         (*((volatile uint32_t *)0x40000014))
+#define WATCHDOG0_TEST_R        (*((volatile uint32_t *)0x40000418))
+#define WATCHDOG0_LOCK_R        (*((volatile uint32_t *)0x40000C00))
+
+//*****************************************************************************
+//
+// Watchdog Timer registers (WATCHDOG1)
+//
+//*****************************************************************************
+#define WATCHDOG1_LOAD_R        (*((volatile uint32_t *)0x40001000))
+#define WATCHDOG1_VALUE_R       (*((volatile uint32_t *)0x40001004))
+#define WATCHDOG1_CTL_R         (*((volatile uint32_t *)0x40001008))
+#define WATCHDOG1_ICR_R         (*((volatile uint32_t *)0x4000100C))
+#define WATCHDOG1_RIS_R         (*((volatile uint32_t *)0x40001010))
+#define WATCHDOG1_MIS_R         (*((volatile uint32_t *)0x40001014))
+#define WATCHDOG1_TEST_R        (*((volatile uint32_t *)0x40001418))
+#define WATCHDOG1_LOCK_R        (*((volatile uint32_t *)0x40001C00))
+
+//*****************************************************************************
+//
+// SSI registers (SSI0)
+//
+//*****************************************************************************
+#define SSI0_CR0_R              (*((volatile uint32_t *)0x40008000))
+#define SSI0_CR1_R              (*((volatile uint32_t *)0x40008004))
+#define SSI0_DR_R               (*((volatile uint32_t *)0x40008008))
+#define SSI0_SR_R               (*((volatile uint32_t *)0x4000800C))
+#define SSI0_CPSR_R             (*((volatile uint32_t *)0x40008010))
+#define SSI0_IM_R               (*((volatile uint32_t *)0x40008014))
+#define SSI0_RIS_R              (*((volatile uint32_t *)0x40008018))
+#define SSI0_MIS_R              (*((volatile uint32_t *)0x4000801C))
+#define SSI0_ICR_R              (*((volatile uint32_t *)0x40008020))
+#define SSI0_DMACTL_R           (*((volatile uint32_t *)0x40008024))
+#define SSI0_PP_R               (*((volatile uint32_t *)0x40008FC0))
+#define SSI0_CC_R               (*((volatile uint32_t *)0x40008FC8))
+
+//*****************************************************************************
+//
+// SSI registers (SSI1)
+//
+//*****************************************************************************
+#define SSI1_CR0_R              (*((volatile uint32_t *)0x40009000))
+#define SSI1_CR1_R              (*((volatile uint32_t *)0x40009004))
+#define SSI1_DR_R               (*((volatile uint32_t *)0x40009008))
+#define SSI1_SR_R               (*((volatile uint32_t *)0x4000900C))
+#define SSI1_CPSR_R             (*((volatile uint32_t *)0x40009010))
+#define SSI1_IM_R               (*((volatile uint32_t *)0x40009014))
+#define SSI1_RIS_R              (*((volatile uint32_t *)0x40009018))
+#define SSI1_MIS_R              (*((volatile uint32_t *)0x4000901C))
+#define SSI1_ICR_R              (*((volatile uint32_t *)0x40009020))
+#define SSI1_DMACTL_R           (*((volatile uint32_t *)0x40009024))
+#define SSI1_PP_R               (*((volatile uint32_t *)0x40009FC0))
+#define SSI1_CC_R               (*((volatile uint32_t *)0x40009FC8))
+
+//*****************************************************************************
+//
+// SSI registers (SSI2)
+//
+//*****************************************************************************
+#define SSI2_CR0_R              (*((volatile uint32_t *)0x4000A000))
+#define SSI2_CR1_R              (*((volatile uint32_t *)0x4000A004))
+#define SSI2_DR_R               (*((volatile uint32_t *)0x4000A008))
+#define SSI2_SR_R               (*((volatile uint32_t *)0x4000A00C))
+#define SSI2_CPSR_R             (*((volatile uint32_t *)0x4000A010))
+#define SSI2_IM_R               (*((volatile uint32_t *)0x4000A014))
+#define SSI2_RIS_R              (*((volatile uint32_t *)0x4000A018))
+#define SSI2_MIS_R              (*((volatile uint32_t *)0x4000A01C))
+#define SSI2_ICR_R              (*((volatile uint32_t *)0x4000A020))
+#define SSI2_DMACTL_R           (*((volatile uint32_t *)0x4000A024))
+#define SSI2_PP_R               (*((volatile uint32_t *)0x4000AFC0))
+#define SSI2_CC_R               (*((volatile uint32_t *)0x4000AFC8))
+
+//*****************************************************************************
+//
+// SSI registers (SSI3)
+//
+//*****************************************************************************
+#define SSI3_CR0_R              (*((volatile uint32_t *)0x4000B000))
+#define SSI3_CR1_R              (*((volatile uint32_t *)0x4000B004))
+#define SSI3_DR_R               (*((volatile uint32_t *)0x4000B008))
+#define SSI3_SR_R               (*((volatile uint32_t *)0x4000B00C))
+#define SSI3_CPSR_R             (*((volatile uint32_t *)0x4000B010))
+#define SSI3_IM_R               (*((volatile uint32_t *)0x4000B014))
+#define SSI3_RIS_R              (*((volatile uint32_t *)0x4000B018))
+#define SSI3_MIS_R              (*((volatile uint32_t *)0x4000B01C))
+#define SSI3_ICR_R              (*((volatile uint32_t *)0x4000B020))
+#define SSI3_DMACTL_R           (*((volatile uint32_t *)0x4000B024))
+#define SSI3_PP_R               (*((volatile uint32_t *)0x4000BFC0))
+#define SSI3_CC_R               (*((volatile uint32_t *)0x4000BFC8))
+
+//*****************************************************************************
+//
+// UART registers (UART0)
+//
+//*****************************************************************************
+#define UART0_DR_R              (*((volatile uint32_t *)0x4000C000))
+#define UART0_RSR_R             (*((volatile uint32_t *)0x4000C004))
+#define UART0_ECR_R             (*((volatile uint32_t *)0x4000C004))
+#define UART0_FR_R              (*((volatile uint32_t *)0x4000C018))
+#define UART0_ILPR_R            (*((volatile uint32_t *)0x4000C020))
+#define UART0_IBRD_R            (*((volatile uint32_t *)0x4000C024))
+#define UART0_FBRD_R            (*((volatile uint32_t *)0x4000C028))
+#define UART0_LCRH_R            (*((volatile uint32_t *)0x4000C02C))
+#define UART0_CTL_R             (*((volatile uint32_t *)0x4000C030))
+#define UART0_IFLS_R            (*((volatile uint32_t *)0x4000C034))
+#define UART0_IM_R              (*((volatile uint32_t *)0x4000C038))
+#define UART0_RIS_R             (*((volatile uint32_t *)0x4000C03C))
+#define UART0_MIS_R             (*((volatile uint32_t *)0x4000C040))
+#define UART0_ICR_R             (*((volatile uint32_t *)0x4000C044))
+#define UART0_DMACTL_R          (*((volatile uint32_t *)0x4000C048))
+#define UART0_9BITADDR_R        (*((volatile uint32_t *)0x4000C0A4))
+#define UART0_9BITAMASK_R       (*((volatile uint32_t *)0x4000C0A8))
+#define UART0_PP_R              (*((volatile uint32_t *)0x4000CFC0))
+#define UART0_CC_R              (*((volatile uint32_t *)0x4000CFC8))
+
+//*****************************************************************************
+//
+// UART registers (UART1)
+//
+//*****************************************************************************
+#define UART1_DR_R              (*((volatile uint32_t *)0x4000D000))
+#define UART1_RSR_R             (*((volatile uint32_t *)0x4000D004))
+#define UART1_ECR_R             (*((volatile uint32_t *)0x4000D004))
+#define UART1_FR_R              (*((volatile uint32_t *)0x4000D018))
+#define UART1_ILPR_R            (*((volatile uint32_t *)0x4000D020))
+#define UART1_IBRD_R            (*((volatile uint32_t *)0x4000D024))
+#define UART1_FBRD_R            (*((volatile uint32_t *)0x4000D028))
+#define UART1_LCRH_R            (*((volatile uint32_t *)0x4000D02C))
+#define UART1_CTL_R             (*((volatile uint32_t *)0x4000D030))
+#define UART1_IFLS_R            (*((volatile uint32_t *)0x4000D034))
+#define UART1_IM_R              (*((volatile uint32_t *)0x4000D038))
+#define UART1_RIS_R             (*((volatile uint32_t *)0x4000D03C))
+#define UART1_MIS_R             (*((volatile uint32_t *)0x4000D040))
+#define UART1_ICR_R             (*((volatile uint32_t *)0x4000D044))
+#define UART1_DMACTL_R          (*((volatile uint32_t *)0x4000D048))
+#define UART1_9BITADDR_R        (*((volatile uint32_t *)0x4000D0A4))
+#define UART1_9BITAMASK_R       (*((volatile uint32_t *)0x4000D0A8))
+#define UART1_PP_R              (*((volatile uint32_t *)0x4000DFC0))
+#define UART1_CC_R              (*((volatile uint32_t *)0x4000DFC8))
+
+//*****************************************************************************
+//
+// UART registers (UART2)
+//
+//*****************************************************************************
+#define UART2_DR_R              (*((volatile uint32_t *)0x4000E000))
+#define UART2_RSR_R             (*((volatile uint32_t *)0x4000E004))
+#define UART2_ECR_R             (*((volatile uint32_t *)0x4000E004))
+#define UART2_FR_R              (*((volatile uint32_t *)0x4000E018))
+#define UART2_ILPR_R            (*((volatile uint32_t *)0x4000E020))
+#define UART2_IBRD_R            (*((volatile uint32_t *)0x4000E024))
+#define UART2_FBRD_R            (*((volatile uint32_t *)0x4000E028))
+#define UART2_LCRH_R            (*((volatile uint32_t *)0x4000E02C))
+#define UART2_CTL_R             (*((volatile uint32_t *)0x4000E030))
+#define UART2_IFLS_R            (*((volatile uint32_t *)0x4000E034))
+#define UART2_IM_R              (*((volatile uint32_t *)0x4000E038))
+#define UART2_RIS_R             (*((volatile uint32_t *)0x4000E03C))
+#define UART2_MIS_R             (*((volatile uint32_t *)0x4000E040))
+#define UART2_ICR_R             (*((volatile uint32_t *)0x4000E044))
+#define UART2_DMACTL_R          (*((volatile uint32_t *)0x4000E048))
+#define UART2_9BITADDR_R        (*((volatile uint32_t *)0x4000E0A4))
+#define UART2_9BITAMASK_R       (*((volatile uint32_t *)0x4000E0A8))
+#define UART2_PP_R              (*((volatile uint32_t *)0x4000EFC0))
+#define UART2_CC_R              (*((volatile uint32_t *)0x4000EFC8))
+
+//*****************************************************************************
+//
+// UART registers (UART3)
+//
+//*****************************************************************************
+#define UART3_DR_R              (*((volatile uint32_t *)0x4000F000))
+#define UART3_RSR_R             (*((volatile uint32_t *)0x4000F004))
+#define UART3_ECR_R             (*((volatile uint32_t *)0x4000F004))
+#define UART3_FR_R              (*((volatile uint32_t *)0x4000F018))
+#define UART3_ILPR_R            (*((volatile uint32_t *)0x4000F020))
+#define UART3_IBRD_R            (*((volatile uint32_t *)0x4000F024))
+#define UART3_FBRD_R            (*((volatile uint32_t *)0x4000F028))
+#define UART3_LCRH_R            (*((volatile uint32_t *)0x4000F02C))
+#define UART3_CTL_R             (*((volatile uint32_t *)0x4000F030))
+#define UART3_IFLS_R            (*((volatile uint32_t *)0x4000F034))
+#define UART3_IM_R              (*((volatile uint32_t *)0x4000F038))
+#define UART3_RIS_R             (*((volatile uint32_t *)0x4000F03C))
+#define UART3_MIS_R             (*((volatile uint32_t *)0x4000F040))
+#define UART3_ICR_R             (*((volatile uint32_t *)0x4000F044))
+#define UART3_DMACTL_R          (*((volatile uint32_t *)0x4000F048))
+#define UART3_9BITADDR_R        (*((volatile uint32_t *)0x4000F0A4))
+#define UART3_9BITAMASK_R       (*((volatile uint32_t *)0x4000F0A8))
+#define UART3_PP_R              (*((volatile uint32_t *)0x4000FFC0))
+#define UART3_CC_R              (*((volatile uint32_t *)0x4000FFC8))
+
+//*****************************************************************************
+//
+// UART registers (UART4)
+//
+//*****************************************************************************
+#define UART4_DR_R              (*((volatile uint32_t *)0x40010000))
+#define UART4_RSR_R             (*((volatile uint32_t *)0x40010004))
+#define UART4_ECR_R             (*((volatile uint32_t *)0x40010004))
+#define UART4_FR_R              (*((volatile uint32_t *)0x40010018))
+#define UART4_ILPR_R            (*((volatile uint32_t *)0x40010020))
+#define UART4_IBRD_R            (*((volatile uint32_t *)0x40010024))
+#define UART4_FBRD_R            (*((volatile uint32_t *)0x40010028))
+#define UART4_LCRH_R            (*((volatile uint32_t *)0x4001002C))
+#define UART4_CTL_R             (*((volatile uint32_t *)0x40010030))
+#define UART4_IFLS_R            (*((volatile uint32_t *)0x40010034))
+#define UART4_IM_R              (*((volatile uint32_t *)0x40010038))
+#define UART4_RIS_R             (*((volatile uint32_t *)0x4001003C))
+#define UART4_MIS_R             (*((volatile uint32_t *)0x40010040))
+#define UART4_ICR_R             (*((volatile uint32_t *)0x40010044))
+#define UART4_DMACTL_R          (*((volatile uint32_t *)0x40010048))
+#define UART4_9BITADDR_R        (*((volatile uint32_t *)0x400100A4))
+#define UART4_9BITAMASK_R       (*((volatile uint32_t *)0x400100A8))
+#define UART4_PP_R              (*((volatile uint32_t *)0x40010FC0))
+#define UART4_CC_R              (*((volatile uint32_t *)0x40010FC8))
+
+//*****************************************************************************
+//
+// UART registers (UART5)
+//
+//*****************************************************************************
+#define UART5_DR_R              (*((volatile uint32_t *)0x40011000))
+#define UART5_RSR_R             (*((volatile uint32_t *)0x40011004))
+#define UART5_ECR_R             (*((volatile uint32_t *)0x40011004))
+#define UART5_FR_R              (*((volatile uint32_t *)0x40011018))
+#define UART5_ILPR_R            (*((volatile uint32_t *)0x40011020))
+#define UART5_IBRD_R            (*((volatile uint32_t *)0x40011024))
+#define UART5_FBRD_R            (*((volatile uint32_t *)0x40011028))
+#define UART5_LCRH_R            (*((volatile uint32_t *)0x4001102C))
+#define UART5_CTL_R             (*((volatile uint32_t *)0x40011030))
+#define UART5_IFLS_R            (*((volatile uint32_t *)0x40011034))
+#define UART5_IM_R              (*((volatile uint32_t *)0x40011038))
+#define UART5_RIS_R             (*((volatile uint32_t *)0x4001103C))
+#define UART5_MIS_R             (*((volatile uint32_t *)0x40011040))
+#define UART5_ICR_R             (*((volatile uint32_t *)0x40011044))
+#define UART5_DMACTL_R          (*((volatile uint32_t *)0x40011048))
+#define UART5_9BITADDR_R        (*((volatile uint32_t *)0x400110A4))
+#define UART5_9BITAMASK_R       (*((volatile uint32_t *)0x400110A8))
+#define UART5_PP_R              (*((volatile uint32_t *)0x40011FC0))
+#define UART5_CC_R              (*((volatile uint32_t *)0x40011FC8))
+
+//*****************************************************************************
+//
+// UART registers (UART6)
+//
+//*****************************************************************************
+#define UART6_DR_R              (*((volatile uint32_t *)0x40012000))
+#define UART6_RSR_R             (*((volatile uint32_t *)0x40012004))
+#define UART6_ECR_R             (*((volatile uint32_t *)0x40012004))
+#define UART6_FR_R              (*((volatile uint32_t *)0x40012018))
+#define UART6_ILPR_R            (*((volatile uint32_t *)0x40012020))
+#define UART6_IBRD_R            (*((volatile uint32_t *)0x40012024))
+#define UART6_FBRD_R            (*((volatile uint32_t *)0x40012028))
+#define UART6_LCRH_R            (*((volatile uint32_t *)0x4001202C))
+#define UART6_CTL_R             (*((volatile uint32_t *)0x40012030))
+#define UART6_IFLS_R            (*((volatile uint32_t *)0x40012034))
+#define UART6_IM_R              (*((volatile uint32_t *)0x40012038))
+#define UART6_RIS_R             (*((volatile uint32_t *)0x4001203C))
+#define UART6_MIS_R             (*((volatile uint32_t *)0x40012040))
+#define UART6_ICR_R             (*((volatile uint32_t *)0x40012044))
+#define UART6_DMACTL_R          (*((volatile uint32_t *)0x40012048))
+#define UART6_9BITADDR_R        (*((volatile uint32_t *)0x400120A4))
+#define UART6_9BITAMASK_R       (*((volatile uint32_t *)0x400120A8))
+#define UART6_PP_R              (*((volatile uint32_t *)0x40012FC0))
+#define UART6_CC_R              (*((volatile uint32_t *)0x40012FC8))
+
+//*****************************************************************************
+//
+// UART registers (UART7)
+//
+//*****************************************************************************
+#define UART7_DR_R              (*((volatile uint32_t *)0x40013000))
+#define UART7_RSR_R             (*((volatile uint32_t *)0x40013004))
+#define UART7_ECR_R             (*((volatile uint32_t *)0x40013004))
+#define UART7_FR_R              (*((volatile uint32_t *)0x40013018))
+#define UART7_ILPR_R            (*((volatile uint32_t *)0x40013020))
+#define UART7_IBRD_R            (*((volatile uint32_t *)0x40013024))
+#define UART7_FBRD_R            (*((volatile uint32_t *)0x40013028))
+#define UART7_LCRH_R            (*((volatile uint32_t *)0x4001302C))
+#define UART7_CTL_R             (*((volatile uint32_t *)0x40013030))
+#define UART7_IFLS_R            (*((volatile uint32_t *)0x40013034))
+#define UART7_IM_R              (*((volatile uint32_t *)0x40013038))
+#define UART7_RIS_R             (*((volatile uint32_t *)0x4001303C))
+#define UART7_MIS_R             (*((volatile uint32_t *)0x40013040))
+#define UART7_ICR_R             (*((volatile uint32_t *)0x40013044))
+#define UART7_DMACTL_R          (*((volatile uint32_t *)0x40013048))
+#define UART7_9BITADDR_R        (*((volatile uint32_t *)0x400130A4))
+#define UART7_9BITAMASK_R       (*((volatile uint32_t *)0x400130A8))
+#define UART7_PP_R              (*((volatile uint32_t *)0x40013FC0))
+#define UART7_CC_R              (*((volatile uint32_t *)0x40013FC8))
+
+//*****************************************************************************
+//
+// I2C registers (I2C0)
+//
+//*****************************************************************************
+#define I2C0_MSA_R              (*((volatile uint32_t *)0x40020000))
+#define I2C0_MCS_R              (*((volatile uint32_t *)0x40020004))
+#define I2C0_MDR_R              (*((volatile uint32_t *)0x40020008))
+#define I2C0_MTPR_R             (*((volatile uint32_t *)0x4002000C))
+#define I2C0_MIMR_R             (*((volatile uint32_t *)0x40020010))
+#define I2C0_MRIS_R             (*((volatile uint32_t *)0x40020014))
+#define I2C0_MMIS_R             (*((volatile uint32_t *)0x40020018))
+#define I2C0_MICR_R             (*((volatile uint32_t *)0x4002001C))
+#define I2C0_MCR_R              (*((volatile uint32_t *)0x40020020))
+#define I2C0_MCLKOCNT_R         (*((volatile uint32_t *)0x40020024))
+#define I2C0_MBMON_R            (*((volatile uint32_t *)0x4002002C))
+#define I2C0_MBLEN_R            (*((volatile uint32_t *)0x40020030))
+#define I2C0_MBCNT_R            (*((volatile uint32_t *)0x40020034))
+#define I2C0_SOAR_R             (*((volatile uint32_t *)0x40020800))
+#define I2C0_SCSR_R             (*((volatile uint32_t *)0x40020804))
+#define I2C0_SDR_R              (*((volatile uint32_t *)0x40020808))
+#define I2C0_SIMR_R             (*((volatile uint32_t *)0x4002080C))
+#define I2C0_SRIS_R             (*((volatile uint32_t *)0x40020810))
+#define I2C0_SMIS_R             (*((volatile uint32_t *)0x40020814))
+#define I2C0_SICR_R             (*((volatile uint32_t *)0x40020818))
+#define I2C0_SOAR2_R            (*((volatile uint32_t *)0x4002081C))
+#define I2C0_SACKCTL_R          (*((volatile uint32_t *)0x40020820))
+#define I2C0_FIFODATA_R         (*((volatile uint32_t *)0x40020F00))
+#define I2C0_FIFOCTL_R          (*((volatile uint32_t *)0x40020F04))
+#define I2C0_FIFOSTATUS_R       (*((volatile uint32_t *)0x40020F08))
+#define I2C0_PP_R               (*((volatile uint32_t *)0x40020FC0))
+#define I2C0_PC_R               (*((volatile uint32_t *)0x40020FC4))
+
+//*****************************************************************************
+//
+// I2C registers (I2C1)
+//
+//*****************************************************************************
+#define I2C1_MSA_R              (*((volatile uint32_t *)0x40021000))
+#define I2C1_MCS_R              (*((volatile uint32_t *)0x40021004))
+#define I2C1_MDR_R              (*((volatile uint32_t *)0x40021008))
+#define I2C1_MTPR_R             (*((volatile uint32_t *)0x4002100C))
+#define I2C1_MIMR_R             (*((volatile uint32_t *)0x40021010))
+#define I2C1_MRIS_R             (*((volatile uint32_t *)0x40021014))
+#define I2C1_MMIS_R             (*((volatile uint32_t *)0x40021018))
+#define I2C1_MICR_R             (*((volatile uint32_t *)0x4002101C))
+#define I2C1_MCR_R              (*((volatile uint32_t *)0x40021020))
+#define I2C1_MCLKOCNT_R         (*((volatile uint32_t *)0x40021024))
+#define I2C1_MBMON_R            (*((volatile uint32_t *)0x4002102C))
+#define I2C1_MBLEN_R            (*((volatile uint32_t *)0x40021030))
+#define I2C1_MBCNT_R            (*((volatile uint32_t *)0x40021034))
+#define I2C1_SOAR_R             (*((volatile uint32_t *)0x40021800))
+#define I2C1_SCSR_R             (*((volatile uint32_t *)0x40021804))
+#define I2C1_SDR_R              (*((volatile uint32_t *)0x40021808))
+#define I2C1_SIMR_R             (*((volatile uint32_t *)0x4002180C))
+#define I2C1_SRIS_R             (*((volatile uint32_t *)0x40021810))
+#define I2C1_SMIS_R             (*((volatile uint32_t *)0x40021814))
+#define I2C1_SICR_R             (*((volatile uint32_t *)0x40021818))
+#define I2C1_SOAR2_R            (*((volatile uint32_t *)0x4002181C))
+#define I2C1_SACKCTL_R          (*((volatile uint32_t *)0x40021820))
+#define I2C1_FIFODATA_R         (*((volatile uint32_t *)0x40021F00))
+#define I2C1_FIFOCTL_R          (*((volatile uint32_t *)0x40021F04))
+#define I2C1_FIFOSTATUS_R       (*((volatile uint32_t *)0x40021F08))
+#define I2C1_PP_R               (*((volatile uint32_t *)0x40021FC0))
+#define I2C1_PC_R               (*((volatile uint32_t *)0x40021FC4))
+
+//*****************************************************************************
+//
+// I2C registers (I2C2)
+//
+//*****************************************************************************
+#define I2C2_MSA_R              (*((volatile uint32_t *)0x40022000))
+#define I2C2_MCS_R              (*((volatile uint32_t *)0x40022004))
+#define I2C2_MDR_R              (*((volatile uint32_t *)0x40022008))
+#define I2C2_MTPR_R             (*((volatile uint32_t *)0x4002200C))
+#define I2C2_MIMR_R             (*((volatile uint32_t *)0x40022010))
+#define I2C2_MRIS_R             (*((volatile uint32_t *)0x40022014))
+#define I2C2_MMIS_R             (*((volatile uint32_t *)0x40022018))
+#define I2C2_MICR_R             (*((volatile uint32_t *)0x4002201C))
+#define I2C2_MCR_R              (*((volatile uint32_t *)0x40022020))
+#define I2C2_MCLKOCNT_R         (*((volatile uint32_t *)0x40022024))
+#define I2C2_MBMON_R            (*((volatile uint32_t *)0x4002202C))
+#define I2C2_MBLEN_R            (*((volatile uint32_t *)0x40022030))
+#define I2C2_MBCNT_R            (*((volatile uint32_t *)0x40022034))
+#define I2C2_SOAR_R             (*((volatile uint32_t *)0x40022800))
+#define I2C2_SCSR_R             (*((volatile uint32_t *)0x40022804))
+#define I2C2_SDR_R              (*((volatile uint32_t *)0x40022808))
+#define I2C2_SIMR_R             (*((volatile uint32_t *)0x4002280C))
+#define I2C2_SRIS_R             (*((volatile uint32_t *)0x40022810))
+#define I2C2_SMIS_R             (*((volatile uint32_t *)0x40022814))
+#define I2C2_SICR_R             (*((volatile uint32_t *)0x40022818))
+#define I2C2_SOAR2_R            (*((volatile uint32_t *)0x4002281C))
+#define I2C2_SACKCTL_R          (*((volatile uint32_t *)0x40022820))
+#define I2C2_FIFODATA_R         (*((volatile uint32_t *)0x40022F00))
+#define I2C2_FIFOCTL_R          (*((volatile uint32_t *)0x40022F04))
+#define I2C2_FIFOSTATUS_R       (*((volatile uint32_t *)0x40022F08))
+#define I2C2_PP_R               (*((volatile uint32_t *)0x40022FC0))
+#define I2C2_PC_R               (*((volatile uint32_t *)0x40022FC4))
+
+//*****************************************************************************
+//
+// I2C registers (I2C3)
+//
+//*****************************************************************************
+#define I2C3_MSA_R              (*((volatile uint32_t *)0x40023000))
+#define I2C3_MCS_R              (*((volatile uint32_t *)0x40023004))
+#define I2C3_MDR_R              (*((volatile uint32_t *)0x40023008))
+#define I2C3_MTPR_R             (*((volatile uint32_t *)0x4002300C))
+#define I2C3_MIMR_R             (*((volatile uint32_t *)0x40023010))
+#define I2C3_MRIS_R             (*((volatile uint32_t *)0x40023014))
+#define I2C3_MMIS_R             (*((volatile uint32_t *)0x40023018))
+#define I2C3_MICR_R             (*((volatile uint32_t *)0x4002301C))
+#define I2C3_MCR_R              (*((volatile uint32_t *)0x40023020))
+#define I2C3_MCLKOCNT_R         (*((volatile uint32_t *)0x40023024))
+#define I2C3_MBMON_R            (*((volatile uint32_t *)0x4002302C))
+#define I2C3_MBLEN_R            (*((volatile uint32_t *)0x40023030))
+#define I2C3_MBCNT_R            (*((volatile uint32_t *)0x40023034))
+#define I2C3_SOAR_R             (*((volatile uint32_t *)0x40023800))
+#define I2C3_SCSR_R             (*((volatile uint32_t *)0x40023804))
+#define I2C3_SDR_R              (*((volatile uint32_t *)0x40023808))
+#define I2C3_SIMR_R             (*((volatile uint32_t *)0x4002380C))
+#define I2C3_SRIS_R             (*((volatile uint32_t *)0x40023810))
+#define I2C3_SMIS_R             (*((volatile uint32_t *)0x40023814))
+#define I2C3_SICR_R             (*((volatile uint32_t *)0x40023818))
+#define I2C3_SOAR2_R            (*((volatile uint32_t *)0x4002381C))
+#define I2C3_SACKCTL_R          (*((volatile uint32_t *)0x40023820))
+#define I2C3_FIFODATA_R         (*((volatile uint32_t *)0x40023F00))
+#define I2C3_FIFOCTL_R          (*((volatile uint32_t *)0x40023F04))
+#define I2C3_FIFOSTATUS_R       (*((volatile uint32_t *)0x40023F08))
+#define I2C3_PP_R               (*((volatile uint32_t *)0x40023FC0))
+#define I2C3_PC_R               (*((volatile uint32_t *)0x40023FC4))
+
+//*****************************************************************************
+//
+// PWM registers (PWM0)
+//
+//*****************************************************************************
+#define PWM0_CTL_R              (*((volatile uint32_t *)0x40028000))
+#define PWM0_SYNC_R             (*((volatile uint32_t *)0x40028004))
+#define PWM0_ENABLE_R           (*((volatile uint32_t *)0x40028008))
+#define PWM0_INVERT_R           (*((volatile uint32_t *)0x4002800C))
+#define PWM0_FAULT_R            (*((volatile uint32_t *)0x40028010))
+#define PWM0_INTEN_R            (*((volatile uint32_t *)0x40028014))
+#define PWM0_RIS_R              (*((volatile uint32_t *)0x40028018))
+#define PWM0_ISC_R              (*((volatile uint32_t *)0x4002801C))
+#define PWM0_STATUS_R           (*((volatile uint32_t *)0x40028020))
+#define PWM0_FAULTVAL_R         (*((volatile uint32_t *)0x40028024))
+#define PWM0_ENUPD_R            (*((volatile uint32_t *)0x40028028))
+#define PWM0_0_CTL_R            (*((volatile uint32_t *)0x40028040))
+#define PWM0_0_INTEN_R          (*((volatile uint32_t *)0x40028044))
+#define PWM0_0_RIS_R            (*((volatile uint32_t *)0x40028048))
+#define PWM0_0_ISC_R            (*((volatile uint32_t *)0x4002804C))
+#define PWM0_0_LOAD_R           (*((volatile uint32_t *)0x40028050))
+#define PWM0_0_COUNT_R          (*((volatile uint32_t *)0x40028054))
+#define PWM0_0_CMPA_R           (*((volatile uint32_t *)0x40028058))
+#define PWM0_0_CMPB_R           (*((volatile uint32_t *)0x4002805C))
+#define PWM0_0_GENA_R           (*((volatile uint32_t *)0x40028060))
+#define PWM0_0_GENB_R           (*((volatile uint32_t *)0x40028064))
+#define PWM0_0_DBCTL_R          (*((volatile uint32_t *)0x40028068))
+#define PWM0_0_DBRISE_R         (*((volatile uint32_t *)0x4002806C))
+#define PWM0_0_DBFALL_R         (*((volatile uint32_t *)0x40028070))
+#define PWM0_0_FLTSRC0_R        (*((volatile uint32_t *)0x40028074))
+#define PWM0_0_FLTSRC1_R        (*((volatile uint32_t *)0x40028078))
+#define PWM0_0_MINFLTPER_R      (*((volatile uint32_t *)0x4002807C))
+#define PWM0_1_CTL_R            (*((volatile uint32_t *)0x40028080))
+#define PWM0_1_INTEN_R          (*((volatile uint32_t *)0x40028084))
+#define PWM0_1_RIS_R            (*((volatile uint32_t *)0x40028088))
+#define PWM0_1_ISC_R            (*((volatile uint32_t *)0x4002808C))
+#define PWM0_1_LOAD_R           (*((volatile uint32_t *)0x40028090))
+#define PWM0_1_COUNT_R          (*((volatile uint32_t *)0x40028094))
+#define PWM0_1_CMPA_R           (*((volatile uint32_t *)0x40028098))
+#define PWM0_1_CMPB_R           (*((volatile uint32_t *)0x4002809C))
+#define PWM0_1_GENA_R           (*((volatile uint32_t *)0x400280A0))
+#define PWM0_1_GENB_R           (*((volatile uint32_t *)0x400280A4))
+#define PWM0_1_DBCTL_R          (*((volatile uint32_t *)0x400280A8))
+#define PWM0_1_DBRISE_R         (*((volatile uint32_t *)0x400280AC))
+#define PWM0_1_DBFALL_R         (*((volatile uint32_t *)0x400280B0))
+#define PWM0_1_FLTSRC0_R        (*((volatile uint32_t *)0x400280B4))
+#define PWM0_1_FLTSRC1_R        (*((volatile uint32_t *)0x400280B8))
+#define PWM0_1_MINFLTPER_R      (*((volatile uint32_t *)0x400280BC))
+#define PWM0_2_CTL_R            (*((volatile uint32_t *)0x400280C0))
+#define PWM0_2_INTEN_R          (*((volatile uint32_t *)0x400280C4))
+#define PWM0_2_RIS_R            (*((volatile uint32_t *)0x400280C8))
+#define PWM0_2_ISC_R            (*((volatile uint32_t *)0x400280CC))
+#define PWM0_2_LOAD_R           (*((volatile uint32_t *)0x400280D0))
+#define PWM0_2_COUNT_R          (*((volatile uint32_t *)0x400280D4))
+#define PWM0_2_CMPA_R           (*((volatile uint32_t *)0x400280D8))
+#define PWM0_2_CMPB_R           (*((volatile uint32_t *)0x400280DC))
+#define PWM0_2_GENA_R           (*((volatile uint32_t *)0x400280E0))
+#define PWM0_2_GENB_R           (*((volatile uint32_t *)0x400280E4))
+#define PWM0_2_DBCTL_R          (*((volatile uint32_t *)0x400280E8))
+#define PWM0_2_DBRISE_R         (*((volatile uint32_t *)0x400280EC))
+#define PWM0_2_DBFALL_R         (*((volatile uint32_t *)0x400280F0))
+#define PWM0_2_FLTSRC0_R        (*((volatile uint32_t *)0x400280F4))
+#define PWM0_2_FLTSRC1_R        (*((volatile uint32_t *)0x400280F8))
+#define PWM0_2_MINFLTPER_R      (*((volatile uint32_t *)0x400280FC))
+#define PWM0_3_CTL_R            (*((volatile uint32_t *)0x40028100))
+#define PWM0_3_INTEN_R          (*((volatile uint32_t *)0x40028104))
+#define PWM0_3_RIS_R            (*((volatile uint32_t *)0x40028108))
+#define PWM0_3_ISC_R            (*((volatile uint32_t *)0x4002810C))
+#define PWM0_3_LOAD_R           (*((volatile uint32_t *)0x40028110))
+#define PWM0_3_COUNT_R          (*((volatile uint32_t *)0x40028114))
+#define PWM0_3_CMPA_R           (*((volatile uint32_t *)0x40028118))
+#define PWM0_3_CMPB_R           (*((volatile uint32_t *)0x4002811C))
+#define PWM0_3_GENA_R           (*((volatile uint32_t *)0x40028120))
+#define PWM0_3_GENB_R           (*((volatile uint32_t *)0x40028124))
+#define PWM0_3_DBCTL_R          (*((volatile uint32_t *)0x40028128))
+#define PWM0_3_DBRISE_R         (*((volatile uint32_t *)0x4002812C))
+#define PWM0_3_DBFALL_R         (*((volatile uint32_t *)0x40028130))
+#define PWM0_3_FLTSRC0_R        (*((volatile uint32_t *)0x40028134))
+#define PWM0_3_FLTSRC1_R        (*((volatile uint32_t *)0x40028138))
+#define PWM0_3_MINFLTPER_R      (*((volatile uint32_t *)0x4002813C))
+#define PWM0_0_FLTSEN_R         (*((volatile uint32_t *)0x40028800))
+#define PWM0_0_FLTSTAT0_R       (*((volatile uint32_t *)0x40028804))
+#define PWM0_0_FLTSTAT1_R       (*((volatile uint32_t *)0x40028808))
+#define PWM0_1_FLTSEN_R         (*((volatile uint32_t *)0x40028880))
+#define PWM0_1_FLTSTAT0_R       (*((volatile uint32_t *)0x40028884))
+#define PWM0_1_FLTSTAT1_R       (*((volatile uint32_t *)0x40028888))
+#define PWM0_2_FLTSEN_R         (*((volatile uint32_t *)0x40028900))
+#define PWM0_2_FLTSTAT0_R       (*((volatile uint32_t *)0x40028904))
+#define PWM0_2_FLTSTAT1_R       (*((volatile uint32_t *)0x40028908))
+#define PWM0_3_FLTSEN_R         (*((volatile uint32_t *)0x40028980))
+#define PWM0_3_FLTSTAT0_R       (*((volatile uint32_t *)0x40028984))
+#define PWM0_3_FLTSTAT1_R       (*((volatile uint32_t *)0x40028988))
+#define PWM0_PP_R               (*((volatile uint32_t *)0x40028FC0))
+#define PWM0_CC_R               (*((volatile uint32_t *)0x40028FC8))
+
+//*****************************************************************************
+//
+// QEI registers (QEI0)
+//
+//*****************************************************************************
+#define QEI0_CTL_R              (*((volatile uint32_t *)0x4002C000))
+#define QEI0_STAT_R             (*((volatile uint32_t *)0x4002C004))
+#define QEI0_POS_R              (*((volatile uint32_t *)0x4002C008))
+#define QEI0_MAXPOS_R           (*((volatile uint32_t *)0x4002C00C))
+#define QEI0_LOAD_R             (*((volatile uint32_t *)0x4002C010))
+#define QEI0_TIME_R             (*((volatile uint32_t *)0x4002C014))
+#define QEI0_COUNT_R            (*((volatile uint32_t *)0x4002C018))
+#define QEI0_SPEED_R            (*((volatile uint32_t *)0x4002C01C))
+#define QEI0_INTEN_R            (*((volatile uint32_t *)0x4002C020))
+#define QEI0_RIS_R              (*((volatile uint32_t *)0x4002C024))
+#define QEI0_ISC_R              (*((volatile uint32_t *)0x4002C028))
+
+//*****************************************************************************
+//
+// Timer registers (TIMER0)
+//
+//*****************************************************************************
+#define TIMER0_CFG_R            (*((volatile uint32_t *)0x40030000))
+#define TIMER0_TAMR_R           (*((volatile uint32_t *)0x40030004))
+#define TIMER0_TBMR_R           (*((volatile uint32_t *)0x40030008))
+#define TIMER0_CTL_R            (*((volatile uint32_t *)0x4003000C))
+#define TIMER0_SYNC_R           (*((volatile uint32_t *)0x40030010))
+#define TIMER0_IMR_R            (*((volatile uint32_t *)0x40030018))
+#define TIMER0_RIS_R            (*((volatile uint32_t *)0x4003001C))
+#define TIMER0_MIS_R            (*((volatile uint32_t *)0x40030020))
+#define TIMER0_ICR_R            (*((volatile uint32_t *)0x40030024))
+#define TIMER0_TAILR_R          (*((volatile uint32_t *)0x40030028))
+#define TIMER0_TBILR_R          (*((volatile uint32_t *)0x4003002C))
+#define TIMER0_TAMATCHR_R       (*((volatile uint32_t *)0x40030030))
+#define TIMER0_TBMATCHR_R       (*((volatile uint32_t *)0x40030034))
+#define TIMER0_TAPR_R           (*((volatile uint32_t *)0x40030038))
+#define TIMER0_TBPR_R           (*((volatile uint32_t *)0x4003003C))
+#define TIMER0_TAPMR_R          (*((volatile uint32_t *)0x40030040))
+#define TIMER0_TBPMR_R          (*((volatile uint32_t *)0x40030044))
+#define TIMER0_TAR_R            (*((volatile uint32_t *)0x40030048))
+#define TIMER0_TBR_R            (*((volatile uint32_t *)0x4003004C))
+#define TIMER0_TAV_R            (*((volatile uint32_t *)0x40030050))
+#define TIMER0_TBV_R            (*((volatile uint32_t *)0x40030054))
+#define TIMER0_RTCPD_R          (*((volatile uint32_t *)0x40030058))
+#define TIMER0_TAPS_R           (*((volatile uint32_t *)0x4003005C))
+#define TIMER0_TBPS_R           (*((volatile uint32_t *)0x40030060))
+#define TIMER0_DMAEV_R          (*((volatile uint32_t *)0x4003006C))
+#define TIMER0_ADCEV_R          (*((volatile uint32_t *)0x40030070))
+#define TIMER0_PP_R             (*((volatile uint32_t *)0x40030FC0))
+#define TIMER0_CC_R             (*((volatile uint32_t *)0x40030FC8))
+
+//*****************************************************************************
+//
+// Timer registers (TIMER1)
+//
+//*****************************************************************************
+#define TIMER1_CFG_R            (*((volatile uint32_t *)0x40031000))
+#define TIMER1_TAMR_R           (*((volatile uint32_t *)0x40031004))
+#define TIMER1_TBMR_R           (*((volatile uint32_t *)0x40031008))
+#define TIMER1_CTL_R            (*((volatile uint32_t *)0x4003100C))
+#define TIMER1_SYNC_R           (*((volatile uint32_t *)0x40031010))
+#define TIMER1_IMR_R            (*((volatile uint32_t *)0x40031018))
+#define TIMER1_RIS_R            (*((volatile uint32_t *)0x4003101C))
+#define TIMER1_MIS_R            (*((volatile uint32_t *)0x40031020))
+#define TIMER1_ICR_R            (*((volatile uint32_t *)0x40031024))
+#define TIMER1_TAILR_R          (*((volatile uint32_t *)0x40031028))
+#define TIMER1_TBILR_R          (*((volatile uint32_t *)0x4003102C))
+#define TIMER1_TAMATCHR_R       (*((volatile uint32_t *)0x40031030))
+#define TIMER1_TBMATCHR_R       (*((volatile uint32_t *)0x40031034))
+#define TIMER1_TAPR_R           (*((volatile uint32_t *)0x40031038))
+#define TIMER1_TBPR_R           (*((volatile uint32_t *)0x4003103C))
+#define TIMER1_TAPMR_R          (*((volatile uint32_t *)0x40031040))
+#define TIMER1_TBPMR_R          (*((volatile uint32_t *)0x40031044))
+#define TIMER1_TAR_R            (*((volatile uint32_t *)0x40031048))
+#define TIMER1_TBR_R            (*((volatile uint32_t *)0x4003104C))
+#define TIMER1_TAV_R            (*((volatile uint32_t *)0x40031050))
+#define TIMER1_TBV_R            (*((volatile uint32_t *)0x40031054))
+#define TIMER1_RTCPD_R          (*((volatile uint32_t *)0x40031058))
+#define TIMER1_TAPS_R           (*((volatile uint32_t *)0x4003105C))
+#define TIMER1_TBPS_R           (*((volatile uint32_t *)0x40031060))
+#define TIMER1_DMAEV_R          (*((volatile uint32_t *)0x4003106C))
+#define TIMER1_ADCEV_R          (*((volatile uint32_t *)0x40031070))
+#define TIMER1_PP_R             (*((volatile uint32_t *)0x40031FC0))
+#define TIMER1_CC_R             (*((volatile uint32_t *)0x40031FC8))
+
+//*****************************************************************************
+//
+// Timer registers (TIMER2)
+//
+//*****************************************************************************
+#define TIMER2_CFG_R            (*((volatile uint32_t *)0x40032000))
+#define TIMER2_TAMR_R           (*((volatile uint32_t *)0x40032004))
+#define TIMER2_TBMR_R           (*((volatile uint32_t *)0x40032008))
+#define TIMER2_CTL_R            (*((volatile uint32_t *)0x4003200C))
+#define TIMER2_SYNC_R           (*((volatile uint32_t *)0x40032010))
+#define TIMER2_IMR_R            (*((volatile uint32_t *)0x40032018))
+#define TIMER2_RIS_R            (*((volatile uint32_t *)0x4003201C))
+#define TIMER2_MIS_R            (*((volatile uint32_t *)0x40032020))
+#define TIMER2_ICR_R            (*((volatile uint32_t *)0x40032024))
+#define TIMER2_TAILR_R          (*((volatile uint32_t *)0x40032028))
+#define TIMER2_TBILR_R          (*((volatile uint32_t *)0x4003202C))
+#define TIMER2_TAMATCHR_R       (*((volatile uint32_t *)0x40032030))
+#define TIMER2_TBMATCHR_R       (*((volatile uint32_t *)0x40032034))
+#define TIMER2_TAPR_R           (*((volatile uint32_t *)0x40032038))
+#define TIMER2_TBPR_R           (*((volatile uint32_t *)0x4003203C))
+#define TIMER2_TAPMR_R          (*((volatile uint32_t *)0x40032040))
+#define TIMER2_TBPMR_R          (*((volatile uint32_t *)0x40032044))
+#define TIMER2_TAR_R            (*((volatile uint32_t *)0x40032048))
+#define TIMER2_TBR_R            (*((volatile uint32_t *)0x4003204C))
+#define TIMER2_TAV_R            (*((volatile uint32_t *)0x40032050))
+#define TIMER2_TBV_R            (*((volatile uint32_t *)0x40032054))
+#define TIMER2_RTCPD_R          (*((volatile uint32_t *)0x40032058))
+#define TIMER2_TAPS_R           (*((volatile uint32_t *)0x4003205C))
+#define TIMER2_TBPS_R           (*((volatile uint32_t *)0x40032060))
+#define TIMER2_DMAEV_R          (*((volatile uint32_t *)0x4003206C))
+#define TIMER2_ADCEV_R          (*((volatile uint32_t *)0x40032070))
+#define TIMER2_PP_R             (*((volatile uint32_t *)0x40032FC0))
+#define TIMER2_CC_R             (*((volatile uint32_t *)0x40032FC8))
+
+//*****************************************************************************
+//
+// Timer registers (TIMER3)
+//
+//*****************************************************************************
+#define TIMER3_CFG_R            (*((volatile uint32_t *)0x40033000))
+#define TIMER3_TAMR_R           (*((volatile uint32_t *)0x40033004))
+#define TIMER3_TBMR_R           (*((volatile uint32_t *)0x40033008))
+#define TIMER3_CTL_R            (*((volatile uint32_t *)0x4003300C))
+#define TIMER3_SYNC_R           (*((volatile uint32_t *)0x40033010))
+#define TIMER3_IMR_R            (*((volatile uint32_t *)0x40033018))
+#define TIMER3_RIS_R            (*((volatile uint32_t *)0x4003301C))
+#define TIMER3_MIS_R            (*((volatile uint32_t *)0x40033020))
+#define TIMER3_ICR_R            (*((volatile uint32_t *)0x40033024))
+#define TIMER3_TAILR_R          (*((volatile uint32_t *)0x40033028))
+#define TIMER3_TBILR_R          (*((volatile uint32_t *)0x4003302C))
+#define TIMER3_TAMATCHR_R       (*((volatile uint32_t *)0x40033030))
+#define TIMER3_TBMATCHR_R       (*((volatile uint32_t *)0x40033034))
+#define TIMER3_TAPR_R           (*((volatile uint32_t *)0x40033038))
+#define TIMER3_TBPR_R           (*((volatile uint32_t *)0x4003303C))
+#define TIMER3_TAPMR_R          (*((volatile uint32_t *)0x40033040))
+#define TIMER3_TBPMR_R          (*((volatile uint32_t *)0x40033044))
+#define TIMER3_TAR_R            (*((volatile uint32_t *)0x40033048))
+#define TIMER3_TBR_R            (*((volatile uint32_t *)0x4003304C))
+#define TIMER3_TAV_R            (*((volatile uint32_t *)0x40033050))
+#define TIMER3_TBV_R            (*((volatile uint32_t *)0x40033054))
+#define TIMER3_RTCPD_R          (*((volatile uint32_t *)0x40033058))
+#define TIMER3_TAPS_R           (*((volatile uint32_t *)0x4003305C))
+#define TIMER3_TBPS_R           (*((volatile uint32_t *)0x40033060))
+#define TIMER3_DMAEV_R          (*((volatile uint32_t *)0x4003306C))
+#define TIMER3_ADCEV_R          (*((volatile uint32_t *)0x40033070))
+#define TIMER3_PP_R             (*((volatile uint32_t *)0x40033FC0))
+#define TIMER3_CC_R             (*((volatile uint32_t *)0x40033FC8))
+
+//*****************************************************************************
+//
+// Timer registers (TIMER4)
+//
+//*****************************************************************************
+#define TIMER4_CFG_R            (*((volatile uint32_t *)0x40034000))
+#define TIMER4_TAMR_R           (*((volatile uint32_t *)0x40034004))
+#define TIMER4_TBMR_R           (*((volatile uint32_t *)0x40034008))
+#define TIMER4_CTL_R            (*((volatile uint32_t *)0x4003400C))
+#define TIMER4_SYNC_R           (*((volatile uint32_t *)0x40034010))
+#define TIMER4_IMR_R            (*((volatile uint32_t *)0x40034018))
+#define TIMER4_RIS_R            (*((volatile uint32_t *)0x4003401C))
+#define TIMER4_MIS_R            (*((volatile uint32_t *)0x40034020))
+#define TIMER4_ICR_R            (*((volatile uint32_t *)0x40034024))
+#define TIMER4_TAILR_R          (*((volatile uint32_t *)0x40034028))
+#define TIMER4_TBILR_R          (*((volatile uint32_t *)0x4003402C))
+#define TIMER4_TAMATCHR_R       (*((volatile uint32_t *)0x40034030))
+#define TIMER4_TBMATCHR_R       (*((volatile uint32_t *)0x40034034))
+#define TIMER4_TAPR_R           (*((volatile uint32_t *)0x40034038))
+#define TIMER4_TBPR_R           (*((volatile uint32_t *)0x4003403C))
+#define TIMER4_TAPMR_R          (*((volatile uint32_t *)0x40034040))
+#define TIMER4_TBPMR_R          (*((volatile uint32_t *)0x40034044))
+#define TIMER4_TAR_R            (*((volatile uint32_t *)0x40034048))
+#define TIMER4_TBR_R            (*((volatile uint32_t *)0x4003404C))
+#define TIMER4_TAV_R            (*((volatile uint32_t *)0x40034050))
+#define TIMER4_TBV_R            (*((volatile uint32_t *)0x40034054))
+#define TIMER4_RTCPD_R          (*((volatile uint32_t *)0x40034058))
+#define TIMER4_TAPS_R           (*((volatile uint32_t *)0x4003405C))
+#define TIMER4_TBPS_R           (*((volatile uint32_t *)0x40034060))
+#define TIMER4_DMAEV_R          (*((volatile uint32_t *)0x4003406C))
+#define TIMER4_ADCEV_R          (*((volatile uint32_t *)0x40034070))
+#define TIMER4_PP_R             (*((volatile uint32_t *)0x40034FC0))
+#define TIMER4_CC_R             (*((volatile uint32_t *)0x40034FC8))
+
+//*****************************************************************************
+//
+// Timer registers (TIMER5)
+//
+//*****************************************************************************
+#define TIMER5_CFG_R            (*((volatile uint32_t *)0x40035000))
+#define TIMER5_TAMR_R           (*((volatile uint32_t *)0x40035004))
+#define TIMER5_TBMR_R           (*((volatile uint32_t *)0x40035008))
+#define TIMER5_CTL_R            (*((volatile uint32_t *)0x4003500C))
+#define TIMER5_SYNC_R           (*((volatile uint32_t *)0x40035010))
+#define TIMER5_IMR_R            (*((volatile uint32_t *)0x40035018))
+#define TIMER5_RIS_R            (*((volatile uint32_t *)0x4003501C))
+#define TIMER5_MIS_R            (*((volatile uint32_t *)0x40035020))
+#define TIMER5_ICR_R            (*((volatile uint32_t *)0x40035024))
+#define TIMER5_TAILR_R          (*((volatile uint32_t *)0x40035028))
+#define TIMER5_TBILR_R          (*((volatile uint32_t *)0x4003502C))
+#define TIMER5_TAMATCHR_R       (*((volatile uint32_t *)0x40035030))
+#define TIMER5_TBMATCHR_R       (*((volatile uint32_t *)0x40035034))
+#define TIMER5_TAPR_R           (*((volatile uint32_t *)0x40035038))
+#define TIMER5_TBPR_R           (*((volatile uint32_t *)0x4003503C))
+#define TIMER5_TAPMR_R          (*((volatile uint32_t *)0x40035040))
+#define TIMER5_TBPMR_R          (*((volatile uint32_t *)0x40035044))
+#define TIMER5_TAR_R            (*((volatile uint32_t *)0x40035048))
+#define TIMER5_TBR_R            (*((volatile uint32_t *)0x4003504C))
+#define TIMER5_TAV_R            (*((volatile uint32_t *)0x40035050))
+#define TIMER5_TBV_R            (*((volatile uint32_t *)0x40035054))
+#define TIMER5_RTCPD_R          (*((volatile uint32_t *)0x40035058))
+#define TIMER5_TAPS_R           (*((volatile uint32_t *)0x4003505C))
+#define TIMER5_TBPS_R           (*((volatile uint32_t *)0x40035060))
+#define TIMER5_DMAEV_R          (*((volatile uint32_t *)0x4003506C))
+#define TIMER5_ADCEV_R          (*((volatile uint32_t *)0x40035070))
+#define TIMER5_PP_R             (*((volatile uint32_t *)0x40035FC0))
+#define TIMER5_CC_R             (*((volatile uint32_t *)0x40035FC8))
+
+//*****************************************************************************
+//
+// ADC registers (ADC0)
+//
+//*****************************************************************************
+#define ADC0_ACTSS_R            (*((volatile uint32_t *)0x40038000))
+#define ADC0_RIS_R              (*((volatile uint32_t *)0x40038004))
+#define ADC0_IM_R               (*((volatile uint32_t *)0x40038008))
+#define ADC0_ISC_R              (*((volatile uint32_t *)0x4003800C))
+#define ADC0_OSTAT_R            (*((volatile uint32_t *)0x40038010))
+#define ADC0_EMUX_R             (*((volatile uint32_t *)0x40038014))
+#define ADC0_USTAT_R            (*((volatile uint32_t *)0x40038018))
+#define ADC0_TSSEL_R            (*((volatile uint32_t *)0x4003801C))
+#define ADC0_SSPRI_R            (*((volatile uint32_t *)0x40038020))
+#define ADC0_SPC_R              (*((volatile uint32_t *)0x40038024))
+#define ADC0_PSSI_R             (*((volatile uint32_t *)0x40038028))
+#define ADC0_SAC_R              (*((volatile uint32_t *)0x40038030))
+#define ADC0_DCISC_R            (*((volatile uint32_t *)0x40038034))
+#define ADC0_CTL_R              (*((volatile uint32_t *)0x40038038))
+#define ADC0_SSMUX0_R           (*((volatile uint32_t *)0x40038040))
+#define ADC0_SSCTL0_R           (*((volatile uint32_t *)0x40038044))
+#define ADC0_SSFIFO0_R          (*((volatile uint32_t *)0x40038048))
+#define ADC0_SSFSTAT0_R         (*((volatile uint32_t *)0x4003804C))
+#define ADC0_SSOP0_R            (*((volatile uint32_t *)0x40038050))
+#define ADC0_SSDC0_R            (*((volatile uint32_t *)0x40038054))
+#define ADC0_SSEMUX0_R          (*((volatile uint32_t *)0x40038058))
+#define ADC0_SSTSH0_R           (*((volatile uint32_t *)0x4003805C))
+#define ADC0_SSMUX1_R           (*((volatile uint32_t *)0x40038060))
+#define ADC0_SSCTL1_R           (*((volatile uint32_t *)0x40038064))
+#define ADC0_SSFIFO1_R          (*((volatile uint32_t *)0x40038068))
+#define ADC0_SSFSTAT1_R         (*((volatile uint32_t *)0x4003806C))
+#define ADC0_SSOP1_R            (*((volatile uint32_t *)0x40038070))
+#define ADC0_SSDC1_R            (*((volatile uint32_t *)0x40038074))
+#define ADC0_SSEMUX1_R          (*((volatile uint32_t *)0x40038078))
+#define ADC0_SSTSH1_R           (*((volatile uint32_t *)0x4003807C))
+#define ADC0_SSMUX2_R           (*((volatile uint32_t *)0x40038080))
+#define ADC0_SSCTL2_R           (*((volatile uint32_t *)0x40038084))
+#define ADC0_SSFIFO2_R          (*((volatile uint32_t *)0x40038088))
+#define ADC0_SSFSTAT2_R         (*((volatile uint32_t *)0x4003808C))
+#define ADC0_SSOP2_R            (*((volatile uint32_t *)0x40038090))
+#define ADC0_SSDC2_R            (*((volatile uint32_t *)0x40038094))
+#define ADC0_SSEMUX2_R          (*((volatile uint32_t *)0x40038098))
+#define ADC0_SSTSH2_R           (*((volatile uint32_t *)0x4003809C))
+#define ADC0_SSMUX3_R           (*((volatile uint32_t *)0x400380A0))
+#define ADC0_SSCTL3_R           (*((volatile uint32_t *)0x400380A4))
+#define ADC0_SSFIFO3_R          (*((volatile uint32_t *)0x400380A8))
+#define ADC0_SSFSTAT3_R         (*((volatile uint32_t *)0x400380AC))
+#define ADC0_SSOP3_R            (*((volatile uint32_t *)0x400380B0))
+#define ADC0_SSDC3_R            (*((volatile uint32_t *)0x400380B4))
+#define ADC0_SSEMUX3_R          (*((volatile uint32_t *)0x400380B8))
+#define ADC0_SSTSH3_R           (*((volatile uint32_t *)0x400380BC))
+#define ADC0_DCRIC_R            (*((volatile uint32_t *)0x40038D00))
+#define ADC0_DCCTL0_R           (*((volatile uint32_t *)0x40038E00))
+#define ADC0_DCCTL1_R           (*((volatile uint32_t *)0x40038E04))
+#define ADC0_DCCTL2_R           (*((volatile uint32_t *)0x40038E08))
+#define ADC0_DCCTL3_R           (*((volatile uint32_t *)0x40038E0C))
+#define ADC0_DCCTL4_R           (*((volatile uint32_t *)0x40038E10))
+#define ADC0_DCCTL5_R           (*((volatile uint32_t *)0x40038E14))
+#define ADC0_DCCTL6_R           (*((volatile uint32_t *)0x40038E18))
+#define ADC0_DCCTL7_R           (*((volatile uint32_t *)0x40038E1C))
+#define ADC0_DCCMP0_R           (*((volatile uint32_t *)0x40038E40))
+#define ADC0_DCCMP1_R           (*((volatile uint32_t *)0x40038E44))
+#define ADC0_DCCMP2_R           (*((volatile uint32_t *)0x40038E48))
+#define ADC0_DCCMP3_R           (*((volatile uint32_t *)0x40038E4C))
+#define ADC0_DCCMP4_R           (*((volatile uint32_t *)0x40038E50))
+#define ADC0_DCCMP5_R           (*((volatile uint32_t *)0x40038E54))
+#define ADC0_DCCMP6_R           (*((volatile uint32_t *)0x40038E58))
+#define ADC0_DCCMP7_R           (*((volatile uint32_t *)0x40038E5C))
+#define ADC0_PP_R               (*((volatile uint32_t *)0x40038FC0))
+#define ADC0_PC_R               (*((volatile uint32_t *)0x40038FC4))
+#define ADC0_CC_R               (*((volatile uint32_t *)0x40038FC8))
+
+//*****************************************************************************
+//
+// ADC registers (ADC1)
+//
+//*****************************************************************************
+#define ADC1_ACTSS_R            (*((volatile uint32_t *)0x40039000))
+#define ADC1_RIS_R              (*((volatile uint32_t *)0x40039004))
+#define ADC1_IM_R               (*((volatile uint32_t *)0x40039008))
+#define ADC1_ISC_R              (*((volatile uint32_t *)0x4003900C))
+#define ADC1_OSTAT_R            (*((volatile uint32_t *)0x40039010))
+#define ADC1_EMUX_R             (*((volatile uint32_t *)0x40039014))
+#define ADC1_USTAT_R            (*((volatile uint32_t *)0x40039018))
+#define ADC1_TSSEL_R            (*((volatile uint32_t *)0x4003901C))
+#define ADC1_SSPRI_R            (*((volatile uint32_t *)0x40039020))
+#define ADC1_SPC_R              (*((volatile uint32_t *)0x40039024))
+#define ADC1_PSSI_R             (*((volatile uint32_t *)0x40039028))
+#define ADC1_SAC_R              (*((volatile uint32_t *)0x40039030))
+#define ADC1_DCISC_R            (*((volatile uint32_t *)0x40039034))
+#define ADC1_CTL_R              (*((volatile uint32_t *)0x40039038))
+#define ADC1_SSMUX0_R           (*((volatile uint32_t *)0x40039040))
+#define ADC1_SSCTL0_R           (*((volatile uint32_t *)0x40039044))
+#define ADC1_SSFIFO0_R          (*((volatile uint32_t *)0x40039048))
+#define ADC1_SSFSTAT0_R         (*((volatile uint32_t *)0x4003904C))
+#define ADC1_SSOP0_R            (*((volatile uint32_t *)0x40039050))
+#define ADC1_SSDC0_R            (*((volatile uint32_t *)0x40039054))
+#define ADC1_SSEMUX0_R          (*((volatile uint32_t *)0x40039058))
+#define ADC1_SSTSH0_R           (*((volatile uint32_t *)0x4003905C))
+#define ADC1_SSMUX1_R           (*((volatile uint32_t *)0x40039060))
+#define ADC1_SSCTL1_R           (*((volatile uint32_t *)0x40039064))
+#define ADC1_SSFIFO1_R          (*((volatile uint32_t *)0x40039068))
+#define ADC1_SSFSTAT1_R         (*((volatile uint32_t *)0x4003906C))
+#define ADC1_SSOP1_R            (*((volatile uint32_t *)0x40039070))
+#define ADC1_SSDC1_R            (*((volatile uint32_t *)0x40039074))
+#define ADC1_SSEMUX1_R          (*((volatile uint32_t *)0x40039078))
+#define ADC1_SSTSH1_R           (*((volatile uint32_t *)0x4003907C))
+#define ADC1_SSMUX2_R           (*((volatile uint32_t *)0x40039080))
+#define ADC1_SSCTL2_R           (*((volatile uint32_t *)0x40039084))
+#define ADC1_SSFIFO2_R          (*((volatile uint32_t *)0x40039088))
+#define ADC1_SSFSTAT2_R         (*((volatile uint32_t *)0x4003908C))
+#define ADC1_SSOP2_R            (*((volatile uint32_t *)0x40039090))
+#define ADC1_SSDC2_R            (*((volatile uint32_t *)0x40039094))
+#define ADC1_SSEMUX2_R          (*((volatile uint32_t *)0x40039098))
+#define ADC1_SSTSH2_R           (*((volatile uint32_t *)0x4003909C))
+#define ADC1_SSMUX3_R           (*((volatile uint32_t *)0x400390A0))
+#define ADC1_SSCTL3_R           (*((volatile uint32_t *)0x400390A4))
+#define ADC1_SSFIFO3_R          (*((volatile uint32_t *)0x400390A8))
+#define ADC1_SSFSTAT3_R         (*((volatile uint32_t *)0x400390AC))
+#define ADC1_SSOP3_R            (*((volatile uint32_t *)0x400390B0))
+#define ADC1_SSDC3_R            (*((volatile uint32_t *)0x400390B4))
+#define ADC1_SSEMUX3_R          (*((volatile uint32_t *)0x400390B8))
+#define ADC1_SSTSH3_R           (*((volatile uint32_t *)0x400390BC))
+#define ADC1_DCRIC_R            (*((volatile uint32_t *)0x40039D00))
+#define ADC1_DCCTL0_R           (*((volatile uint32_t *)0x40039E00))
+#define ADC1_DCCTL1_R           (*((volatile uint32_t *)0x40039E04))
+#define ADC1_DCCTL2_R           (*((volatile uint32_t *)0x40039E08))
+#define ADC1_DCCTL3_R           (*((volatile uint32_t *)0x40039E0C))
+#define ADC1_DCCTL4_R           (*((volatile uint32_t *)0x40039E10))
+#define ADC1_DCCTL5_R           (*((volatile uint32_t *)0x40039E14))
+#define ADC1_DCCTL6_R           (*((volatile uint32_t *)0x40039E18))
+#define ADC1_DCCTL7_R           (*((volatile uint32_t *)0x40039E1C))
+#define ADC1_DCCMP0_R           (*((volatile uint32_t *)0x40039E40))
+#define ADC1_DCCMP1_R           (*((volatile uint32_t *)0x40039E44))
+#define ADC1_DCCMP2_R           (*((volatile uint32_t *)0x40039E48))
+#define ADC1_DCCMP3_R           (*((volatile uint32_t *)0x40039E4C))
+#define ADC1_DCCMP4_R           (*((volatile uint32_t *)0x40039E50))
+#define ADC1_DCCMP5_R           (*((volatile uint32_t *)0x40039E54))
+#define ADC1_DCCMP6_R           (*((volatile uint32_t *)0x40039E58))
+#define ADC1_DCCMP7_R           (*((volatile uint32_t *)0x40039E5C))
+#define ADC1_PP_R               (*((volatile uint32_t *)0x40039FC0))
+#define ADC1_PC_R               (*((volatile uint32_t *)0x40039FC4))
+#define ADC1_CC_R               (*((volatile uint32_t *)0x40039FC8))
+
+//*****************************************************************************
+//
+// Comparator registers (COMP)
+//
+//*****************************************************************************
+#define COMP_ACMIS_R            (*((volatile uint32_t *)0x4003C000))
+#define COMP_ACRIS_R            (*((volatile uint32_t *)0x4003C004))
+#define COMP_ACINTEN_R          (*((volatile uint32_t *)0x4003C008))
+#define COMP_ACREFCTL_R         (*((volatile uint32_t *)0x4003C010))
+#define COMP_ACSTAT0_R          (*((volatile uint32_t *)0x4003C020))
+#define COMP_ACCTL0_R           (*((volatile uint32_t *)0x4003C024))
+#define COMP_ACSTAT1_R          (*((volatile uint32_t *)0x4003C040))
+#define COMP_ACCTL1_R           (*((volatile uint32_t *)0x4003C044))
+#define COMP_ACSTAT2_R          (*((volatile uint32_t *)0x4003C060))
+#define COMP_ACCTL2_R           (*((volatile uint32_t *)0x4003C064))
+#define COMP_PP_R               (*((volatile uint32_t *)0x4003CFC0))
+
+//*****************************************************************************
+//
+// CAN registers (CAN0)
+//
+//*****************************************************************************
+#define CAN0_CTL_R              (*((volatile uint32_t *)0x40040000))
+#define CAN0_STS_R              (*((volatile uint32_t *)0x40040004))
+#define CAN0_ERR_R              (*((volatile uint32_t *)0x40040008))
+#define CAN0_BIT_R              (*((volatile uint32_t *)0x4004000C))
+#define CAN0_INT_R              (*((volatile uint32_t *)0x40040010))
+#define CAN0_TST_R              (*((volatile uint32_t *)0x40040014))
+#define CAN0_BRPE_R             (*((volatile uint32_t *)0x40040018))
+#define CAN0_IF1CRQ_R           (*((volatile uint32_t *)0x40040020))
+#define CAN0_IF1CMSK_R          (*((volatile uint32_t *)0x40040024))
+#define CAN0_IF1MSK1_R          (*((volatile uint32_t *)0x40040028))
+#define CAN0_IF1MSK2_R          (*((volatile uint32_t *)0x4004002C))
+#define CAN0_IF1ARB1_R          (*((volatile uint32_t *)0x40040030))
+#define CAN0_IF1ARB2_R          (*((volatile uint32_t *)0x40040034))
+#define CAN0_IF1MCTL_R          (*((volatile uint32_t *)0x40040038))
+#define CAN0_IF1DA1_R           (*((volatile uint32_t *)0x4004003C))
+#define CAN0_IF1DA2_R           (*((volatile uint32_t *)0x40040040))
+#define CAN0_IF1DB1_R           (*((volatile uint32_t *)0x40040044))
+#define CAN0_IF1DB2_R           (*((volatile uint32_t *)0x40040048))
+#define CAN0_IF2CRQ_R           (*((volatile uint32_t *)0x40040080))
+#define CAN0_IF2CMSK_R          (*((volatile uint32_t *)0x40040084))
+#define CAN0_IF2MSK1_R          (*((volatile uint32_t *)0x40040088))
+#define CAN0_IF2MSK2_R          (*((volatile uint32_t *)0x4004008C))
+#define CAN0_IF2ARB1_R          (*((volatile uint32_t *)0x40040090))
+#define CAN0_IF2ARB2_R          (*((volatile uint32_t *)0x40040094))
+#define CAN0_IF2MCTL_R          (*((volatile uint32_t *)0x40040098))
+#define CAN0_IF2DA1_R           (*((volatile uint32_t *)0x4004009C))
+#define CAN0_IF2DA2_R           (*((volatile uint32_t *)0x400400A0))
+#define CAN0_IF2DB1_R           (*((volatile uint32_t *)0x400400A4))
+#define CAN0_IF2DB2_R           (*((volatile uint32_t *)0x400400A8))
+#define CAN0_TXRQ1_R            (*((volatile uint32_t *)0x40040100))
+#define CAN0_TXRQ2_R            (*((volatile uint32_t *)0x40040104))
+#define CAN0_NWDA1_R            (*((volatile uint32_t *)0x40040120))
+#define CAN0_NWDA2_R            (*((volatile uint32_t *)0x40040124))
+#define CAN0_MSG1INT_R          (*((volatile uint32_t *)0x40040140))
+#define CAN0_MSG2INT_R          (*((volatile uint32_t *)0x40040144))
+#define CAN0_MSG1VAL_R          (*((volatile uint32_t *)0x40040160))
+#define CAN0_MSG2VAL_R          (*((volatile uint32_t *)0x40040164))
+
+//*****************************************************************************
+//
+// CAN registers (CAN1)
+//
+//*****************************************************************************
+#define CAN1_CTL_R              (*((volatile uint32_t *)0x40041000))
+#define CAN1_STS_R              (*((volatile uint32_t *)0x40041004))
+#define CAN1_ERR_R              (*((volatile uint32_t *)0x40041008))
+#define CAN1_BIT_R              (*((volatile uint32_t *)0x4004100C))
+#define CAN1_INT_R              (*((volatile uint32_t *)0x40041010))
+#define CAN1_TST_R              (*((volatile uint32_t *)0x40041014))
+#define CAN1_BRPE_R             (*((volatile uint32_t *)0x40041018))
+#define CAN1_IF1CRQ_R           (*((volatile uint32_t *)0x40041020))
+#define CAN1_IF1CMSK_R          (*((volatile uint32_t *)0x40041024))
+#define CAN1_IF1MSK1_R          (*((volatile uint32_t *)0x40041028))
+#define CAN1_IF1MSK2_R          (*((volatile uint32_t *)0x4004102C))
+#define CAN1_IF1ARB1_R          (*((volatile uint32_t *)0x40041030))
+#define CAN1_IF1ARB2_R          (*((volatile uint32_t *)0x40041034))
+#define CAN1_IF1MCTL_R          (*((volatile uint32_t *)0x40041038))
+#define CAN1_IF1DA1_R           (*((volatile uint32_t *)0x4004103C))
+#define CAN1_IF1DA2_R           (*((volatile uint32_t *)0x40041040))
+#define CAN1_IF1DB1_R           (*((volatile uint32_t *)0x40041044))
+#define CAN1_IF1DB2_R           (*((volatile uint32_t *)0x40041048))
+#define CAN1_IF2CRQ_R           (*((volatile uint32_t *)0x40041080))
+#define CAN1_IF2CMSK_R          (*((volatile uint32_t *)0x40041084))
+#define CAN1_IF2MSK1_R          (*((volatile uint32_t *)0x40041088))
+#define CAN1_IF2MSK2_R          (*((volatile uint32_t *)0x4004108C))
+#define CAN1_IF2ARB1_R          (*((volatile uint32_t *)0x40041090))
+#define CAN1_IF2ARB2_R          (*((volatile uint32_t *)0x40041094))
+#define CAN1_IF2MCTL_R          (*((volatile uint32_t *)0x40041098))
+#define CAN1_IF2DA1_R           (*((volatile uint32_t *)0x4004109C))
+#define CAN1_IF2DA2_R           (*((volatile uint32_t *)0x400410A0))
+#define CAN1_IF2DB1_R           (*((volatile uint32_t *)0x400410A4))
+#define CAN1_IF2DB2_R           (*((volatile uint32_t *)0x400410A8))
+#define CAN1_TXRQ1_R            (*((volatile uint32_t *)0x40041100))
+#define CAN1_TXRQ2_R            (*((volatile uint32_t *)0x40041104))
+#define CAN1_NWDA1_R            (*((volatile uint32_t *)0x40041120))
+#define CAN1_NWDA2_R            (*((volatile uint32_t *)0x40041124))
+#define CAN1_MSG1INT_R          (*((volatile uint32_t *)0x40041140))
+#define CAN1_MSG2INT_R          (*((volatile uint32_t *)0x40041144))
+#define CAN1_MSG1VAL_R          (*((volatile uint32_t *)0x40041160))
+#define CAN1_MSG2VAL_R          (*((volatile uint32_t *)0x40041164))
+
+//*****************************************************************************
+//
+// Univeral Serial Bus registers (USB0)
+//
+//*****************************************************************************
+#define USB0_FADDR_R            (*((volatile uint8_t *)0x40050000))
+#define USB0_POWER_R            (*((volatile uint8_t *)0x40050001))
+#define USB0_TXIS_R             (*((volatile uint16_t *)0x40050002))
+#define USB0_RXIS_R             (*((volatile uint16_t *)0x40050004))
+#define USB0_TXIE_R             (*((volatile uint16_t *)0x40050006))
+#define USB0_RXIE_R             (*((volatile uint16_t *)0x40050008))
+#define USB0_IS_R               (*((volatile uint8_t *)0x4005000A))
+#define USB0_IE_R               (*((volatile uint8_t *)0x4005000B))
+#define USB0_FRAME_R            (*((volatile uint16_t *)0x4005000C))
+#define USB0_EPIDX_R            (*((volatile uint8_t *)0x4005000E))
+#define USB0_TEST_R             (*((volatile uint8_t *)0x4005000F))
+#define USB0_FIFO0_R            (*((volatile uint32_t *)0x40050020))
+#define USB0_FIFO1_R            (*((volatile uint32_t *)0x40050024))
+#define USB0_FIFO2_R            (*((volatile uint32_t *)0x40050028))
+#define USB0_FIFO3_R            (*((volatile uint32_t *)0x4005002C))
+#define USB0_FIFO4_R            (*((volatile uint32_t *)0x40050030))
+#define USB0_FIFO5_R            (*((volatile uint32_t *)0x40050034))
+#define USB0_FIFO6_R            (*((volatile uint32_t *)0x40050038))
+#define USB0_FIFO7_R            (*((volatile uint32_t *)0x4005003C))
+#define USB0_DEVCTL_R           (*((volatile uint8_t *)0x40050060))
+#define USB0_CCONF_R            (*((volatile uint8_t *)0x40050061))
+#define USB0_TXFIFOSZ_R         (*((volatile uint8_t *)0x40050062))
+#define USB0_RXFIFOSZ_R         (*((volatile uint8_t *)0x40050063))
+#define USB0_TXFIFOADD_R        (*((volatile uint16_t *)0x40050064))
+#define USB0_RXFIFOADD_R        (*((volatile uint16_t *)0x40050066))
+#define USB0_ULPIVBUSCTL_R      (*((volatile uint8_t *)0x40050070))
+#define USB0_ULPIREGDATA_R      (*((volatile uint8_t *)0x40050074))
+#define USB0_ULPIREGADDR_R      (*((volatile uint8_t *)0x40050075))
+#define USB0_ULPIREGCTL_R       (*((volatile uint8_t *)0x40050076))
+#define USB0_EPINFO_R           (*((volatile uint8_t *)0x40050078))
+#define USB0_RAMINFO_R          (*((volatile uint8_t *)0x40050079))
+#define USB0_CONTIM_R           (*((volatile uint8_t *)0x4005007A))
+#define USB0_VPLEN_R            (*((volatile uint8_t *)0x4005007B))
+#define USB0_HSEOF_R            (*((volatile uint8_t *)0x4005007C))
+#define USB0_FSEOF_R            (*((volatile uint8_t *)0x4005007D))
+#define USB0_LSEOF_R            (*((volatile uint8_t *)0x4005007E))
+#define USB0_TXFUNCADDR0_R      (*((volatile uint8_t *)0x40050080))
+#define USB0_TXHUBADDR0_R       (*((volatile uint8_t *)0x40050082))
+#define USB0_TXHUBPORT0_R       (*((volatile uint8_t *)0x40050083))
+#define USB0_TXFUNCADDR1_R      (*((volatile uint8_t *)0x40050088))
+#define USB0_TXHUBADDR1_R       (*((volatile uint8_t *)0x4005008A))
+#define USB0_TXHUBPORT1_R       (*((volatile uint8_t *)0x4005008B))
+#define USB0_RXFUNCADDR1_R      (*((volatile uint8_t *)0x4005008C))
+#define USB0_RXHUBADDR1_R       (*((volatile uint8_t *)0x4005008E))
+#define USB0_RXHUBPORT1_R       (*((volatile uint8_t *)0x4005008F))
+#define USB0_TXFUNCADDR2_R      (*((volatile uint8_t *)0x40050090))
+#define USB0_TXHUBADDR2_R       (*((volatile uint8_t *)0x40050092))
+#define USB0_TXHUBPORT2_R       (*((volatile uint8_t *)0x40050093))
+#define USB0_RXFUNCADDR2_R      (*((volatile uint8_t *)0x40050094))
+#define USB0_RXHUBADDR2_R       (*((volatile uint8_t *)0x40050096))
+#define USB0_RXHUBPORT2_R       (*((volatile uint8_t *)0x40050097))
+#define USB0_TXFUNCADDR3_R      (*((volatile uint8_t *)0x40050098))
+#define USB0_TXHUBADDR3_R       (*((volatile uint8_t *)0x4005009A))
+#define USB0_TXHUBPORT3_R       (*((volatile uint8_t *)0x4005009B))
+#define USB0_RXFUNCADDR3_R      (*((volatile uint8_t *)0x4005009C))
+#define USB0_RXHUBADDR3_R       (*((volatile uint8_t *)0x4005009E))
+#define USB0_RXHUBPORT3_R       (*((volatile uint8_t *)0x4005009F))
+#define USB0_TXFUNCADDR4_R      (*((volatile uint8_t *)0x400500A0))
+#define USB0_TXHUBADDR4_R       (*((volatile uint8_t *)0x400500A2))
+#define USB0_TXHUBPORT4_R       (*((volatile uint8_t *)0x400500A3))
+#define USB0_RXFUNCADDR4_R      (*((volatile uint8_t *)0x400500A4))
+#define USB0_RXHUBADDR4_R       (*((volatile uint8_t *)0x400500A6))
+#define USB0_RXHUBPORT4_R       (*((volatile uint8_t *)0x400500A7))
+#define USB0_TXFUNCADDR5_R      (*((volatile uint8_t *)0x400500A8))
+#define USB0_TXHUBADDR5_R       (*((volatile uint8_t *)0x400500AA))
+#define USB0_TXHUBPORT5_R       (*((volatile uint8_t *)0x400500AB))
+#define USB0_RXFUNCADDR5_R      (*((volatile uint8_t *)0x400500AC))
+#define USB0_RXHUBADDR5_R       (*((volatile uint8_t *)0x400500AE))
+#define USB0_RXHUBPORT5_R       (*((volatile uint8_t *)0x400500AF))
+#define USB0_TXFUNCADDR6_R      (*((volatile uint8_t *)0x400500B0))
+#define USB0_TXHUBADDR6_R       (*((volatile uint8_t *)0x400500B2))
+#define USB0_TXHUBPORT6_R       (*((volatile uint8_t *)0x400500B3))
+#define USB0_RXFUNCADDR6_R      (*((volatile uint8_t *)0x400500B4))
+#define USB0_RXHUBADDR6_R       (*((volatile uint8_t *)0x400500B6))
+#define USB0_RXHUBPORT6_R       (*((volatile uint8_t *)0x400500B7))
+#define USB0_TXFUNCADDR7_R      (*((volatile uint8_t *)0x400500B8))
+#define USB0_TXHUBADDR7_R       (*((volatile uint8_t *)0x400500BA))
+#define USB0_TXHUBPORT7_R       (*((volatile uint8_t *)0x400500BB))
+#define USB0_RXFUNCADDR7_R      (*((volatile uint8_t *)0x400500BC))
+#define USB0_RXHUBADDR7_R       (*((volatile uint8_t *)0x400500BE))
+#define USB0_RXHUBPORT7_R       (*((volatile uint8_t *)0x400500BF))
+#define USB0_CSRL0_R            (*((volatile uint8_t *)0x40050102))
+#define USB0_CSRH0_R            (*((volatile uint8_t *)0x40050103))
+#define USB0_COUNT0_R           (*((volatile uint8_t *)0x40050108))
+#define USB0_TYPE0_R            (*((volatile uint8_t *)0x4005010A))
+#define USB0_NAKLMT_R           (*((volatile uint8_t *)0x4005010B))
+#define USB0_TXMAXP1_R          (*((volatile uint16_t *)0x40050110))
+#define USB0_TXCSRL1_R          (*((volatile uint8_t *)0x40050112))
+#define USB0_TXCSRH1_R          (*((volatile uint8_t *)0x40050113))
+#define USB0_RXMAXP1_R          (*((volatile uint16_t *)0x40050114))
+#define USB0_RXCSRL1_R          (*((volatile uint8_t *)0x40050116))
+#define USB0_RXCSRH1_R          (*((volatile uint8_t *)0x40050117))
+#define USB0_RXCOUNT1_R         (*((volatile uint16_t *)0x40050118))
+#define USB0_TXTYPE1_R          (*((volatile uint8_t *)0x4005011A))
+#define USB0_TXINTERVAL1_R      (*((volatile uint8_t *)0x4005011B))
+#define USB0_RXTYPE1_R          (*((volatile uint8_t *)0x4005011C))
+#define USB0_RXINTERVAL1_R      (*((volatile uint8_t *)0x4005011D))
+#define USB0_TXMAXP2_R          (*((volatile uint16_t *)0x40050120))
+#define USB0_TXCSRL2_R          (*((volatile uint8_t *)0x40050122))
+#define USB0_TXCSRH2_R          (*((volatile uint8_t *)0x40050123))
+#define USB0_RXMAXP2_R          (*((volatile uint16_t *)0x40050124))
+#define USB0_RXCSRL2_R          (*((volatile uint8_t *)0x40050126))
+#define USB0_RXCSRH2_R          (*((volatile uint8_t *)0x40050127))
+#define USB0_RXCOUNT2_R         (*((volatile uint16_t *)0x40050128))
+#define USB0_TXTYPE2_R          (*((volatile uint8_t *)0x4005012A))
+#define USB0_TXINTERVAL2_R      (*((volatile uint8_t *)0x4005012B))
+#define USB0_RXTYPE2_R          (*((volatile uint8_t *)0x4005012C))
+#define USB0_RXINTERVAL2_R      (*((volatile uint8_t *)0x4005012D))
+#define USB0_TXMAXP3_R          (*((volatile uint16_t *)0x40050130))
+#define USB0_TXCSRL3_R          (*((volatile uint8_t *)0x40050132))
+#define USB0_TXCSRH3_R          (*((volatile uint8_t *)0x40050133))
+#define USB0_RXMAXP3_R          (*((volatile uint16_t *)0x40050134))
+#define USB0_RXCSRL3_R          (*((volatile uint8_t *)0x40050136))
+#define USB0_RXCSRH3_R          (*((volatile uint8_t *)0x40050137))
+#define USB0_RXCOUNT3_R         (*((volatile uint16_t *)0x40050138))
+#define USB0_TXTYPE3_R          (*((volatile uint8_t *)0x4005013A))
+#define USB0_TXINTERVAL3_R      (*((volatile uint8_t *)0x4005013B))
+#define USB0_RXTYPE3_R          (*((volatile uint8_t *)0x4005013C))
+#define USB0_RXINTERVAL3_R      (*((volatile uint8_t *)0x4005013D))
+#define USB0_TXMAXP4_R          (*((volatile uint16_t *)0x40050140))
+#define USB0_TXCSRL4_R          (*((volatile uint8_t *)0x40050142))
+#define USB0_TXCSRH4_R          (*((volatile uint8_t *)0x40050143))
+#define USB0_RXMAXP4_R          (*((volatile uint16_t *)0x40050144))
+#define USB0_RXCSRL4_R          (*((volatile uint8_t *)0x40050146))
+#define USB0_RXCSRH4_R          (*((volatile uint8_t *)0x40050147))
+#define USB0_RXCOUNT4_R         (*((volatile uint16_t *)0x40050148))
+#define USB0_TXTYPE4_R          (*((volatile uint8_t *)0x4005014A))
+#define USB0_TXINTERVAL4_R      (*((volatile uint8_t *)0x4005014B))
+#define USB0_RXTYPE4_R          (*((volatile uint8_t *)0x4005014C))
+#define USB0_RXINTERVAL4_R      (*((volatile uint8_t *)0x4005014D))
+#define USB0_TXMAXP5_R          (*((volatile uint16_t *)0x40050150))
+#define USB0_TXCSRL5_R          (*((volatile uint8_t *)0x40050152))
+#define USB0_TXCSRH5_R          (*((volatile uint8_t *)0x40050153))
+#define USB0_RXMAXP5_R          (*((volatile uint16_t *)0x40050154))
+#define USB0_RXCSRL5_R          (*((volatile uint8_t *)0x40050156))
+#define USB0_RXCSRH5_R          (*((volatile uint8_t *)0x40050157))
+#define USB0_RXCOUNT5_R         (*((volatile uint16_t *)0x40050158))
+#define USB0_TXTYPE5_R          (*((volatile uint8_t *)0x4005015A))
+#define USB0_TXINTERVAL5_R      (*((volatile uint8_t *)0x4005015B))
+#define USB0_RXTYPE5_R          (*((volatile uint8_t *)0x4005015C))
+#define USB0_RXINTERVAL5_R      (*((volatile uint8_t *)0x4005015D))
+#define USB0_TXMAXP6_R          (*((volatile uint16_t *)0x40050160))
+#define USB0_TXCSRL6_R          (*((volatile uint8_t *)0x40050162))
+#define USB0_TXCSRH6_R          (*((volatile uint8_t *)0x40050163))
+#define USB0_RXMAXP6_R          (*((volatile uint16_t *)0x40050164))
+#define USB0_RXCSRL6_R          (*((volatile uint8_t *)0x40050166))
+#define USB0_RXCSRH6_R          (*((volatile uint8_t *)0x40050167))
+#define USB0_RXCOUNT6_R         (*((volatile uint16_t *)0x40050168))
+#define USB0_TXTYPE6_R          (*((volatile uint8_t *)0x4005016A))
+#define USB0_TXINTERVAL6_R      (*((volatile uint8_t *)0x4005016B))
+#define USB0_RXTYPE6_R          (*((volatile uint8_t *)0x4005016C))
+#define USB0_RXINTERVAL6_R      (*((volatile uint8_t *)0x4005016D))
+#define USB0_TXMAXP7_R          (*((volatile uint16_t *)0x40050170))
+#define USB0_TXCSRL7_R          (*((volatile uint8_t *)0x40050172))
+#define USB0_TXCSRH7_R          (*((volatile uint8_t *)0x40050173))
+#define USB0_RXMAXP7_R          (*((volatile uint16_t *)0x40050174))
+#define USB0_RXCSRL7_R          (*((volatile uint8_t *)0x40050176))
+#define USB0_RXCSRH7_R          (*((volatile uint8_t *)0x40050177))
+#define USB0_RXCOUNT7_R         (*((volatile uint16_t *)0x40050178))
+#define USB0_TXTYPE7_R          (*((volatile uint8_t *)0x4005017A))
+#define USB0_TXINTERVAL7_R      (*((volatile uint8_t *)0x4005017B))
+#define USB0_RXTYPE7_R          (*((volatile uint8_t *)0x4005017C))
+#define USB0_RXINTERVAL7_R      (*((volatile uint8_t *)0x4005017D))
+#define USB0_DMAINTR_R          (*((volatile uint8_t *)0x40050200))
+#define USB0_DMACTL0_R          (*((volatile uint16_t *)0x40050204))
+#define USB0_DMAADDR0_R         (*((volatile uint32_t *)0x40050208))
+#define USB0_DMACOUNT0_R        (*((volatile uint32_t *)0x4005020C))
+#define USB0_DMACTL1_R          (*((volatile uint16_t *)0x40050214))
+#define USB0_DMAADDR1_R         (*((volatile uint32_t *)0x40050218))
+#define USB0_DMACOUNT1_R        (*((volatile uint32_t *)0x4005021C))
+#define USB0_DMACTL2_R          (*((volatile uint16_t *)0x40050224))
+#define USB0_DMAADDR2_R         (*((volatile uint32_t *)0x40050228))
+#define USB0_DMACOUNT2_R        (*((volatile uint32_t *)0x4005022C))
+#define USB0_DMACTL3_R          (*((volatile uint16_t *)0x40050234))
+#define USB0_DMAADDR3_R         (*((volatile uint32_t *)0x40050238))
+#define USB0_DMACOUNT3_R        (*((volatile uint32_t *)0x4005023C))
+#define USB0_DMACTL4_R          (*((volatile uint16_t *)0x40050244))
+#define USB0_DMAADDR4_R         (*((volatile uint32_t *)0x40050248))
+#define USB0_DMACOUNT4_R        (*((volatile uint32_t *)0x4005024C))
+#define USB0_DMACTL5_R          (*((volatile uint16_t *)0x40050254))
+#define USB0_DMAADDR5_R         (*((volatile uint32_t *)0x40050258))
+#define USB0_DMACOUNT5_R        (*((volatile uint32_t *)0x4005025C))
+#define USB0_DMACTL6_R          (*((volatile uint16_t *)0x40050264))
+#define USB0_DMAADDR6_R         (*((volatile uint32_t *)0x40050268))
+#define USB0_DMACOUNT6_R        (*((volatile uint32_t *)0x4005026C))
+#define USB0_DMACTL7_R          (*((volatile uint16_t *)0x40050274))
+#define USB0_DMAADDR7_R         (*((volatile uint32_t *)0x40050278))
+#define USB0_DMACOUNT7_R        (*((volatile uint32_t *)0x4005027C))
+#define USB0_RQPKTCOUNT1_R      (*((volatile uint16_t *)0x40050304))
+#define USB0_RQPKTCOUNT2_R      (*((volatile uint16_t *)0x40050308))
+#define USB0_RQPKTCOUNT3_R      (*((volatile uint16_t *)0x4005030C))
+#define USB0_RQPKTCOUNT4_R      (*((volatile uint16_t *)0x40050310))
+#define USB0_RQPKTCOUNT5_R      (*((volatile uint16_t *)0x40050314))
+#define USB0_RQPKTCOUNT6_R      (*((volatile uint16_t *)0x40050318))
+#define USB0_RQPKTCOUNT7_R      (*((volatile uint16_t *)0x4005031C))
+#define USB0_RXDPKTBUFDIS_R     (*((volatile uint16_t *)0x40050340))
+#define USB0_TXDPKTBUFDIS_R     (*((volatile uint16_t *)0x40050342))
+#define USB0_CTO_R              (*((volatile uint16_t *)0x40050344))
+#define USB0_HHSRTN_R           (*((volatile uint16_t *)0x40050346))
+#define USB0_HSBT_R             (*((volatile uint16_t *)0x40050348))
+#define USB0_LPMATTR_R          (*((volatile uint16_t *)0x40050360))
+#define USB0_LPMCNTRL_R         (*((volatile uint8_t *)0x40050362))
+#define USB0_LPMIM_R            (*((volatile uint8_t *)0x40050363))
+#define USB0_LPMRIS_R           (*((volatile uint8_t *)0x40050364))
+#define USB0_LPMFADDR_R         (*((volatile uint8_t *)0x40050365))
+#define USB0_EPC_R              (*((volatile uint32_t *)0x40050400))
+#define USB0_EPCRIS_R           (*((volatile uint32_t *)0x40050404))
+#define USB0_EPCIM_R            (*((volatile uint32_t *)0x40050408))
+#define USB0_EPCISC_R           (*((volatile uint32_t *)0x4005040C))
+#define USB0_DRRIS_R            (*((volatile uint32_t *)0x40050410))
+#define USB0_DRIM_R             (*((volatile uint32_t *)0x40050414))
+#define USB0_DRISC_R            (*((volatile uint32_t *)0x40050418))
+#define USB0_GPCS_R             (*((volatile uint32_t *)0x4005041C))
+#define USB0_VDC_R              (*((volatile uint32_t *)0x40050430))
+#define USB0_VDCRIS_R           (*((volatile uint32_t *)0x40050434))
+#define USB0_VDCIM_R            (*((volatile uint32_t *)0x40050438))
+#define USB0_VDCISC_R           (*((volatile uint32_t *)0x4005043C))
+#define USB0_PP_R               (*((volatile uint32_t *)0x40050FC0))
+#define USB0_PC_R               (*((volatile uint32_t *)0x40050FC4))
+#define USB0_CC_R               (*((volatile uint32_t *)0x40050FC8))
+
+//*****************************************************************************
+//
+// GPIO registers (PORTA AHB)
+//
+//*****************************************************************************
+#define GPIO_PORTA_AHB_DATA_BITS_R                                            \
+                                ((volatile uint32_t *)0x40058000)
+#define GPIO_PORTA_AHB_DATA_R   (*((volatile uint32_t *)0x400583FC))
+#define GPIO_PORTA_AHB_DIR_R    (*((volatile uint32_t *)0x40058400))
+#define GPIO_PORTA_AHB_IS_R     (*((volatile uint32_t *)0x40058404))
+#define GPIO_PORTA_AHB_IBE_R    (*((volatile uint32_t *)0x40058408))
+#define GPIO_PORTA_AHB_IEV_R    (*((volatile uint32_t *)0x4005840C))
+#define GPIO_PORTA_AHB_IM_R     (*((volatile uint32_t *)0x40058410))
+#define GPIO_PORTA_AHB_RIS_R    (*((volatile uint32_t *)0x40058414))
+#define GPIO_PORTA_AHB_MIS_R    (*((volatile uint32_t *)0x40058418))
+#define GPIO_PORTA_AHB_ICR_R    (*((volatile uint32_t *)0x4005841C))
+#define GPIO_PORTA_AHB_AFSEL_R  (*((volatile uint32_t *)0x40058420))
+#define GPIO_PORTA_AHB_DR2R_R   (*((volatile uint32_t *)0x40058500))
+#define GPIO_PORTA_AHB_DR4R_R   (*((volatile uint32_t *)0x40058504))
+#define GPIO_PORTA_AHB_DR8R_R   (*((volatile uint32_t *)0x40058508))
+#define GPIO_PORTA_AHB_ODR_R    (*((volatile uint32_t *)0x4005850C))
+#define GPIO_PORTA_AHB_PUR_R    (*((volatile uint32_t *)0x40058510))
+#define GPIO_PORTA_AHB_PDR_R    (*((volatile uint32_t *)0x40058514))
+#define GPIO_PORTA_AHB_SLR_R    (*((volatile uint32_t *)0x40058518))
+#define GPIO_PORTA_AHB_DEN_R    (*((volatile uint32_t *)0x4005851C))
+#define GPIO_PORTA_AHB_LOCK_R   (*((volatile uint32_t *)0x40058520))
+#define GPIO_PORTA_AHB_CR_R     (*((volatile uint32_t *)0x40058524))
+#define GPIO_PORTA_AHB_AMSEL_R  (*((volatile uint32_t *)0x40058528))
+#define GPIO_PORTA_AHB_PCTL_R   (*((volatile uint32_t *)0x4005852C))
+#define GPIO_PORTA_AHB_ADCCTL_R (*((volatile uint32_t *)0x40058530))
+#define GPIO_PORTA_AHB_DMACTL_R (*((volatile uint32_t *)0x40058534))
+#define GPIO_PORTA_AHB_SI_R     (*((volatile uint32_t *)0x40058538))
+#define GPIO_PORTA_AHB_DR12R_R  (*((volatile uint32_t *)0x4005853C))
+#define GPIO_PORTA_AHB_WAKEPEN_R                                              \
+                                (*((volatile uint32_t *)0x40058540))
+#define GPIO_PORTA_AHB_WAKELVL_R                                              \
+                                (*((volatile uint32_t *)0x40058544))
+#define GPIO_PORTA_AHB_WAKESTAT_R                                             \
+                                (*((volatile uint32_t *)0x40058548))
+#define GPIO_PORTA_AHB_PP_R     (*((volatile uint32_t *)0x40058FC0))
+#define GPIO_PORTA_AHB_PC_R     (*((volatile uint32_t *)0x40058FC4))
+#define GPIO_PCTL_PR_R          (*((volatile uint32_t *)0x00012000))
+#define GPIO_PCTL_PS_R          (*((volatile uint32_t *)0x00013000))
+#define GPIO_PCTL_PT_R          (*((volatile uint32_t *)0x00014000))
+
+//*****************************************************************************
+//
+// GPIO registers (PORTB AHB)
+//
+//*****************************************************************************
+#define GPIO_PORTB_AHB_DATA_BITS_R                                            \
+                                ((volatile uint32_t *)0x40059000)
+#define GPIO_PORTB_AHB_DATA_R   (*((volatile uint32_t *)0x400593FC))
+#define GPIO_PORTB_AHB_DIR_R    (*((volatile uint32_t *)0x40059400))
+#define GPIO_PORTB_AHB_IS_R     (*((volatile uint32_t *)0x40059404))
+#define GPIO_PORTB_AHB_IBE_R    (*((volatile uint32_t *)0x40059408))
+#define GPIO_PORTB_AHB_IEV_R    (*((volatile uint32_t *)0x4005940C))
+#define GPIO_PORTB_AHB_IM_R     (*((volatile uint32_t *)0x40059410))
+#define GPIO_PORTB_AHB_RIS_R    (*((volatile uint32_t *)0x40059414))
+#define GPIO_PORTB_AHB_MIS_R    (*((volatile uint32_t *)0x40059418))
+#define GPIO_PORTB_AHB_ICR_R    (*((volatile uint32_t *)0x4005941C))
+#define GPIO_PORTB_AHB_AFSEL_R  (*((volatile uint32_t *)0x40059420))
+#define GPIO_PORTB_AHB_DR2R_R   (*((volatile uint32_t *)0x40059500))
+#define GPIO_PORTB_AHB_DR4R_R   (*((volatile uint32_t *)0x40059504))
+#define GPIO_PORTB_AHB_DR8R_R   (*((volatile uint32_t *)0x40059508))
+#define GPIO_PORTB_AHB_ODR_R    (*((volatile uint32_t *)0x4005950C))
+#define GPIO_PORTB_AHB_PUR_R    (*((volatile uint32_t *)0x40059510))
+#define GPIO_PORTB_AHB_PDR_R    (*((volatile uint32_t *)0x40059514))
+#define GPIO_PORTB_AHB_SLR_R    (*((volatile uint32_t *)0x40059518))
+#define GPIO_PORTB_AHB_DEN_R    (*((volatile uint32_t *)0x4005951C))
+#define GPIO_PORTB_AHB_LOCK_R   (*((volatile uint32_t *)0x40059520))
+#define GPIO_PORTB_AHB_CR_R     (*((volatile uint32_t *)0x40059524))
+#define GPIO_PORTB_AHB_AMSEL_R  (*((volatile uint32_t *)0x40059528))
+#define GPIO_PORTB_AHB_PCTL_R   (*((volatile uint32_t *)0x4005952C))
+#define GPIO_PORTB_AHB_ADCCTL_R (*((volatile uint32_t *)0x40059530))
+#define GPIO_PORTB_AHB_DMACTL_R (*((volatile uint32_t *)0x40059534))
+#define GPIO_PORTB_AHB_SI_R     (*((volatile uint32_t *)0x40059538))
+#define GPIO_PORTB_AHB_DR12R_R  (*((volatile uint32_t *)0x4005953C))
+#define GPIO_PORTB_AHB_WAKEPEN_R                                              \
+                                (*((volatile uint32_t *)0x40059540))
+#define GPIO_PORTB_AHB_WAKELVL_R                                              \
+                                (*((volatile uint32_t *)0x40059544))
+#define GPIO_PORTB_AHB_WAKESTAT_R                                             \
+                                (*((volatile uint32_t *)0x40059548))
+#define GPIO_PORTB_AHB_PP_R     (*((volatile uint32_t *)0x40059FC0))
+#define GPIO_PORTB_AHB_PC_R     (*((volatile uint32_t *)0x40059FC4))
+#define GPIO_PCTL_PR_R          (*((volatile uint32_t *)0x00012000))
+#define GPIO_PCTL_PS_R          (*((volatile uint32_t *)0x00013000))
+#define GPIO_PCTL_PT_R          (*((volatile uint32_t *)0x00014000))
+
+//*****************************************************************************
+//
+// GPIO registers (PORTC AHB)
+//
+//*****************************************************************************
+#define GPIO_PORTC_AHB_DATA_BITS_R                                            \
+                                ((volatile uint32_t *)0x4005A000)
+#define GPIO_PORTC_AHB_DATA_R   (*((volatile uint32_t *)0x4005A3FC))
+#define GPIO_PORTC_AHB_DIR_R    (*((volatile uint32_t *)0x4005A400))
+#define GPIO_PORTC_AHB_IS_R     (*((volatile uint32_t *)0x4005A404))
+#define GPIO_PORTC_AHB_IBE_R    (*((volatile uint32_t *)0x4005A408))
+#define GPIO_PORTC_AHB_IEV_R    (*((volatile uint32_t *)0x4005A40C))
+#define GPIO_PORTC_AHB_IM_R     (*((volatile uint32_t *)0x4005A410))
+#define GPIO_PORTC_AHB_RIS_R    (*((volatile uint32_t *)0x4005A414))
+#define GPIO_PORTC_AHB_MIS_R    (*((volatile uint32_t *)0x4005A418))
+#define GPIO_PORTC_AHB_ICR_R    (*((volatile uint32_t *)0x4005A41C))
+#define GPIO_PORTC_AHB_AFSEL_R  (*((volatile uint32_t *)0x4005A420))
+#define GPIO_PORTC_AHB_DR2R_R   (*((volatile uint32_t *)0x4005A500))
+#define GPIO_PORTC_AHB_DR4R_R   (*((volatile uint32_t *)0x4005A504))
+#define GPIO_PORTC_AHB_DR8R_R   (*((volatile uint32_t *)0x4005A508))
+#define GPIO_PORTC_AHB_ODR_R    (*((volatile uint32_t *)0x4005A50C))
+#define GPIO_PORTC_AHB_PUR_R    (*((volatile uint32_t *)0x4005A510))
+#define GPIO_PORTC_AHB_PDR_R    (*((volatile uint32_t *)0x4005A514))
+#define GPIO_PORTC_AHB_SLR_R    (*((volatile uint32_t *)0x4005A518))
+#define GPIO_PORTC_AHB_DEN_R    (*((volatile uint32_t *)0x4005A51C))
+#define GPIO_PORTC_AHB_LOCK_R   (*((volatile uint32_t *)0x4005A520))
+#define GPIO_PORTC_AHB_CR_R     (*((volatile uint32_t *)0x4005A524))
+#define GPIO_PORTC_AHB_AMSEL_R  (*((volatile uint32_t *)0x4005A528))
+#define GPIO_PORTC_AHB_PCTL_R   (*((volatile uint32_t *)0x4005A52C))
+#define GPIO_PORTC_AHB_ADCCTL_R (*((volatile uint32_t *)0x4005A530))
+#define GPIO_PORTC_AHB_DMACTL_R (*((volatile uint32_t *)0x4005A534))
+#define GPIO_PORTC_AHB_SI_R     (*((volatile uint32_t *)0x4005A538))
+#define GPIO_PORTC_AHB_DR12R_R  (*((volatile uint32_t *)0x4005A53C))
+#define GPIO_PORTC_AHB_WAKEPEN_R                                              \
+                                (*((volatile uint32_t *)0x4005A540))
+#define GPIO_PORTC_AHB_WAKELVL_R                                              \
+                                (*((volatile uint32_t *)0x4005A544))
+#define GPIO_PORTC_AHB_WAKESTAT_R                                             \
+                                (*((volatile uint32_t *)0x4005A548))
+#define GPIO_PORTC_AHB_PP_R     (*((volatile uint32_t *)0x4005AFC0))
+#define GPIO_PORTC_AHB_PC_R     (*((volatile uint32_t *)0x4005AFC4))
+#define GPIO_PCTL_PR_R          (*((volatile uint32_t *)0x00012000))
+#define GPIO_PCTL_PS_R          (*((volatile uint32_t *)0x00013000))
+#define GPIO_PCTL_PT_R          (*((volatile uint32_t *)0x00014000))
+
+//*****************************************************************************
+//
+// GPIO registers (PORTD AHB)
+//
+//*****************************************************************************
+#define GPIO_PORTD_AHB_DATA_BITS_R                                            \
+                                ((volatile uint32_t *)0x4005B000)
+#define GPIO_PORTD_AHB_DATA_R   (*((volatile uint32_t *)0x4005B3FC))
+#define GPIO_PORTD_AHB_DIR_R    (*((volatile uint32_t *)0x4005B400))
+#define GPIO_PORTD_AHB_IS_R     (*((volatile uint32_t *)0x4005B404))
+#define GPIO_PORTD_AHB_IBE_R    (*((volatile uint32_t *)0x4005B408))
+#define GPIO_PORTD_AHB_IEV_R    (*((volatile uint32_t *)0x4005B40C))
+#define GPIO_PORTD_AHB_IM_R     (*((volatile uint32_t *)0x4005B410))
+#define GPIO_PORTD_AHB_RIS_R    (*((volatile uint32_t *)0x4005B414))
+#define GPIO_PORTD_AHB_MIS_R    (*((volatile uint32_t *)0x4005B418))
+#define GPIO_PORTD_AHB_ICR_R    (*((volatile uint32_t *)0x4005B41C))
+#define GPIO_PORTD_AHB_AFSEL_R  (*((volatile uint32_t *)0x4005B420))
+#define GPIO_PORTD_AHB_DR2R_R   (*((volatile uint32_t *)0x4005B500))
+#define GPIO_PORTD_AHB_DR4R_R   (*((volatile uint32_t *)0x4005B504))
+#define GPIO_PORTD_AHB_DR8R_R   (*((volatile uint32_t *)0x4005B508))
+#define GPIO_PORTD_AHB_ODR_R    (*((volatile uint32_t *)0x4005B50C))
+#define GPIO_PORTD_AHB_PUR_R    (*((volatile uint32_t *)0x4005B510))
+#define GPIO_PORTD_AHB_PDR_R    (*((volatile uint32_t *)0x4005B514))
+#define GPIO_PORTD_AHB_SLR_R    (*((volatile uint32_t *)0x4005B518))
+#define GPIO_PORTD_AHB_DEN_R    (*((volatile uint32_t *)0x4005B51C))
+#define GPIO_PORTD_AHB_LOCK_R   (*((volatile uint32_t *)0x4005B520))
+#define GPIO_PORTD_AHB_CR_R     (*((volatile uint32_t *)0x4005B524))
+#define GPIO_PORTD_AHB_AMSEL_R  (*((volatile uint32_t *)0x4005B528))
+#define GPIO_PORTD_AHB_PCTL_R   (*((volatile uint32_t *)0x4005B52C))
+#define GPIO_PORTD_AHB_ADCCTL_R (*((volatile uint32_t *)0x4005B530))
+#define GPIO_PORTD_AHB_DMACTL_R (*((volatile uint32_t *)0x4005B534))
+#define GPIO_PORTD_AHB_SI_R     (*((volatile uint32_t *)0x4005B538))
+#define GPIO_PORTD_AHB_DR12R_R  (*((volatile uint32_t *)0x4005B53C))
+#define GPIO_PORTD_AHB_WAKEPEN_R                                              \
+                                (*((volatile uint32_t *)0x4005B540))
+#define GPIO_PORTD_AHB_WAKELVL_R                                              \
+                                (*((volatile uint32_t *)0x4005B544))
+#define GPIO_PORTD_AHB_WAKESTAT_R                                             \
+                                (*((volatile uint32_t *)0x4005B548))
+#define GPIO_PORTD_AHB_PP_R     (*((volatile uint32_t *)0x4005BFC0))
+#define GPIO_PORTD_AHB_PC_R     (*((volatile uint32_t *)0x4005BFC4))
+#define GPIO_PCTL_PR_R          (*((volatile uint32_t *)0x00012000))
+#define GPIO_PCTL_PS_R          (*((volatile uint32_t *)0x00013000))
+#define GPIO_PCTL_PT_R          (*((volatile uint32_t *)0x00014000))
+
+//*****************************************************************************
+//
+// GPIO registers (PORTE AHB)
+//
+//*****************************************************************************
+#define GPIO_PORTE_AHB_DATA_BITS_R                                            \
+                                ((volatile uint32_t *)0x4005C000)
+#define GPIO_PORTE_AHB_DATA_R   (*((volatile uint32_t *)0x4005C3FC))
+#define GPIO_PORTE_AHB_DIR_R    (*((volatile uint32_t *)0x4005C400))
+#define GPIO_PORTE_AHB_IS_R     (*((volatile uint32_t *)0x4005C404))
+#define GPIO_PORTE_AHB_IBE_R    (*((volatile uint32_t *)0x4005C408))
+#define GPIO_PORTE_AHB_IEV_R    (*((volatile uint32_t *)0x4005C40C))
+#define GPIO_PORTE_AHB_IM_R     (*((volatile uint32_t *)0x4005C410))
+#define GPIO_PORTE_AHB_RIS_R    (*((volatile uint32_t *)0x4005C414))
+#define GPIO_PORTE_AHB_MIS_R    (*((volatile uint32_t *)0x4005C418))
+#define GPIO_PORTE_AHB_ICR_R    (*((volatile uint32_t *)0x4005C41C))
+#define GPIO_PORTE_AHB_AFSEL_R  (*((volatile uint32_t *)0x4005C420))
+#define GPIO_PORTE_AHB_DR2R_R   (*((volatile uint32_t *)0x4005C500))
+#define GPIO_PORTE_AHB_DR4R_R   (*((volatile uint32_t *)0x4005C504))
+#define GPIO_PORTE_AHB_DR8R_R   (*((volatile uint32_t *)0x4005C508))
+#define GPIO_PORTE_AHB_ODR_R    (*((volatile uint32_t *)0x4005C50C))
+#define GPIO_PORTE_AHB_PUR_R    (*((volatile uint32_t *)0x4005C510))
+#define GPIO_PORTE_AHB_PDR_R    (*((volatile uint32_t *)0x4005C514))
+#define GPIO_PORTE_AHB_SLR_R    (*((volatile uint32_t *)0x4005C518))
+#define GPIO_PORTE_AHB_DEN_R    (*((volatile uint32_t *)0x4005C51C))
+#define GPIO_PORTE_AHB_LOCK_R   (*((volatile uint32_t *)0x4005C520))
+#define GPIO_PORTE_AHB_CR_R     (*((volatile uint32_t *)0x4005C524))
+#define GPIO_PORTE_AHB_AMSEL_R  (*((volatile uint32_t *)0x4005C528))
+#define GPIO_PORTE_AHB_PCTL_R   (*((volatile uint32_t *)0x4005C52C))
+#define GPIO_PORTE_AHB_ADCCTL_R (*((volatile uint32_t *)0x4005C530))
+#define GPIO_PORTE_AHB_DMACTL_R (*((volatile uint32_t *)0x4005C534))
+#define GPIO_PORTE_AHB_SI_R     (*((volatile uint32_t *)0x4005C538))
+#define GPIO_PORTE_AHB_DR12R_R  (*((volatile uint32_t *)0x4005C53C))
+#define GPIO_PORTE_AHB_WAKEPEN_R                                              \
+                                (*((volatile uint32_t *)0x4005C540))
+#define GPIO_PORTE_AHB_WAKELVL_R                                              \
+                                (*((volatile uint32_t *)0x4005C544))
+#define GPIO_PORTE_AHB_WAKESTAT_R                                             \
+                                (*((volatile uint32_t *)0x4005C548))
+#define GPIO_PORTE_AHB_PP_R     (*((volatile uint32_t *)0x4005CFC0))
+#define GPIO_PORTE_AHB_PC_R     (*((volatile uint32_t *)0x4005CFC4))
+#define GPIO_PCTL_PR_R          (*((volatile uint32_t *)0x00012000))
+#define GPIO_PCTL_PS_R          (*((volatile uint32_t *)0x00013000))
+#define GPIO_PCTL_PT_R          (*((volatile uint32_t *)0x00014000))
+
+//*****************************************************************************
+//
+// GPIO registers (PORTF AHB)
+//
+//*****************************************************************************
+#define GPIO_PORTF_AHB_DATA_BITS_R                                            \
+                                ((volatile uint32_t *)0x4005D000)
+#define GPIO_PORTF_AHB_DATA_R   (*((volatile uint32_t *)0x4005D3FC))
+#define GPIO_PORTF_AHB_DIR_R    (*((volatile uint32_t *)0x4005D400))
+#define GPIO_PORTF_AHB_IS_R     (*((volatile uint32_t *)0x4005D404))
+#define GPIO_PORTF_AHB_IBE_R    (*((volatile uint32_t *)0x4005D408))
+#define GPIO_PORTF_AHB_IEV_R    (*((volatile uint32_t *)0x4005D40C))
+#define GPIO_PORTF_AHB_IM_R     (*((volatile uint32_t *)0x4005D410))
+#define GPIO_PORTF_AHB_RIS_R    (*((volatile uint32_t *)0x4005D414))
+#define GPIO_PORTF_AHB_MIS_R    (*((volatile uint32_t *)0x4005D418))
+#define GPIO_PORTF_AHB_ICR_R    (*((volatile uint32_t *)0x4005D41C))
+#define GPIO_PORTF_AHB_AFSEL_R  (*((volatile uint32_t *)0x4005D420))
+#define GPIO_PORTF_AHB_DR2R_R   (*((volatile uint32_t *)0x4005D500))
+#define GPIO_PORTF_AHB_DR4R_R   (*((volatile uint32_t *)0x4005D504))
+#define GPIO_PORTF_AHB_DR8R_R   (*((volatile uint32_t *)0x4005D508))
+#define GPIO_PORTF_AHB_ODR_R    (*((volatile uint32_t *)0x4005D50C))
+#define GPIO_PORTF_AHB_PUR_R    (*((volatile uint32_t *)0x4005D510))
+#define GPIO_PORTF_AHB_PDR_R    (*((volatile uint32_t *)0x4005D514))
+#define GPIO_PORTF_AHB_SLR_R    (*((volatile uint32_t *)0x4005D518))
+#define GPIO_PORTF_AHB_DEN_R    (*((volatile uint32_t *)0x4005D51C))
+#define GPIO_PORTF_AHB_LOCK_R   (*((volatile uint32_t *)0x4005D520))
+#define GPIO_PORTF_AHB_CR_R     (*((volatile uint32_t *)0x4005D524))
+#define GPIO_PORTF_AHB_AMSEL_R  (*((volatile uint32_t *)0x4005D528))
+#define GPIO_PORTF_AHB_PCTL_R   (*((volatile uint32_t *)0x4005D52C))
+#define GPIO_PORTF_AHB_ADCCTL_R (*((volatile uint32_t *)0x4005D530))
+#define GPIO_PORTF_AHB_DMACTL_R (*((volatile uint32_t *)0x4005D534))
+#define GPIO_PORTF_AHB_SI_R     (*((volatile uint32_t *)0x4005D538))
+#define GPIO_PORTF_AHB_DR12R_R  (*((volatile uint32_t *)0x4005D53C))
+#define GPIO_PORTF_AHB_WAKEPEN_R                                              \
+                                (*((volatile uint32_t *)0x4005D540))
+#define GPIO_PORTF_AHB_WAKELVL_R                                              \
+                                (*((volatile uint32_t *)0x4005D544))
+#define GPIO_PORTF_AHB_WAKESTAT_R                                             \
+                                (*((volatile uint32_t *)0x4005D548))
+#define GPIO_PORTF_AHB_PP_R     (*((volatile uint32_t *)0x4005DFC0))
+#define GPIO_PORTF_AHB_PC_R     (*((volatile uint32_t *)0x4005DFC4))
+#define GPIO_PCTL_PR_R          (*((volatile uint32_t *)0x00012000))
+#define GPIO_PCTL_PS_R          (*((volatile uint32_t *)0x00013000))
+#define GPIO_PCTL_PT_R          (*((volatile uint32_t *)0x00014000))
+
+//*****************************************************************************
+//
+// GPIO registers (PORTG AHB)
+//
+//*****************************************************************************
+#define GPIO_PORTG_AHB_DATA_BITS_R                                            \
+                                ((volatile uint32_t *)0x4005E000)
+#define GPIO_PORTG_AHB_DATA_R   (*((volatile uint32_t *)0x4005E3FC))
+#define GPIO_PORTG_AHB_DIR_R    (*((volatile uint32_t *)0x4005E400))
+#define GPIO_PORTG_AHB_IS_R     (*((volatile uint32_t *)0x4005E404))
+#define GPIO_PORTG_AHB_IBE_R    (*((volatile uint32_t *)0x4005E408))
+#define GPIO_PORTG_AHB_IEV_R    (*((volatile uint32_t *)0x4005E40C))
+#define GPIO_PORTG_AHB_IM_R     (*((volatile uint32_t *)0x4005E410))
+#define GPIO_PORTG_AHB_RIS_R    (*((volatile uint32_t *)0x4005E414))
+#define GPIO_PORTG_AHB_MIS_R    (*((volatile uint32_t *)0x4005E418))
+#define GPIO_PORTG_AHB_ICR_R    (*((volatile uint32_t *)0x4005E41C))
+#define GPIO_PORTG_AHB_AFSEL_R  (*((volatile uint32_t *)0x4005E420))
+#define GPIO_PORTG_AHB_DR2R_R   (*((volatile uint32_t *)0x4005E500))
+#define GPIO_PORTG_AHB_DR4R_R   (*((volatile uint32_t *)0x4005E504))
+#define GPIO_PORTG_AHB_DR8R_R   (*((volatile uint32_t *)0x4005E508))
+#define GPIO_PORTG_AHB_ODR_R    (*((volatile uint32_t *)0x4005E50C))
+#define GPIO_PORTG_AHB_PUR_R    (*((volatile uint32_t *)0x4005E510))
+#define GPIO_PORTG_AHB_PDR_R    (*((volatile uint32_t *)0x4005E514))
+#define GPIO_PORTG_AHB_SLR_R    (*((volatile uint32_t *)0x4005E518))
+#define GPIO_PORTG_AHB_DEN_R    (*((volatile uint32_t *)0x4005E51C))
+#define GPIO_PORTG_AHB_LOCK_R   (*((volatile uint32_t *)0x4005E520))
+#define GPIO_PORTG_AHB_CR_R     (*((volatile uint32_t *)0x4005E524))
+#define GPIO_PORTG_AHB_AMSEL_R  (*((volatile uint32_t *)0x4005E528))
+#define GPIO_PORTG_AHB_PCTL_R   (*((volatile uint32_t *)0x4005E52C))
+#define GPIO_PORTG_AHB_ADCCTL_R (*((volatile uint32_t *)0x4005E530))
+#define GPIO_PORTG_AHB_DMACTL_R (*((volatile uint32_t *)0x4005E534))
+#define GPIO_PORTG_AHB_SI_R     (*((volatile uint32_t *)0x4005E538))
+#define GPIO_PORTG_AHB_DR12R_R  (*((volatile uint32_t *)0x4005E53C))
+#define GPIO_PORTG_AHB_WAKEPEN_R                                              \
+                                (*((volatile uint32_t *)0x4005E540))
+#define GPIO_PORTG_AHB_WAKELVL_R                                              \
+                                (*((volatile uint32_t *)0x4005E544))
+#define GPIO_PORTG_AHB_WAKESTAT_R                                             \
+                                (*((volatile uint32_t *)0x4005E548))
+#define GPIO_PORTG_AHB_PP_R     (*((volatile uint32_t *)0x4005EFC0))
+#define GPIO_PORTG_AHB_PC_R     (*((volatile uint32_t *)0x4005EFC4))
+#define GPIO_PCTL_PR_R          (*((volatile uint32_t *)0x00012000))
+#define GPIO_PCTL_PS_R          (*((volatile uint32_t *)0x00013000))
+#define GPIO_PCTL_PT_R          (*((volatile uint32_t *)0x00014000))
+
+//*****************************************************************************
+//
+// GPIO registers (PORTH AHB)
+//
+//*****************************************************************************
+#define GPIO_PORTH_AHB_DATA_BITS_R                                            \
+                                ((volatile uint32_t *)0x4005F000)
+#define GPIO_PORTH_AHB_DATA_R   (*((volatile uint32_t *)0x4005F3FC))
+#define GPIO_PORTH_AHB_DIR_R    (*((volatile uint32_t *)0x4005F400))
+#define GPIO_PORTH_AHB_IS_R     (*((volatile uint32_t *)0x4005F404))
+#define GPIO_PORTH_AHB_IBE_R    (*((volatile uint32_t *)0x4005F408))
+#define GPIO_PORTH_AHB_IEV_R    (*((volatile uint32_t *)0x4005F40C))
+#define GPIO_PORTH_AHB_IM_R     (*((volatile uint32_t *)0x4005F410))
+#define GPIO_PORTH_AHB_RIS_R    (*((volatile uint32_t *)0x4005F414))
+#define GPIO_PORTH_AHB_MIS_R    (*((volatile uint32_t *)0x4005F418))
+#define GPIO_PORTH_AHB_ICR_R    (*((volatile uint32_t *)0x4005F41C))
+#define GPIO_PORTH_AHB_AFSEL_R  (*((volatile uint32_t *)0x4005F420))
+#define GPIO_PORTH_AHB_DR2R_R   (*((volatile uint32_t *)0x4005F500))
+#define GPIO_PORTH_AHB_DR4R_R   (*((volatile uint32_t *)0x4005F504))
+#define GPIO_PORTH_AHB_DR8R_R   (*((volatile uint32_t *)0x4005F508))
+#define GPIO_PORTH_AHB_ODR_R    (*((volatile uint32_t *)0x4005F50C))
+#define GPIO_PORTH_AHB_PUR_R    (*((volatile uint32_t *)0x4005F510))
+#define GPIO_PORTH_AHB_PDR_R    (*((volatile uint32_t *)0x4005F514))
+#define GPIO_PORTH_AHB_SLR_R    (*((volatile uint32_t *)0x4005F518))
+#define GPIO_PORTH_AHB_DEN_R    (*((volatile uint32_t *)0x4005F51C))
+#define GPIO_PORTH_AHB_LOCK_R   (*((volatile uint32_t *)0x4005F520))
+#define GPIO_PORTH_AHB_CR_R     (*((volatile uint32_t *)0x4005F524))
+#define GPIO_PORTH_AHB_AMSEL_R  (*((volatile uint32_t *)0x4005F528))
+#define GPIO_PORTH_AHB_PCTL_R   (*((volatile uint32_t *)0x4005F52C))
+#define GPIO_PORTH_AHB_ADCCTL_R (*((volatile uint32_t *)0x4005F530))
+#define GPIO_PORTH_AHB_DMACTL_R (*((volatile uint32_t *)0x4005F534))
+#define GPIO_PORTH_AHB_SI_R     (*((volatile uint32_t *)0x4005F538))
+#define GPIO_PORTH_AHB_DR12R_R  (*((volatile uint32_t *)0x4005F53C))
+#define GPIO_PORTH_AHB_WAKEPEN_R                                              \
+                                (*((volatile uint32_t *)0x4005F540))
+#define GPIO_PORTH_AHB_WAKELVL_R                                              \
+                                (*((volatile uint32_t *)0x4005F544))
+#define GPIO_PORTH_AHB_WAKESTAT_R                                             \
+                                (*((volatile uint32_t *)0x4005F548))
+#define GPIO_PORTH_AHB_PP_R     (*((volatile uint32_t *)0x4005FFC0))
+#define GPIO_PORTH_AHB_PC_R     (*((volatile uint32_t *)0x4005FFC4))
+#define GPIO_PCTL_PR_R          (*((volatile uint32_t *)0x00012000))
+#define GPIO_PCTL_PS_R          (*((volatile uint32_t *)0x00013000))
+#define GPIO_PCTL_PT_R          (*((volatile uint32_t *)0x00014000))
+
+//*****************************************************************************
+//
+// GPIO registers (PORTJ AHB)
+//
+//*****************************************************************************
+#define GPIO_PORTJ_AHB_DATA_BITS_R                                            \
+                                ((volatile uint32_t *)0x40060000)
+#define GPIO_PORTJ_AHB_DATA_R   (*((volatile uint32_t *)0x400603FC))
+#define GPIO_PORTJ_AHB_DIR_R    (*((volatile uint32_t *)0x40060400))
+#define GPIO_PORTJ_AHB_IS_R     (*((volatile uint32_t *)0x40060404))
+#define GPIO_PORTJ_AHB_IBE_R    (*((volatile uint32_t *)0x40060408))
+#define GPIO_PORTJ_AHB_IEV_R    (*((volatile uint32_t *)0x4006040C))
+#define GPIO_PORTJ_AHB_IM_R     (*((volatile uint32_t *)0x40060410))
+#define GPIO_PORTJ_AHB_RIS_R    (*((volatile uint32_t *)0x40060414))
+#define GPIO_PORTJ_AHB_MIS_R    (*((volatile uint32_t *)0x40060418))
+#define GPIO_PORTJ_AHB_ICR_R    (*((volatile uint32_t *)0x4006041C))
+#define GPIO_PORTJ_AHB_AFSEL_R  (*((volatile uint32_t *)0x40060420))
+#define GPIO_PORTJ_AHB_DR2R_R   (*((volatile uint32_t *)0x40060500))
+#define GPIO_PORTJ_AHB_DR4R_R   (*((volatile uint32_t *)0x40060504))
+#define GPIO_PORTJ_AHB_DR8R_R   (*((volatile uint32_t *)0x40060508))
+#define GPIO_PORTJ_AHB_ODR_R    (*((volatile uint32_t *)0x4006050C))
+#define GPIO_PORTJ_AHB_PUR_R    (*((volatile uint32_t *)0x40060510))
+#define GPIO_PORTJ_AHB_PDR_R    (*((volatile uint32_t *)0x40060514))
+#define GPIO_PORTJ_AHB_SLR_R    (*((volatile uint32_t *)0x40060518))
+#define GPIO_PORTJ_AHB_DEN_R    (*((volatile uint32_t *)0x4006051C))
+#define GPIO_PORTJ_AHB_LOCK_R   (*((volatile uint32_t *)0x40060520))
+#define GPIO_PORTJ_AHB_CR_R     (*((volatile uint32_t *)0x40060524))
+#define GPIO_PORTJ_AHB_AMSEL_R  (*((volatile uint32_t *)0x40060528))
+#define GPIO_PORTJ_AHB_PCTL_R   (*((volatile uint32_t *)0x4006052C))
+#define GPIO_PORTJ_AHB_ADCCTL_R (*((volatile uint32_t *)0x40060530))
+#define GPIO_PORTJ_AHB_DMACTL_R (*((volatile uint32_t *)0x40060534))
+#define GPIO_PORTJ_AHB_SI_R     (*((volatile uint32_t *)0x40060538))
+#define GPIO_PORTJ_AHB_DR12R_R  (*((volatile uint32_t *)0x4006053C))
+#define GPIO_PORTJ_AHB_WAKEPEN_R                                              \
+                                (*((volatile uint32_t *)0x40060540))
+#define GPIO_PORTJ_AHB_WAKELVL_R                                              \
+                                (*((volatile uint32_t *)0x40060544))
+#define GPIO_PORTJ_AHB_WAKESTAT_R                                             \
+                                (*((volatile uint32_t *)0x40060548))
+#define GPIO_PORTJ_AHB_PP_R     (*((volatile uint32_t *)0x40060FC0))
+#define GPIO_PORTJ_AHB_PC_R     (*((volatile uint32_t *)0x40060FC4))
+#define GPIO_PCTL_PR_R          (*((volatile uint32_t *)0x00012000))
+#define GPIO_PCTL_PS_R          (*((volatile uint32_t *)0x00013000))
+#define GPIO_PCTL_PT_R          (*((volatile uint32_t *)0x00014000))
+
+//*****************************************************************************
+//
+// GPIO registers (PORTK)
+//
+//*****************************************************************************
+#define GPIO_PORTK_DATA_BITS_R  ((volatile uint32_t *)0x40061000)
+#define GPIO_PORTK_DATA_R       (*((volatile uint32_t *)0x400613FC))
+#define GPIO_PORTK_DIR_R        (*((volatile uint32_t *)0x40061400))
+#define GPIO_PORTK_IS_R         (*((volatile uint32_t *)0x40061404))
+#define GPIO_PORTK_IBE_R        (*((volatile uint32_t *)0x40061408))
+#define GPIO_PORTK_IEV_R        (*((volatile uint32_t *)0x4006140C))
+#define GPIO_PORTK_IM_R         (*((volatile uint32_t *)0x40061410))
+#define GPIO_PORTK_RIS_R        (*((volatile uint32_t *)0x40061414))
+#define GPIO_PORTK_MIS_R        (*((volatile uint32_t *)0x40061418))
+#define GPIO_PORTK_ICR_R        (*((volatile uint32_t *)0x4006141C))
+#define GPIO_PORTK_AFSEL_R      (*((volatile uint32_t *)0x40061420))
+#define GPIO_PORTK_DR2R_R       (*((volatile uint32_t *)0x40061500))
+#define GPIO_PORTK_DR4R_R       (*((volatile uint32_t *)0x40061504))
+#define GPIO_PORTK_DR8R_R       (*((volatile uint32_t *)0x40061508))
+#define GPIO_PORTK_ODR_R        (*((volatile uint32_t *)0x4006150C))
+#define GPIO_PORTK_PUR_R        (*((volatile uint32_t *)0x40061510))
+#define GPIO_PORTK_PDR_R        (*((volatile uint32_t *)0x40061514))
+#define GPIO_PORTK_SLR_R        (*((volatile uint32_t *)0x40061518))
+#define GPIO_PORTK_DEN_R        (*((volatile uint32_t *)0x4006151C))
+#define GPIO_PORTK_LOCK_R       (*((volatile uint32_t *)0x40061520))
+#define GPIO_PORTK_CR_R         (*((volatile uint32_t *)0x40061524))
+#define GPIO_PORTK_AMSEL_R      (*((volatile uint32_t *)0x40061528))
+#define GPIO_PORTK_PCTL_R       (*((volatile uint32_t *)0x4006152C))
+#define GPIO_PORTK_ADCCTL_R     (*((volatile uint32_t *)0x40061530))
+#define GPIO_PORTK_DMACTL_R     (*((volatile uint32_t *)0x40061534))
+#define GPIO_PORTK_SI_R         (*((volatile uint32_t *)0x40061538))
+#define GPIO_PORTK_DR12R_R      (*((volatile uint32_t *)0x4006153C))
+#define GPIO_PORTK_WAKEPEN_R    (*((volatile uint32_t *)0x40061540))
+#define GPIO_PORTK_WAKELVL_R    (*((volatile uint32_t *)0x40061544))
+#define GPIO_PORTK_WAKESTAT_R   (*((volatile uint32_t *)0x40061548))
+#define GPIO_PORTK_PP_R         (*((volatile uint32_t *)0x40061FC0))
+#define GPIO_PORTK_PC_R         (*((volatile uint32_t *)0x40061FC4))
+#define GPIO_PCTL_PR_R          (*((volatile uint32_t *)0x00012000))
+#define GPIO_PCTL_PS_R          (*((volatile uint32_t *)0x00013000))
+#define GPIO_PCTL_PT_R          (*((volatile uint32_t *)0x00014000))
+
+//*****************************************************************************
+//
+// GPIO registers (PORTL)
+//
+//*****************************************************************************
+#define GPIO_PORTL_DATA_BITS_R  ((volatile uint32_t *)0x40062000)
+#define GPIO_PORTL_DATA_R       (*((volatile uint32_t *)0x400623FC))
+#define GPIO_PORTL_DIR_R        (*((volatile uint32_t *)0x40062400))
+#define GPIO_PORTL_IS_R         (*((volatile uint32_t *)0x40062404))
+#define GPIO_PORTL_IBE_R        (*((volatile uint32_t *)0x40062408))
+#define GPIO_PORTL_IEV_R        (*((volatile uint32_t *)0x4006240C))
+#define GPIO_PORTL_IM_R         (*((volatile uint32_t *)0x40062410))
+#define GPIO_PORTL_RIS_R        (*((volatile uint32_t *)0x40062414))
+#define GPIO_PORTL_MIS_R        (*((volatile uint32_t *)0x40062418))
+#define GPIO_PORTL_ICR_R        (*((volatile uint32_t *)0x4006241C))
+#define GPIO_PORTL_AFSEL_R      (*((volatile uint32_t *)0x40062420))
+#define GPIO_PORTL_DR2R_R       (*((volatile uint32_t *)0x40062500))
+#define GPIO_PORTL_DR4R_R       (*((volatile uint32_t *)0x40062504))
+#define GPIO_PORTL_DR8R_R       (*((volatile uint32_t *)0x40062508))
+#define GPIO_PORTL_ODR_R        (*((volatile uint32_t *)0x4006250C))
+#define GPIO_PORTL_PUR_R        (*((volatile uint32_t *)0x40062510))
+#define GPIO_PORTL_PDR_R        (*((volatile uint32_t *)0x40062514))
+#define GPIO_PORTL_SLR_R        (*((volatile uint32_t *)0x40062518))
+#define GPIO_PORTL_DEN_R        (*((volatile uint32_t *)0x4006251C))
+#define GPIO_PORTL_LOCK_R       (*((volatile uint32_t *)0x40062520))
+#define GPIO_PORTL_CR_R         (*((volatile uint32_t *)0x40062524))
+#define GPIO_PORTL_AMSEL_R      (*((volatile uint32_t *)0x40062528))
+#define GPIO_PORTL_PCTL_R       (*((volatile uint32_t *)0x4006252C))
+#define GPIO_PORTL_ADCCTL_R     (*((volatile uint32_t *)0x40062530))
+#define GPIO_PORTL_DMACTL_R     (*((volatile uint32_t *)0x40062534))
+#define GPIO_PORTL_SI_R         (*((volatile uint32_t *)0x40062538))
+#define GPIO_PORTL_DR12R_R      (*((volatile uint32_t *)0x4006253C))
+#define GPIO_PORTL_WAKEPEN_R    (*((volatile uint32_t *)0x40062540))
+#define GPIO_PORTL_WAKELVL_R    (*((volatile uint32_t *)0x40062544))
+#define GPIO_PORTL_WAKESTAT_R   (*((volatile uint32_t *)0x40062548))
+#define GPIO_PORTL_PP_R         (*((volatile uint32_t *)0x40062FC0))
+#define GPIO_PORTL_PC_R         (*((volatile uint32_t *)0x40062FC4))
+#define GPIO_PCTL_PR_R          (*((volatile uint32_t *)0x00012000))
+#define GPIO_PCTL_PS_R          (*((volatile uint32_t *)0x00013000))
+#define GPIO_PCTL_PT_R          (*((volatile uint32_t *)0x00014000))
+
+//*****************************************************************************
+//
+// GPIO registers (PORTM)
+//
+//*****************************************************************************
+#define GPIO_PORTM_DATA_BITS_R  ((volatile uint32_t *)0x40063000)
+#define GPIO_PORTM_DATA_R       (*((volatile uint32_t *)0x400633FC))
+#define GPIO_PORTM_DIR_R        (*((volatile uint32_t *)0x40063400))
+#define GPIO_PORTM_IS_R         (*((volatile uint32_t *)0x40063404))
+#define GPIO_PORTM_IBE_R        (*((volatile uint32_t *)0x40063408))
+#define GPIO_PORTM_IEV_R        (*((volatile uint32_t *)0x4006340C))
+#define GPIO_PORTM_IM_R         (*((volatile uint32_t *)0x40063410))
+#define GPIO_PORTM_RIS_R        (*((volatile uint32_t *)0x40063414))
+#define GPIO_PORTM_MIS_R        (*((volatile uint32_t *)0x40063418))
+#define GPIO_PORTM_ICR_R        (*((volatile uint32_t *)0x4006341C))
+#define GPIO_PORTM_AFSEL_R      (*((volatile uint32_t *)0x40063420))
+#define GPIO_PORTM_DR2R_R       (*((volatile uint32_t *)0x40063500))
+#define GPIO_PORTM_DR4R_R       (*((volatile uint32_t *)0x40063504))
+#define GPIO_PORTM_DR8R_R       (*((volatile uint32_t *)0x40063508))
+#define GPIO_PORTM_ODR_R        (*((volatile uint32_t *)0x4006350C))
+#define GPIO_PORTM_PUR_R        (*((volatile uint32_t *)0x40063510))
+#define GPIO_PORTM_PDR_R        (*((volatile uint32_t *)0x40063514))
+#define GPIO_PORTM_SLR_R        (*((volatile uint32_t *)0x40063518))
+#define GPIO_PORTM_DEN_R        (*((volatile uint32_t *)0x4006351C))
+#define GPIO_PORTM_LOCK_R       (*((volatile uint32_t *)0x40063520))
+#define GPIO_PORTM_CR_R         (*((volatile uint32_t *)0x40063524))
+#define GPIO_PORTM_AMSEL_R      (*((volatile uint32_t *)0x40063528))
+#define GPIO_PORTM_PCTL_R       (*((volatile uint32_t *)0x4006352C))
+#define GPIO_PORTM_ADCCTL_R     (*((volatile uint32_t *)0x40063530))
+#define GPIO_PORTM_DMACTL_R     (*((volatile uint32_t *)0x40063534))
+#define GPIO_PORTM_SI_R         (*((volatile uint32_t *)0x40063538))
+#define GPIO_PORTM_DR12R_R      (*((volatile uint32_t *)0x4006353C))
+#define GPIO_PORTM_WAKEPEN_R    (*((volatile uint32_t *)0x40063540))
+#define GPIO_PORTM_WAKELVL_R    (*((volatile uint32_t *)0x40063544))
+#define GPIO_PORTM_WAKESTAT_R   (*((volatile uint32_t *)0x40063548))
+#define GPIO_PORTM_PP_R         (*((volatile uint32_t *)0x40063FC0))
+#define GPIO_PORTM_PC_R         (*((volatile uint32_t *)0x40063FC4))
+#define GPIO_PCTL_PR_R          (*((volatile uint32_t *)0x00012000))
+#define GPIO_PCTL_PS_R          (*((volatile uint32_t *)0x00013000))
+#define GPIO_PCTL_PT_R          (*((volatile uint32_t *)0x00014000))
+
+//*****************************************************************************
+//
+// GPIO registers (PORTN)
+//
+//*****************************************************************************
+#define GPIO_PORTN_DATA_BITS_R  ((volatile uint32_t *)0x40064000)
+#define GPIO_PORTN_DATA_R       (*((volatile uint32_t *)0x400643FC))
+#define GPIO_PORTN_DIR_R        (*((volatile uint32_t *)0x40064400))
+#define GPIO_PORTN_IS_R         (*((volatile uint32_t *)0x40064404))
+#define GPIO_PORTN_IBE_R        (*((volatile uint32_t *)0x40064408))
+#define GPIO_PORTN_IEV_R        (*((volatile uint32_t *)0x4006440C))
+#define GPIO_PORTN_IM_R         (*((volatile uint32_t *)0x40064410))
+#define GPIO_PORTN_RIS_R        (*((volatile uint32_t *)0x40064414))
+#define GPIO_PORTN_MIS_R        (*((volatile uint32_t *)0x40064418))
+#define GPIO_PORTN_ICR_R        (*((volatile uint32_t *)0x4006441C))
+#define GPIO_PORTN_AFSEL_R      (*((volatile uint32_t *)0x40064420))
+#define GPIO_PORTN_DR2R_R       (*((volatile uint32_t *)0x40064500))
+#define GPIO_PORTN_DR4R_R       (*((volatile uint32_t *)0x40064504))
+#define GPIO_PORTN_DR8R_R       (*((volatile uint32_t *)0x40064508))
+#define GPIO_PORTN_ODR_R        (*((volatile uint32_t *)0x4006450C))
+#define GPIO_PORTN_PUR_R        (*((volatile uint32_t *)0x40064510))
+#define GPIO_PORTN_PDR_R        (*((volatile uint32_t *)0x40064514))
+#define GPIO_PORTN_SLR_R        (*((volatile uint32_t *)0x40064518))
+#define GPIO_PORTN_DEN_R        (*((volatile uint32_t *)0x4006451C))
+#define GPIO_PORTN_LOCK_R       (*((volatile uint32_t *)0x40064520))
+#define GPIO_PORTN_CR_R         (*((volatile uint32_t *)0x40064524))
+#define GPIO_PORTN_AMSEL_R      (*((volatile uint32_t *)0x40064528))
+#define GPIO_PORTN_PCTL_R       (*((volatile uint32_t *)0x4006452C))
+#define GPIO_PORTN_ADCCTL_R     (*((volatile uint32_t *)0x40064530))
+#define GPIO_PORTN_DMACTL_R     (*((volatile uint32_t *)0x40064534))
+#define GPIO_PORTN_SI_R         (*((volatile uint32_t *)0x40064538))
+#define GPIO_PORTN_DR12R_R      (*((volatile uint32_t *)0x4006453C))
+#define GPIO_PORTN_WAKEPEN_R    (*((volatile uint32_t *)0x40064540))
+#define GPIO_PORTN_WAKELVL_R    (*((volatile uint32_t *)0x40064544))
+#define GPIO_PORTN_WAKESTAT_R   (*((volatile uint32_t *)0x40064548))
+#define GPIO_PORTN_PP_R         (*((volatile uint32_t *)0x40064FC0))
+#define GPIO_PORTN_PC_R         (*((volatile uint32_t *)0x40064FC4))
+#define GPIO_PCTL_PR_R          (*((volatile uint32_t *)0x00012000))
+#define GPIO_PCTL_PS_R          (*((volatile uint32_t *)0x00013000))
+#define GPIO_PCTL_PT_R          (*((volatile uint32_t *)0x00014000))
+
+//*****************************************************************************
+//
+// GPIO registers (PORTP)
+//
+//*****************************************************************************
+#define GPIO_PORTP_DATA_BITS_R  ((volatile uint32_t *)0x40065000)
+#define GPIO_PORTP_DATA_R       (*((volatile uint32_t *)0x400653FC))
+#define GPIO_PORTP_DIR_R        (*((volatile uint32_t *)0x40065400))
+#define GPIO_PORTP_IS_R         (*((volatile uint32_t *)0x40065404))
+#define GPIO_PORTP_IBE_R        (*((volatile uint32_t *)0x40065408))
+#define GPIO_PORTP_IEV_R        (*((volatile uint32_t *)0x4006540C))
+#define GPIO_PORTP_IM_R         (*((volatile uint32_t *)0x40065410))
+#define GPIO_PORTP_RIS_R        (*((volatile uint32_t *)0x40065414))
+#define GPIO_PORTP_MIS_R        (*((volatile uint32_t *)0x40065418))
+#define GPIO_PORTP_ICR_R        (*((volatile uint32_t *)0x4006541C))
+#define GPIO_PORTP_AFSEL_R      (*((volatile uint32_t *)0x40065420))
+#define GPIO_PORTP_DR2R_R       (*((volatile uint32_t *)0x40065500))
+#define GPIO_PORTP_DR4R_R       (*((volatile uint32_t *)0x40065504))
+#define GPIO_PORTP_DR8R_R       (*((volatile uint32_t *)0x40065508))
+#define GPIO_PORTP_ODR_R        (*((volatile uint32_t *)0x4006550C))
+#define GPIO_PORTP_PUR_R        (*((volatile uint32_t *)0x40065510))
+#define GPIO_PORTP_PDR_R        (*((volatile uint32_t *)0x40065514))
+#define GPIO_PORTP_SLR_R        (*((volatile uint32_t *)0x40065518))
+#define GPIO_PORTP_DEN_R        (*((volatile uint32_t *)0x4006551C))
+#define GPIO_PORTP_LOCK_R       (*((volatile uint32_t *)0x40065520))
+#define GPIO_PORTP_CR_R         (*((volatile uint32_t *)0x40065524))
+#define GPIO_PORTP_AMSEL_R      (*((volatile uint32_t *)0x40065528))
+#define GPIO_PORTP_PCTL_R       (*((volatile uint32_t *)0x4006552C))
+#define GPIO_PORTP_ADCCTL_R     (*((volatile uint32_t *)0x40065530))
+#define GPIO_PORTP_DMACTL_R     (*((volatile uint32_t *)0x40065534))
+#define GPIO_PORTP_SI_R         (*((volatile uint32_t *)0x40065538))
+#define GPIO_PORTP_DR12R_R      (*((volatile uint32_t *)0x4006553C))
+#define GPIO_PORTP_WAKEPEN_R    (*((volatile uint32_t *)0x40065540))
+#define GPIO_PORTP_WAKELVL_R    (*((volatile uint32_t *)0x40065544))
+#define GPIO_PORTP_WAKESTAT_R   (*((volatile uint32_t *)0x40065548))
+#define GPIO_PORTP_PP_R         (*((volatile uint32_t *)0x40065FC0))
+#define GPIO_PORTP_PC_R         (*((volatile uint32_t *)0x40065FC4))
+#define GPIO_PCTL_PR_R          (*((volatile uint32_t *)0x00012000))
+#define GPIO_PCTL_PS_R          (*((volatile uint32_t *)0x00013000))
+#define GPIO_PCTL_PT_R          (*((volatile uint32_t *)0x00014000))
+
+//*****************************************************************************
+//
+// GPIO registers (PORTQ)
+//
+//*****************************************************************************
+#define GPIO_PORTQ_DATA_BITS_R  ((volatile uint32_t *)0x40066000)
+#define GPIO_PORTQ_DATA_R       (*((volatile uint32_t *)0x400663FC))
+#define GPIO_PORTQ_DIR_R        (*((volatile uint32_t *)0x40066400))
+#define GPIO_PORTQ_IS_R         (*((volatile uint32_t *)0x40066404))
+#define GPIO_PORTQ_IBE_R        (*((volatile uint32_t *)0x40066408))
+#define GPIO_PORTQ_IEV_R        (*((volatile uint32_t *)0x4006640C))
+#define GPIO_PORTQ_IM_R         (*((volatile uint32_t *)0x40066410))
+#define GPIO_PORTQ_RIS_R        (*((volatile uint32_t *)0x40066414))
+#define GPIO_PORTQ_MIS_R        (*((volatile uint32_t *)0x40066418))
+#define GPIO_PORTQ_ICR_R        (*((volatile uint32_t *)0x4006641C))
+#define GPIO_PORTQ_AFSEL_R      (*((volatile uint32_t *)0x40066420))
+#define GPIO_PORTQ_DR2R_R       (*((volatile uint32_t *)0x40066500))
+#define GPIO_PORTQ_DR4R_R       (*((volatile uint32_t *)0x40066504))
+#define GPIO_PORTQ_DR8R_R       (*((volatile uint32_t *)0x40066508))
+#define GPIO_PORTQ_ODR_R        (*((volatile uint32_t *)0x4006650C))
+#define GPIO_PORTQ_PUR_R        (*((volatile uint32_t *)0x40066510))
+#define GPIO_PORTQ_PDR_R        (*((volatile uint32_t *)0x40066514))
+#define GPIO_PORTQ_SLR_R        (*((volatile uint32_t *)0x40066518))
+#define GPIO_PORTQ_DEN_R        (*((volatile uint32_t *)0x4006651C))
+#define GPIO_PORTQ_LOCK_R       (*((volatile uint32_t *)0x40066520))
+#define GPIO_PORTQ_CR_R         (*((volatile uint32_t *)0x40066524))
+#define GPIO_PORTQ_AMSEL_R      (*((volatile uint32_t *)0x40066528))
+#define GPIO_PORTQ_PCTL_R       (*((volatile uint32_t *)0x4006652C))
+#define GPIO_PORTQ_ADCCTL_R     (*((volatile uint32_t *)0x40066530))
+#define GPIO_PORTQ_DMACTL_R     (*((volatile uint32_t *)0x40066534))
+#define GPIO_PORTQ_SI_R         (*((volatile uint32_t *)0x40066538))
+#define GPIO_PORTQ_DR12R_R      (*((volatile uint32_t *)0x4006653C))
+#define GPIO_PORTQ_WAKEPEN_R    (*((volatile uint32_t *)0x40066540))
+#define GPIO_PORTQ_WAKELVL_R    (*((volatile uint32_t *)0x40066544))
+#define GPIO_PORTQ_WAKESTAT_R   (*((volatile uint32_t *)0x40066548))
+#define GPIO_PORTQ_PP_R         (*((volatile uint32_t *)0x40066FC0))
+#define GPIO_PORTQ_PC_R         (*((volatile uint32_t *)0x40066FC4))
+#define GPIO_PCTL_PR_R          (*((volatile uint32_t *)0x00012000))
+#define GPIO_PCTL_PS_R          (*((volatile uint32_t *)0x00013000))
+#define GPIO_PCTL_PT_R          (*((volatile uint32_t *)0x00014000))
+
+//*****************************************************************************
+//
+// GPIO registers (PORTR)
+//
+//*****************************************************************************
+#define GPIO_PORTR_DATA_BITS_R  ((volatile uint32_t *)0x40067000)
+#define GPIO_PORTR_DATA_R       (*((volatile uint32_t *)0x400673FC))
+#define GPIO_PORTR_DIR_R        (*((volatile uint32_t *)0x40067400))
+#define GPIO_PORTR_IS_R         (*((volatile uint32_t *)0x40067404))
+#define GPIO_PORTR_IBE_R        (*((volatile uint32_t *)0x40067408))
+#define GPIO_PORTR_IEV_R        (*((volatile uint32_t *)0x4006740C))
+#define GPIO_PORTR_IM_R         (*((volatile uint32_t *)0x40067410))
+#define GPIO_PORTR_RIS_R        (*((volatile uint32_t *)0x40067414))
+#define GPIO_PORTR_MIS_R        (*((volatile uint32_t *)0x40067418))
+#define GPIO_PORTR_ICR_R        (*((volatile uint32_t *)0x4006741C))
+#define GPIO_PORTR_AFSEL_R      (*((volatile uint32_t *)0x40067420))
+#define GPIO_PORTR_DR2R_R       (*((volatile uint32_t *)0x40067500))
+#define GPIO_PORTR_DR4R_R       (*((volatile uint32_t *)0x40067504))
+#define GPIO_PORTR_DR8R_R       (*((volatile uint32_t *)0x40067508))
+#define GPIO_PORTR_ODR_R        (*((volatile uint32_t *)0x4006750C))
+#define GPIO_PORTR_PUR_R        (*((volatile uint32_t *)0x40067510))
+#define GPIO_PORTR_PDR_R        (*((volatile uint32_t *)0x40067514))
+#define GPIO_PORTR_SLR_R        (*((volatile uint32_t *)0x40067518))
+#define GPIO_PORTR_DEN_R        (*((volatile uint32_t *)0x4006751C))
+#define GPIO_PORTR_LOCK_R       (*((volatile uint32_t *)0x40067520))
+#define GPIO_PORTR_CR_R         (*((volatile uint32_t *)0x40067524))
+#define GPIO_PORTR_AMSEL_R      (*((volatile uint32_t *)0x40067528))
+#define GPIO_PORTR_PCTL_R       (*((volatile uint32_t *)0x4006752C))
+#define GPIO_PORTR_ADCCTL_R     (*((volatile uint32_t *)0x40067530))
+#define GPIO_PORTR_DMACTL_R     (*((volatile uint32_t *)0x40067534))
+#define GPIO_PORTR_SI_R         (*((volatile uint32_t *)0x40067538))
+#define GPIO_PORTR_DR12R_R      (*((volatile uint32_t *)0x4006753C))
+#define GPIO_PORTR_WAKEPEN_R    (*((volatile uint32_t *)0x40067540))
+#define GPIO_PORTR_WAKELVL_R    (*((volatile uint32_t *)0x40067544))
+#define GPIO_PORTR_WAKESTAT_R   (*((volatile uint32_t *)0x40067548))
+#define GPIO_PORTR_PP_R         (*((volatile uint32_t *)0x40067FC0))
+#define GPIO_PORTR_PC_R         (*((volatile uint32_t *)0x40067FC4))
+#define GPIO_PCTL_PR_R          (*((volatile uint32_t *)0x00012000))
+#define GPIO_PCTL_PS_R          (*((volatile uint32_t *)0x00013000))
+#define GPIO_PCTL_PT_R          (*((volatile uint32_t *)0x00014000))
+
+//*****************************************************************************
+//
+// GPIO registers (PORTS)
+//
+//*****************************************************************************
+#define GPIO_PORTS_DATA_BITS_R  ((volatile uint32_t *)0x40068000)
+#define GPIO_PORTS_DATA_R       (*((volatile uint32_t *)0x400683FC))
+#define GPIO_PORTS_DIR_R        (*((volatile uint32_t *)0x40068400))
+#define GPIO_PORTS_IS_R         (*((volatile uint32_t *)0x40068404))
+#define GPIO_PORTS_IBE_R        (*((volatile uint32_t *)0x40068408))
+#define GPIO_PORTS_IEV_R        (*((volatile uint32_t *)0x4006840C))
+#define GPIO_PORTS_IM_R         (*((volatile uint32_t *)0x40068410))
+#define GPIO_PORTS_RIS_R        (*((volatile uint32_t *)0x40068414))
+#define GPIO_PORTS_MIS_R        (*((volatile uint32_t *)0x40068418))
+#define GPIO_PORTS_ICR_R        (*((volatile uint32_t *)0x4006841C))
+#define GPIO_PORTS_AFSEL_R      (*((volatile uint32_t *)0x40068420))
+#define GPIO_PORTS_DR2R_R       (*((volatile uint32_t *)0x40068500))
+#define GPIO_PORTS_DR4R_R       (*((volatile uint32_t *)0x40068504))
+#define GPIO_PORTS_DR8R_R       (*((volatile uint32_t *)0x40068508))
+#define GPIO_PORTS_ODR_R        (*((volatile uint32_t *)0x4006850C))
+#define GPIO_PORTS_PUR_R        (*((volatile uint32_t *)0x40068510))
+#define GPIO_PORTS_PDR_R        (*((volatile uint32_t *)0x40068514))
+#define GPIO_PORTS_SLR_R        (*((volatile uint32_t *)0x40068518))
+#define GPIO_PORTS_DEN_R        (*((volatile uint32_t *)0x4006851C))
+#define GPIO_PORTS_LOCK_R       (*((volatile uint32_t *)0x40068520))
+#define GPIO_PORTS_CR_R         (*((volatile uint32_t *)0x40068524))
+#define GPIO_PORTS_AMSEL_R      (*((volatile uint32_t *)0x40068528))
+#define GPIO_PORTS_PCTL_R       (*((volatile uint32_t *)0x4006852C))
+#define GPIO_PORTS_ADCCTL_R     (*((volatile uint32_t *)0x40068530))
+#define GPIO_PORTS_DMACTL_R     (*((volatile uint32_t *)0x40068534))
+#define GPIO_PORTS_SI_R         (*((volatile uint32_t *)0x40068538))
+#define GPIO_PORTS_DR12R_R      (*((volatile uint32_t *)0x4006853C))
+#define GPIO_PORTS_WAKEPEN_R    (*((volatile uint32_t *)0x40068540))
+#define GPIO_PORTS_WAKELVL_R    (*((volatile uint32_t *)0x40068544))
+#define GPIO_PORTS_WAKESTAT_R   (*((volatile uint32_t *)0x40068548))
+#define GPIO_PORTS_PP_R         (*((volatile uint32_t *)0x40068FC0))
+#define GPIO_PORTS_PC_R         (*((volatile uint32_t *)0x40068FC4))
+#define GPIO_PCTL_PR_R          (*((volatile uint32_t *)0x00012000))
+#define GPIO_PCTL_PS_R          (*((volatile uint32_t *)0x00013000))
+#define GPIO_PCTL_PT_R          (*((volatile uint32_t *)0x00014000))
+
+//*****************************************************************************
+//
+// GPIO registers (PORTT)
+//
+//*****************************************************************************
+#define GPIO_PORTT_DATA_BITS_R  ((volatile uint32_t *)0x40069000)
+#define GPIO_PORTT_DATA_R       (*((volatile uint32_t *)0x400693FC))
+#define GPIO_PORTT_DIR_R        (*((volatile uint32_t *)0x40069400))
+#define GPIO_PORTT_IS_R         (*((volatile uint32_t *)0x40069404))
+#define GPIO_PORTT_IBE_R        (*((volatile uint32_t *)0x40069408))
+#define GPIO_PORTT_IEV_R        (*((volatile uint32_t *)0x4006940C))
+#define GPIO_PORTT_IM_R         (*((volatile uint32_t *)0x40069410))
+#define GPIO_PORTT_RIS_R        (*((volatile uint32_t *)0x40069414))
+#define GPIO_PORTT_MIS_R        (*((volatile uint32_t *)0x40069418))
+#define GPIO_PORTT_ICR_R        (*((volatile uint32_t *)0x4006941C))
+#define GPIO_PORTT_AFSEL_R      (*((volatile uint32_t *)0x40069420))
+#define GPIO_PORTT_DR2R_R       (*((volatile uint32_t *)0x40069500))
+#define GPIO_PORTT_DR4R_R       (*((volatile uint32_t *)0x40069504))
+#define GPIO_PORTT_DR8R_R       (*((volatile uint32_t *)0x40069508))
+#define GPIO_PORTT_ODR_R        (*((volatile uint32_t *)0x4006950C))
+#define GPIO_PORTT_PUR_R        (*((volatile uint32_t *)0x40069510))
+#define GPIO_PORTT_PDR_R        (*((volatile uint32_t *)0x40069514))
+#define GPIO_PORTT_SLR_R        (*((volatile uint32_t *)0x40069518))
+#define GPIO_PORTT_DEN_R        (*((volatile uint32_t *)0x4006951C))
+#define GPIO_PORTT_LOCK_R       (*((volatile uint32_t *)0x40069520))
+#define GPIO_PORTT_CR_R         (*((volatile uint32_t *)0x40069524))
+#define GPIO_PORTT_AMSEL_R      (*((volatile uint32_t *)0x40069528))
+#define GPIO_PORTT_PCTL_R       (*((volatile uint32_t *)0x4006952C))
+#define GPIO_PORTT_ADCCTL_R     (*((volatile uint32_t *)0x40069530))
+#define GPIO_PORTT_DMACTL_R     (*((volatile uint32_t *)0x40069534))
+#define GPIO_PORTT_SI_R         (*((volatile uint32_t *)0x40069538))
+#define GPIO_PORTT_DR12R_R      (*((volatile uint32_t *)0x4006953C))
+#define GPIO_PORTT_WAKEPEN_R    (*((volatile uint32_t *)0x40069540))
+#define GPIO_PORTT_WAKELVL_R    (*((volatile uint32_t *)0x40069544))
+#define GPIO_PORTT_WAKESTAT_R   (*((volatile uint32_t *)0x40069548))
+#define GPIO_PORTT_PP_R         (*((volatile uint32_t *)0x40069FC0))
+#define GPIO_PORTT_PC_R         (*((volatile uint32_t *)0x40069FC4))
+#define GPIO_PCTL_PR_R          (*((volatile uint32_t *)0x00012000))
+#define GPIO_PCTL_PS_R          (*((volatile uint32_t *)0x00013000))
+#define GPIO_PCTL_PT_R          (*((volatile uint32_t *)0x00014000))
+
+//*****************************************************************************
+//
+// EEPROM registers (EEPROM)
+//
+//*****************************************************************************
+#define EEPROM_EESIZE_R         (*((volatile uint32_t *)0x400AF000))
+#define EEPROM_EEBLOCK_R        (*((volatile uint32_t *)0x400AF004))
+#define EEPROM_EEOFFSET_R       (*((volatile uint32_t *)0x400AF008))
+#define EEPROM_EERDWR_R         (*((volatile uint32_t *)0x400AF010))
+#define EEPROM_EERDWRINC_R      (*((volatile uint32_t *)0x400AF014))
+#define EEPROM_EEDONE_R         (*((volatile uint32_t *)0x400AF018))
+#define EEPROM_EESUPP_R         (*((volatile uint32_t *)0x400AF01C))
+#define EEPROM_EEUNLOCK_R       (*((volatile uint32_t *)0x400AF020))
+#define EEPROM_EEPROT_R         (*((volatile uint32_t *)0x400AF030))
+#define EEPROM_EEPASS0_R        (*((volatile uint32_t *)0x400AF034))
+#define EEPROM_EEPASS1_R        (*((volatile uint32_t *)0x400AF038))
+#define EEPROM_EEPASS2_R        (*((volatile uint32_t *)0x400AF03C))
+#define EEPROM_EEINT_R          (*((volatile uint32_t *)0x400AF040))
+#define EEPROM_EEHIDE0_R        (*((volatile uint32_t *)0x400AF050))
+#define EEPROM_EEHIDE1_R        (*((volatile uint32_t *)0x400AF054))
+#define EEPROM_EEHIDE2_R        (*((volatile uint32_t *)0x400AF058))
+#define EEPROM_EEDBGME_R        (*((volatile uint32_t *)0x400AF080))
+#define EEPROM_PP_R             (*((volatile uint32_t *)0x400AFFC0))
+
+//*****************************************************************************
+//
+// One wire registers (ONEWIRE0)
+//
+//*****************************************************************************
+#define ONEWIRE0_CS_R           (*((volatile uint32_t *)0x400B6000))
+#define ONEWIRE0_TIM_R          (*((volatile uint32_t *)0x400B6004))
+#define ONEWIRE0_DATW_R         (*((volatile uint32_t *)0x400B6008))
+#define ONEWIRE0_DATR_R         (*((volatile uint32_t *)0x400B600C))
+#define ONEWIRE0_IM_R           (*((volatile uint32_t *)0x400B6100))
+#define ONEWIRE0_RIS_R          (*((volatile uint32_t *)0x400B6104))
+#define ONEWIRE0_MIS_R          (*((volatile uint32_t *)0x400B6108))
+#define ONEWIRE0_ICR_R          (*((volatile uint32_t *)0x400B610C))
+#define ONEWIRE0_DMA_R          (*((volatile uint32_t *)0x400B6120))
+#define ONEWIRE0_PP_R           (*((volatile uint32_t *)0x400B6FC0))
+
+//*****************************************************************************
+//
+// I2C registers (I2C8)
+//
+//*****************************************************************************
+#define I2C8_MSA_R              (*((volatile uint32_t *)0x400B8000))
+#define I2C8_MCS_R              (*((volatile uint32_t *)0x400B8004))
+#define I2C8_MDR_R              (*((volatile uint32_t *)0x400B8008))
+#define I2C8_MTPR_R             (*((volatile uint32_t *)0x400B800C))
+#define I2C8_MIMR_R             (*((volatile uint32_t *)0x400B8010))
+#define I2C8_MRIS_R             (*((volatile uint32_t *)0x400B8014))
+#define I2C8_MMIS_R             (*((volatile uint32_t *)0x400B8018))
+#define I2C8_MICR_R             (*((volatile uint32_t *)0x400B801C))
+#define I2C8_MCR_R              (*((volatile uint32_t *)0x400B8020))
+#define I2C8_MCLKOCNT_R         (*((volatile uint32_t *)0x400B8024))
+#define I2C8_MBMON_R            (*((volatile uint32_t *)0x400B802C))
+#define I2C8_MBLEN_R            (*((volatile uint32_t *)0x400B8030))
+#define I2C8_MBCNT_R            (*((volatile uint32_t *)0x400B8034))
+#define I2C8_SOAR_R             (*((volatile uint32_t *)0x400B8800))
+#define I2C8_SCSR_R             (*((volatile uint32_t *)0x400B8804))
+#define I2C8_SDR_R              (*((volatile uint32_t *)0x400B8808))
+#define I2C8_SIMR_R             (*((volatile uint32_t *)0x400B880C))
+#define I2C8_SRIS_R             (*((volatile uint32_t *)0x400B8810))
+#define I2C8_SMIS_R             (*((volatile uint32_t *)0x400B8814))
+#define I2C8_SICR_R             (*((volatile uint32_t *)0x400B8818))
+#define I2C8_SOAR2_R            (*((volatile uint32_t *)0x400B881C))
+#define I2C8_SACKCTL_R          (*((volatile uint32_t *)0x400B8820))
+#define I2C8_FIFODATA_R         (*((volatile uint32_t *)0x400B8F00))
+#define I2C8_FIFOCTL_R          (*((volatile uint32_t *)0x400B8F04))
+#define I2C8_FIFOSTATUS_R       (*((volatile uint32_t *)0x400B8F08))
+#define I2C8_PP_R               (*((volatile uint32_t *)0x400B8FC0))
+#define I2C8_PC_R               (*((volatile uint32_t *)0x400B8FC4))
+
+//*****************************************************************************
+//
+// I2C registers (I2C9)
+//
+//*****************************************************************************
+#define I2C9_MSA_R              (*((volatile uint32_t *)0x400B9000))
+#define I2C9_MCS_R              (*((volatile uint32_t *)0x400B9004))
+#define I2C9_MDR_R              (*((volatile uint32_t *)0x400B9008))
+#define I2C9_MTPR_R             (*((volatile uint32_t *)0x400B900C))
+#define I2C9_MIMR_R             (*((volatile uint32_t *)0x400B9010))
+#define I2C9_MRIS_R             (*((volatile uint32_t *)0x400B9014))
+#define I2C9_MMIS_R             (*((volatile uint32_t *)0x400B9018))
+#define I2C9_MICR_R             (*((volatile uint32_t *)0x400B901C))
+#define I2C9_MCR_R              (*((volatile uint32_t *)0x400B9020))
+#define I2C9_MCLKOCNT_R         (*((volatile uint32_t *)0x400B9024))
+#define I2C9_MBMON_R            (*((volatile uint32_t *)0x400B902C))
+#define I2C9_MBLEN_R            (*((volatile uint32_t *)0x400B9030))
+#define I2C9_MBCNT_R            (*((volatile uint32_t *)0x400B9034))
+#define I2C9_SOAR_R             (*((volatile uint32_t *)0x400B9800))
+#define I2C9_SCSR_R             (*((volatile uint32_t *)0x400B9804))
+#define I2C9_SDR_R              (*((volatile uint32_t *)0x400B9808))
+#define I2C9_SIMR_R             (*((volatile uint32_t *)0x400B980C))
+#define I2C9_SRIS_R             (*((volatile uint32_t *)0x400B9810))
+#define I2C9_SMIS_R             (*((volatile uint32_t *)0x400B9814))
+#define I2C9_SICR_R             (*((volatile uint32_t *)0x400B9818))
+#define I2C9_SOAR2_R            (*((volatile uint32_t *)0x400B981C))
+#define I2C9_SACKCTL_R          (*((volatile uint32_t *)0x400B9820))
+#define I2C9_FIFODATA_R         (*((volatile uint32_t *)0x400B9F00))
+#define I2C9_FIFOCTL_R          (*((volatile uint32_t *)0x400B9F04))
+#define I2C9_FIFOSTATUS_R       (*((volatile uint32_t *)0x400B9F08))
+#define I2C9_PP_R               (*((volatile uint32_t *)0x400B9FC0))
+#define I2C9_PC_R               (*((volatile uint32_t *)0x400B9FC4))
+
+//*****************************************************************************
+//
+// I2C registers (I2C4)
+//
+//*****************************************************************************
+#define I2C4_MSA_R              (*((volatile uint32_t *)0x400C0000))
+#define I2C4_MCS_R              (*((volatile uint32_t *)0x400C0004))
+#define I2C4_MDR_R              (*((volatile uint32_t *)0x400C0008))
+#define I2C4_MTPR_R             (*((volatile uint32_t *)0x400C000C))
+#define I2C4_MIMR_R             (*((volatile uint32_t *)0x400C0010))
+#define I2C4_MRIS_R             (*((volatile uint32_t *)0x400C0014))
+#define I2C4_MMIS_R             (*((volatile uint32_t *)0x400C0018))
+#define I2C4_MICR_R             (*((volatile uint32_t *)0x400C001C))
+#define I2C4_MCR_R              (*((volatile uint32_t *)0x400C0020))
+#define I2C4_MCLKOCNT_R         (*((volatile uint32_t *)0x400C0024))
+#define I2C4_MBMON_R            (*((volatile uint32_t *)0x400C002C))
+#define I2C4_MBLEN_R            (*((volatile uint32_t *)0x400C0030))
+#define I2C4_MBCNT_R            (*((volatile uint32_t *)0x400C0034))
+#define I2C4_SOAR_R             (*((volatile uint32_t *)0x400C0800))
+#define I2C4_SCSR_R             (*((volatile uint32_t *)0x400C0804))
+#define I2C4_SDR_R              (*((volatile uint32_t *)0x400C0808))
+#define I2C4_SIMR_R             (*((volatile uint32_t *)0x400C080C))
+#define I2C4_SRIS_R             (*((volatile uint32_t *)0x400C0810))
+#define I2C4_SMIS_R             (*((volatile uint32_t *)0x400C0814))
+#define I2C4_SICR_R             (*((volatile uint32_t *)0x400C0818))
+#define I2C4_SOAR2_R            (*((volatile uint32_t *)0x400C081C))
+#define I2C4_SACKCTL_R          (*((volatile uint32_t *)0x400C0820))
+#define I2C4_FIFODATA_R         (*((volatile uint32_t *)0x400C0F00))
+#define I2C4_FIFOCTL_R          (*((volatile uint32_t *)0x400C0F04))
+#define I2C4_FIFOSTATUS_R       (*((volatile uint32_t *)0x400C0F08))
+#define I2C4_PP_R               (*((volatile uint32_t *)0x400C0FC0))
+#define I2C4_PC_R               (*((volatile uint32_t *)0x400C0FC4))
+
+//*****************************************************************************
+//
+// I2C registers (I2C5)
+//
+//*****************************************************************************
+#define I2C5_MSA_R              (*((volatile uint32_t *)0x400C1000))
+#define I2C5_MCS_R              (*((volatile uint32_t *)0x400C1004))
+#define I2C5_MDR_R              (*((volatile uint32_t *)0x400C1008))
+#define I2C5_MTPR_R             (*((volatile uint32_t *)0x400C100C))
+#define I2C5_MIMR_R             (*((volatile uint32_t *)0x400C1010))
+#define I2C5_MRIS_R             (*((volatile uint32_t *)0x400C1014))
+#define I2C5_MMIS_R             (*((volatile uint32_t *)0x400C1018))
+#define I2C5_MICR_R             (*((volatile uint32_t *)0x400C101C))
+#define I2C5_MCR_R              (*((volatile uint32_t *)0x400C1020))
+#define I2C5_MCLKOCNT_R         (*((volatile uint32_t *)0x400C1024))
+#define I2C5_MBMON_R            (*((volatile uint32_t *)0x400C102C))
+#define I2C5_MBLEN_R            (*((volatile uint32_t *)0x400C1030))
+#define I2C5_MBCNT_R            (*((volatile uint32_t *)0x400C1034))
+#define I2C5_SOAR_R             (*((volatile uint32_t *)0x400C1800))
+#define I2C5_SCSR_R             (*((volatile uint32_t *)0x400C1804))
+#define I2C5_SDR_R              (*((volatile uint32_t *)0x400C1808))
+#define I2C5_SIMR_R             (*((volatile uint32_t *)0x400C180C))
+#define I2C5_SRIS_R             (*((volatile uint32_t *)0x400C1810))
+#define I2C5_SMIS_R             (*((volatile uint32_t *)0x400C1814))
+#define I2C5_SICR_R             (*((volatile uint32_t *)0x400C1818))
+#define I2C5_SOAR2_R            (*((volatile uint32_t *)0x400C181C))
+#define I2C5_SACKCTL_R          (*((volatile uint32_t *)0x400C1820))
+#define I2C5_FIFODATA_R         (*((volatile uint32_t *)0x400C1F00))
+#define I2C5_FIFOCTL_R          (*((volatile uint32_t *)0x400C1F04))
+#define I2C5_FIFOSTATUS_R       (*((volatile uint32_t *)0x400C1F08))
+#define I2C5_PP_R               (*((volatile uint32_t *)0x400C1FC0))
+#define I2C5_PC_R               (*((volatile uint32_t *)0x400C1FC4))
+
+//*****************************************************************************
+//
+// I2C registers (I2C6)
+//
+//*****************************************************************************
+#define I2C6_MSA_R              (*((volatile uint32_t *)0x400C2000))
+#define I2C6_MCS_R              (*((volatile uint32_t *)0x400C2004))
+#define I2C6_MDR_R              (*((volatile uint32_t *)0x400C2008))
+#define I2C6_MTPR_R             (*((volatile uint32_t *)0x400C200C))
+#define I2C6_MIMR_R             (*((volatile uint32_t *)0x400C2010))
+#define I2C6_MRIS_R             (*((volatile uint32_t *)0x400C2014))
+#define I2C6_MMIS_R             (*((volatile uint32_t *)0x400C2018))
+#define I2C6_MICR_R             (*((volatile uint32_t *)0x400C201C))
+#define I2C6_MCR_R              (*((volatile uint32_t *)0x400C2020))
+#define I2C6_MCLKOCNT_R         (*((volatile uint32_t *)0x400C2024))
+#define I2C6_MBMON_R            (*((volatile uint32_t *)0x400C202C))
+#define I2C6_MBLEN_R            (*((volatile uint32_t *)0x400C2030))
+#define I2C6_MBCNT_R            (*((volatile uint32_t *)0x400C2034))
+#define I2C6_SOAR_R             (*((volatile uint32_t *)0x400C2800))
+#define I2C6_SCSR_R             (*((volatile uint32_t *)0x400C2804))
+#define I2C6_SDR_R              (*((volatile uint32_t *)0x400C2808))
+#define I2C6_SIMR_R             (*((volatile uint32_t *)0x400C280C))
+#define I2C6_SRIS_R             (*((volatile uint32_t *)0x400C2810))
+#define I2C6_SMIS_R             (*((volatile uint32_t *)0x400C2814))
+#define I2C6_SICR_R             (*((volatile uint32_t *)0x400C2818))
+#define I2C6_SOAR2_R            (*((volatile uint32_t *)0x400C281C))
+#define I2C6_SACKCTL_R          (*((volatile uint32_t *)0x400C2820))
+#define I2C6_FIFODATA_R         (*((volatile uint32_t *)0x400C2F00))
+#define I2C6_FIFOCTL_R          (*((volatile uint32_t *)0x400C2F04))
+#define I2C6_FIFOSTATUS_R       (*((volatile uint32_t *)0x400C2F08))
+#define I2C6_PP_R               (*((volatile uint32_t *)0x400C2FC0))
+#define I2C6_PC_R               (*((volatile uint32_t *)0x400C2FC4))
+
+//*****************************************************************************
+//
+// I2C registers (I2C7)
+//
+//*****************************************************************************
+#define I2C7_MSA_R              (*((volatile uint32_t *)0x400C3000))
+#define I2C7_MCS_R              (*((volatile uint32_t *)0x400C3004))
+#define I2C7_MDR_R              (*((volatile uint32_t *)0x400C3008))
+#define I2C7_MTPR_R             (*((volatile uint32_t *)0x400C300C))
+#define I2C7_MIMR_R             (*((volatile uint32_t *)0x400C3010))
+#define I2C7_MRIS_R             (*((volatile uint32_t *)0x400C3014))
+#define I2C7_MMIS_R             (*((volatile uint32_t *)0x400C3018))
+#define I2C7_MICR_R             (*((volatile uint32_t *)0x400C301C))
+#define I2C7_MCR_R              (*((volatile uint32_t *)0x400C3020))
+#define I2C7_MCLKOCNT_R         (*((volatile uint32_t *)0x400C3024))
+#define I2C7_MBMON_R            (*((volatile uint32_t *)0x400C302C))
+#define I2C7_MBLEN_R            (*((volatile uint32_t *)0x400C3030))
+#define I2C7_MBCNT_R            (*((volatile uint32_t *)0x400C3034))
+#define I2C7_SOAR_R             (*((volatile uint32_t *)0x400C3800))
+#define I2C7_SCSR_R             (*((volatile uint32_t *)0x400C3804))
+#define I2C7_SDR_R              (*((volatile uint32_t *)0x400C3808))
+#define I2C7_SIMR_R             (*((volatile uint32_t *)0x400C380C))
+#define I2C7_SRIS_R             (*((volatile uint32_t *)0x400C3810))
+#define I2C7_SMIS_R             (*((volatile uint32_t *)0x400C3814))
+#define I2C7_SICR_R             (*((volatile uint32_t *)0x400C3818))
+#define I2C7_SOAR2_R            (*((volatile uint32_t *)0x400C381C))
+#define I2C7_SACKCTL_R          (*((volatile uint32_t *)0x400C3820))
+#define I2C7_FIFODATA_R         (*((volatile uint32_t *)0x400C3F00))
+#define I2C7_FIFOCTL_R          (*((volatile uint32_t *)0x400C3F04))
+#define I2C7_FIFOSTATUS_R       (*((volatile uint32_t *)0x400C3F08))
+#define I2C7_PP_R               (*((volatile uint32_t *)0x400C3FC0))
+#define I2C7_PC_R               (*((volatile uint32_t *)0x400C3FC4))
+
+//*****************************************************************************
+//
+// External Peripheral Interface registers (EPI0)
+//
+//*****************************************************************************
+#define EPI0_CFG_R              (*((volatile uint32_t *)0x400D0000))
+#define EPI0_BAUD_R             (*((volatile uint32_t *)0x400D0004))
+#define EPI0_BAUD2_R            (*((volatile uint32_t *)0x400D0008))
+#define EPI0_HB16CFG_R          (*((volatile uint32_t *)0x400D0010))
+#define EPI0_GPCFG_R            (*((volatile uint32_t *)0x400D0010))
+#define EPI0_SDRAMCFG_R         (*((volatile uint32_t *)0x400D0010))
+#define EPI0_HB8CFG_R           (*((volatile uint32_t *)0x400D0010))
+#define EPI0_HB8CFG2_R          (*((volatile uint32_t *)0x400D0014))
+#define EPI0_HB16CFG2_R         (*((volatile uint32_t *)0x400D0014))
+#define EPI0_ADDRMAP_R          (*((volatile uint32_t *)0x400D001C))
+#define EPI0_RSIZE0_R           (*((volatile uint32_t *)0x400D0020))
+#define EPI0_RADDR0_R           (*((volatile uint32_t *)0x400D0024))
+#define EPI0_RPSTD0_R           (*((volatile uint32_t *)0x400D0028))
+#define EPI0_RSIZE1_R           (*((volatile uint32_t *)0x400D0030))
+#define EPI0_RADDR1_R           (*((volatile uint32_t *)0x400D0034))
+#define EPI0_RPSTD1_R           (*((volatile uint32_t *)0x400D0038))
+#define EPI0_STAT_R             (*((volatile uint32_t *)0x400D0060))
+#define EPI0_RFIFOCNT_R         (*((volatile uint32_t *)0x400D006C))
+#define EPI0_READFIFO0_R        (*((volatile uint32_t *)0x400D0070))
+#define EPI0_READFIFO1_R        (*((volatile uint32_t *)0x400D0074))
+#define EPI0_READFIFO2_R        (*((volatile uint32_t *)0x400D0078))
+#define EPI0_READFIFO3_R        (*((volatile uint32_t *)0x400D007C))
+#define EPI0_READFIFO4_R        (*((volatile uint32_t *)0x400D0080))
+#define EPI0_READFIFO5_R        (*((volatile uint32_t *)0x400D0084))
+#define EPI0_READFIFO6_R        (*((volatile uint32_t *)0x400D0088))
+#define EPI0_READFIFO7_R        (*((volatile uint32_t *)0x400D008C))
+#define EPI0_FIFOLVL_R          (*((volatile uint32_t *)0x400D0200))
+#define EPI0_WFIFOCNT_R         (*((volatile uint32_t *)0x400D0204))
+#define EPI0_DMATXCNT_R         (*((volatile uint32_t *)0x400D0208))
+#define EPI0_IM_R               (*((volatile uint32_t *)0x400D0210))
+#define EPI0_RIS_R              (*((volatile uint32_t *)0x400D0214))
+#define EPI0_MIS_R              (*((volatile uint32_t *)0x400D0218))
+#define EPI0_EISC_R             (*((volatile uint32_t *)0x400D021C))
+#define EPI0_HB8CFG3_R          (*((volatile uint32_t *)0x400D0308))
+#define EPI0_HB16CFG3_R         (*((volatile uint32_t *)0x400D0308))
+#define EPI0_HB16CFG4_R         (*((volatile uint32_t *)0x400D030C))
+#define EPI0_HB8CFG4_R          (*((volatile uint32_t *)0x400D030C))
+#define EPI0_HB8TIME_R          (*((volatile uint32_t *)0x400D0310))
+#define EPI0_HB16TIME_R         (*((volatile uint32_t *)0x400D0310))
+#define EPI0_HB8TIME2_R         (*((volatile uint32_t *)0x400D0314))
+#define EPI0_HB16TIME2_R        (*((volatile uint32_t *)0x400D0314))
+#define EPI0_HB16TIME3_R        (*((volatile uint32_t *)0x400D0318))
+#define EPI0_HB8TIME3_R         (*((volatile uint32_t *)0x400D0318))
+#define EPI0_HB8TIME4_R         (*((volatile uint32_t *)0x400D031C))
+#define EPI0_HB16TIME4_R        (*((volatile uint32_t *)0x400D031C))
+#define EPI0_HBPSRAM_R          (*((volatile uint32_t *)0x400D0360))
+
+//*****************************************************************************
+//
+// Timer registers (TIMER6)
+//
+//*****************************************************************************
+#define TIMER6_CFG_R            (*((volatile uint32_t *)0x400E0000))
+#define TIMER6_TAMR_R           (*((volatile uint32_t *)0x400E0004))
+#define TIMER6_TBMR_R           (*((volatile uint32_t *)0x400E0008))
+#define TIMER6_CTL_R            (*((volatile uint32_t *)0x400E000C))
+#define TIMER6_SYNC_R           (*((volatile uint32_t *)0x400E0010))
+#define TIMER6_IMR_R            (*((volatile uint32_t *)0x400E0018))
+#define TIMER6_RIS_R            (*((volatile uint32_t *)0x400E001C))
+#define TIMER6_MIS_R            (*((volatile uint32_t *)0x400E0020))
+#define TIMER6_ICR_R            (*((volatile uint32_t *)0x400E0024))
+#define TIMER6_TAILR_R          (*((volatile uint32_t *)0x400E0028))
+#define TIMER6_TBILR_R          (*((volatile uint32_t *)0x400E002C))
+#define TIMER6_TAMATCHR_R       (*((volatile uint32_t *)0x400E0030))
+#define TIMER6_TBMATCHR_R       (*((volatile uint32_t *)0x400E0034))
+#define TIMER6_TAPR_R           (*((volatile uint32_t *)0x400E0038))
+#define TIMER6_TBPR_R           (*((volatile uint32_t *)0x400E003C))
+#define TIMER6_TAPMR_R          (*((volatile uint32_t *)0x400E0040))
+#define TIMER6_TBPMR_R          (*((volatile uint32_t *)0x400E0044))
+#define TIMER6_TAR_R            (*((volatile uint32_t *)0x400E0048))
+#define TIMER6_TBR_R            (*((volatile uint32_t *)0x400E004C))
+#define TIMER6_TAV_R            (*((volatile uint32_t *)0x400E0050))
+#define TIMER6_TBV_R            (*((volatile uint32_t *)0x400E0054))
+#define TIMER6_RTCPD_R          (*((volatile uint32_t *)0x400E0058))
+#define TIMER6_TAPS_R           (*((volatile uint32_t *)0x400E005C))
+#define TIMER6_TBPS_R           (*((volatile uint32_t *)0x400E0060))
+#define TIMER6_DMAEV_R          (*((volatile uint32_t *)0x400E006C))
+#define TIMER6_ADCEV_R          (*((volatile uint32_t *)0x400E0070))
+#define TIMER6_PP_R             (*((volatile uint32_t *)0x400E0FC0))
+#define TIMER6_CC_R             (*((volatile uint32_t *)0x400E0FC8))
+
+//*****************************************************************************
+//
+// Timer registers (TIMER7)
+//
+//*****************************************************************************
+#define TIMER7_CFG_R            (*((volatile uint32_t *)0x400E1000))
+#define TIMER7_TAMR_R           (*((volatile uint32_t *)0x400E1004))
+#define TIMER7_TBMR_R           (*((volatile uint32_t *)0x400E1008))
+#define TIMER7_CTL_R            (*((volatile uint32_t *)0x400E100C))
+#define TIMER7_SYNC_R           (*((volatile uint32_t *)0x400E1010))
+#define TIMER7_IMR_R            (*((volatile uint32_t *)0x400E1018))
+#define TIMER7_RIS_R            (*((volatile uint32_t *)0x400E101C))
+#define TIMER7_MIS_R            (*((volatile uint32_t *)0x400E1020))
+#define TIMER7_ICR_R            (*((volatile uint32_t *)0x400E1024))
+#define TIMER7_TAILR_R          (*((volatile uint32_t *)0x400E1028))
+#define TIMER7_TBILR_R          (*((volatile uint32_t *)0x400E102C))
+#define TIMER7_TAMATCHR_R       (*((volatile uint32_t *)0x400E1030))
+#define TIMER7_TBMATCHR_R       (*((volatile uint32_t *)0x400E1034))
+#define TIMER7_TAPR_R           (*((volatile uint32_t *)0x400E1038))
+#define TIMER7_TBPR_R           (*((volatile uint32_t *)0x400E103C))
+#define TIMER7_TAPMR_R          (*((volatile uint32_t *)0x400E1040))
+#define TIMER7_TBPMR_R          (*((volatile uint32_t *)0x400E1044))
+#define TIMER7_TAR_R            (*((volatile uint32_t *)0x400E1048))
+#define TIMER7_TBR_R            (*((volatile uint32_t *)0x400E104C))
+#define TIMER7_TAV_R            (*((volatile uint32_t *)0x400E1050))
+#define TIMER7_TBV_R            (*((volatile uint32_t *)0x400E1054))
+#define TIMER7_RTCPD_R          (*((volatile uint32_t *)0x400E1058))
+#define TIMER7_TAPS_R           (*((volatile uint32_t *)0x400E105C))
+#define TIMER7_TBPS_R           (*((volatile uint32_t *)0x400E1060))
+#define TIMER7_DMAEV_R          (*((volatile uint32_t *)0x400E106C))
+#define TIMER7_ADCEV_R          (*((volatile uint32_t *)0x400E1070))
+#define TIMER7_PP_R             (*((volatile uint32_t *)0x400E1FC0))
+#define TIMER7_CC_R             (*((volatile uint32_t *)0x400E1FC8))
+
+//*****************************************************************************
+//
+// EMAC registers (EMAC0)
+//
+//*****************************************************************************
+#define EMAC0_CFG_R             (*((volatile uint32_t *)0x400EC000))
+#define EMAC0_FRAMEFLTR_R       (*((volatile uint32_t *)0x400EC004))
+#define EMAC0_HASHTBLH_R        (*((volatile uint32_t *)0x400EC008))
+#define EMAC0_HASHTBLL_R        (*((volatile uint32_t *)0x400EC00C))
+#define EMAC0_MIIADDR_R         (*((volatile uint32_t *)0x400EC010))
+#define EMAC0_MIIDATA_R         (*((volatile uint32_t *)0x400EC014))
+#define EMAC0_FLOWCTL_R         (*((volatile uint32_t *)0x400EC018))
+#define EMAC0_VLANTG_R          (*((volatile uint32_t *)0x400EC01C))
+#define EMAC0_STATUS_R          (*((volatile uint32_t *)0x400EC024))
+#define EMAC0_RWUFF_R           (*((volatile uint32_t *)0x400EC028))
+#define EMAC0_PMTCTLSTAT_R      (*((volatile uint32_t *)0x400EC02C))
+#define EMAC0_RIS_R             (*((volatile uint32_t *)0x400EC038))
+#define EMAC0_IM_R              (*((volatile uint32_t *)0x400EC03C))
+#define EMAC0_ADDR0H_R          (*((volatile uint32_t *)0x400EC040))
+#define EMAC0_ADDR0L_R          (*((volatile uint32_t *)0x400EC044))
+#define EMAC0_ADDR1H_R          (*((volatile uint32_t *)0x400EC048))
+#define EMAC0_ADDR1L_R          (*((volatile uint32_t *)0x400EC04C))
+#define EMAC0_ADDR2H_R          (*((volatile uint32_t *)0x400EC050))
+#define EMAC0_ADDR2L_R          (*((volatile uint32_t *)0x400EC054))
+#define EMAC0_ADDR3H_R          (*((volatile uint32_t *)0x400EC058))
+#define EMAC0_ADDR3L_R          (*((volatile uint32_t *)0x400EC05C))
+#define EMAC0_WDOGTO_R          (*((volatile uint32_t *)0x400EC0DC))
+#define EMAC0_MMCCTRL_R         (*((volatile uint32_t *)0x400EC100))
+#define EMAC0_MMCRXRIS_R        (*((volatile uint32_t *)0x400EC104))
+#define EMAC0_MMCTXRIS_R        (*((volatile uint32_t *)0x400EC108))
+#define EMAC0_MMCRXIM_R         (*((volatile uint32_t *)0x400EC10C))
+#define EMAC0_MMCTXIM_R         (*((volatile uint32_t *)0x400EC110))
+#define EMAC0_TXCNTGB_R         (*((volatile uint32_t *)0x400EC118))
+#define EMAC0_TXCNTSCOL_R       (*((volatile uint32_t *)0x400EC14C))
+#define EMAC0_TXCNTMCOL_R       (*((volatile uint32_t *)0x400EC150))
+#define EMAC0_TXOCTCNTG_R       (*((volatile uint32_t *)0x400EC164))
+#define EMAC0_RXCNTGB_R         (*((volatile uint32_t *)0x400EC180))
+#define EMAC0_RXCNTCRCERR_R     (*((volatile uint32_t *)0x400EC194))
+#define EMAC0_RXCNTALGNERR_R    (*((volatile uint32_t *)0x400EC198))
+#define EMAC0_RXCNTGUNI_R       (*((volatile uint32_t *)0x400EC1C4))
+#define EMAC0_VLNINCREP_R       (*((volatile uint32_t *)0x400EC584))
+#define EMAC0_VLANHASH_R        (*((volatile uint32_t *)0x400EC588))
+#define EMAC0_TIMSTCTRL_R       (*((volatile uint32_t *)0x400EC700))
+#define EMAC0_SUBSECINC_R       (*((volatile uint32_t *)0x400EC704))
+#define EMAC0_TIMSEC_R          (*((volatile uint32_t *)0x400EC708))
+#define EMAC0_TIMNANO_R         (*((volatile uint32_t *)0x400EC70C))
+#define EMAC0_TIMSECU_R         (*((volatile uint32_t *)0x400EC710))
+#define EMAC0_TIMNANOU_R        (*((volatile uint32_t *)0x400EC714))
+#define EMAC0_TIMADD_R          (*((volatile uint32_t *)0x400EC718))
+#define EMAC0_TARGSEC_R         (*((volatile uint32_t *)0x400EC71C))
+#define EMAC0_TARGNANO_R        (*((volatile uint32_t *)0x400EC720))
+#define EMAC0_HWORDSEC_R        (*((volatile uint32_t *)0x400EC724))
+#define EMAC0_TIMSTAT_R         (*((volatile uint32_t *)0x400EC728))
+#define EMAC0_PPSCTRL_R         (*((volatile uint32_t *)0x400EC72C))
+#define EMAC0_PPS0INTVL_R       (*((volatile uint32_t *)0x400EC760))
+#define EMAC0_PPS0WIDTH_R       (*((volatile uint32_t *)0x400EC764))
+#define EMAC0_DMABUSMOD_R       (*((volatile uint32_t *)0x400ECC00))
+#define EMAC0_TXPOLLD_R         (*((volatile uint32_t *)0x400ECC04))
+#define EMAC0_RXPOLLD_R         (*((volatile uint32_t *)0x400ECC08))
+#define EMAC0_RXDLADDR_R        (*((volatile uint32_t *)0x400ECC0C))
+#define EMAC0_TXDLADDR_R        (*((volatile uint32_t *)0x400ECC10))
+#define EMAC0_DMARIS_R          (*((volatile uint32_t *)0x400ECC14))
+#define EMAC0_DMAOPMODE_R       (*((volatile uint32_t *)0x400ECC18))
+#define EMAC0_DMAIM_R           (*((volatile uint32_t *)0x400ECC1C))
+#define EMAC0_MFBOC_R           (*((volatile uint32_t *)0x400ECC20))
+#define EMAC0_RXINTWDT_R        (*((volatile uint32_t *)0x400ECC24))
+#define EMAC0_HOSTXDESC_R       (*((volatile uint32_t *)0x400ECC48))
+#define EMAC0_HOSRXDESC_R       (*((volatile uint32_t *)0x400ECC4C))
+#define EMAC0_HOSTXBA_R         (*((volatile uint32_t *)0x400ECC50))
+#define EMAC0_HOSRXBA_R         (*((volatile uint32_t *)0x400ECC54))
+#define EMAC0_PP_R              (*((volatile uint32_t *)0x400ECFC0))
+#define EMAC0_PC_R              (*((volatile uint32_t *)0x400ECFC4))
+#define EMAC0_CC_R              (*((volatile uint32_t *)0x400ECFC8))
+#define EMAC0_EPHYRIS_R         (*((volatile uint32_t *)0x400ECFD0))
+#define EMAC0_EPHYIM_R          (*((volatile uint32_t *)0x400ECFD4))
+#define EMAC0_EPHYMISC_R        (*((volatile uint32_t *)0x400ECFD8))
+
+//*****************************************************************************
+//
+// EPHY registers (EMAC0)
+//
+//*****************************************************************************
+#define EPHY_BMCR               0x00000000  // Ethernet PHY Basic Mode Control
+#define EPHY_BMSR               0x00000001  // Ethernet PHY Basic Mode Status
+#define EPHY_ID1                0x00000002  // Ethernet PHY Identifier Register
+                                            // 1
+#define EPHY_ID2                0x00000003  // Ethernet PHY Identifier Register
+                                            // 2
+#define EPHY_ANA                0x00000004  // Ethernet PHY Auto-Negotiation
+                                            // Advertisement
+#define EPHY_ANLPA              0x00000005  // Ethernet PHY Auto-Negotiation
+                                            // Link Partner Ability
+#define EPHY_ANER               0x00000006  // Ethernet PHY Auto-Negotiation
+                                            // Expansion
+#define EPHY_ANNPTR             0x00000007  // Ethernet PHY Auto-Negotiation
+                                            // Next Page TX
+#define EPHY_ANLNPTR            0x00000008  // Ethernet PHY Auto-Negotiation
+                                            // Link Partner Ability Next Page
+#define EPHY_CFG1               0x00000009  // Ethernet PHY Configuration 1
+#define EPHY_CFG2               0x0000000A  // Ethernet PHY Configuration 2
+#define EPHY_CFG3               0x0000000B  // Ethernet PHY Configuration 3
+#define EPHY_REGCTL             0x0000000D  // Ethernet PHY Register Control
+#define EPHY_ADDAR              0x0000000E  // Ethernet PHY Address or Data
+#define EPHY_STS                0x00000010  // Ethernet PHY Status
+#define EPHY_SCR                0x00000011  // Ethernet PHY Specific Control
+#define EPHY_MISR1              0x00000012  // Ethernet PHY MII Interrupt
+                                            // Status 1
+#define EPHY_MISR2              0x00000013  // Ethernet PHY MII Interrupt
+                                            // Status 2
+#define EPHY_FCSCR              0x00000014  // Ethernet PHY False Carrier Sense
+                                            // Counter
+#define EPHY_RXERCNT            0x00000015  // Ethernet PHY Receive Error Count
+#define EPHY_BISTCR             0x00000016  // Ethernet PHY BIST Control
+#define EPHY_LEDCR              0x00000018  // Ethernet PHY LED Control
+#define EPHY_CTL                0x00000019  // Ethernet PHY Control
+#define EPHY_10BTSC             0x0000001A  // Ethernet PHY 10Base-T
+                                            // Status/Control - MR26
+#define EPHY_BICSR1             0x0000001B  // Ethernet PHY BIST Control and
+                                            // Status 1
+#define EPHY_BICSR2             0x0000001C  // Ethernet PHY BIST Control and
+                                            // Status 2
+#define EPHY_CDCR               0x0000001E  // Ethernet PHY Cable Diagnostic
+                                            // Control
+#define EPHY_RCR                0x0000001F  // Ethernet PHY Reset Control
+#define EPHY_LEDCFG             0x00000025  // Ethernet PHY LED Configuration
+
+//*****************************************************************************
+//
+// System Exception Module registers (SYSEXC)
+//
+//*****************************************************************************
+#define SYSEXC_RIS_R            (*((volatile uint32_t *)0x400F9000))
+#define SYSEXC_IM_R             (*((volatile uint32_t *)0x400F9004))
+#define SYSEXC_MIS_R            (*((volatile uint32_t *)0x400F9008))
+#define SYSEXC_IC_R             (*((volatile uint32_t *)0x400F900C))
+
+//*****************************************************************************
+//
+// Hibernation module registers (HIB)
+//
+//*****************************************************************************
+#define HIB_RTCC_R              (*((volatile uint32_t *)0x400FC000))
+#define HIB_RTCM0_R             (*((volatile uint32_t *)0x400FC004))
+#define HIB_RTCLD_R             (*((volatile uint32_t *)0x400FC00C))
+#define HIB_CTL_R               (*((volatile uint32_t *)0x400FC010))
+#define HIB_IM_R                (*((volatile uint32_t *)0x400FC014))
+#define HIB_RIS_R               (*((volatile uint32_t *)0x400FC018))
+#define HIB_MIS_R               (*((volatile uint32_t *)0x400FC01C))
+#define HIB_IC_R                (*((volatile uint32_t *)0x400FC020))
+#define HIB_RTCT_R              (*((volatile uint32_t *)0x400FC024))
+#define HIB_RTCSS_R             (*((volatile uint32_t *)0x400FC028))
+#define HIB_IO_R                (*((volatile uint32_t *)0x400FC02C))
+#define HIB_DATA_R              (*((volatile uint32_t *)0x400FC030))
+#define HIB_CALCTL_R            (*((volatile uint32_t *)0x400FC300))
+#define HIB_CAL0_R              (*((volatile uint32_t *)0x400FC310))
+#define HIB_CAL1_R              (*((volatile uint32_t *)0x400FC314))
+#define HIB_CALLD0_R            (*((volatile uint32_t *)0x400FC320))
+#define HIB_CALLD1_R            (*((volatile uint32_t *)0x400FC324))
+#define HIB_CALM0_R             (*((volatile uint32_t *)0x400FC330))
+#define HIB_CALM1_R             (*((volatile uint32_t *)0x400FC334))
+#define HIB_LOCK_R              (*((volatile uint32_t *)0x400FC360))
+#define HIB_TPCTL_R             (*((volatile uint32_t *)0x400FC400))
+#define HIB_TPSTAT_R            (*((volatile uint32_t *)0x400FC404))
+#define HIB_TPIO_R              (*((volatile uint32_t *)0x400FC410))
+#define HIB_TPLOG0_R            (*((volatile uint32_t *)0x400FC4E0))
+#define HIB_TPLOG1_R            (*((volatile uint32_t *)0x400FC4E4))
+#define HIB_TPLOG2_R            (*((volatile uint32_t *)0x400FC4E8))
+#define HIB_TPLOG3_R            (*((volatile uint32_t *)0x400FC4EC))
+#define HIB_TPLOG4_R            (*((volatile uint32_t *)0x400FC4F0))
+#define HIB_TPLOG5_R            (*((volatile uint32_t *)0x400FC4F4))
+#define HIB_TPLOG6_R            (*((volatile uint32_t *)0x400FC4F8))
+#define HIB_TPLOG7_R            (*((volatile uint32_t *)0x400FC4FC))
+#define HIB_PP_R                (*((volatile uint32_t *)0x400FCFC0))
+#define HIB_CC_R                (*((volatile uint32_t *)0x400FCFC8))
+
+//*****************************************************************************
+//
+// FLASH registers (FLASH CTRL)
+//
+//*****************************************************************************
+#define FLASH_FMA_R             (*((volatile uint32_t *)0x400FD000))
+#define FLASH_FMD_R             (*((volatile uint32_t *)0x400FD004))
+#define FLASH_FMC_R             (*((volatile uint32_t *)0x400FD008))
+#define FLASH_FCRIS_R           (*((volatile uint32_t *)0x400FD00C))
+#define FLASH_FCIM_R            (*((volatile uint32_t *)0x400FD010))
+#define FLASH_FCMISC_R          (*((volatile uint32_t *)0x400FD014))
+#define FLASH_FMC2_R            (*((volatile uint32_t *)0x400FD020))
+#define FLASH_FWBVAL_R          (*((volatile uint32_t *)0x400FD030))
+#define FLASH_FLPEKEY_R         (*((volatile uint32_t *)0x400FD03C))
+#define FLASH_FWBN_R            (*((volatile uint32_t *)0x400FD100))
+#define FLASH_PP_R              (*((volatile uint32_t *)0x400FDFC0))
+#define FLASH_SSIZE_R           (*((volatile uint32_t *)0x400FDFC4))
+#define FLASH_CONF_R            (*((volatile uint32_t *)0x400FDFC8))
+#define FLASH_ROMSWMAP_R        (*((volatile uint32_t *)0x400FDFCC))
+#define FLASH_DMASZ_R           (*((volatile uint32_t *)0x400FDFD0))
+#define FLASH_DMAST_R           (*((volatile uint32_t *)0x400FDFD4))
+#define FLASH_RVP_R             (*((volatile uint32_t *)0x400FE0D4))
+#define FLASH_BOOTCFG_R         (*((volatile uint32_t *)0x400FE1D0))
+#define FLASH_USERREG0_R        (*((volatile uint32_t *)0x400FE1E0))
+#define FLASH_USERREG1_R        (*((volatile uint32_t *)0x400FE1E4))
+#define FLASH_USERREG2_R        (*((volatile uint32_t *)0x400FE1E8))
+#define FLASH_USERREG3_R        (*((volatile uint32_t *)0x400FE1EC))
+#define FLASH_FMPRE0_R          (*((volatile uint32_t *)0x400FE200))
+#define FLASH_FMPRE1_R          (*((volatile uint32_t *)0x400FE204))
+#define FLASH_FMPRE2_R          (*((volatile uint32_t *)0x400FE208))
+#define FLASH_FMPRE3_R          (*((volatile uint32_t *)0x400FE20C))
+#define FLASH_FMPRE4_R          (*((volatile uint32_t *)0x400FE210))
+#define FLASH_FMPRE5_R          (*((volatile uint32_t *)0x400FE214))
+#define FLASH_FMPRE6_R          (*((volatile uint32_t *)0x400FE218))
+#define FLASH_FMPRE7_R          (*((volatile uint32_t *)0x400FE21C))
+#define FLASH_FMPRE8_R          (*((volatile uint32_t *)0x400FE220))
+#define FLASH_FMPRE9_R          (*((volatile uint32_t *)0x400FE224))
+#define FLASH_FMPRE10_R         (*((volatile uint32_t *)0x400FE228))
+#define FLASH_FMPRE11_R         (*((volatile uint32_t *)0x400FE22C))
+#define FLASH_FMPRE12_R         (*((volatile uint32_t *)0x400FE230))
+#define FLASH_FMPRE13_R         (*((volatile uint32_t *)0x400FE234))
+#define FLASH_FMPRE14_R         (*((volatile uint32_t *)0x400FE238))
+#define FLASH_FMPRE15_R         (*((volatile uint32_t *)0x400FE23C))
+#define FLASH_FMPPE0_R          (*((volatile uint32_t *)0x400FE400))
+#define FLASH_FMPPE1_R          (*((volatile uint32_t *)0x400FE404))
+#define FLASH_FMPPE2_R          (*((volatile uint32_t *)0x400FE408))
+#define FLASH_FMPPE3_R          (*((volatile uint32_t *)0x400FE40C))
+#define FLASH_FMPPE4_R          (*((volatile uint32_t *)0x400FE410))
+#define FLASH_FMPPE5_R          (*((volatile uint32_t *)0x400FE414))
+#define FLASH_FMPPE6_R          (*((volatile uint32_t *)0x400FE418))
+#define FLASH_FMPPE7_R          (*((volatile uint32_t *)0x400FE41C))
+#define FLASH_FMPPE8_R          (*((volatile uint32_t *)0x400FE420))
+#define FLASH_FMPPE9_R          (*((volatile uint32_t *)0x400FE424))
+#define FLASH_FMPPE10_R         (*((volatile uint32_t *)0x400FE428))
+#define FLASH_FMPPE11_R         (*((volatile uint32_t *)0x400FE42C))
+#define FLASH_FMPPE12_R         (*((volatile uint32_t *)0x400FE430))
+#define FLASH_FMPPE13_R         (*((volatile uint32_t *)0x400FE434))
+#define FLASH_FMPPE14_R         (*((volatile uint32_t *)0x400FE438))
+#define FLASH_FMPPE15_R         (*((volatile uint32_t *)0x400FE43C))
+
+//*****************************************************************************
+//
+// System Control registers (SYSCTL)
+//
+//*****************************************************************************
+#define SYSCTL_DID0_R           (*((volatile uint32_t *)0x400FE000))
+#define SYSCTL_DID1_R           (*((volatile uint32_t *)0x400FE004))
+#define SYSCTL_PTBOCTL_R        (*((volatile uint32_t *)0x400FE038))
+#define SYSCTL_RIS_R            (*((volatile uint32_t *)0x400FE050))
+#define SYSCTL_IMC_R            (*((volatile uint32_t *)0x400FE054))
+#define SYSCTL_MISC_R           (*((volatile uint32_t *)0x400FE058))
+#define SYSCTL_RESC_R           (*((volatile uint32_t *)0x400FE05C))
+#define SYSCTL_PWRTC_R          (*((volatile uint32_t *)0x400FE060))
+#define SYSCTL_NMIC_R           (*((volatile uint32_t *)0x400FE064))
+#define SYSCTL_MOSCCTL_R        (*((volatile uint32_t *)0x400FE07C))
+#define SYSCTL_RSCLKCFG_R       (*((volatile uint32_t *)0x400FE0B0))
+#define SYSCTL_MEMTIM0_R        (*((volatile uint32_t *)0x400FE0C0))
+#define SYSCTL_ALTCLKCFG_R      (*((volatile uint32_t *)0x400FE138))
+#define SYSCTL_DSCLKCFG_R       (*((volatile uint32_t *)0x400FE144))
+#define SYSCTL_DIVSCLK_R        (*((volatile uint32_t *)0x400FE148))
+#define SYSCTL_SYSPROP_R        (*((volatile uint32_t *)0x400FE14C))
+#define SYSCTL_PIOSCCAL_R       (*((volatile uint32_t *)0x400FE150))
+#define SYSCTL_PIOSCSTAT_R      (*((volatile uint32_t *)0x400FE154))
+#define SYSCTL_PLLFREQ0_R       (*((volatile uint32_t *)0x400FE160))
+#define SYSCTL_PLLFREQ1_R       (*((volatile uint32_t *)0x400FE164))
+#define SYSCTL_PLLSTAT_R        (*((volatile uint32_t *)0x400FE168))
+#define SYSCTL_SLPPWRCFG_R      (*((volatile uint32_t *)0x400FE188))
+#define SYSCTL_DSLPPWRCFG_R     (*((volatile uint32_t *)0x400FE18C))
+#define SYSCTL_NVMSTAT_R        (*((volatile uint32_t *)0x400FE1A0))
+#define SYSCTL_LDOSPCTL_R       (*((volatile uint32_t *)0x400FE1B4))
+#define SYSCTL_LDODPCTL_R       (*((volatile uint32_t *)0x400FE1BC))
+#define SYSCTL_RESBEHAVCTL_R    (*((volatile uint32_t *)0x400FE1D8))
+#define SYSCTL_HSSR_R           (*((volatile uint32_t *)0x400FE1F4))
+#define SYSCTL_USBPDS_R         (*((volatile uint32_t *)0x400FE280))
+#define SYSCTL_USBMPC_R         (*((volatile uint32_t *)0x400FE284))
+#define SYSCTL_EMACPDS_R        (*((volatile uint32_t *)0x400FE288))
+#define SYSCTL_EMACMPC_R        (*((volatile uint32_t *)0x400FE28C))
+#define SYSCTL_LCDMPC_R         (*((volatile uint32_t *)0x400FE294))
+#define SYSCTL_PPWD_R           (*((volatile uint32_t *)0x400FE300))
+#define SYSCTL_PPTIMER_R        (*((volatile uint32_t *)0x400FE304))
+#define SYSCTL_PPGPIO_R         (*((volatile uint32_t *)0x400FE308))
+#define SYSCTL_PPDMA_R          (*((volatile uint32_t *)0x400FE30C))
+#define SYSCTL_PPEPI_R          (*((volatile uint32_t *)0x400FE310))
+#define SYSCTL_PPHIB_R          (*((volatile uint32_t *)0x400FE314))
+#define SYSCTL_PPUART_R         (*((volatile uint32_t *)0x400FE318))
+#define SYSCTL_PPSSI_R          (*((volatile uint32_t *)0x400FE31C))
+#define SYSCTL_PPI2C_R          (*((volatile uint32_t *)0x400FE320))
+#define SYSCTL_PPUSB_R          (*((volatile uint32_t *)0x400FE328))
+#define SYSCTL_PPEPHY_R         (*((volatile uint32_t *)0x400FE330))
+#define SYSCTL_PPCAN_R          (*((volatile uint32_t *)0x400FE334))
+#define SYSCTL_PPADC_R          (*((volatile uint32_t *)0x400FE338))
+#define SYSCTL_PPACMP_R         (*((volatile uint32_t *)0x400FE33C))
+#define SYSCTL_PPPWM_R          (*((volatile uint32_t *)0x400FE340))
+#define SYSCTL_PPQEI_R          (*((volatile uint32_t *)0x400FE344))
+#define SYSCTL_PPLPC_R          (*((volatile uint32_t *)0x400FE348))
+#define SYSCTL_PPPECI_R         (*((volatile uint32_t *)0x400FE350))
+#define SYSCTL_PPFAN_R          (*((volatile uint32_t *)0x400FE354))
+#define SYSCTL_PPEEPROM_R       (*((volatile uint32_t *)0x400FE358))
+#define SYSCTL_PPWTIMER_R       (*((volatile uint32_t *)0x400FE35C))
+#define SYSCTL_PPRTS_R          (*((volatile uint32_t *)0x400FE370))
+#define SYSCTL_PPCCM_R          (*((volatile uint32_t *)0x400FE374))
+#define SYSCTL_PPLCD_R          (*((volatile uint32_t *)0x400FE390))
+#define SYSCTL_PPOWIRE_R        (*((volatile uint32_t *)0x400FE398))
+#define SYSCTL_PPEMAC_R         (*((volatile uint32_t *)0x400FE39C))
+#define SYSCTL_PPHIM_R          (*((volatile uint32_t *)0x400FE3A4))
+#define SYSCTL_SRWD_R           (*((volatile uint32_t *)0x400FE500))
+#define SYSCTL_SRTIMER_R        (*((volatile uint32_t *)0x400FE504))
+#define SYSCTL_SRGPIO_R         (*((volatile uint32_t *)0x400FE508))
+#define SYSCTL_SRDMA_R          (*((volatile uint32_t *)0x400FE50C))
+#define SYSCTL_SREPI_R          (*((volatile uint32_t *)0x400FE510))
+#define SYSCTL_SRHIB_R          (*((volatile uint32_t *)0x400FE514))
+#define SYSCTL_SRUART_R         (*((volatile uint32_t *)0x400FE518))
+#define SYSCTL_SRSSI_R          (*((volatile uint32_t *)0x400FE51C))
+#define SYSCTL_SRI2C_R          (*((volatile uint32_t *)0x400FE520))
+#define SYSCTL_SRUSB_R          (*((volatile uint32_t *)0x400FE528))
+#define SYSCTL_SREPHY_R         (*((volatile uint32_t *)0x400FE530))
+#define SYSCTL_SRCAN_R          (*((volatile uint32_t *)0x400FE534))
+#define SYSCTL_SRADC_R          (*((volatile uint32_t *)0x400FE538))
+#define SYSCTL_SRACMP_R         (*((volatile uint32_t *)0x400FE53C))
+#define SYSCTL_SRPWM_R          (*((volatile uint32_t *)0x400FE540))
+#define SYSCTL_SRQEI_R          (*((volatile uint32_t *)0x400FE544))
+#define SYSCTL_SREEPROM_R       (*((volatile uint32_t *)0x400FE558))
+#define SYSCTL_SRCCM_R          (*((volatile uint32_t *)0x400FE574))
+#define SYSCTL_SRLCD_R          (*((volatile uint32_t *)0x400FE590))
+#define SYSCTL_SROWIRE_R        (*((volatile uint32_t *)0x400FE598))
+#define SYSCTL_SREMAC_R         (*((volatile uint32_t *)0x400FE59C))
+#define SYSCTL_RCGCWD_R         (*((volatile uint32_t *)0x400FE600))
+#define SYSCTL_RCGCTIMER_R      (*((volatile uint32_t *)0x400FE604))
+#define SYSCTL_RCGCGPIO_R       (*((volatile uint32_t *)0x400FE608))
+#define SYSCTL_RCGCDMA_R        (*((volatile uint32_t *)0x400FE60C))
+#define SYSCTL_RCGCEPI_R        (*((volatile uint32_t *)0x400FE610))
+#define SYSCTL_RCGCHIB_R        (*((volatile uint32_t *)0x400FE614))
+#define SYSCTL_RCGCUART_R       (*((volatile uint32_t *)0x400FE618))
+#define SYSCTL_RCGCSSI_R        (*((volatile uint32_t *)0x400FE61C))
+#define SYSCTL_RCGCI2C_R        (*((volatile uint32_t *)0x400FE620))
+#define SYSCTL_RCGCUSB_R        (*((volatile uint32_t *)0x400FE628))
+#define SYSCTL_RCGCEPHY_R       (*((volatile uint32_t *)0x400FE630))
+#define SYSCTL_RCGCCAN_R        (*((volatile uint32_t *)0x400FE634))
+#define SYSCTL_RCGCADC_R        (*((volatile uint32_t *)0x400FE638))
+#define SYSCTL_RCGCACMP_R       (*((volatile uint32_t *)0x400FE63C))
+#define SYSCTL_RCGCPWM_R        (*((volatile uint32_t *)0x400FE640))
+#define SYSCTL_RCGCQEI_R        (*((volatile uint32_t *)0x400FE644))
+#define SYSCTL_RCGCEEPROM_R     (*((volatile uint32_t *)0x400FE658))
+#define SYSCTL_RCGCCCM_R        (*((volatile uint32_t *)0x400FE674))
+#define SYSCTL_RCGCLCD_R        (*((volatile uint32_t *)0x400FE690))
+#define SYSCTL_RCGCOWIRE_R      (*((volatile uint32_t *)0x400FE698))
+#define SYSCTL_RCGCEMAC_R       (*((volatile uint32_t *)0x400FE69C))
+#define SYSCTL_SCGCWD_R         (*((volatile uint32_t *)0x400FE700))
+#define SYSCTL_SCGCTIMER_R      (*((volatile uint32_t *)0x400FE704))
+#define SYSCTL_SCGCGPIO_R       (*((volatile uint32_t *)0x400FE708))
+#define SYSCTL_SCGCDMA_R        (*((volatile uint32_t *)0x400FE70C))
+#define SYSCTL_SCGCEPI_R        (*((volatile uint32_t *)0x400FE710))
+#define SYSCTL_SCGCHIB_R        (*((volatile uint32_t *)0x400FE714))
+#define SYSCTL_SCGCUART_R       (*((volatile uint32_t *)0x400FE718))
+#define SYSCTL_SCGCSSI_R        (*((volatile uint32_t *)0x400FE71C))
+#define SYSCTL_SCGCI2C_R        (*((volatile uint32_t *)0x400FE720))
+#define SYSCTL_SCGCUSB_R        (*((volatile uint32_t *)0x400FE728))
+#define SYSCTL_SCGCEPHY_R       (*((volatile uint32_t *)0x400FE730))
+#define SYSCTL_SCGCCAN_R        (*((volatile uint32_t *)0x400FE734))
+#define SYSCTL_SCGCADC_R        (*((volatile uint32_t *)0x400FE738))
+#define SYSCTL_SCGCACMP_R       (*((volatile uint32_t *)0x400FE73C))
+#define SYSCTL_SCGCPWM_R        (*((volatile uint32_t *)0x400FE740))
+#define SYSCTL_SCGCQEI_R        (*((volatile uint32_t *)0x400FE744))
+#define SYSCTL_SCGCEEPROM_R     (*((volatile uint32_t *)0x400FE758))
+#define SYSCTL_SCGCCCM_R        (*((volatile uint32_t *)0x400FE774))
+#define SYSCTL_SCGCLCD_R        (*((volatile uint32_t *)0x400FE790))
+#define SYSCTL_SCGCOWIRE_R      (*((volatile uint32_t *)0x400FE798))
+#define SYSCTL_SCGCEMAC_R       (*((volatile uint32_t *)0x400FE79C))
+#define SYSCTL_DCGCWD_R         (*((volatile uint32_t *)0x400FE800))
+#define SYSCTL_DCGCTIMER_R      (*((volatile uint32_t *)0x400FE804))
+#define SYSCTL_DCGCGPIO_R       (*((volatile uint32_t *)0x400FE808))
+#define SYSCTL_DCGCDMA_R        (*((volatile uint32_t *)0x400FE80C))
+#define SYSCTL_DCGCEPI_R        (*((volatile uint32_t *)0x400FE810))
+#define SYSCTL_DCGCHIB_R        (*((volatile uint32_t *)0x400FE814))
+#define SYSCTL_DCGCUART_R       (*((volatile uint32_t *)0x400FE818))
+#define SYSCTL_DCGCSSI_R        (*((volatile uint32_t *)0x400FE81C))
+#define SYSCTL_DCGCI2C_R        (*((volatile uint32_t *)0x400FE820))
+#define SYSCTL_DCGCUSB_R        (*((volatile uint32_t *)0x400FE828))
+#define SYSCTL_DCGCEPHY_R       (*((volatile uint32_t *)0x400FE830))
+#define SYSCTL_DCGCCAN_R        (*((volatile uint32_t *)0x400FE834))
+#define SYSCTL_DCGCADC_R        (*((volatile uint32_t *)0x400FE838))
+#define SYSCTL_DCGCACMP_R       (*((volatile uint32_t *)0x400FE83C))
+#define SYSCTL_DCGCPWM_R        (*((volatile uint32_t *)0x400FE840))
+#define SYSCTL_DCGCQEI_R        (*((volatile uint32_t *)0x400FE844))
+#define SYSCTL_DCGCEEPROM_R     (*((volatile uint32_t *)0x400FE858))
+#define SYSCTL_DCGCCCM_R        (*((volatile uint32_t *)0x400FE874))
+#define SYSCTL_DCGCLCD_R        (*((volatile uint32_t *)0x400FE890))
+#define SYSCTL_DCGCOWIRE_R      (*((volatile uint32_t *)0x400FE898))
+#define SYSCTL_DCGCEMAC_R       (*((volatile uint32_t *)0x400FE89C))
+#define SYSCTL_PCWD_R           (*((volatile uint32_t *)0x400FE900))
+#define SYSCTL_PCTIMER_R        (*((volatile uint32_t *)0x400FE904))
+#define SYSCTL_PCGPIO_R         (*((volatile uint32_t *)0x400FE908))
+#define SYSCTL_PCDMA_R          (*((volatile uint32_t *)0x400FE90C))
+#define SYSCTL_PCEPI_R          (*((volatile uint32_t *)0x400FE910))
+#define SYSCTL_PCHIB_R          (*((volatile uint32_t *)0x400FE914))
+#define SYSCTL_PCUART_R         (*((volatile uint32_t *)0x400FE918))
+#define SYSCTL_PCSSI_R          (*((volatile uint32_t *)0x400FE91C))
+#define SYSCTL_PCI2C_R          (*((volatile uint32_t *)0x400FE920))
+#define SYSCTL_PCUSB_R          (*((volatile uint32_t *)0x400FE928))
+#define SYSCTL_PCEPHY_R         (*((volatile uint32_t *)0x400FE930))
+#define SYSCTL_PCCAN_R          (*((volatile uint32_t *)0x400FE934))
+#define SYSCTL_PCADC_R          (*((volatile uint32_t *)0x400FE938))
+#define SYSCTL_PCACMP_R         (*((volatile uint32_t *)0x400FE93C))
+#define SYSCTL_PCPWM_R          (*((volatile uint32_t *)0x400FE940))
+#define SYSCTL_PCQEI_R          (*((volatile uint32_t *)0x400FE944))
+#define SYSCTL_PCEEPROM_R       (*((volatile uint32_t *)0x400FE958))
+#define SYSCTL_PCCCM_R          (*((volatile uint32_t *)0x400FE974))
+#define SYSCTL_PCLCD_R          (*((volatile uint32_t *)0x400FE990))
+#define SYSCTL_PCOWIRE_R        (*((volatile uint32_t *)0x400FE998))
+#define SYSCTL_PCEMAC_R         (*((volatile uint32_t *)0x400FE99C))
+#define SYSCTL_PRWD_R           (*((volatile uint32_t *)0x400FEA00))
+#define SYSCTL_PRTIMER_R        (*((volatile uint32_t *)0x400FEA04))
+#define SYSCTL_PRGPIO_R         (*((volatile uint32_t *)0x400FEA08))
+#define SYSCTL_PRDMA_R          (*((volatile uint32_t *)0x400FEA0C))
+#define SYSCTL_PREPI_R          (*((volatile uint32_t *)0x400FEA10))
+#define SYSCTL_PRHIB_R          (*((volatile uint32_t *)0x400FEA14))
+#define SYSCTL_PRUART_R         (*((volatile uint32_t *)0x400FEA18))
+#define SYSCTL_PRSSI_R          (*((volatile uint32_t *)0x400FEA1C))
+#define SYSCTL_PRI2C_R          (*((volatile uint32_t *)0x400FEA20))
+#define SYSCTL_PRUSB_R          (*((volatile uint32_t *)0x400FEA28))
+#define SYSCTL_PREPHY_R         (*((volatile uint32_t *)0x400FEA30))
+#define SYSCTL_PRCAN_R          (*((volatile uint32_t *)0x400FEA34))
+#define SYSCTL_PRADC_R          (*((volatile uint32_t *)0x400FEA38))
+#define SYSCTL_PRACMP_R         (*((volatile uint32_t *)0x400FEA3C))
+#define SYSCTL_PRPWM_R          (*((volatile uint32_t *)0x400FEA40))
+#define SYSCTL_PRQEI_R          (*((volatile uint32_t *)0x400FEA44))
+#define SYSCTL_PREEPROM_R       (*((volatile uint32_t *)0x400FEA58))
+#define SYSCTL_PRCCM_R          (*((volatile uint32_t *)0x400FEA74))
+#define SYSCTL_PRLCD_R          (*((volatile uint32_t *)0x400FEA90))
+#define SYSCTL_PROWIRE_R        (*((volatile uint32_t *)0x400FEA98))
+#define SYSCTL_PREMAC_R         (*((volatile uint32_t *)0x400FEA9C))
+#define SYSCTL_CCMCGREQ_R       (*((volatile uint32_t *)0x44030204))
+
+//*****************************************************************************
+//
+// Micro Direct Memory Access registers (UDMA)
+//
+//*****************************************************************************
+#define UDMA_STAT_R             (*((volatile uint32_t *)0x400FF000))
+#define UDMA_CFG_R              (*((volatile uint32_t *)0x400FF004))
+#define UDMA_CTLBASE_R          (*((volatile uint32_t *)0x400FF008))
+#define UDMA_ALTBASE_R          (*((volatile uint32_t *)0x400FF00C))
+#define UDMA_WAITSTAT_R         (*((volatile uint32_t *)0x400FF010))
+#define UDMA_SWREQ_R            (*((volatile uint32_t *)0x400FF014))
+#define UDMA_USEBURSTSET_R      (*((volatile uint32_t *)0x400FF018))
+#define UDMA_USEBURSTCLR_R      (*((volatile uint32_t *)0x400FF01C))
+#define UDMA_REQMASKSET_R       (*((volatile uint32_t *)0x400FF020))
+#define UDMA_REQMASKCLR_R       (*((volatile uint32_t *)0x400FF024))
+#define UDMA_ENASET_R           (*((volatile uint32_t *)0x400FF028))
+#define UDMA_ENACLR_R           (*((volatile uint32_t *)0x400FF02C))
+#define UDMA_ALTSET_R           (*((volatile uint32_t *)0x400FF030))
+#define UDMA_ALTCLR_R           (*((volatile uint32_t *)0x400FF034))
+#define UDMA_PRIOSET_R          (*((volatile uint32_t *)0x400FF038))
+#define UDMA_PRIOCLR_R          (*((volatile uint32_t *)0x400FF03C))
+#define UDMA_ERRCLR_R           (*((volatile uint32_t *)0x400FF04C))
+#define UDMA_CHASGN_R           (*((volatile uint32_t *)0x400FF500))
+#define UDMA_CHMAP0_R           (*((volatile uint32_t *)0x400FF510))
+#define UDMA_CHMAP1_R           (*((volatile uint32_t *)0x400FF514))
+#define UDMA_CHMAP2_R           (*((volatile uint32_t *)0x400FF518))
+#define UDMA_CHMAP3_R           (*((volatile uint32_t *)0x400FF51C))
+
+//*****************************************************************************
+//
+// Micro Direct Memory Access (uDMA) offsets (UDMA)
+//
+//*****************************************************************************
+#define UDMA_SRCENDP            0x00000000  // DMA Channel Source Address End
+                                            // Pointer
+#define UDMA_DSTENDP            0x00000004  // DMA Channel Destination Address
+                                            // End Pointer
+#define UDMA_CHCTL              0x00000008  // DMA Channel Control Word
+
+//*****************************************************************************
+//
+// EC registers (CCM0)
+//
+//*****************************************************************************
+#define CCM0_CRCCTRL_R          (*((volatile uint32_t *)0x44030400))
+#define CCM0_CRCSEED_R          (*((volatile uint32_t *)0x44030410))
+#define CCM0_CRCDIN_R           (*((volatile uint32_t *)0x44030414))
+#define CCM0_CRCRSLTPP_R        (*((volatile uint32_t *)0x44030418))
+
+//*****************************************************************************
+//
+// SHA/MD5 registers (SHAMD5)
+//
+//*****************************************************************************
+#define SHAMD5_ODIGEST_A_R      (*((volatile uint32_t *)0x44034000))
+#define SHAMD5_ODIGEST_B_R      (*((volatile uint32_t *)0x44034004))
+#define SHAMD5_ODIGEST_C_R      (*((volatile uint32_t *)0x44034008))
+#define SHAMD5_ODIGEST_D_R      (*((volatile uint32_t *)0x4403400C))
+#define SHAMD5_ODIGEST_E_R      (*((volatile uint32_t *)0x44034010))
+#define SHAMD5_ODIGEST_F_R      (*((volatile uint32_t *)0x44034014))
+#define SHAMD5_ODIGEST_G_R      (*((volatile uint32_t *)0x44034018))
+#define SHAMD5_ODIGEST_H_R      (*((volatile uint32_t *)0x4403401C))
+#define SHAMD5_IDIGEST_A_R      (*((volatile uint32_t *)0x44034020))
+#define SHAMD5_IDIGEST_B_R      (*((volatile uint32_t *)0x44034024))
+#define SHAMD5_IDIGEST_C_R      (*((volatile uint32_t *)0x44034028))
+#define SHAMD5_IDIGEST_D_R      (*((volatile uint32_t *)0x4403402C))
+#define SHAMD5_IDIGEST_E_R      (*((volatile uint32_t *)0x44034030))
+#define SHAMD5_IDIGEST_F_R      (*((volatile uint32_t *)0x44034034))
+#define SHAMD5_IDIGEST_G_R      (*((volatile uint32_t *)0x44034038))
+#define SHAMD5_IDIGEST_H_R      (*((volatile uint32_t *)0x4403403C))
+#define SHAMD5_DIGEST_COUNT_R   (*((volatile uint32_t *)0x44034040))
+#define SHAMD5_MODE_R           (*((volatile uint32_t *)0x44034044))
+#define SHAMD5_LENGTH_R         (*((volatile uint32_t *)0x44034048))
+#define SHAMD5_DATA_0_IN_R      (*((volatile uint32_t *)0x44034080))
+#define SHAMD5_DATA_1_IN_R      (*((volatile uint32_t *)0x44034084))
+#define SHAMD5_DATA_2_IN_R      (*((volatile uint32_t *)0x44034088))
+#define SHAMD5_DATA_3_IN_R      (*((volatile uint32_t *)0x4403408C))
+#define SHAMD5_DATA_4_IN_R      (*((volatile uint32_t *)0x44034090))
+#define SHAMD5_DATA_5_IN_R      (*((volatile uint32_t *)0x44034094))
+#define SHAMD5_DATA_6_IN_R      (*((volatile uint32_t *)0x44034098))
+#define SHAMD5_DATA_7_IN_R      (*((volatile uint32_t *)0x4403409C))
+#define SHAMD5_DATA_8_IN_R      (*((volatile uint32_t *)0x440340A0))
+#define SHAMD5_DATA_9_IN_R      (*((volatile uint32_t *)0x440340A4))
+#define SHAMD5_DATA_10_IN_R     (*((volatile uint32_t *)0x440340A8))
+#define SHAMD5_DATA_11_IN_R     (*((volatile uint32_t *)0x440340AC))
+#define SHAMD5_DATA_12_IN_R     (*((volatile uint32_t *)0x440340B0))
+#define SHAMD5_DATA_13_IN_R     (*((volatile uint32_t *)0x440340B4))
+#define SHAMD5_DATA_14_IN_R     (*((volatile uint32_t *)0x440340B8))
+#define SHAMD5_DATA_15_IN_R     (*((volatile uint32_t *)0x440340BC))
+#define SHAMD5_REVISION_R       (*((volatile uint32_t *)0x44034100))
+#define SHAMD5_SYSCONFIG_R      (*((volatile uint32_t *)0x44034110))
+#define SHAMD5_SYSSTATUS_R      (*((volatile uint32_t *)0x44034114))
+#define SHAMD5_IRQSTATUS_R      (*((volatile uint32_t *)0x44034118))
+#define SHAMD5_IRQENABLE_R      (*((volatile uint32_t *)0x4403411C))
+#define SHAMD5_DMAIM_R          (*((volatile uint32_t *)0x144030010))
+#define SHAMD5_DMARIS_R         (*((volatile uint32_t *)0x144030014))
+#define SHAMD5_DMAMIS_R         (*((volatile uint32_t *)0x144030018))
+#define SHAMD5_DMAIC_R          (*((volatile uint32_t *)0x14403001C))
+
+//*****************************************************************************
+//
+// AES registers (AES)
+//
+//*****************************************************************************
+#define AES_KEY2_6_R            (*((volatile uint32_t *)0x44036000))
+#define AES_KEY2_7_R            (*((volatile uint32_t *)0x44036004))
+#define AES_KEY2_4_R            (*((volatile uint32_t *)0x44036008))
+#define AES_KEY2_5_R            (*((volatile uint32_t *)0x4403600C))
+#define AES_KEY2_2_R            (*((volatile uint32_t *)0x44036010))
+#define AES_KEY2_3_R            (*((volatile uint32_t *)0x44036014))
+#define AES_KEY2_0_R            (*((volatile uint32_t *)0x44036018))
+#define AES_KEY2_1_R            (*((volatile uint32_t *)0x4403601C))
+#define AES_KEY1_6_R            (*((volatile uint32_t *)0x44036020))
+#define AES_KEY1_7_R            (*((volatile uint32_t *)0x44036024))
+#define AES_KEY1_4_R            (*((volatile uint32_t *)0x44036028))
+#define AES_KEY1_5_R            (*((volatile uint32_t *)0x4403602C))
+#define AES_KEY1_2_R            (*((volatile uint32_t *)0x44036030))
+#define AES_KEY1_3_R            (*((volatile uint32_t *)0x44036034))
+#define AES_KEY1_0_R            (*((volatile uint32_t *)0x44036038))
+#define AES_KEY1_1_R            (*((volatile uint32_t *)0x4403603C))
+#define AES_IV_IN_0_R           (*((volatile uint32_t *)0x44036040))
+#define AES_IV_IN_1_R           (*((volatile uint32_t *)0x44036044))
+#define AES_IV_IN_2_R           (*((volatile uint32_t *)0x44036048))
+#define AES_IV_IN_3_R           (*((volatile uint32_t *)0x4403604C))
+#define AES_CTRL_R              (*((volatile uint32_t *)0x44036050))
+#define AES_C_LENGTH_0_R        (*((volatile uint32_t *)0x44036054))
+#define AES_C_LENGTH_1_R        (*((volatile uint32_t *)0x44036058))
+#define AES_AUTH_LENGTH_R       (*((volatile uint32_t *)0x4403605C))
+#define AES_DATA_IN_0_R         (*((volatile uint32_t *)0x44036060))
+#define AES_DATA_IN_1_R         (*((volatile uint32_t *)0x44036064))
+#define AES_DATA_IN_2_R         (*((volatile uint32_t *)0x44036068))
+#define AES_DATA_IN_3_R         (*((volatile uint32_t *)0x4403606C))
+#define AES_TAG_OUT_0_R         (*((volatile uint32_t *)0x44036070))
+#define AES_TAG_OUT_1_R         (*((volatile uint32_t *)0x44036074))
+#define AES_TAG_OUT_2_R         (*((volatile uint32_t *)0x44036078))
+#define AES_TAG_OUT_3_R         (*((volatile uint32_t *)0x4403607C))
+#define AES_REVISION_R          (*((volatile uint32_t *)0x44036080))
+#define AES_SYSCONFIG_R         (*((volatile uint32_t *)0x44036084))
+#define AES_SYSSTATUS_R         (*((volatile uint32_t *)0x44036088))
+#define AES_IRQSTATUS_R         (*((volatile uint32_t *)0x4403608C))
+#define AES_IRQENABLE_R         (*((volatile uint32_t *)0x44036090))
+#define AES_DIRTYBITS_R         (*((volatile uint32_t *)0x44036094))
+#define AES_DMAIM_R             (*((volatile uint32_t *)0x144030020))
+#define AES_DMARIS_R            (*((volatile uint32_t *)0x144030024))
+#define AES_DMAMIS_R            (*((volatile uint32_t *)0x144030028))
+#define AES_DMAIC_R             (*((volatile uint32_t *)0x14403002C))
+
+//*****************************************************************************
+//
+// DES registers (DES)
+//
+//*****************************************************************************
+#define DES_KEY3_L_R            (*((volatile uint32_t *)0x44038000))
+#define DES_KEY3_H_R            (*((volatile uint32_t *)0x44038004))
+#define DES_KEY2_L_R            (*((volatile uint32_t *)0x44038008))
+#define DES_KEY2_H_R            (*((volatile uint32_t *)0x4403800C))
+#define DES_KEY1_L_R            (*((volatile uint32_t *)0x44038010))
+#define DES_KEY1_H_R            (*((volatile uint32_t *)0x44038014))
+#define DES_IV_L_R              (*((volatile uint32_t *)0x44038018))
+#define DES_IV_H_R              (*((volatile uint32_t *)0x4403801C))
+#define DES_CTRL_R              (*((volatile uint32_t *)0x44038020))
+#define DES_LENGTH_R            (*((volatile uint32_t *)0x44038024))
+#define DES_DATA_L_R            (*((volatile uint32_t *)0x44038028))
+#define DES_DATA_H_R            (*((volatile uint32_t *)0x4403802C))
+#define DES_REVISION_R          (*((volatile uint32_t *)0x44038030))
+#define DES_SYSCONFIG_R         (*((volatile uint32_t *)0x44038034))
+#define DES_SYSSTATUS_R         (*((volatile uint32_t *)0x44038038))
+#define DES_IRQSTATUS_R         (*((volatile uint32_t *)0x4403803C))
+#define DES_IRQENABLE_R         (*((volatile uint32_t *)0x44038040))
+#define DES_DIRTYBITS_R         (*((volatile uint32_t *)0x44038044))
+#define DES_DMAIM_R             (*((volatile uint32_t *)0x144030030))
+#define DES_DMARIS_R            (*((volatile uint32_t *)0x144030034))
+#define DES_DMAMIS_R            (*((volatile uint32_t *)0x144030038))
+#define DES_DMAIC_R             (*((volatile uint32_t *)0x14403003C))
+
+//*****************************************************************************
+//
+// LCD registers (LCD0)
+//
+//*****************************************************************************
+#define LCD0_PID_R              (*((volatile uint32_t *)0x44050000))
+#define LCD0_CTL_R              (*((volatile uint32_t *)0x44050004))
+#define LCD0_LIDDCTL_R          (*((volatile uint32_t *)0x4405000C))
+#define LCD0_LIDDCS0CFG_R       (*((volatile uint32_t *)0x44050010))
+#define LCD0_LIDDCS0ADDR_R      (*((volatile uint32_t *)0x44050014))
+#define LCD0_LIDDCS0DATA_R      (*((volatile uint32_t *)0x44050018))
+#define LCD0_LIDDCS1CFG_R       (*((volatile uint32_t *)0x4405001C))
+#define LCD0_LIDDCS1ADDR_R      (*((volatile uint32_t *)0x44050020))
+#define LCD0_LIDDCS1DATA_R      (*((volatile uint32_t *)0x44050024))
+#define LCD0_RASTRCTL_R         (*((volatile uint32_t *)0x44050028))
+#define LCD0_RASTRTIM0_R        (*((volatile uint32_t *)0x4405002C))
+#define LCD0_RASTRTIM1_R        (*((volatile uint32_t *)0x44050030))
+#define LCD0_RASTRTIM2_R        (*((volatile uint32_t *)0x44050034))
+#define LCD0_RASTRSUBP1_R       (*((volatile uint32_t *)0x44050038))
+#define LCD0_RASTRSUBP2_R       (*((volatile uint32_t *)0x4405003C))
+#define LCD0_DMACTL_R           (*((volatile uint32_t *)0x44050040))
+#define LCD0_DMABAFB0_R         (*((volatile uint32_t *)0x44050044))
+#define LCD0_DMACAFB0_R         (*((volatile uint32_t *)0x44050048))
+#define LCD0_DMABAFB1_R         (*((volatile uint32_t *)0x4405004C))
+#define LCD0_DMACAFB1_R         (*((volatile uint32_t *)0x44050050))
+#define LCD0_SYSCFG_R           (*((volatile uint32_t *)0x44050054))
+#define LCD0_RISSET_R           (*((volatile uint32_t *)0x44050058))
+#define LCD0_MISCLR_R           (*((volatile uint32_t *)0x4405005C))
+#define LCD0_IM_R               (*((volatile uint32_t *)0x44050060))
+#define LCD0_IENC_R             (*((volatile uint32_t *)0x44050064))
+#define LCD0_CLKEN_R            (*((volatile uint32_t *)0x4405006C))
+#define LCD0_CLKRESET_R         (*((volatile uint32_t *)0x44050070))
+
+//*****************************************************************************
+//
+// NVIC registers (NVIC)
+//
+//*****************************************************************************
+#define NVIC_ACTLR_R            (*((volatile uint32_t *)0xE000E008))
+#define NVIC_ST_CTRL_R          (*((volatile uint32_t *)0xE000E010))
+#define NVIC_ST_RELOAD_R        (*((volatile uint32_t *)0xE000E014))
+#define NVIC_ST_CURRENT_R       (*((volatile uint32_t *)0xE000E018))
+#define NVIC_EN0_R              (*((volatile uint32_t *)0xE000E100))
+#define NVIC_EN1_R              (*((volatile uint32_t *)0xE000E104))
+#define NVIC_EN2_R              (*((volatile uint32_t *)0xE000E108))
+#define NVIC_EN3_R              (*((volatile uint32_t *)0xE000E10C))
+#define NVIC_DIS0_R             (*((volatile uint32_t *)0xE000E180))
+#define NVIC_DIS1_R             (*((volatile uint32_t *)0xE000E184))
+#define NVIC_DIS2_R             (*((volatile uint32_t *)0xE000E188))
+#define NVIC_DIS3_R             (*((volatile uint32_t *)0xE000E18C))
+#define NVIC_PEND0_R            (*((volatile uint32_t *)0xE000E200))
+#define NVIC_PEND1_R            (*((volatile uint32_t *)0xE000E204))
+#define NVIC_PEND2_R            (*((volatile uint32_t *)0xE000E208))
+#define NVIC_PEND3_R            (*((volatile uint32_t *)0xE000E20C))
+#define NVIC_UNPEND0_R          (*((volatile uint32_t *)0xE000E280))
+#define NVIC_UNPEND1_R          (*((volatile uint32_t *)0xE000E284))
+#define NVIC_UNPEND2_R          (*((volatile uint32_t *)0xE000E288))
+#define NVIC_UNPEND3_R          (*((volatile uint32_t *)0xE000E28C))
+#define NVIC_ACTIVE0_R          (*((volatile uint32_t *)0xE000E300))
+#define NVIC_ACTIVE1_R          (*((volatile uint32_t *)0xE000E304))
+#define NVIC_ACTIVE2_R          (*((volatile uint32_t *)0xE000E308))
+#define NVIC_ACTIVE3_R          (*((volatile uint32_t *)0xE000E30C))
+#define NVIC_PRI0_R             (*((volatile uint32_t *)0xE000E400))
+#define NVIC_PRI1_R             (*((volatile uint32_t *)0xE000E404))
+#define NVIC_PRI2_R             (*((volatile uint32_t *)0xE000E408))
+#define NVIC_PRI3_R             (*((volatile uint32_t *)0xE000E40C))
+#define NVIC_PRI4_R             (*((volatile uint32_t *)0xE000E410))
+#define NVIC_PRI5_R             (*((volatile uint32_t *)0xE000E414))
+#define NVIC_PRI6_R             (*((volatile uint32_t *)0xE000E418))
+#define NVIC_PRI7_R             (*((volatile uint32_t *)0xE000E41C))
+#define NVIC_PRI8_R             (*((volatile uint32_t *)0xE000E420))
+#define NVIC_PRI9_R             (*((volatile uint32_t *)0xE000E424))
+#define NVIC_PRI10_R            (*((volatile uint32_t *)0xE000E428))
+#define NVIC_PRI11_R            (*((volatile uint32_t *)0xE000E42C))
+#define NVIC_PRI12_R            (*((volatile uint32_t *)0xE000E430))
+#define NVIC_PRI13_R            (*((volatile uint32_t *)0xE000E434))
+#define NVIC_PRI14_R            (*((volatile uint32_t *)0xE000E438))
+#define NVIC_PRI15_R            (*((volatile uint32_t *)0xE000E43C))
+#define NVIC_PRI16_R            (*((volatile uint32_t *)0xE000E440))
+#define NVIC_PRI17_R            (*((volatile uint32_t *)0xE000E444))
+#define NVIC_PRI18_R            (*((volatile uint32_t *)0xE000E448))
+#define NVIC_PRI19_R            (*((volatile uint32_t *)0xE000E44C))
+#define NVIC_PRI20_R            (*((volatile uint32_t *)0xE000E450))
+#define NVIC_PRI21_R            (*((volatile uint32_t *)0xE000E454))
+#define NVIC_PRI22_R            (*((volatile uint32_t *)0xE000E458))
+#define NVIC_PRI23_R            (*((volatile uint32_t *)0xE000E45C))
+#define NVIC_PRI24_R            (*((volatile uint32_t *)0xE000E460))
+#define NVIC_PRI25_R            (*((volatile uint32_t *)0xE000E464))
+#define NVIC_PRI26_R            (*((volatile uint32_t *)0xE000E468))
+#define NVIC_PRI27_R            (*((volatile uint32_t *)0xE000E46C))
+#define NVIC_PRI28_R            (*((volatile uint32_t *)0xE000E470))
+#define NVIC_CPUID_R            (*((volatile uint32_t *)0xE000ED00))
+#define NVIC_INT_CTRL_R         (*((volatile uint32_t *)0xE000ED04))
+#define NVIC_VTABLE_R           (*((volatile uint32_t *)0xE000ED08))
+#define NVIC_APINT_R            (*((volatile uint32_t *)0xE000ED0C))
+#define NVIC_SYS_CTRL_R         (*((volatile uint32_t *)0xE000ED10))
+#define NVIC_CFG_CTRL_R         (*((volatile uint32_t *)0xE000ED14))
+#define NVIC_SYS_PRI1_R         (*((volatile uint32_t *)0xE000ED18))
+#define NVIC_SYS_PRI2_R         (*((volatile uint32_t *)0xE000ED1C))
+#define NVIC_SYS_PRI3_R         (*((volatile uint32_t *)0xE000ED20))
+#define NVIC_SYS_HND_CTRL_R     (*((volatile uint32_t *)0xE000ED24))
+#define NVIC_FAULT_STAT_R       (*((volatile uint32_t *)0xE000ED28))
+#define NVIC_HFAULT_STAT_R      (*((volatile uint32_t *)0xE000ED2C))
+#define NVIC_DEBUG_STAT_R       (*((volatile uint32_t *)0xE000ED30))
+#define NVIC_MM_ADDR_R          (*((volatile uint32_t *)0xE000ED34))
+#define NVIC_FAULT_ADDR_R       (*((volatile uint32_t *)0xE000ED38))
+#define NVIC_CPAC_R             (*((volatile uint32_t *)0xE000ED88))
+#define NVIC_MPU_TYPE_R         (*((volatile uint32_t *)0xE000ED90))
+#define NVIC_MPU_CTRL_R         (*((volatile uint32_t *)0xE000ED94))
+#define NVIC_MPU_NUMBER_R       (*((volatile uint32_t *)0xE000ED98))
+#define NVIC_MPU_BASE_R         (*((volatile uint32_t *)0xE000ED9C))
+#define NVIC_MPU_ATTR_R         (*((volatile uint32_t *)0xE000EDA0))
+#define NVIC_MPU_BASE1_R        (*((volatile uint32_t *)0xE000EDA4))
+#define NVIC_MPU_ATTR1_R        (*((volatile uint32_t *)0xE000EDA8))
+#define NVIC_MPU_BASE2_R        (*((volatile uint32_t *)0xE000EDAC))
+#define NVIC_MPU_ATTR2_R        (*((volatile uint32_t *)0xE000EDB0))
+#define NVIC_MPU_BASE3_R        (*((volatile uint32_t *)0xE000EDB4))
+#define NVIC_MPU_ATTR3_R        (*((volatile uint32_t *)0xE000EDB8))
+#define NVIC_DBG_CTRL_R         (*((volatile uint32_t *)0xE000EDF0))
+#define NVIC_DBG_XFER_R         (*((volatile uint32_t *)0xE000EDF4))
+#define NVIC_DBG_DATA_R         (*((volatile uint32_t *)0xE000EDF8))
+#define NVIC_DBG_INT_R          (*((volatile uint32_t *)0xE000EDFC))
+#define NVIC_SW_TRIG_R          (*((volatile uint32_t *)0xE000EF00))
+#define NVIC_FPCC_R             (*((volatile uint32_t *)0xE000EF34))
+#define NVIC_FPCA_R             (*((volatile uint32_t *)0xE000EF38))
+#define NVIC_FPDSC_R            (*((volatile uint32_t *)0xE000EF3C))
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_LOAD register.
+//
+//*****************************************************************************
+#define WDT_LOAD_M              0xFFFFFFFF  // Watchdog Load Value
+#define WDT_LOAD_S              0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_VALUE register.
+//
+//*****************************************************************************
+#define WDT_VALUE_M             0xFFFFFFFF  // Watchdog Value
+#define WDT_VALUE_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_CTL register.
+//
+//*****************************************************************************
+#define WDT_CTL_WRC             0x80000000  // Write Complete
+#define WDT_CTL_INTTYPE         0x00000004  // Watchdog Interrupt Type
+#define WDT_CTL_RESEN           0x00000002  // Watchdog Reset Enable
+#define WDT_CTL_INTEN           0x00000001  // Watchdog Interrupt Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_ICR register.
+//
+//*****************************************************************************
+#define WDT_ICR_M               0xFFFFFFFF  // Watchdog Interrupt Clear
+#define WDT_ICR_S               0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_RIS register.
+//
+//*****************************************************************************
+#define WDT_RIS_WDTRIS          0x00000001  // Watchdog Raw Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_MIS register.
+//
+//*****************************************************************************
+#define WDT_MIS_WDTMIS          0x00000001  // Watchdog Masked Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_TEST register.
+//
+//*****************************************************************************
+#define WDT_TEST_STALL          0x00000100  // Watchdog Stall Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_LOCK register.
+//
+//*****************************************************************************
+#define WDT_LOCK_M              0xFFFFFFFF  // Watchdog Lock
+#define WDT_LOCK_UNLOCKED       0x00000000  // Unlocked
+#define WDT_LOCK_LOCKED         0x00000001  // Locked
+#define WDT_LOCK_UNLOCK         0x1ACCE551  // Unlocks the watchdog timer
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_CR0 register.
+//
+//*****************************************************************************
+#define SSI_CR0_SCR_M           0x0000FF00  // SSI Serial Clock Rate
+#define SSI_CR0_SPH             0x00000080  // SSI Serial Clock Phase
+#define SSI_CR0_SPO             0x00000040  // SSI Serial Clock Polarity
+#define SSI_CR0_FRF_M           0x00000030  // SSI Frame Format Select
+#define SSI_CR0_FRF_MOTO        0x00000000  // Freescale SPI Frame Format
+#define SSI_CR0_FRF_TI          0x00000010  // Synchronous Serial Frame Format
+#define SSI_CR0_DSS_M           0x0000000F  // SSI Data Size Select
+#define SSI_CR0_DSS_4           0x00000003  // 4-bit data
+#define SSI_CR0_DSS_5           0x00000004  // 5-bit data
+#define SSI_CR0_DSS_6           0x00000005  // 6-bit data
+#define SSI_CR0_DSS_7           0x00000006  // 7-bit data
+#define SSI_CR0_DSS_8           0x00000007  // 8-bit data
+#define SSI_CR0_DSS_9           0x00000008  // 9-bit data
+#define SSI_CR0_DSS_10          0x00000009  // 10-bit data
+#define SSI_CR0_DSS_11          0x0000000A  // 11-bit data
+#define SSI_CR0_DSS_12          0x0000000B  // 12-bit data
+#define SSI_CR0_DSS_13          0x0000000C  // 13-bit data
+#define SSI_CR0_DSS_14          0x0000000D  // 14-bit data
+#define SSI_CR0_DSS_15          0x0000000E  // 15-bit data
+#define SSI_CR0_DSS_16          0x0000000F  // 16-bit data
+#define SSI_CR0_SCR_S           8
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_CR1 register.
+//
+//*****************************************************************************
+#define SSI_CR1_EOM             0x00000800  // Stop Frame (End of Message)
+#define SSI_CR1_FSSHLDFRM       0x00000400  // FSS Hold Frame
+#define SSI_CR1_HSCLKEN         0x00000200  // High Speed Clock Enable
+#define SSI_CR1_DIR             0x00000100  // SSI Direction of Operation
+#define SSI_CR1_MODE_M          0x000000C0  // SSI Mode
+#define SSI_CR1_MODE_LEGACY     0x00000000  // Legacy SSI mode
+#define SSI_CR1_MODE_BI         0x00000040  // Bi-SSI mode
+#define SSI_CR1_MODE_QUAD       0x00000080  // Quad-SSI Mode
+#define SSI_CR1_MODE_ADVANCED   0x000000C0  // Advanced SSI Mode with 8-bit
+                                            // packet size
+#define SSI_CR1_EOT             0x00000010  // End of Transmission
+#define SSI_CR1_MS              0x00000004  // SSI Master/Slave Select
+#define SSI_CR1_SSE             0x00000002  // SSI Synchronous Serial Port
+                                            // Enable
+#define SSI_CR1_LBM             0x00000001  // SSI Loopback Mode
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_DR register.
+//
+//*****************************************************************************
+#define SSI_DR_DATA_M           0x0000FFFF  // SSI Receive/Transmit Data
+#define SSI_DR_DATA_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_SR register.
+//
+//*****************************************************************************
+#define SSI_SR_BSY              0x00000010  // SSI Busy Bit
+#define SSI_SR_RFF              0x00000008  // SSI Receive FIFO Full
+#define SSI_SR_RNE              0x00000004  // SSI Receive FIFO Not Empty
+#define SSI_SR_TNF              0x00000002  // SSI Transmit FIFO Not Full
+#define SSI_SR_TFE              0x00000001  // SSI Transmit FIFO Empty
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_CPSR register.
+//
+//*****************************************************************************
+#define SSI_CPSR_CPSDVSR_M      0x000000FF  // SSI Clock Prescale Divisor
+#define SSI_CPSR_CPSDVSR_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_IM register.
+//
+//*****************************************************************************
+#define SSI_IM_EOTIM            0x00000040  // End of Transmit Interrupt Mask
+#define SSI_IM_DMATXIM          0x00000020  // SSI Transmit DMA Interrupt Mask
+#define SSI_IM_DMARXIM          0x00000010  // SSI Receive DMA Interrupt Mask
+#define SSI_IM_TXIM             0x00000008  // SSI Transmit FIFO Interrupt Mask
+#define SSI_IM_RXIM             0x00000004  // SSI Receive FIFO Interrupt Mask
+#define SSI_IM_RTIM             0x00000002  // SSI Receive Time-Out Interrupt
+                                            // Mask
+#define SSI_IM_RORIM            0x00000001  // SSI Receive Overrun Interrupt
+                                            // Mask
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_RIS register.
+//
+//*****************************************************************************
+#define SSI_RIS_EOTRIS          0x00000040  // End of Transmit Raw Interrupt
+                                            // Status
+#define SSI_RIS_DMATXRIS        0x00000020  // SSI Transmit DMA Raw Interrupt
+                                            // Status
+#define SSI_RIS_DMARXRIS        0x00000010  // SSI Receive DMA Raw Interrupt
+                                            // Status
+#define SSI_RIS_TXRIS           0x00000008  // SSI Transmit FIFO Raw Interrupt
+                                            // Status
+#define SSI_RIS_RXRIS           0x00000004  // SSI Receive FIFO Raw Interrupt
+                                            // Status
+#define SSI_RIS_RTRIS           0x00000002  // SSI Receive Time-Out Raw
+                                            // Interrupt Status
+#define SSI_RIS_RORRIS          0x00000001  // SSI Receive Overrun Raw
+                                            // Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_MIS register.
+//
+//*****************************************************************************
+#define SSI_MIS_EOTMIS          0x00000040  // End of Transmit Masked Interrupt
+                                            // Status
+#define SSI_MIS_DMATXMIS        0x00000020  // SSI Transmit DMA Masked
+                                            // Interrupt Status
+#define SSI_MIS_DMARXMIS        0x00000010  // SSI Receive DMA Masked Interrupt
+                                            // Status
+#define SSI_MIS_TXMIS           0x00000008  // SSI Transmit FIFO Masked
+                                            // Interrupt Status
+#define SSI_MIS_RXMIS           0x00000004  // SSI Receive FIFO Masked
+                                            // Interrupt Status
+#define SSI_MIS_RTMIS           0x00000002  // SSI Receive Time-Out Masked
+                                            // Interrupt Status
+#define SSI_MIS_RORMIS          0x00000001  // SSI Receive Overrun Masked
+                                            // Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_ICR register.
+//
+//*****************************************************************************
+#define SSI_ICR_EOTIC           0x00000040  // End of Transmit Interrupt Clear
+#define SSI_ICR_DMATXIC         0x00000020  // SSI Transmit DMA Interrupt Clear
+#define SSI_ICR_DMARXIC         0x00000010  // SSI Receive DMA Interrupt Clear
+#define SSI_ICR_RTIC            0x00000002  // SSI Receive Time-Out Interrupt
+                                            // Clear
+#define SSI_ICR_RORIC           0x00000001  // SSI Receive Overrun Interrupt
+                                            // Clear
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_DMACTL register.
+//
+//*****************************************************************************
+#define SSI_DMACTL_TXDMAE       0x00000002  // Transmit DMA Enable
+#define SSI_DMACTL_RXDMAE       0x00000001  // Receive DMA Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_PP register.
+//
+//*****************************************************************************
+#define SSI_PP_FSSHLDFRM        0x00000008  // FSS Hold Frame Capability
+#define SSI_PP_MODE_M           0x00000006  // Mode of Operation
+#define SSI_PP_MODE_LEGACY      0x00000000  // Legacy SSI mode
+#define SSI_PP_MODE_ADVBI       0x00000002  // Legacy mode, Advanced SSI mode
+                                            // and Bi-SSI mode enabled
+#define SSI_PP_MODE_ADVBIQUAD   0x00000004  // Legacy mode, Advanced mode,
+                                            // Bi-SSI and Quad-SSI mode enabled
+#define SSI_PP_HSCLK            0x00000001  // High Speed Capability
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_CC register.
+//
+//*****************************************************************************
+#define SSI_CC_CS_M             0x0000000F  // SSI Baud Clock Source
+#define SSI_CC_CS_SYSPLL        0x00000000  // System clock (based on clock
+                                            // source and divisor factor)
+#define SSI_CC_CS_PIOSC         0x00000005  // PIOSC
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_DR register.
+//
+//*****************************************************************************
+#define UART_DR_OE              0x00000800  // UART Overrun Error
+#define UART_DR_BE              0x00000400  // UART Break Error
+#define UART_DR_PE              0x00000200  // UART Parity Error
+#define UART_DR_FE              0x00000100  // UART Framing Error
+#define UART_DR_DATA_M          0x000000FF  // Data Transmitted or Received
+#define UART_DR_DATA_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_RSR register.
+//
+//*****************************************************************************
+#define UART_RSR_OE             0x00000008  // UART Overrun Error
+#define UART_RSR_BE             0x00000004  // UART Break Error
+#define UART_RSR_PE             0x00000002  // UART Parity Error
+#define UART_RSR_FE             0x00000001  // UART Framing Error
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_ECR register.
+//
+//*****************************************************************************
+#define UART_ECR_DATA_M         0x000000FF  // Error Clear
+#define UART_ECR_DATA_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_FR register.
+//
+//*****************************************************************************
+#define UART_FR_RI              0x00000100  // Ring Indicator
+#define UART_FR_TXFE            0x00000080  // UART Transmit FIFO Empty
+#define UART_FR_RXFF            0x00000040  // UART Receive FIFO Full
+#define UART_FR_TXFF            0x00000020  // UART Transmit FIFO Full
+#define UART_FR_RXFE            0x00000010  // UART Receive FIFO Empty
+#define UART_FR_BUSY            0x00000008  // UART Busy
+#define UART_FR_DCD             0x00000004  // Data Carrier Detect
+#define UART_FR_DSR             0x00000002  // Data Set Ready
+#define UART_FR_CTS             0x00000001  // Clear To Send
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_ILPR register.
+//
+//*****************************************************************************
+#define UART_ILPR_ILPDVSR_M     0x000000FF  // IrDA Low-Power Divisor
+#define UART_ILPR_ILPDVSR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_IBRD register.
+//
+//*****************************************************************************
+#define UART_IBRD_DIVINT_M      0x0000FFFF  // Integer Baud-Rate Divisor
+#define UART_IBRD_DIVINT_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_FBRD register.
+//
+//*****************************************************************************
+#define UART_FBRD_DIVFRAC_M     0x0000003F  // Fractional Baud-Rate Divisor
+#define UART_FBRD_DIVFRAC_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_LCRH register.
+//
+//*****************************************************************************
+#define UART_LCRH_SPS           0x00000080  // UART Stick Parity Select
+#define UART_LCRH_WLEN_M        0x00000060  // UART Word Length
+#define UART_LCRH_WLEN_5        0x00000000  // 5 bits (default)
+#define UART_LCRH_WLEN_6        0x00000020  // 6 bits
+#define UART_LCRH_WLEN_7        0x00000040  // 7 bits
+#define UART_LCRH_WLEN_8        0x00000060  // 8 bits
+#define UART_LCRH_FEN           0x00000010  // UART Enable FIFOs
+#define UART_LCRH_STP2          0x00000008  // UART Two Stop Bits Select
+#define UART_LCRH_EPS           0x00000004  // UART Even Parity Select
+#define UART_LCRH_PEN           0x00000002  // UART Parity Enable
+#define UART_LCRH_BRK           0x00000001  // UART Send Break
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_CTL register.
+//
+//*****************************************************************************
+#define UART_CTL_CTSEN          0x00008000  // Enable Clear To Send
+#define UART_CTL_RTSEN          0x00004000  // Enable Request to Send
+#define UART_CTL_RTS            0x00000800  // Request to Send
+#define UART_CTL_DTR            0x00000400  // Data Terminal Ready
+#define UART_CTL_RXE            0x00000200  // UART Receive Enable
+#define UART_CTL_TXE            0x00000100  // UART Transmit Enable
+#define UART_CTL_LBE            0x00000080  // UART Loop Back Enable
+#define UART_CTL_HSE            0x00000020  // High-Speed Enable
+#define UART_CTL_EOT            0x00000010  // End of Transmission
+#define UART_CTL_SMART          0x00000008  // ISO 7816 Smart Card Support
+#define UART_CTL_SIRLP          0x00000004  // UART SIR Low-Power Mode
+#define UART_CTL_SIREN          0x00000002  // UART SIR Enable
+#define UART_CTL_UARTEN         0x00000001  // UART Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_IFLS register.
+//
+//*****************************************************************************
+#define UART_IFLS_RX_M          0x00000038  // UART Receive Interrupt FIFO
+                                            // Level Select
+#define UART_IFLS_RX1_8         0x00000000  // RX FIFO >= 1/8 full
+#define UART_IFLS_RX2_8         0x00000008  // RX FIFO >= 1/4 full
+#define UART_IFLS_RX4_8         0x00000010  // RX FIFO >= 1/2 full (default)
+#define UART_IFLS_RX6_8         0x00000018  // RX FIFO >= 3/4 full
+#define UART_IFLS_RX7_8         0x00000020  // RX FIFO >= 7/8 full
+#define UART_IFLS_TX_M          0x00000007  // UART Transmit Interrupt FIFO
+                                            // Level Select
+#define UART_IFLS_TX1_8         0x00000000  // TX FIFO <= 1/8 full
+#define UART_IFLS_TX2_8         0x00000001  // TX FIFO <= 1/4 full
+#define UART_IFLS_TX4_8         0x00000002  // TX FIFO <= 1/2 full (default)
+#define UART_IFLS_TX6_8         0x00000003  // TX FIFO <= 3/4 full
+#define UART_IFLS_TX7_8         0x00000004  // TX FIFO <= 7/8 full
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_IM register.
+//
+//*****************************************************************************
+#define UART_IM_DMATXIM         0x00020000  // Transmit DMA Interrupt Mask
+#define UART_IM_DMARXIM         0x00010000  // Receive DMA Interrupt Mask
+#define UART_IM_9BITIM          0x00001000  // 9-Bit Mode Interrupt Mask
+#define UART_IM_EOTIM           0x00000800  // End of Transmission Interrupt
+                                            // Mask
+#define UART_IM_OEIM            0x00000400  // UART Overrun Error Interrupt
+                                            // Mask
+#define UART_IM_BEIM            0x00000200  // UART Break Error Interrupt Mask
+#define UART_IM_PEIM            0x00000100  // UART Parity Error Interrupt Mask
+#define UART_IM_FEIM            0x00000080  // UART Framing Error Interrupt
+                                            // Mask
+#define UART_IM_RTIM            0x00000040  // UART Receive Time-Out Interrupt
+                                            // Mask
+#define UART_IM_TXIM            0x00000020  // UART Transmit Interrupt Mask
+#define UART_IM_RXIM            0x00000010  // UART Receive Interrupt Mask
+#define UART_IM_DSRMIM          0x00000008  // UART Data Set Ready Modem
+                                            // Interrupt Mask
+#define UART_IM_DCDMIM          0x00000004  // UART Data Carrier Detect Modem
+                                            // Interrupt Mask
+#define UART_IM_CTSMIM          0x00000002  // UART Clear to Send Modem
+                                            // Interrupt Mask
+#define UART_IM_RIMIM           0x00000001  // UART Ring Indicator Modem
+                                            // Interrupt Mask
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_RIS register.
+//
+//*****************************************************************************
+#define UART_RIS_DMATXRIS       0x00020000  // Transmit DMA Raw Interrupt
+                                            // Status
+#define UART_RIS_DMARXRIS       0x00010000  // Receive DMA Raw Interrupt Status
+#define UART_RIS_9BITRIS        0x00001000  // 9-Bit Mode Raw Interrupt Status
+#define UART_RIS_EOTRIS         0x00000800  // End of Transmission Raw
+                                            // Interrupt Status
+#define UART_RIS_OERIS          0x00000400  // UART Overrun Error Raw Interrupt
+                                            // Status
+#define UART_RIS_BERIS          0x00000200  // UART Break Error Raw Interrupt
+                                            // Status
+#define UART_RIS_PERIS          0x00000100  // UART Parity Error Raw Interrupt
+                                            // Status
+#define UART_RIS_FERIS          0x00000080  // UART Framing Error Raw Interrupt
+                                            // Status
+#define UART_RIS_RTRIS          0x00000040  // UART Receive Time-Out Raw
+                                            // Interrupt Status
+#define UART_RIS_TXRIS          0x00000020  // UART Transmit Raw Interrupt
+                                            // Status
+#define UART_RIS_RXRIS          0x00000010  // UART Receive Raw Interrupt
+                                            // Status
+#define UART_RIS_DSRRIS         0x00000008  // UART Data Set Ready Modem Raw
+                                            // Interrupt Status
+#define UART_RIS_DCDRIS         0x00000004  // UART Data Carrier Detect Modem
+                                            // Raw Interrupt Status
+#define UART_RIS_CTSRIS         0x00000002  // UART Clear to Send Modem Raw
+                                            // Interrupt Status
+#define UART_RIS_RIRIS          0x00000001  // UART Ring Indicator Modem Raw
+                                            // Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_MIS register.
+//
+//*****************************************************************************
+#define UART_MIS_DMATXMIS       0x00020000  // Transmit DMA Masked Interrupt
+                                            // Status
+#define UART_MIS_DMARXMIS       0x00010000  // Receive DMA Masked Interrupt
+                                            // Status
+#define UART_MIS_9BITMIS        0x00001000  // 9-Bit Mode Masked Interrupt
+                                            // Status
+#define UART_MIS_EOTMIS         0x00000800  // End of Transmission Masked
+                                            // Interrupt Status
+#define UART_MIS_OEMIS          0x00000400  // UART Overrun Error Masked
+                                            // Interrupt Status
+#define UART_MIS_BEMIS          0x00000200  // UART Break Error Masked
+                                            // Interrupt Status
+#define UART_MIS_PEMIS          0x00000100  // UART Parity Error Masked
+                                            // Interrupt Status
+#define UART_MIS_FEMIS          0x00000080  // UART Framing Error Masked
+                                            // Interrupt Status
+#define UART_MIS_RTMIS          0x00000040  // UART Receive Time-Out Masked
+                                            // Interrupt Status
+#define UART_MIS_TXMIS          0x00000020  // UART Transmit Masked Interrupt
+                                            // Status
+#define UART_MIS_RXMIS          0x00000010  // UART Receive Masked Interrupt
+                                            // Status
+#define UART_MIS_DSRMIS         0x00000008  // UART Data Set Ready Modem Masked
+                                            // Interrupt Status
+#define UART_MIS_DCDMIS         0x00000004  // UART Data Carrier Detect Modem
+                                            // Masked Interrupt Status
+#define UART_MIS_CTSMIS         0x00000002  // UART Clear to Send Modem Masked
+                                            // Interrupt Status
+#define UART_MIS_RIMIS          0x00000001  // UART Ring Indicator Modem Masked
+                                            // Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_ICR register.
+//
+//*****************************************************************************
+#define UART_ICR_DMATXIC        0x00020000  // Transmit DMA Interrupt Clear
+#define UART_ICR_DMARXIC        0x00010000  // Receive DMA Interrupt Clear
+#define UART_ICR_9BITIC         0x00001000  // 9-Bit Mode Interrupt Clear
+#define UART_ICR_EOTIC          0x00000800  // End of Transmission Interrupt
+                                            // Clear
+#define UART_ICR_OEIC           0x00000400  // Overrun Error Interrupt Clear
+#define UART_ICR_BEIC           0x00000200  // Break Error Interrupt Clear
+#define UART_ICR_PEIC           0x00000100  // Parity Error Interrupt Clear
+#define UART_ICR_FEIC           0x00000080  // Framing Error Interrupt Clear
+#define UART_ICR_RTIC           0x00000040  // Receive Time-Out Interrupt Clear
+#define UART_ICR_TXIC           0x00000020  // Transmit Interrupt Clear
+#define UART_ICR_RXIC           0x00000010  // Receive Interrupt Clear
+#define UART_ICR_DSRMIC         0x00000008  // UART Data Set Ready Modem
+                                            // Interrupt Clear
+#define UART_ICR_DCDMIC         0x00000004  // UART Data Carrier Detect Modem
+                                            // Interrupt Clear
+#define UART_ICR_CTSMIC         0x00000002  // UART Clear to Send Modem
+                                            // Interrupt Clear
+#define UART_ICR_RIMIC          0x00000001  // UART Ring Indicator Modem
+                                            // Interrupt Clear
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_DMACTL register.
+//
+//*****************************************************************************
+#define UART_DMACTL_DMAERR      0x00000004  // DMA on Error
+#define UART_DMACTL_TXDMAE      0x00000002  // Transmit DMA Enable
+#define UART_DMACTL_RXDMAE      0x00000001  // Receive DMA Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_9BITADDR
+// register.
+//
+//*****************************************************************************
+#define UART_9BITADDR_9BITEN    0x00008000  // Enable 9-Bit Mode
+#define UART_9BITADDR_ADDR_M    0x000000FF  // Self Address for 9-Bit Mode
+#define UART_9BITADDR_ADDR_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_9BITAMASK
+// register.
+//
+//*****************************************************************************
+#define UART_9BITAMASK_MASK_M   0x000000FF  // Self Address Mask for 9-Bit Mode
+#define UART_9BITAMASK_MASK_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_PP register.
+//
+//*****************************************************************************
+#define UART_PP_MSE             0x00000008  // Modem Support Extended
+#define UART_PP_MS              0x00000004  // Modem Support
+#define UART_PP_NB              0x00000002  // 9-Bit Support
+#define UART_PP_SC              0x00000001  // Smart Card Support
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_CC register.
+//
+//*****************************************************************************
+#define UART_CC_CS_M            0x0000000F  // UART Baud Clock Source
+#define UART_CC_CS_SYSCLK       0x00000000  // System clock (based on clock
+                                            // source and divisor factor)
+#define UART_CC_CS_PIOSC        0x00000005  // PIOSC
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MSA register.
+//
+//*****************************************************************************
+#define I2C_MSA_SA_M            0x000000FE  // I2C Slave Address
+#define I2C_MSA_RS              0x00000001  // Receive not send
+#define I2C_MSA_SA_S            1
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MCS register.
+//
+//*****************************************************************************
+#define I2C_MCS_ACTDMARX        0x80000000  // DMA RX Active Status
+#define I2C_MCS_ACTDMATX        0x40000000  // DMA TX Active Status
+#define I2C_MCS_CLKTO           0x00000080  // Clock Timeout Error
+#define I2C_MCS_BURST           0x00000040  // Burst Enable
+#define I2C_MCS_BUSBSY          0x00000040  // Bus Busy
+#define I2C_MCS_IDLE            0x00000020  // I2C Idle
+#define I2C_MCS_QCMD            0x00000020  // Quick Command
+#define I2C_MCS_ARBLST          0x00000010  // Arbitration Lost
+#define I2C_MCS_HS              0x00000010  // High-Speed Enable
+#define I2C_MCS_ACK             0x00000008  // Data Acknowledge Enable
+#define I2C_MCS_DATACK          0x00000008  // Acknowledge Data
+#define I2C_MCS_ADRACK          0x00000004  // Acknowledge Address
+#define I2C_MCS_STOP            0x00000004  // Generate STOP
+#define I2C_MCS_ERROR           0x00000002  // Error
+#define I2C_MCS_START           0x00000002  // Generate START
+#define I2C_MCS_RUN             0x00000001  // I2C Master Enable
+#define I2C_MCS_BUSY            0x00000001  // I2C Busy
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MDR register.
+//
+//*****************************************************************************
+#define I2C_MDR_DATA_M          0x000000FF  // This byte contains the data
+                                            // transferred during a transaction
+#define I2C_MDR_DATA_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MTPR register.
+//
+//*****************************************************************************
+#define I2C_MTPR_PULSEL_M       0x00070000  // Glitch Suppression Pulse Width
+#define I2C_MTPR_PULSEL_BYPASS  0x00000000  // Bypass
+#define I2C_MTPR_PULSEL_1       0x00010000  // 1 clock
+#define I2C_MTPR_PULSEL_2       0x00020000  // 2 clocks
+#define I2C_MTPR_PULSEL_3       0x00030000  // 3 clocks
+#define I2C_MTPR_PULSEL_4       0x00040000  // 4 clocks
+#define I2C_MTPR_PULSEL_8       0x00050000  // 8 clocks
+#define I2C_MTPR_PULSEL_16      0x00060000  // 16 clocks
+#define I2C_MTPR_PULSEL_31      0x00070000  // 31 clocks
+#define I2C_MTPR_HS             0x00000080  // High-Speed Enable
+#define I2C_MTPR_TPR_M          0x0000007F  // Timer Period
+#define I2C_MTPR_TPR_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MIMR register.
+//
+//*****************************************************************************
+#define I2C_MIMR_RXFFIM         0x00000800  // Receive FIFO Full Interrupt Mask
+#define I2C_MIMR_TXFEIM         0x00000400  // Transmit FIFO Empty Interrupt
+                                            // Mask
+#define I2C_MIMR_RXIM           0x00000200  // Receive FIFO Request Interrupt
+                                            // Mask
+#define I2C_MIMR_TXIM           0x00000100  // Transmit FIFO Request Interrupt
+                                            // Mask
+#define I2C_MIMR_ARBLOSTIM      0x00000080  // Arbitration Lost Interrupt Mask
+#define I2C_MIMR_STOPIM         0x00000040  // STOP Detection Interrupt Mask
+#define I2C_MIMR_STARTIM        0x00000020  // START Detection Interrupt Mask
+#define I2C_MIMR_NACKIM         0x00000010  // Address/Data NACK Interrupt Mask
+#define I2C_MIMR_DMATXIM        0x00000008  // Transmit DMA Interrupt Mask
+#define I2C_MIMR_DMARXIM        0x00000004  // Receive DMA Interrupt Mask
+#define I2C_MIMR_CLKIM          0x00000002  // Clock Timeout Interrupt Mask
+#define I2C_MIMR_IM             0x00000001  // Master Interrupt Mask
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MRIS register.
+//
+//*****************************************************************************
+#define I2C_MRIS_RXFFRIS        0x00000800  // Receive FIFO Full Raw Interrupt
+                                            // Status
+#define I2C_MRIS_TXFERIS        0x00000400  // Transmit FIFO Empty Raw
+                                            // Interrupt Status
+#define I2C_MRIS_RXRIS          0x00000200  // Receive FIFO Request Raw
+                                            // Interrupt Status
+#define I2C_MRIS_TXRIS          0x00000100  // Transmit Request Raw Interrupt
+                                            // Status
+#define I2C_MRIS_ARBLOSTRIS     0x00000080  // Arbitration Lost Raw Interrupt
+                                            // Status
+#define I2C_MRIS_STOPRIS        0x00000040  // STOP Detection Raw Interrupt
+                                            // Status
+#define I2C_MRIS_STARTRIS       0x00000020  // START Detection Raw Interrupt
+                                            // Status
+#define I2C_MRIS_NACKRIS        0x00000010  // Address/Data NACK Raw Interrupt
+                                            // Status
+#define I2C_MRIS_DMATXRIS       0x00000008  // Transmit DMA Raw Interrupt
+                                            // Status
+#define I2C_MRIS_DMARXRIS       0x00000004  // Receive DMA Raw Interrupt Status
+#define I2C_MRIS_CLKRIS         0x00000002  // Clock Timeout Raw Interrupt
+                                            // Status
+#define I2C_MRIS_RIS            0x00000001  // Master Raw Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MMIS register.
+//
+//*****************************************************************************
+#define I2C_MMIS_RXFFMIS        0x00000800  // Receive FIFO Full Interrupt Mask
+#define I2C_MMIS_TXFEMIS        0x00000400  // Transmit FIFO Empty Interrupt
+                                            // Mask
+#define I2C_MMIS_RXMIS          0x00000200  // Receive FIFO Request Interrupt
+                                            // Mask
+#define I2C_MMIS_TXMIS          0x00000100  // Transmit Request Interrupt Mask
+#define I2C_MMIS_ARBLOSTMIS     0x00000080  // Arbitration Lost Interrupt Mask
+#define I2C_MMIS_STOPMIS        0x00000040  // STOP Detection Interrupt Mask
+#define I2C_MMIS_STARTMIS       0x00000020  // START Detection Interrupt Mask
+#define I2C_MMIS_NACKMIS        0x00000010  // Address/Data NACK Interrupt Mask
+#define I2C_MMIS_DMATXMIS       0x00000008  // Transmit DMA Interrupt Status
+#define I2C_MMIS_DMARXMIS       0x00000004  // Receive DMA Interrupt Status
+#define I2C_MMIS_CLKMIS         0x00000002  // Clock Timeout Masked Interrupt
+                                            // Status
+#define I2C_MMIS_MIS            0x00000001  // Masked Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MICR register.
+//
+//*****************************************************************************
+#define I2C_MICR_RXFFIC         0x00000800  // Receive FIFO Full Interrupt
+                                            // Clear
+#define I2C_MICR_TXFEIC         0x00000400  // Transmit FIFO Empty Interrupt
+                                            // Clear
+#define I2C_MICR_RXIC           0x00000200  // Receive FIFO Request Interrupt
+                                            // Clear
+#define I2C_MICR_TXIC           0x00000100  // Transmit FIFO Request Interrupt
+                                            // Clear
+#define I2C_MICR_ARBLOSTIC      0x00000080  // Arbitration Lost Interrupt Clear
+#define I2C_MICR_STOPIC         0x00000040  // STOP Detection Interrupt Clear
+#define I2C_MICR_STARTIC        0x00000020  // START Detection Interrupt Clear
+#define I2C_MICR_NACKIC         0x00000010  // Address/Data NACK Interrupt
+                                            // Clear
+#define I2C_MICR_DMATXIC        0x00000008  // Transmit DMA Interrupt Clear
+#define I2C_MICR_DMARXIC        0x00000004  // Receive DMA Interrupt Clear
+#define I2C_MICR_CLKIC          0x00000002  // Clock Timeout Interrupt Clear
+#define I2C_MICR_IC             0x00000001  // Master Interrupt Clear
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MCR register.
+//
+//*****************************************************************************
+#define I2C_MCR_SFE             0x00000020  // I2C Slave Function Enable
+#define I2C_MCR_MFE             0x00000010  // I2C Master Function Enable
+#define I2C_MCR_LPBK            0x00000001  // I2C Loopback
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MCLKOCNT register.
+//
+//*****************************************************************************
+#define I2C_MCLKOCNT_CNTL_M     0x000000FF  // I2C Master Count
+#define I2C_MCLKOCNT_CNTL_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MBMON register.
+//
+//*****************************************************************************
+#define I2C_MBMON_SDA           0x00000002  // I2C SDA Status
+#define I2C_MBMON_SCL           0x00000001  // I2C SCL Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MBLEN register.
+//
+//*****************************************************************************
+#define I2C_MBLEN_CNTL_M        0x000000FF  // I2C Burst Length
+#define I2C_MBLEN_CNTL_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MBCNT register.
+//
+//*****************************************************************************
+#define I2C_MBCNT_CNTL_M        0x000000FF  // I2C Master Burst Count
+#define I2C_MBCNT_CNTL_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SOAR register.
+//
+//*****************************************************************************
+#define I2C_SOAR_OAR_M          0x0000007F  // I2C Slave Own Address
+#define I2C_SOAR_OAR_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SCSR register.
+//
+//*****************************************************************************
+#define I2C_SCSR_ACTDMARX       0x80000000  // DMA RX Active Status
+#define I2C_SCSR_ACTDMATX       0x40000000  // DMA TX Active Status
+#define I2C_SCSR_QCMDRW         0x00000020  // Quick Command Read / Write
+#define I2C_SCSR_QCMDST         0x00000010  // Quick Command Status
+#define I2C_SCSR_OAR2SEL        0x00000008  // OAR2 Address Matched
+#define I2C_SCSR_FBR            0x00000004  // First Byte Received
+#define I2C_SCSR_RXFIFO         0x00000004  // RX FIFO Enable
+#define I2C_SCSR_TXFIFO         0x00000002  // TX FIFO Enable
+#define I2C_SCSR_TREQ           0x00000002  // Transmit Request
+#define I2C_SCSR_DA             0x00000001  // Device Active
+#define I2C_SCSR_RREQ           0x00000001  // Receive Request
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SDR register.
+//
+//*****************************************************************************
+#define I2C_SDR_DATA_M          0x000000FF  // Data for Transfer
+#define I2C_SDR_DATA_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SIMR register.
+//
+//*****************************************************************************
+#define I2C_SIMR_RXFFIM         0x00000100  // Receive FIFO Full Interrupt Mask
+#define I2C_SIMR_TXFEIM         0x00000080  // Transmit FIFO Empty Interrupt
+                                            // Mask
+#define I2C_SIMR_RXIM           0x00000040  // Receive FIFO Request Interrupt
+                                            // Mask
+#define I2C_SIMR_TXIM           0x00000020  // Transmit FIFO Request Interrupt
+                                            // Mask
+#define I2C_SIMR_DMATXIM        0x00000010  // Transmit DMA Interrupt Mask
+#define I2C_SIMR_DMARXIM        0x00000008  // Receive DMA Interrupt Mask
+#define I2C_SIMR_STOPIM         0x00000004  // Stop Condition Interrupt Mask
+#define I2C_SIMR_STARTIM        0x00000002  // Start Condition Interrupt Mask
+#define I2C_SIMR_DATAIM         0x00000001  // Data Interrupt Mask
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SRIS register.
+//
+//*****************************************************************************
+#define I2C_SRIS_RXFFRIS        0x00000100  // Receive FIFO Full Raw Interrupt
+                                            // Status
+#define I2C_SRIS_TXFERIS        0x00000080  // Transmit FIFO Empty Raw
+                                            // Interrupt Status
+#define I2C_SRIS_RXRIS          0x00000040  // Receive FIFO Request Raw
+                                            // Interrupt Status
+#define I2C_SRIS_TXRIS          0x00000020  // Transmit Request Raw Interrupt
+                                            // Status
+#define I2C_SRIS_DMATXRIS       0x00000010  // Transmit DMA Raw Interrupt
+                                            // Status
+#define I2C_SRIS_DMARXRIS       0x00000008  // Receive DMA Raw Interrupt Status
+#define I2C_SRIS_STOPRIS        0x00000004  // Stop Condition Raw Interrupt
+                                            // Status
+#define I2C_SRIS_STARTRIS       0x00000002  // Start Condition Raw Interrupt
+                                            // Status
+#define I2C_SRIS_DATARIS        0x00000001  // Data Raw Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SMIS register.
+//
+//*****************************************************************************
+#define I2C_SMIS_RXFFMIS        0x00000100  // Receive FIFO Full Interrupt Mask
+#define I2C_SMIS_TXFEMIS        0x00000080  // Transmit FIFO Empty Interrupt
+                                            // Mask
+#define I2C_SMIS_RXMIS          0x00000040  // Receive FIFO Request Interrupt
+                                            // Mask
+#define I2C_SMIS_TXMIS          0x00000020  // Transmit FIFO Request Interrupt
+                                            // Mask
+#define I2C_SMIS_DMATXMIS       0x00000010  // Transmit DMA Masked Interrupt
+                                            // Status
+#define I2C_SMIS_DMARXMIS       0x00000008  // Receive DMA Masked Interrupt
+                                            // Status
+#define I2C_SMIS_STOPMIS        0x00000004  // Stop Condition Masked Interrupt
+                                            // Status
+#define I2C_SMIS_STARTMIS       0x00000002  // Start Condition Masked Interrupt
+                                            // Status
+#define I2C_SMIS_DATAMIS        0x00000001  // Data Masked Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SICR register.
+//
+//*****************************************************************************
+#define I2C_SICR_RXFFIC         0x00000100  // Receive FIFO Full Interrupt Mask
+#define I2C_SICR_TXFEIC         0x00000080  // Transmit FIFO Empty Interrupt
+                                            // Mask
+#define I2C_SICR_RXIC           0x00000040  // Receive Request Interrupt Mask
+#define I2C_SICR_TXIC           0x00000020  // Transmit Request Interrupt Mask
+#define I2C_SICR_DMATXIC        0x00000010  // Transmit DMA Interrupt Clear
+#define I2C_SICR_DMARXIC        0x00000008  // Receive DMA Interrupt Clear
+#define I2C_SICR_STOPIC         0x00000004  // Stop Condition Interrupt Clear
+#define I2C_SICR_STARTIC        0x00000002  // Start Condition Interrupt Clear
+#define I2C_SICR_DATAIC         0x00000001  // Data Interrupt Clear
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SOAR2 register.
+//
+//*****************************************************************************
+#define I2C_SOAR2_OAR2EN        0x00000080  // I2C Slave Own Address 2 Enable
+#define I2C_SOAR2_OAR2_M        0x0000007F  // I2C Slave Own Address 2
+#define I2C_SOAR2_OAR2_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SACKCTL register.
+//
+//*****************************************************************************
+#define I2C_SACKCTL_ACKOVAL     0x00000002  // I2C Slave ACK Override Value
+#define I2C_SACKCTL_ACKOEN      0x00000001  // I2C Slave ACK Override Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_FIFODATA register.
+//
+//*****************************************************************************
+#define I2C_FIFODATA_DATA_M     0x000000FF  // I2C TX FIFO Write Data Byte
+#define I2C_FIFODATA_DATA_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_FIFOCTL register.
+//
+//*****************************************************************************
+#define I2C_FIFOCTL_RXASGNMT    0x80000000  // RX Control Assignment
+#define I2C_FIFOCTL_RXFLUSH     0x40000000  // RX FIFO Flush
+#define I2C_FIFOCTL_DMARXENA    0x20000000  // DMA RX Channel Enable
+#define I2C_FIFOCTL_RXTRIG_M    0x00070000  // RX FIFO Trigger
+#define I2C_FIFOCTL_TXASGNMT    0x00008000  // TX Control Assignment
+#define I2C_FIFOCTL_TXFLUSH     0x00004000  // TX FIFO Flush
+#define I2C_FIFOCTL_DMATXENA    0x00002000  // DMA TX Channel Enable
+#define I2C_FIFOCTL_TXTRIG_M    0x00000007  // TX FIFO Trigger
+#define I2C_FIFOCTL_RXTRIG_S    16
+#define I2C_FIFOCTL_TXTRIG_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_FIFOSTATUS
+// register.
+//
+//*****************************************************************************
+#define I2C_FIFOSTATUS_RXABVTRIG                                              \
+                                0x00040000  // RX FIFO Above Trigger Level
+#define I2C_FIFOSTATUS_RXFF     0x00020000  // RX FIFO Full
+#define I2C_FIFOSTATUS_RXFE     0x00010000  // RX FIFO Empty
+#define I2C_FIFOSTATUS_TXBLWTRIG                                              \
+                                0x00000004  // TX FIFO Below Trigger Level
+#define I2C_FIFOSTATUS_TXFF     0x00000002  // TX FIFO Full
+#define I2C_FIFOSTATUS_TXFE     0x00000001  // TX FIFO Empty
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_PP register.
+//
+//*****************************************************************************
+#define I2C_PP_HS               0x00000001  // High-Speed Capable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_PC register.
+//
+//*****************************************************************************
+#define I2C_PC_HS               0x00000001  // High-Speed Capable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_CTL register.
+//
+//*****************************************************************************
+#define PWM_CTL_GLOBALSYNC3     0x00000008  // Update PWM Generator 3
+#define PWM_CTL_GLOBALSYNC2     0x00000004  // Update PWM Generator 2
+#define PWM_CTL_GLOBALSYNC1     0x00000002  // Update PWM Generator 1
+#define PWM_CTL_GLOBALSYNC0     0x00000001  // Update PWM Generator 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_SYNC register.
+//
+//*****************************************************************************
+#define PWM_SYNC_SYNC3          0x00000008  // Reset Generator 3 Counter
+#define PWM_SYNC_SYNC2          0x00000004  // Reset Generator 2 Counter
+#define PWM_SYNC_SYNC1          0x00000002  // Reset Generator 1 Counter
+#define PWM_SYNC_SYNC0          0x00000001  // Reset Generator 0 Counter
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_ENABLE register.
+//
+//*****************************************************************************
+#define PWM_ENABLE_PWM7EN       0x00000080  // MnPWM7 Output Enable
+#define PWM_ENABLE_PWM6EN       0x00000040  // MnPWM6 Output Enable
+#define PWM_ENABLE_PWM5EN       0x00000020  // MnPWM5 Output Enable
+#define PWM_ENABLE_PWM4EN       0x00000010  // MnPWM4 Output Enable
+#define PWM_ENABLE_PWM3EN       0x00000008  // MnPWM3 Output Enable
+#define PWM_ENABLE_PWM2EN       0x00000004  // MnPWM2 Output Enable
+#define PWM_ENABLE_PWM1EN       0x00000002  // MnPWM1 Output Enable
+#define PWM_ENABLE_PWM0EN       0x00000001  // MnPWM0 Output Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_INVERT register.
+//
+//*****************************************************************************
+#define PWM_INVERT_PWM7INV      0x00000080  // Invert MnPWM7 Signal
+#define PWM_INVERT_PWM6INV      0x00000040  // Invert MnPWM6 Signal
+#define PWM_INVERT_PWM5INV      0x00000020  // Invert MnPWM5 Signal
+#define PWM_INVERT_PWM4INV      0x00000010  // Invert MnPWM4 Signal
+#define PWM_INVERT_PWM3INV      0x00000008  // Invert MnPWM3 Signal
+#define PWM_INVERT_PWM2INV      0x00000004  // Invert MnPWM2 Signal
+#define PWM_INVERT_PWM1INV      0x00000002  // Invert MnPWM1 Signal
+#define PWM_INVERT_PWM0INV      0x00000001  // Invert MnPWM0 Signal
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_FAULT register.
+//
+//*****************************************************************************
+#define PWM_FAULT_FAULT7        0x00000080  // MnPWM7 Fault
+#define PWM_FAULT_FAULT6        0x00000040  // MnPWM6 Fault
+#define PWM_FAULT_FAULT5        0x00000020  // MnPWM5 Fault
+#define PWM_FAULT_FAULT4        0x00000010  // MnPWM4 Fault
+#define PWM_FAULT_FAULT3        0x00000008  // MnPWM3 Fault
+#define PWM_FAULT_FAULT2        0x00000004  // MnPWM2 Fault
+#define PWM_FAULT_FAULT1        0x00000002  // MnPWM1 Fault
+#define PWM_FAULT_FAULT0        0x00000001  // MnPWM0 Fault
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_INTEN register.
+//
+//*****************************************************************************
+#define PWM_INTEN_INTFAULT3     0x00080000  // Interrupt Fault 3
+#define PWM_INTEN_INTFAULT2     0x00040000  // Interrupt Fault 2
+#define PWM_INTEN_INTFAULT1     0x00020000  // Interrupt Fault 1
+#define PWM_INTEN_INTFAULT0     0x00010000  // Interrupt Fault 0
+#define PWM_INTEN_INTPWM3       0x00000008  // PWM3 Interrupt Enable
+#define PWM_INTEN_INTPWM2       0x00000004  // PWM2 Interrupt Enable
+#define PWM_INTEN_INTPWM1       0x00000002  // PWM1 Interrupt Enable
+#define PWM_INTEN_INTPWM0       0x00000001  // PWM0 Interrupt Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_RIS register.
+//
+//*****************************************************************************
+#define PWM_RIS_INTFAULT3       0x00080000  // Interrupt Fault PWM 3
+#define PWM_RIS_INTFAULT2       0x00040000  // Interrupt Fault PWM 2
+#define PWM_RIS_INTFAULT1       0x00020000  // Interrupt Fault PWM 1
+#define PWM_RIS_INTFAULT0       0x00010000  // Interrupt Fault PWM 0
+#define PWM_RIS_INTPWM3         0x00000008  // PWM3 Interrupt Asserted
+#define PWM_RIS_INTPWM2         0x00000004  // PWM2 Interrupt Asserted
+#define PWM_RIS_INTPWM1         0x00000002  // PWM1 Interrupt Asserted
+#define PWM_RIS_INTPWM0         0x00000001  // PWM0 Interrupt Asserted
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_ISC register.
+//
+//*****************************************************************************
+#define PWM_ISC_INTFAULT3       0x00080000  // FAULT3 Interrupt Asserted
+#define PWM_ISC_INTFAULT2       0x00040000  // FAULT2 Interrupt Asserted
+#define PWM_ISC_INTFAULT1       0x00020000  // FAULT1 Interrupt Asserted
+#define PWM_ISC_INTFAULT0       0x00010000  // FAULT0 Interrupt Asserted
+#define PWM_ISC_INTPWM3         0x00000008  // PWM3 Interrupt Status
+#define PWM_ISC_INTPWM2         0x00000004  // PWM2 Interrupt Status
+#define PWM_ISC_INTPWM1         0x00000002  // PWM1 Interrupt Status
+#define PWM_ISC_INTPWM0         0x00000001  // PWM0 Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_STATUS register.
+//
+//*****************************************************************************
+#define PWM_STATUS_FAULT3       0x00000008  // Generator 3 Fault Status
+#define PWM_STATUS_FAULT2       0x00000004  // Generator 2 Fault Status
+#define PWM_STATUS_FAULT1       0x00000002  // Generator 1 Fault Status
+#define PWM_STATUS_FAULT0       0x00000001  // Generator 0 Fault Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_FAULTVAL register.
+//
+//*****************************************************************************
+#define PWM_FAULTVAL_PWM7       0x00000080  // MnPWM7 Fault Value
+#define PWM_FAULTVAL_PWM6       0x00000040  // MnPWM6 Fault Value
+#define PWM_FAULTVAL_PWM5       0x00000020  // MnPWM5 Fault Value
+#define PWM_FAULTVAL_PWM4       0x00000010  // MnPWM4 Fault Value
+#define PWM_FAULTVAL_PWM3       0x00000008  // MnPWM3 Fault Value
+#define PWM_FAULTVAL_PWM2       0x00000004  // MnPWM2 Fault Value
+#define PWM_FAULTVAL_PWM1       0x00000002  // MnPWM1 Fault Value
+#define PWM_FAULTVAL_PWM0       0x00000001  // MnPWM0 Fault Value
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_ENUPD register.
+//
+//*****************************************************************************
+#define PWM_ENUPD_ENUPD7_M      0x0000C000  // MnPWM7 Enable Update Mode
+#define PWM_ENUPD_ENUPD7_IMM    0x00000000  // Immediate
+#define PWM_ENUPD_ENUPD7_LSYNC  0x00008000  // Locally Synchronized
+#define PWM_ENUPD_ENUPD7_GSYNC  0x0000C000  // Globally Synchronized
+#define PWM_ENUPD_ENUPD6_M      0x00003000  // MnPWM6 Enable Update Mode
+#define PWM_ENUPD_ENUPD6_IMM    0x00000000  // Immediate
+#define PWM_ENUPD_ENUPD6_LSYNC  0x00002000  // Locally Synchronized
+#define PWM_ENUPD_ENUPD6_GSYNC  0x00003000  // Globally Synchronized
+#define PWM_ENUPD_ENUPD5_M      0x00000C00  // MnPWM5 Enable Update Mode
+#define PWM_ENUPD_ENUPD5_IMM    0x00000000  // Immediate
+#define PWM_ENUPD_ENUPD5_LSYNC  0x00000800  // Locally Synchronized
+#define PWM_ENUPD_ENUPD5_GSYNC  0x00000C00  // Globally Synchronized
+#define PWM_ENUPD_ENUPD4_M      0x00000300  // MnPWM4 Enable Update Mode
+#define PWM_ENUPD_ENUPD4_IMM    0x00000000  // Immediate
+#define PWM_ENUPD_ENUPD4_LSYNC  0x00000200  // Locally Synchronized
+#define PWM_ENUPD_ENUPD4_GSYNC  0x00000300  // Globally Synchronized
+#define PWM_ENUPD_ENUPD3_M      0x000000C0  // MnPWM3 Enable Update Mode
+#define PWM_ENUPD_ENUPD3_IMM    0x00000000  // Immediate
+#define PWM_ENUPD_ENUPD3_LSYNC  0x00000080  // Locally Synchronized
+#define PWM_ENUPD_ENUPD3_GSYNC  0x000000C0  // Globally Synchronized
+#define PWM_ENUPD_ENUPD2_M      0x00000030  // MnPWM2 Enable Update Mode
+#define PWM_ENUPD_ENUPD2_IMM    0x00000000  // Immediate
+#define PWM_ENUPD_ENUPD2_LSYNC  0x00000020  // Locally Synchronized
+#define PWM_ENUPD_ENUPD2_GSYNC  0x00000030  // Globally Synchronized
+#define PWM_ENUPD_ENUPD1_M      0x0000000C  // MnPWM1 Enable Update Mode
+#define PWM_ENUPD_ENUPD1_IMM    0x00000000  // Immediate
+#define PWM_ENUPD_ENUPD1_LSYNC  0x00000008  // Locally Synchronized
+#define PWM_ENUPD_ENUPD1_GSYNC  0x0000000C  // Globally Synchronized
+#define PWM_ENUPD_ENUPD0_M      0x00000003  // MnPWM0 Enable Update Mode
+#define PWM_ENUPD_ENUPD0_IMM    0x00000000  // Immediate
+#define PWM_ENUPD_ENUPD0_LSYNC  0x00000002  // Locally Synchronized
+#define PWM_ENUPD_ENUPD0_GSYNC  0x00000003  // Globally Synchronized
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_CTL register.
+//
+//*****************************************************************************
+#define PWM_0_CTL_LATCH         0x00040000  // Latch Fault Input
+#define PWM_0_CTL_MINFLTPER     0x00020000  // Minimum Fault Period
+#define PWM_0_CTL_FLTSRC        0x00010000  // Fault Condition Source
+#define PWM_0_CTL_DBFALLUPD_M   0x0000C000  // PWMnDBFALL Update Mode
+#define PWM_0_CTL_DBFALLUPD_I   0x00000000  // Immediate
+#define PWM_0_CTL_DBFALLUPD_LS  0x00008000  // Locally Synchronized
+#define PWM_0_CTL_DBFALLUPD_GS  0x0000C000  // Globally Synchronized
+#define PWM_0_CTL_DBRISEUPD_M   0x00003000  // PWMnDBRISE Update Mode
+#define PWM_0_CTL_DBRISEUPD_I   0x00000000  // Immediate
+#define PWM_0_CTL_DBRISEUPD_LS  0x00002000  // Locally Synchronized
+#define PWM_0_CTL_DBRISEUPD_GS  0x00003000  // Globally Synchronized
+#define PWM_0_CTL_DBCTLUPD_M    0x00000C00  // PWMnDBCTL Update Mode
+#define PWM_0_CTL_DBCTLUPD_I    0x00000000  // Immediate
+#define PWM_0_CTL_DBCTLUPD_LS   0x00000800  // Locally Synchronized
+#define PWM_0_CTL_DBCTLUPD_GS   0x00000C00  // Globally Synchronized
+#define PWM_0_CTL_GENBUPD_M     0x00000300  // PWMnGENB Update Mode
+#define PWM_0_CTL_GENBUPD_I     0x00000000  // Immediate
+#define PWM_0_CTL_GENBUPD_LS    0x00000200  // Locally Synchronized
+#define PWM_0_CTL_GENBUPD_GS    0x00000300  // Globally Synchronized
+#define PWM_0_CTL_GENAUPD_M     0x000000C0  // PWMnGENA Update Mode
+#define PWM_0_CTL_GENAUPD_I     0x00000000  // Immediate
+#define PWM_0_CTL_GENAUPD_LS    0x00000080  // Locally Synchronized
+#define PWM_0_CTL_GENAUPD_GS    0x000000C0  // Globally Synchronized
+#define PWM_0_CTL_CMPBUPD       0x00000020  // Comparator B Update Mode
+#define PWM_0_CTL_CMPAUPD       0x00000010  // Comparator A Update Mode
+#define PWM_0_CTL_LOADUPD       0x00000008  // Load Register Update Mode
+#define PWM_0_CTL_DEBUG         0x00000004  // Debug Mode
+#define PWM_0_CTL_MODE          0x00000002  // Counter Mode
+#define PWM_0_CTL_ENABLE        0x00000001  // PWM Block Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_INTEN register.
+//
+//*****************************************************************************
+#define PWM_0_INTEN_TRCMPBD     0x00002000  // Trigger for Counter=PWMnCMPB
+                                            // Down
+#define PWM_0_INTEN_TRCMPBU     0x00001000  // Trigger for Counter=PWMnCMPB Up
+#define PWM_0_INTEN_TRCMPAD     0x00000800  // Trigger for Counter=PWMnCMPA
+                                            // Down
+#define PWM_0_INTEN_TRCMPAU     0x00000400  // Trigger for Counter=PWMnCMPA Up
+#define PWM_0_INTEN_TRCNTLOAD   0x00000200  // Trigger for Counter=PWMnLOAD
+#define PWM_0_INTEN_TRCNTZERO   0x00000100  // Trigger for Counter=0
+#define PWM_0_INTEN_INTCMPBD    0x00000020  // Interrupt for Counter=PWMnCMPB
+                                            // Down
+#define PWM_0_INTEN_INTCMPBU    0x00000010  // Interrupt for Counter=PWMnCMPB
+                                            // Up
+#define PWM_0_INTEN_INTCMPAD    0x00000008  // Interrupt for Counter=PWMnCMPA
+                                            // Down
+#define PWM_0_INTEN_INTCMPAU    0x00000004  // Interrupt for Counter=PWMnCMPA
+                                            // Up
+#define PWM_0_INTEN_INTCNTLOAD  0x00000002  // Interrupt for Counter=PWMnLOAD
+#define PWM_0_INTEN_INTCNTZERO  0x00000001  // Interrupt for Counter=0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_RIS register.
+//
+//*****************************************************************************
+#define PWM_0_RIS_INTCMPBD      0x00000020  // Comparator B Down Interrupt
+                                            // Status
+#define PWM_0_RIS_INTCMPBU      0x00000010  // Comparator B Up Interrupt Status
+#define PWM_0_RIS_INTCMPAD      0x00000008  // Comparator A Down Interrupt
+                                            // Status
+#define PWM_0_RIS_INTCMPAU      0x00000004  // Comparator A Up Interrupt Status
+#define PWM_0_RIS_INTCNTLOAD    0x00000002  // Counter=Load Interrupt Status
+#define PWM_0_RIS_INTCNTZERO    0x00000001  // Counter=0 Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_ISC register.
+//
+//*****************************************************************************
+#define PWM_0_ISC_INTCMPBD      0x00000020  // Comparator B Down Interrupt
+#define PWM_0_ISC_INTCMPBU      0x00000010  // Comparator B Up Interrupt
+#define PWM_0_ISC_INTCMPAD      0x00000008  // Comparator A Down Interrupt
+#define PWM_0_ISC_INTCMPAU      0x00000004  // Comparator A Up Interrupt
+#define PWM_0_ISC_INTCNTLOAD    0x00000002  // Counter=Load Interrupt
+#define PWM_0_ISC_INTCNTZERO    0x00000001  // Counter=0 Interrupt
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_LOAD register.
+//
+//*****************************************************************************
+#define PWM_0_LOAD_M            0x0000FFFF  // Counter Load Value
+#define PWM_0_LOAD_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_COUNT register.
+//
+//*****************************************************************************
+#define PWM_0_COUNT_M           0x0000FFFF  // Counter Value
+#define PWM_0_COUNT_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_CMPA register.
+//
+//*****************************************************************************
+#define PWM_0_CMPA_M            0x0000FFFF  // Comparator A Value
+#define PWM_0_CMPA_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_CMPB register.
+//
+//*****************************************************************************
+#define PWM_0_CMPB_M            0x0000FFFF  // Comparator B Value
+#define PWM_0_CMPB_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_GENA register.
+//
+//*****************************************************************************
+#define PWM_0_GENA_ACTCMPBD_M   0x00000C00  // Action for Comparator B Down
+#define PWM_0_GENA_ACTCMPBD_NONE                                              \
+                                0x00000000  // Do nothing
+#define PWM_0_GENA_ACTCMPBD_INV 0x00000400  // Invert pwmA
+#define PWM_0_GENA_ACTCMPBD_ZERO                                              \
+                                0x00000800  // Drive pwmA Low
+#define PWM_0_GENA_ACTCMPBD_ONE 0x00000C00  // Drive pwmA High
+#define PWM_0_GENA_ACTCMPBU_M   0x00000300  // Action for Comparator B Up
+#define PWM_0_GENA_ACTCMPBU_NONE                                              \
+                                0x00000000  // Do nothing
+#define PWM_0_GENA_ACTCMPBU_INV 0x00000100  // Invert pwmA
+#define PWM_0_GENA_ACTCMPBU_ZERO                                              \
+                                0x00000200  // Drive pwmA Low
+#define PWM_0_GENA_ACTCMPBU_ONE 0x00000300  // Drive pwmA High
+#define PWM_0_GENA_ACTCMPAD_M   0x000000C0  // Action for Comparator A Down
+#define PWM_0_GENA_ACTCMPAD_NONE                                              \
+                                0x00000000  // Do nothing
+#define PWM_0_GENA_ACTCMPAD_INV 0x00000040  // Invert pwmA
+#define PWM_0_GENA_ACTCMPAD_ZERO                                              \
+                                0x00000080  // Drive pwmA Low
+#define PWM_0_GENA_ACTCMPAD_ONE 0x000000C0  // Drive pwmA High
+#define PWM_0_GENA_ACTCMPAU_M   0x00000030  // Action for Comparator A Up
+#define PWM_0_GENA_ACTCMPAU_NONE                                              \
+                                0x00000000  // Do nothing
+#define PWM_0_GENA_ACTCMPAU_INV 0x00000010  // Invert pwmA
+#define PWM_0_GENA_ACTCMPAU_ZERO                                              \
+                                0x00000020  // Drive pwmA Low
+#define PWM_0_GENA_ACTCMPAU_ONE 0x00000030  // Drive pwmA High
+#define PWM_0_GENA_ACTLOAD_M    0x0000000C  // Action for Counter=LOAD
+#define PWM_0_GENA_ACTLOAD_NONE 0x00000000  // Do nothing
+#define PWM_0_GENA_ACTLOAD_INV  0x00000004  // Invert pwmA
+#define PWM_0_GENA_ACTLOAD_ZERO 0x00000008  // Drive pwmA Low
+#define PWM_0_GENA_ACTLOAD_ONE  0x0000000C  // Drive pwmA High
+#define PWM_0_GENA_ACTZERO_M    0x00000003  // Action for Counter=0
+#define PWM_0_GENA_ACTZERO_NONE 0x00000000  // Do nothing
+#define PWM_0_GENA_ACTZERO_INV  0x00000001  // Invert pwmA
+#define PWM_0_GENA_ACTZERO_ZERO 0x00000002  // Drive pwmA Low
+#define PWM_0_GENA_ACTZERO_ONE  0x00000003  // Drive pwmA High
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_GENB register.
+//
+//*****************************************************************************
+#define PWM_0_GENB_ACTCMPBD_M   0x00000C00  // Action for Comparator B Down
+#define PWM_0_GENB_ACTCMPBD_NONE                                              \
+                                0x00000000  // Do nothing
+#define PWM_0_GENB_ACTCMPBD_INV 0x00000400  // Invert pwmB
+#define PWM_0_GENB_ACTCMPBD_ZERO                                              \
+                                0x00000800  // Drive pwmB Low
+#define PWM_0_GENB_ACTCMPBD_ONE 0x00000C00  // Drive pwmB High
+#define PWM_0_GENB_ACTCMPBU_M   0x00000300  // Action for Comparator B Up
+#define PWM_0_GENB_ACTCMPBU_NONE                                              \
+                                0x00000000  // Do nothing
+#define PWM_0_GENB_ACTCMPBU_INV 0x00000100  // Invert pwmB
+#define PWM_0_GENB_ACTCMPBU_ZERO                                              \
+                                0x00000200  // Drive pwmB Low
+#define PWM_0_GENB_ACTCMPBU_ONE 0x00000300  // Drive pwmB High
+#define PWM_0_GENB_ACTCMPAD_M   0x000000C0  // Action for Comparator A Down
+#define PWM_0_GENB_ACTCMPAD_NONE                                              \
+                                0x00000000  // Do nothing
+#define PWM_0_GENB_ACTCMPAD_INV 0x00000040  // Invert pwmB
+#define PWM_0_GENB_ACTCMPAD_ZERO                                              \
+                                0x00000080  // Drive pwmB Low
+#define PWM_0_GENB_ACTCMPAD_ONE 0x000000C0  // Drive pwmB High
+#define PWM_0_GENB_ACTCMPAU_M   0x00000030  // Action for Comparator A Up
+#define PWM_0_GENB_ACTCMPAU_NONE                                              \
+                                0x00000000  // Do nothing
+#define PWM_0_GENB_ACTCMPAU_INV 0x00000010  // Invert pwmB
+#define PWM_0_GENB_ACTCMPAU_ZERO                                              \
+                                0x00000020  // Drive pwmB Low
+#define PWM_0_GENB_ACTCMPAU_ONE 0x00000030  // Drive pwmB High
+#define PWM_0_GENB_ACTLOAD_M    0x0000000C  // Action for Counter=LOAD
+#define PWM_0_GENB_ACTLOAD_NONE 0x00000000  // Do nothing
+#define PWM_0_GENB_ACTLOAD_INV  0x00000004  // Invert pwmB
+#define PWM_0_GENB_ACTLOAD_ZERO 0x00000008  // Drive pwmB Low
+#define PWM_0_GENB_ACTLOAD_ONE  0x0000000C  // Drive pwmB High
+#define PWM_0_GENB_ACTZERO_M    0x00000003  // Action for Counter=0
+#define PWM_0_GENB_ACTZERO_NONE 0x00000000  // Do nothing
+#define PWM_0_GENB_ACTZERO_INV  0x00000001  // Invert pwmB
+#define PWM_0_GENB_ACTZERO_ZERO 0x00000002  // Drive pwmB Low
+#define PWM_0_GENB_ACTZERO_ONE  0x00000003  // Drive pwmB High
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_DBCTL register.
+//
+//*****************************************************************************
+#define PWM_0_DBCTL_ENABLE      0x00000001  // Dead-Band Generator Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_DBRISE register.
+//
+//*****************************************************************************
+#define PWM_0_DBRISE_DELAY_M    0x00000FFF  // Dead-Band Rise Delay
+#define PWM_0_DBRISE_DELAY_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_DBFALL register.
+//
+//*****************************************************************************
+#define PWM_0_DBFALL_DELAY_M    0x00000FFF  // Dead-Band Fall Delay
+#define PWM_0_DBFALL_DELAY_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_FLTSRC0
+// register.
+//
+//*****************************************************************************
+#define PWM_0_FLTSRC0_FAULT3    0x00000008  // Fault3 Input
+#define PWM_0_FLTSRC0_FAULT2    0x00000004  // Fault2 Input
+#define PWM_0_FLTSRC0_FAULT1    0x00000002  // Fault1 Input
+#define PWM_0_FLTSRC0_FAULT0    0x00000001  // Fault0 Input
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_FLTSRC1
+// register.
+//
+//*****************************************************************************
+#define PWM_0_FLTSRC1_DCMP7     0x00000080  // Digital Comparator 7
+#define PWM_0_FLTSRC1_DCMP6     0x00000040  // Digital Comparator 6
+#define PWM_0_FLTSRC1_DCMP5     0x00000020  // Digital Comparator 5
+#define PWM_0_FLTSRC1_DCMP4     0x00000010  // Digital Comparator 4
+#define PWM_0_FLTSRC1_DCMP3     0x00000008  // Digital Comparator 3
+#define PWM_0_FLTSRC1_DCMP2     0x00000004  // Digital Comparator 2
+#define PWM_0_FLTSRC1_DCMP1     0x00000002  // Digital Comparator 1
+#define PWM_0_FLTSRC1_DCMP0     0x00000001  // Digital Comparator 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_MINFLTPER
+// register.
+//
+//*****************************************************************************
+#define PWM_0_MINFLTPER_M       0x0000FFFF  // Minimum Fault Period
+#define PWM_0_MINFLTPER_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_1_CTL register.
+//
+//*****************************************************************************
+#define PWM_1_CTL_LATCH         0x00040000  // Latch Fault Input
+#define PWM_1_CTL_MINFLTPER     0x00020000  // Minimum Fault Period
+#define PWM_1_CTL_FLTSRC        0x00010000  // Fault Condition Source
+#define PWM_1_CTL_DBFALLUPD_M   0x0000C000  // PWMnDBFALL Update Mode
+#define PWM_1_CTL_DBFALLUPD_I   0x00000000  // Immediate
+#define PWM_1_CTL_DBFALLUPD_LS  0x00008000  // Locally Synchronized
+#define PWM_1_CTL_DBFALLUPD_GS  0x0000C000  // Globally Synchronized
+#define PWM_1_CTL_DBRISEUPD_M   0x00003000  // PWMnDBRISE Update Mode
+#define PWM_1_CTL_DBRISEUPD_I   0x00000000  // Immediate
+#define PWM_1_CTL_DBRISEUPD_LS  0x00002000  // Locally Synchronized
+#define PWM_1_CTL_DBRISEUPD_GS  0x00003000  // Globally Synchronized
+#define PWM_1_CTL_DBCTLUPD_M    0x00000C00  // PWMnDBCTL Update Mode
+#define PWM_1_CTL_DBCTLUPD_I    0x00000000  // Immediate
+#define PWM_1_CTL_DBCTLUPD_LS   0x00000800  // Locally Synchronized
+#define PWM_1_CTL_DBCTLUPD_GS   0x00000C00  // Globally Synchronized
+#define PWM_1_CTL_GENBUPD_M     0x00000300  // PWMnGENB Update Mode
+#define PWM_1_CTL_GENBUPD_I     0x00000000  // Immediate
+#define PWM_1_CTL_GENBUPD_LS    0x00000200  // Locally Synchronized
+#define PWM_1_CTL_GENBUPD_GS    0x00000300  // Globally Synchronized
+#define PWM_1_CTL_GENAUPD_M     0x000000C0  // PWMnGENA Update Mode
+#define PWM_1_CTL_GENAUPD_I     0x00000000  // Immediate
+#define PWM_1_CTL_GENAUPD_LS    0x00000080  // Locally Synchronized
+#define PWM_1_CTL_GENAUPD_GS    0x000000C0  // Globally Synchronized
+#define PWM_1_CTL_CMPBUPD       0x00000020  // Comparator B Update Mode
+#define PWM_1_CTL_CMPAUPD       0x00000010  // Comparator A Update Mode
+#define PWM_1_CTL_LOADUPD       0x00000008  // Load Register Update Mode
+#define PWM_1_CTL_DEBUG         0x00000004  // Debug Mode
+#define PWM_1_CTL_MODE          0x00000002  // Counter Mode
+#define PWM_1_CTL_ENABLE        0x00000001  // PWM Block Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_1_INTEN register.
+//
+//*****************************************************************************
+#define PWM_1_INTEN_TRCMPBD     0x00002000  // Trigger for Counter=PWMnCMPB
+                                            // Down
+#define PWM_1_INTEN_TRCMPBU     0x00001000  // Trigger for Counter=PWMnCMPB Up
+#define PWM_1_INTEN_TRCMPAD     0x00000800  // Trigger for Counter=PWMnCMPA
+                                            // Down
+#define PWM_1_INTEN_TRCMPAU     0x00000400  // Trigger for Counter=PWMnCMPA Up
+#define PWM_1_INTEN_TRCNTLOAD   0x00000200  // Trigger for Counter=PWMnLOAD
+#define PWM_1_INTEN_TRCNTZERO   0x00000100  // Trigger for Counter=0
+#define PWM_1_INTEN_INTCMPBD    0x00000020  // Interrupt for Counter=PWMnCMPB
+                                            // Down
+#define PWM_1_INTEN_INTCMPBU    0x00000010  // Interrupt for Counter=PWMnCMPB
+                                            // Up
+#define PWM_1_INTEN_INTCMPAD    0x00000008  // Interrupt for Counter=PWMnCMPA
+                                            // Down
+#define PWM_1_INTEN_INTCMPAU    0x00000004  // Interrupt for Counter=PWMnCMPA
+                                            // Up
+#define PWM_1_INTEN_INTCNTLOAD  0x00000002  // Interrupt for Counter=PWMnLOAD
+#define PWM_1_INTEN_INTCNTZERO  0x00000001  // Interrupt for Counter=0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_1_RIS register.
+//
+//*****************************************************************************
+#define PWM_1_RIS_INTCMPBD      0x00000020  // Comparator B Down Interrupt
+                                            // Status
+#define PWM_1_RIS_INTCMPBU      0x00000010  // Comparator B Up Interrupt Status
+#define PWM_1_RIS_INTCMPAD      0x00000008  // Comparator A Down Interrupt
+                                            // Status
+#define PWM_1_RIS_INTCMPAU      0x00000004  // Comparator A Up Interrupt Status
+#define PWM_1_RIS_INTCNTLOAD    0x00000002  // Counter=Load Interrupt Status
+#define PWM_1_RIS_INTCNTZERO    0x00000001  // Counter=0 Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_1_ISC register.
+//
+//*****************************************************************************
+#define PWM_1_ISC_INTCMPBD      0x00000020  // Comparator B Down Interrupt
+#define PWM_1_ISC_INTCMPBU      0x00000010  // Comparator B Up Interrupt
+#define PWM_1_ISC_INTCMPAD      0x00000008  // Comparator A Down Interrupt
+#define PWM_1_ISC_INTCMPAU      0x00000004  // Comparator A Up Interrupt
+#define PWM_1_ISC_INTCNTLOAD    0x00000002  // Counter=Load Interrupt
+#define PWM_1_ISC_INTCNTZERO    0x00000001  // Counter=0 Interrupt
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_1_LOAD register.
+//
+//*****************************************************************************
+#define PWM_1_LOAD_LOAD_M       0x0000FFFF  // Counter Load Value
+#define PWM_1_LOAD_LOAD_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_1_COUNT register.
+//
+//*****************************************************************************
+#define PWM_1_COUNT_COUNT_M     0x0000FFFF  // Counter Value
+#define PWM_1_COUNT_COUNT_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_1_CMPA register.
+//
+//*****************************************************************************
+#define PWM_1_CMPA_COMPA_M      0x0000FFFF  // Comparator A Value
+#define PWM_1_CMPA_COMPA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_1_CMPB register.
+//
+//*****************************************************************************
+#define PWM_1_CMPB_COMPB_M      0x0000FFFF  // Comparator B Value
+#define PWM_1_CMPB_COMPB_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_1_GENA register.
+//
+//*****************************************************************************
+#define PWM_1_GENA_ACTCMPBD_M   0x00000C00  // Action for Comparator B Down
+#define PWM_1_GENA_ACTCMPBD_NONE                                              \
+                                0x00000000  // Do nothing
+#define PWM_1_GENA_ACTCMPBD_INV 0x00000400  // Invert pwmA
+#define PWM_1_GENA_ACTCMPBD_ZERO                                              \
+                                0x00000800  // Drive pwmA Low
+#define PWM_1_GENA_ACTCMPBD_ONE 0x00000C00  // Drive pwmA High
+#define PWM_1_GENA_ACTCMPBU_M   0x00000300  // Action for Comparator B Up
+#define PWM_1_GENA_ACTCMPBU_NONE                                              \
+                                0x00000000  // Do nothing
+#define PWM_1_GENA_ACTCMPBU_INV 0x00000100  // Invert pwmA
+#define PWM_1_GENA_ACTCMPBU_ZERO                                              \
+                                0x00000200  // Drive pwmA Low
+#define PWM_1_GENA_ACTCMPBU_ONE 0x00000300  // Drive pwmA High
+#define PWM_1_GENA_ACTCMPAD_M   0x000000C0  // Action for Comparator A Down
+#define PWM_1_GENA_ACTCMPAD_NONE                                              \
+                                0x00000000  // Do nothing
+#define PWM_1_GENA_ACTCMPAD_INV 0x00000040  // Invert pwmA
+#define PWM_1_GENA_ACTCMPAD_ZERO                                              \
+                                0x00000080  // Drive pwmA Low
+#define PWM_1_GENA_ACTCMPAD_ONE 0x000000C0  // Drive pwmA High
+#define PWM_1_GENA_ACTCMPAU_M   0x00000030  // Action for Comparator A Up
+#define PWM_1_GENA_ACTCMPAU_NONE                                              \
+                                0x00000000  // Do nothing
+#define PWM_1_GENA_ACTCMPAU_INV 0x00000010  // Invert pwmA
+#define PWM_1_GENA_ACTCMPAU_ZERO                                              \
+                                0x00000020  // Drive pwmA Low
+#define PWM_1_GENA_ACTCMPAU_ONE 0x00000030  // Drive pwmA High
+#define PWM_1_GENA_ACTLOAD_M    0x0000000C  // Action for Counter=LOAD
+#define PWM_1_GENA_ACTLOAD_NONE 0x00000000  // Do nothing
+#define PWM_1_GENA_ACTLOAD_INV  0x00000004  // Invert pwmA
+#define PWM_1_GENA_ACTLOAD_ZERO 0x00000008  // Drive pwmA Low
+#define PWM_1_GENA_ACTLOAD_ONE  0x0000000C  // Drive pwmA High
+#define PWM_1_GENA_ACTZERO_M    0x00000003  // Action for Counter=0
+#define PWM_1_GENA_ACTZERO_NONE 0x00000000  // Do nothing
+#define PWM_1_GENA_ACTZERO_INV  0x00000001  // Invert pwmA
+#define PWM_1_GENA_ACTZERO_ZERO 0x00000002  // Drive pwmA Low
+#define PWM_1_GENA_ACTZERO_ONE  0x00000003  // Drive pwmA High
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_1_GENB register.
+//
+//*****************************************************************************
+#define PWM_1_GENB_ACTCMPBD_M   0x00000C00  // Action for Comparator B Down
+#define PWM_1_GENB_ACTCMPBD_NONE                                              \
+                                0x00000000  // Do nothing
+#define PWM_1_GENB_ACTCMPBD_INV 0x00000400  // Invert pwmB
+#define PWM_1_GENB_ACTCMPBD_ZERO                                              \
+                                0x00000800  // Drive pwmB Low
+#define PWM_1_GENB_ACTCMPBD_ONE 0x00000C00  // Drive pwmB High
+#define PWM_1_GENB_ACTCMPBU_M   0x00000300  // Action for Comparator B Up
+#define PWM_1_GENB_ACTCMPBU_NONE                                              \
+                                0x00000000  // Do nothing
+#define PWM_1_GENB_ACTCMPBU_INV 0x00000100  // Invert pwmB
+#define PWM_1_GENB_ACTCMPBU_ZERO                                              \
+                                0x00000200  // Drive pwmB Low
+#define PWM_1_GENB_ACTCMPBU_ONE 0x00000300  // Drive pwmB High
+#define PWM_1_GENB_ACTCMPAD_M   0x000000C0  // Action for Comparator A Down
+#define PWM_1_GENB_ACTCMPAD_NONE                                              \
+                                0x00000000  // Do nothing
+#define PWM_1_GENB_ACTCMPAD_INV 0x00000040  // Invert pwmB
+#define PWM_1_GENB_ACTCMPAD_ZERO                                              \
+                                0x00000080  // Drive pwmB Low
+#define PWM_1_GENB_ACTCMPAD_ONE 0x000000C0  // Drive pwmB High
+#define PWM_1_GENB_ACTCMPAU_M   0x00000030  // Action for Comparator A Up
+#define PWM_1_GENB_ACTCMPAU_NONE                                              \
+                                0x00000000  // Do nothing
+#define PWM_1_GENB_ACTCMPAU_INV 0x00000010  // Invert pwmB
+#define PWM_1_GENB_ACTCMPAU_ZERO                                              \
+                                0x00000020  // Drive pwmB Low
+#define PWM_1_GENB_ACTCMPAU_ONE 0x00000030  // Drive pwmB High
+#define PWM_1_GENB_ACTLOAD_M    0x0000000C  // Action for Counter=LOAD
+#define PWM_1_GENB_ACTLOAD_NONE 0x00000000  // Do nothing
+#define PWM_1_GENB_ACTLOAD_INV  0x00000004  // Invert pwmB
+#define PWM_1_GENB_ACTLOAD_ZERO 0x00000008  // Drive pwmB Low
+#define PWM_1_GENB_ACTLOAD_ONE  0x0000000C  // Drive pwmB High
+#define PWM_1_GENB_ACTZERO_M    0x00000003  // Action for Counter=0
+#define PWM_1_GENB_ACTZERO_NONE 0x00000000  // Do nothing
+#define PWM_1_GENB_ACTZERO_INV  0x00000001  // Invert pwmB
+#define PWM_1_GENB_ACTZERO_ZERO 0x00000002  // Drive pwmB Low
+#define PWM_1_GENB_ACTZERO_ONE  0x00000003  // Drive pwmB High
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_1_DBCTL register.
+//
+//*****************************************************************************
+#define PWM_1_DBCTL_ENABLE      0x00000001  // Dead-Band Generator Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_1_DBRISE register.
+//
+//*****************************************************************************
+#define PWM_1_DBRISE_RISEDELAY_M                                              \
+                                0x00000FFF  // Dead-Band Rise Delay
+#define PWM_1_DBRISE_RISEDELAY_S                                              \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_1_DBFALL register.
+//
+//*****************************************************************************
+#define PWM_1_DBFALL_FALLDELAY_M                                              \
+                                0x00000FFF  // Dead-Band Fall Delay
+#define PWM_1_DBFALL_FALLDELAY_S                                              \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_1_FLTSRC0
+// register.
+//
+//*****************************************************************************
+#define PWM_1_FLTSRC0_FAULT3    0x00000008  // Fault3 Input
+#define PWM_1_FLTSRC0_FAULT2    0x00000004  // Fault2 Input
+#define PWM_1_FLTSRC0_FAULT1    0x00000002  // Fault1 Input
+#define PWM_1_FLTSRC0_FAULT0    0x00000001  // Fault0 Input
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_1_FLTSRC1
+// register.
+//
+//*****************************************************************************
+#define PWM_1_FLTSRC1_DCMP7     0x00000080  // Digital Comparator 7
+#define PWM_1_FLTSRC1_DCMP6     0x00000040  // Digital Comparator 6
+#define PWM_1_FLTSRC1_DCMP5     0x00000020  // Digital Comparator 5
+#define PWM_1_FLTSRC1_DCMP4     0x00000010  // Digital Comparator 4
+#define PWM_1_FLTSRC1_DCMP3     0x00000008  // Digital Comparator 3
+#define PWM_1_FLTSRC1_DCMP2     0x00000004  // Digital Comparator 2
+#define PWM_1_FLTSRC1_DCMP1     0x00000002  // Digital Comparator 1
+#define PWM_1_FLTSRC1_DCMP0     0x00000001  // Digital Comparator 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_1_MINFLTPER
+// register.
+//
+//*****************************************************************************
+#define PWM_1_MINFLTPER_MFP_M   0x0000FFFF  // Minimum Fault Period
+#define PWM_1_MINFLTPER_MFP_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_2_CTL register.
+//
+//*****************************************************************************
+#define PWM_2_CTL_LATCH         0x00040000  // Latch Fault Input
+#define PWM_2_CTL_MINFLTPER     0x00020000  // Minimum Fault Period
+#define PWM_2_CTL_FLTSRC        0x00010000  // Fault Condition Source
+#define PWM_2_CTL_DBFALLUPD_M   0x0000C000  // PWMnDBFALL Update Mode
+#define PWM_2_CTL_DBFALLUPD_I   0x00000000  // Immediate
+#define PWM_2_CTL_DBFALLUPD_LS  0x00008000  // Locally Synchronized
+#define PWM_2_CTL_DBFALLUPD_GS  0x0000C000  // Globally Synchronized
+#define PWM_2_CTL_DBRISEUPD_M   0x00003000  // PWMnDBRISE Update Mode
+#define PWM_2_CTL_DBRISEUPD_I   0x00000000  // Immediate
+#define PWM_2_CTL_DBRISEUPD_LS  0x00002000  // Locally Synchronized
+#define PWM_2_CTL_DBRISEUPD_GS  0x00003000  // Globally Synchronized
+#define PWM_2_CTL_DBCTLUPD_M    0x00000C00  // PWMnDBCTL Update Mode
+#define PWM_2_CTL_DBCTLUPD_I    0x00000000  // Immediate
+#define PWM_2_CTL_DBCTLUPD_LS   0x00000800  // Locally Synchronized
+#define PWM_2_CTL_DBCTLUPD_GS   0x00000C00  // Globally Synchronized
+#define PWM_2_CTL_GENBUPD_M     0x00000300  // PWMnGENB Update Mode
+#define PWM_2_CTL_GENBUPD_I     0x00000000  // Immediate
+#define PWM_2_CTL_GENBUPD_LS    0x00000200  // Locally Synchronized
+#define PWM_2_CTL_GENBUPD_GS    0x00000300  // Globally Synchronized
+#define PWM_2_CTL_GENAUPD_M     0x000000C0  // PWMnGENA Update Mode
+#define PWM_2_CTL_GENAUPD_I     0x00000000  // Immediate
+#define PWM_2_CTL_GENAUPD_LS    0x00000080  // Locally Synchronized
+#define PWM_2_CTL_GENAUPD_GS    0x000000C0  // Globally Synchronized
+#define PWM_2_CTL_CMPBUPD       0x00000020  // Comparator B Update Mode
+#define PWM_2_CTL_CMPAUPD       0x00000010  // Comparator A Update Mode
+#define PWM_2_CTL_LOADUPD       0x00000008  // Load Register Update Mode
+#define PWM_2_CTL_DEBUG         0x00000004  // Debug Mode
+#define PWM_2_CTL_MODE          0x00000002  // Counter Mode
+#define PWM_2_CTL_ENABLE        0x00000001  // PWM Block Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_2_INTEN register.
+//
+//*****************************************************************************
+#define PWM_2_INTEN_TRCMPBD     0x00002000  // Trigger for Counter=PWMnCMPB
+                                            // Down
+#define PWM_2_INTEN_TRCMPBU     0x00001000  // Trigger for Counter=PWMnCMPB Up
+#define PWM_2_INTEN_TRCMPAD     0x00000800  // Trigger for Counter=PWMnCMPA
+                                            // Down
+#define PWM_2_INTEN_TRCMPAU     0x00000400  // Trigger for Counter=PWMnCMPA Up
+#define PWM_2_INTEN_TRCNTLOAD   0x00000200  // Trigger for Counter=PWMnLOAD
+#define PWM_2_INTEN_TRCNTZERO   0x00000100  // Trigger for Counter=0
+#define PWM_2_INTEN_INTCMPBD    0x00000020  // Interrupt for Counter=PWMnCMPB
+                                            // Down
+#define PWM_2_INTEN_INTCMPBU    0x00000010  // Interrupt for Counter=PWMnCMPB
+                                            // Up
+#define PWM_2_INTEN_INTCMPAD    0x00000008  // Interrupt for Counter=PWMnCMPA
+                                            // Down
+#define PWM_2_INTEN_INTCMPAU    0x00000004  // Interrupt for Counter=PWMnCMPA
+                                            // Up
+#define PWM_2_INTEN_INTCNTLOAD  0x00000002  // Interrupt for Counter=PWMnLOAD
+#define PWM_2_INTEN_INTCNTZERO  0x00000001  // Interrupt for Counter=0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_2_RIS register.
+//
+//*****************************************************************************
+#define PWM_2_RIS_INTCMPBD      0x00000020  // Comparator B Down Interrupt
+                                            // Status
+#define PWM_2_RIS_INTCMPBU      0x00000010  // Comparator B Up Interrupt Status
+#define PWM_2_RIS_INTCMPAD      0x00000008  // Comparator A Down Interrupt
+                                            // Status
+#define PWM_2_RIS_INTCMPAU      0x00000004  // Comparator A Up Interrupt Status
+#define PWM_2_RIS_INTCNTLOAD    0x00000002  // Counter=Load Interrupt Status
+#define PWM_2_RIS_INTCNTZERO    0x00000001  // Counter=0 Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_2_ISC register.
+//
+//*****************************************************************************
+#define PWM_2_ISC_INTCMPBD      0x00000020  // Comparator B Down Interrupt
+#define PWM_2_ISC_INTCMPBU      0x00000010  // Comparator B Up Interrupt
+#define PWM_2_ISC_INTCMPAD      0x00000008  // Comparator A Down Interrupt
+#define PWM_2_ISC_INTCMPAU      0x00000004  // Comparator A Up Interrupt
+#define PWM_2_ISC_INTCNTLOAD    0x00000002  // Counter=Load Interrupt
+#define PWM_2_ISC_INTCNTZERO    0x00000001  // Counter=0 Interrupt
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_2_LOAD register.
+//
+//*****************************************************************************
+#define PWM_2_LOAD_LOAD_M       0x0000FFFF  // Counter Load Value
+#define PWM_2_LOAD_LOAD_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_2_COUNT register.
+//
+//*****************************************************************************
+#define PWM_2_COUNT_COUNT_M     0x0000FFFF  // Counter Value
+#define PWM_2_COUNT_COUNT_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_2_CMPA register.
+//
+//*****************************************************************************
+#define PWM_2_CMPA_COMPA_M      0x0000FFFF  // Comparator A Value
+#define PWM_2_CMPA_COMPA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_2_CMPB register.
+//
+//*****************************************************************************
+#define PWM_2_CMPB_COMPB_M      0x0000FFFF  // Comparator B Value
+#define PWM_2_CMPB_COMPB_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_2_GENA register.
+//
+//*****************************************************************************
+#define PWM_2_GENA_ACTCMPBD_M   0x00000C00  // Action for Comparator B Down
+#define PWM_2_GENA_ACTCMPBD_NONE                                              \
+                                0x00000000  // Do nothing
+#define PWM_2_GENA_ACTCMPBD_INV 0x00000400  // Invert pwmA
+#define PWM_2_GENA_ACTCMPBD_ZERO                                              \
+                                0x00000800  // Drive pwmA Low
+#define PWM_2_GENA_ACTCMPBD_ONE 0x00000C00  // Drive pwmA High
+#define PWM_2_GENA_ACTCMPBU_M   0x00000300  // Action for Comparator B Up
+#define PWM_2_GENA_ACTCMPBU_NONE                                              \
+                                0x00000000  // Do nothing
+#define PWM_2_GENA_ACTCMPBU_INV 0x00000100  // Invert pwmA
+#define PWM_2_GENA_ACTCMPBU_ZERO                                              \
+                                0x00000200  // Drive pwmA Low
+#define PWM_2_GENA_ACTCMPBU_ONE 0x00000300  // Drive pwmA High
+#define PWM_2_GENA_ACTCMPAD_M   0x000000C0  // Action for Comparator A Down
+#define PWM_2_GENA_ACTCMPAD_NONE                                              \
+                                0x00000000  // Do nothing
+#define PWM_2_GENA_ACTCMPAD_INV 0x00000040  // Invert pwmA
+#define PWM_2_GENA_ACTCMPAD_ZERO                                              \
+                                0x00000080  // Drive pwmA Low
+#define PWM_2_GENA_ACTCMPAD_ONE 0x000000C0  // Drive pwmA High
+#define PWM_2_GENA_ACTCMPAU_M   0x00000030  // Action for Comparator A Up
+#define PWM_2_GENA_ACTCMPAU_NONE                                              \
+                                0x00000000  // Do nothing
+#define PWM_2_GENA_ACTCMPAU_INV 0x00000010  // Invert pwmA
+#define PWM_2_GENA_ACTCMPAU_ZERO                                              \
+                                0x00000020  // Drive pwmA Low
+#define PWM_2_GENA_ACTCMPAU_ONE 0x00000030  // Drive pwmA High
+#define PWM_2_GENA_ACTLOAD_M    0x0000000C  // Action for Counter=LOAD
+#define PWM_2_GENA_ACTLOAD_NONE 0x00000000  // Do nothing
+#define PWM_2_GENA_ACTLOAD_INV  0x00000004  // Invert pwmA
+#define PWM_2_GENA_ACTLOAD_ZERO 0x00000008  // Drive pwmA Low
+#define PWM_2_GENA_ACTLOAD_ONE  0x0000000C  // Drive pwmA High
+#define PWM_2_GENA_ACTZERO_M    0x00000003  // Action for Counter=0
+#define PWM_2_GENA_ACTZERO_NONE 0x00000000  // Do nothing
+#define PWM_2_GENA_ACTZERO_INV  0x00000001  // Invert pwmA
+#define PWM_2_GENA_ACTZERO_ZERO 0x00000002  // Drive pwmA Low
+#define PWM_2_GENA_ACTZERO_ONE  0x00000003  // Drive pwmA High
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_2_GENB register.
+//
+//*****************************************************************************
+#define PWM_2_GENB_ACTCMPBD_M   0x00000C00  // Action for Comparator B Down
+#define PWM_2_GENB_ACTCMPBD_NONE                                              \
+                                0x00000000  // Do nothing
+#define PWM_2_GENB_ACTCMPBD_INV 0x00000400  // Invert pwmB
+#define PWM_2_GENB_ACTCMPBD_ZERO                                              \
+                                0x00000800  // Drive pwmB Low
+#define PWM_2_GENB_ACTCMPBD_ONE 0x00000C00  // Drive pwmB High
+#define PWM_2_GENB_ACTCMPBU_M   0x00000300  // Action for Comparator B Up
+#define PWM_2_GENB_ACTCMPBU_NONE                                              \
+                                0x00000000  // Do nothing
+#define PWM_2_GENB_ACTCMPBU_INV 0x00000100  // Invert pwmB
+#define PWM_2_GENB_ACTCMPBU_ZERO                                              \
+                                0x00000200  // Drive pwmB Low
+#define PWM_2_GENB_ACTCMPBU_ONE 0x00000300  // Drive pwmB High
+#define PWM_2_GENB_ACTCMPAD_M   0x000000C0  // Action for Comparator A Down
+#define PWM_2_GENB_ACTCMPAD_NONE                                              \
+                                0x00000000  // Do nothing
+#define PWM_2_GENB_ACTCMPAD_INV 0x00000040  // Invert pwmB
+#define PWM_2_GENB_ACTCMPAD_ZERO                                              \
+                                0x00000080  // Drive pwmB Low
+#define PWM_2_GENB_ACTCMPAD_ONE 0x000000C0  // Drive pwmB High
+#define PWM_2_GENB_ACTCMPAU_M   0x00000030  // Action for Comparator A Up
+#define PWM_2_GENB_ACTCMPAU_NONE                                              \
+                                0x00000000  // Do nothing
+#define PWM_2_GENB_ACTCMPAU_INV 0x00000010  // Invert pwmB
+#define PWM_2_GENB_ACTCMPAU_ZERO                                              \
+                                0x00000020  // Drive pwmB Low
+#define PWM_2_GENB_ACTCMPAU_ONE 0x00000030  // Drive pwmB High
+#define PWM_2_GENB_ACTLOAD_M    0x0000000C  // Action for Counter=LOAD
+#define PWM_2_GENB_ACTLOAD_NONE 0x00000000  // Do nothing
+#define PWM_2_GENB_ACTLOAD_INV  0x00000004  // Invert pwmB
+#define PWM_2_GENB_ACTLOAD_ZERO 0x00000008  // Drive pwmB Low
+#define PWM_2_GENB_ACTLOAD_ONE  0x0000000C  // Drive pwmB High
+#define PWM_2_GENB_ACTZERO_M    0x00000003  // Action for Counter=0
+#define PWM_2_GENB_ACTZERO_NONE 0x00000000  // Do nothing
+#define PWM_2_GENB_ACTZERO_INV  0x00000001  // Invert pwmB
+#define PWM_2_GENB_ACTZERO_ZERO 0x00000002  // Drive pwmB Low
+#define PWM_2_GENB_ACTZERO_ONE  0x00000003  // Drive pwmB High
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_2_DBCTL register.
+//
+//*****************************************************************************
+#define PWM_2_DBCTL_ENABLE      0x00000001  // Dead-Band Generator Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_2_DBRISE register.
+//
+//*****************************************************************************
+#define PWM_2_DBRISE_RISEDELAY_M                                              \
+                                0x00000FFF  // Dead-Band Rise Delay
+#define PWM_2_DBRISE_RISEDELAY_S                                              \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_2_DBFALL register.
+//
+//*****************************************************************************
+#define PWM_2_DBFALL_FALLDELAY_M                                              \
+                                0x00000FFF  // Dead-Band Fall Delay
+#define PWM_2_DBFALL_FALLDELAY_S                                              \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_2_FLTSRC0
+// register.
+//
+//*****************************************************************************
+#define PWM_2_FLTSRC0_FAULT3    0x00000008  // Fault3 Input
+#define PWM_2_FLTSRC0_FAULT2    0x00000004  // Fault2 Input
+#define PWM_2_FLTSRC0_FAULT1    0x00000002  // Fault1 Input
+#define PWM_2_FLTSRC0_FAULT0    0x00000001  // Fault0 Input
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_2_FLTSRC1
+// register.
+//
+//*****************************************************************************
+#define PWM_2_FLTSRC1_DCMP7     0x00000080  // Digital Comparator 7
+#define PWM_2_FLTSRC1_DCMP6     0x00000040  // Digital Comparator 6
+#define PWM_2_FLTSRC1_DCMP5     0x00000020  // Digital Comparator 5
+#define PWM_2_FLTSRC1_DCMP4     0x00000010  // Digital Comparator 4
+#define PWM_2_FLTSRC1_DCMP3     0x00000008  // Digital Comparator 3
+#define PWM_2_FLTSRC1_DCMP2     0x00000004  // Digital Comparator 2
+#define PWM_2_FLTSRC1_DCMP1     0x00000002  // Digital Comparator 1
+#define PWM_2_FLTSRC1_DCMP0     0x00000001  // Digital Comparator 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_2_MINFLTPER
+// register.
+//
+//*****************************************************************************
+#define PWM_2_MINFLTPER_MFP_M   0x0000FFFF  // Minimum Fault Period
+#define PWM_2_MINFLTPER_MFP_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_3_CTL register.
+//
+//*****************************************************************************
+#define PWM_3_CTL_LATCH         0x00040000  // Latch Fault Input
+#define PWM_3_CTL_MINFLTPER     0x00020000  // Minimum Fault Period
+#define PWM_3_CTL_FLTSRC        0x00010000  // Fault Condition Source
+#define PWM_3_CTL_DBFALLUPD_M   0x0000C000  // PWMnDBFALL Update Mode
+#define PWM_3_CTL_DBFALLUPD_I   0x00000000  // Immediate
+#define PWM_3_CTL_DBFALLUPD_LS  0x00008000  // Locally Synchronized
+#define PWM_3_CTL_DBFALLUPD_GS  0x0000C000  // Globally Synchronized
+#define PWM_3_CTL_DBRISEUPD_M   0x00003000  // PWMnDBRISE Update Mode
+#define PWM_3_CTL_DBRISEUPD_I   0x00000000  // Immediate
+#define PWM_3_CTL_DBRISEUPD_LS  0x00002000  // Locally Synchronized
+#define PWM_3_CTL_DBRISEUPD_GS  0x00003000  // Globally Synchronized
+#define PWM_3_CTL_DBCTLUPD_M    0x00000C00  // PWMnDBCTL Update Mode
+#define PWM_3_CTL_DBCTLUPD_I    0x00000000  // Immediate
+#define PWM_3_CTL_DBCTLUPD_LS   0x00000800  // Locally Synchronized
+#define PWM_3_CTL_DBCTLUPD_GS   0x00000C00  // Globally Synchronized
+#define PWM_3_CTL_GENBUPD_M     0x00000300  // PWMnGENB Update Mode
+#define PWM_3_CTL_GENBUPD_I     0x00000000  // Immediate
+#define PWM_3_CTL_GENBUPD_LS    0x00000200  // Locally Synchronized
+#define PWM_3_CTL_GENBUPD_GS    0x00000300  // Globally Synchronized
+#define PWM_3_CTL_GENAUPD_M     0x000000C0  // PWMnGENA Update Mode
+#define PWM_3_CTL_GENAUPD_I     0x00000000  // Immediate
+#define PWM_3_CTL_GENAUPD_LS    0x00000080  // Locally Synchronized
+#define PWM_3_CTL_GENAUPD_GS    0x000000C0  // Globally Synchronized
+#define PWM_3_CTL_CMPBUPD       0x00000020  // Comparator B Update Mode
+#define PWM_3_CTL_CMPAUPD       0x00000010  // Comparator A Update Mode
+#define PWM_3_CTL_LOADUPD       0x00000008  // Load Register Update Mode
+#define PWM_3_CTL_DEBUG         0x00000004  // Debug Mode
+#define PWM_3_CTL_MODE          0x00000002  // Counter Mode
+#define PWM_3_CTL_ENABLE        0x00000001  // PWM Block Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_3_INTEN register.
+//
+//*****************************************************************************
+#define PWM_3_INTEN_TRCMPBD     0x00002000  // Trigger for Counter=PWMnCMPB
+                                            // Down
+#define PWM_3_INTEN_TRCMPBU     0x00001000  // Trigger for Counter=PWMnCMPB Up
+#define PWM_3_INTEN_TRCMPAD     0x00000800  // Trigger for Counter=PWMnCMPA
+                                            // Down
+#define PWM_3_INTEN_TRCMPAU     0x00000400  // Trigger for Counter=PWMnCMPA Up
+#define PWM_3_INTEN_TRCNTLOAD   0x00000200  // Trigger for Counter=PWMnLOAD
+#define PWM_3_INTEN_TRCNTZERO   0x00000100  // Trigger for Counter=0
+#define PWM_3_INTEN_INTCMPBD    0x00000020  // Interrupt for Counter=PWMnCMPB
+                                            // Down
+#define PWM_3_INTEN_INTCMPBU    0x00000010  // Interrupt for Counter=PWMnCMPB
+                                            // Up
+#define PWM_3_INTEN_INTCMPAD    0x00000008  // Interrupt for Counter=PWMnCMPA
+                                            // Down
+#define PWM_3_INTEN_INTCMPAU    0x00000004  // Interrupt for Counter=PWMnCMPA
+                                            // Up
+#define PWM_3_INTEN_INTCNTLOAD  0x00000002  // Interrupt for Counter=PWMnLOAD
+#define PWM_3_INTEN_INTCNTZERO  0x00000001  // Interrupt for Counter=0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_3_RIS register.
+//
+//*****************************************************************************
+#define PWM_3_RIS_INTCMPBD      0x00000020  // Comparator B Down Interrupt
+                                            // Status
+#define PWM_3_RIS_INTCMPBU      0x00000010  // Comparator B Up Interrupt Status
+#define PWM_3_RIS_INTCMPAD      0x00000008  // Comparator A Down Interrupt
+                                            // Status
+#define PWM_3_RIS_INTCMPAU      0x00000004  // Comparator A Up Interrupt Status
+#define PWM_3_RIS_INTCNTLOAD    0x00000002  // Counter=Load Interrupt Status
+#define PWM_3_RIS_INTCNTZERO    0x00000001  // Counter=0 Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_3_ISC register.
+//
+//*****************************************************************************
+#define PWM_3_ISC_INTCMPBD      0x00000020  // Comparator B Down Interrupt
+#define PWM_3_ISC_INTCMPBU      0x00000010  // Comparator B Up Interrupt
+#define PWM_3_ISC_INTCMPAD      0x00000008  // Comparator A Down Interrupt
+#define PWM_3_ISC_INTCMPAU      0x00000004  // Comparator A Up Interrupt
+#define PWM_3_ISC_INTCNTLOAD    0x00000002  // Counter=Load Interrupt
+#define PWM_3_ISC_INTCNTZERO    0x00000001  // Counter=0 Interrupt
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_3_LOAD register.
+//
+//*****************************************************************************
+#define PWM_3_LOAD_LOAD_M       0x0000FFFF  // Counter Load Value
+#define PWM_3_LOAD_LOAD_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_3_COUNT register.
+//
+//*****************************************************************************
+#define PWM_3_COUNT_COUNT_M     0x0000FFFF  // Counter Value
+#define PWM_3_COUNT_COUNT_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_3_CMPA register.
+//
+//*****************************************************************************
+#define PWM_3_CMPA_COMPA_M      0x0000FFFF  // Comparator A Value
+#define PWM_3_CMPA_COMPA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_3_CMPB register.
+//
+//*****************************************************************************
+#define PWM_3_CMPB_COMPB_M      0x0000FFFF  // Comparator B Value
+#define PWM_3_CMPB_COMPB_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_3_GENA register.
+//
+//*****************************************************************************
+#define PWM_3_GENA_ACTCMPBD_M   0x00000C00  // Action for Comparator B Down
+#define PWM_3_GENA_ACTCMPBD_NONE                                              \
+                                0x00000000  // Do nothing
+#define PWM_3_GENA_ACTCMPBD_INV 0x00000400  // Invert pwmA
+#define PWM_3_GENA_ACTCMPBD_ZERO                                              \
+                                0x00000800  // Drive pwmA Low
+#define PWM_3_GENA_ACTCMPBD_ONE 0x00000C00  // Drive pwmA High
+#define PWM_3_GENA_ACTCMPBU_M   0x00000300  // Action for Comparator B Up
+#define PWM_3_GENA_ACTCMPBU_NONE                                              \
+                                0x00000000  // Do nothing
+#define PWM_3_GENA_ACTCMPBU_INV 0x00000100  // Invert pwmA
+#define PWM_3_GENA_ACTCMPBU_ZERO                                              \
+                                0x00000200  // Drive pwmA Low
+#define PWM_3_GENA_ACTCMPBU_ONE 0x00000300  // Drive pwmA High
+#define PWM_3_GENA_ACTCMPAD_M   0x000000C0  // Action for Comparator A Down
+#define PWM_3_GENA_ACTCMPAD_NONE                                              \
+                                0x00000000  // Do nothing
+#define PWM_3_GENA_ACTCMPAD_INV 0x00000040  // Invert pwmA
+#define PWM_3_GENA_ACTCMPAD_ZERO                                              \
+                                0x00000080  // Drive pwmA Low
+#define PWM_3_GENA_ACTCMPAD_ONE 0x000000C0  // Drive pwmA High
+#define PWM_3_GENA_ACTCMPAU_M   0x00000030  // Action for Comparator A Up
+#define PWM_3_GENA_ACTCMPAU_NONE                                              \
+                                0x00000000  // Do nothing
+#define PWM_3_GENA_ACTCMPAU_INV 0x00000010  // Invert pwmA
+#define PWM_3_GENA_ACTCMPAU_ZERO                                              \
+                                0x00000020  // Drive pwmA Low
+#define PWM_3_GENA_ACTCMPAU_ONE 0x00000030  // Drive pwmA High
+#define PWM_3_GENA_ACTLOAD_M    0x0000000C  // Action for Counter=LOAD
+#define PWM_3_GENA_ACTLOAD_NONE 0x00000000  // Do nothing
+#define PWM_3_GENA_ACTLOAD_INV  0x00000004  // Invert pwmA
+#define PWM_3_GENA_ACTLOAD_ZERO 0x00000008  // Drive pwmA Low
+#define PWM_3_GENA_ACTLOAD_ONE  0x0000000C  // Drive pwmA High
+#define PWM_3_GENA_ACTZERO_M    0x00000003  // Action for Counter=0
+#define PWM_3_GENA_ACTZERO_NONE 0x00000000  // Do nothing
+#define PWM_3_GENA_ACTZERO_INV  0x00000001  // Invert pwmA
+#define PWM_3_GENA_ACTZERO_ZERO 0x00000002  // Drive pwmA Low
+#define PWM_3_GENA_ACTZERO_ONE  0x00000003  // Drive pwmA High
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_3_GENB register.
+//
+//*****************************************************************************
+#define PWM_3_GENB_ACTCMPBD_M   0x00000C00  // Action for Comparator B Down
+#define PWM_3_GENB_ACTCMPBD_NONE                                              \
+                                0x00000000  // Do nothing
+#define PWM_3_GENB_ACTCMPBD_INV 0x00000400  // Invert pwmB
+#define PWM_3_GENB_ACTCMPBD_ZERO                                              \
+                                0x00000800  // Drive pwmB Low
+#define PWM_3_GENB_ACTCMPBD_ONE 0x00000C00  // Drive pwmB High
+#define PWM_3_GENB_ACTCMPBU_M   0x00000300  // Action for Comparator B Up
+#define PWM_3_GENB_ACTCMPBU_NONE                                              \
+                                0x00000000  // Do nothing
+#define PWM_3_GENB_ACTCMPBU_INV 0x00000100  // Invert pwmB
+#define PWM_3_GENB_ACTCMPBU_ZERO                                              \
+                                0x00000200  // Drive pwmB Low
+#define PWM_3_GENB_ACTCMPBU_ONE 0x00000300  // Drive pwmB High
+#define PWM_3_GENB_ACTCMPAD_M   0x000000C0  // Action for Comparator A Down
+#define PWM_3_GENB_ACTCMPAD_NONE                                              \
+                                0x00000000  // Do nothing
+#define PWM_3_GENB_ACTCMPAD_INV 0x00000040  // Invert pwmB
+#define PWM_3_GENB_ACTCMPAD_ZERO                                              \
+                                0x00000080  // Drive pwmB Low
+#define PWM_3_GENB_ACTCMPAD_ONE 0x000000C0  // Drive pwmB High
+#define PWM_3_GENB_ACTCMPAU_M   0x00000030  // Action for Comparator A Up
+#define PWM_3_GENB_ACTCMPAU_NONE                                              \
+                                0x00000000  // Do nothing
+#define PWM_3_GENB_ACTCMPAU_INV 0x00000010  // Invert pwmB
+#define PWM_3_GENB_ACTCMPAU_ZERO                                              \
+                                0x00000020  // Drive pwmB Low
+#define PWM_3_GENB_ACTCMPAU_ONE 0x00000030  // Drive pwmB High
+#define PWM_3_GENB_ACTLOAD_M    0x0000000C  // Action for Counter=LOAD
+#define PWM_3_GENB_ACTLOAD_NONE 0x00000000  // Do nothing
+#define PWM_3_GENB_ACTLOAD_INV  0x00000004  // Invert pwmB
+#define PWM_3_GENB_ACTLOAD_ZERO 0x00000008  // Drive pwmB Low
+#define PWM_3_GENB_ACTLOAD_ONE  0x0000000C  // Drive pwmB High
+#define PWM_3_GENB_ACTZERO_M    0x00000003  // Action for Counter=0
+#define PWM_3_GENB_ACTZERO_NONE 0x00000000  // Do nothing
+#define PWM_3_GENB_ACTZERO_INV  0x00000001  // Invert pwmB
+#define PWM_3_GENB_ACTZERO_ZERO 0x00000002  // Drive pwmB Low
+#define PWM_3_GENB_ACTZERO_ONE  0x00000003  // Drive pwmB High
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_3_DBCTL register.
+//
+//*****************************************************************************
+#define PWM_3_DBCTL_ENABLE      0x00000001  // Dead-Band Generator Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_3_DBRISE register.
+//
+//*****************************************************************************
+#define PWM_3_DBRISE_RISEDELAY_M                                              \
+                                0x00000FFF  // Dead-Band Rise Delay
+#define PWM_3_DBRISE_RISEDELAY_S                                              \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_3_DBFALL register.
+//
+//*****************************************************************************
+#define PWM_3_DBFALL_FALLDELAY_M                                              \
+                                0x00000FFF  // Dead-Band Fall Delay
+#define PWM_3_DBFALL_FALLDELAY_S                                              \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_3_FLTSRC0
+// register.
+//
+//*****************************************************************************
+#define PWM_3_FLTSRC0_FAULT3    0x00000008  // Fault3 Input
+#define PWM_3_FLTSRC0_FAULT2    0x00000004  // Fault2 Input
+#define PWM_3_FLTSRC0_FAULT1    0x00000002  // Fault1 Input
+#define PWM_3_FLTSRC0_FAULT0    0x00000001  // Fault0 Input
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_3_FLTSRC1
+// register.
+//
+//*****************************************************************************
+#define PWM_3_FLTSRC1_DCMP7     0x00000080  // Digital Comparator 7
+#define PWM_3_FLTSRC1_DCMP6     0x00000040  // Digital Comparator 6
+#define PWM_3_FLTSRC1_DCMP5     0x00000020  // Digital Comparator 5
+#define PWM_3_FLTSRC1_DCMP4     0x00000010  // Digital Comparator 4
+#define PWM_3_FLTSRC1_DCMP3     0x00000008  // Digital Comparator 3
+#define PWM_3_FLTSRC1_DCMP2     0x00000004  // Digital Comparator 2
+#define PWM_3_FLTSRC1_DCMP1     0x00000002  // Digital Comparator 1
+#define PWM_3_FLTSRC1_DCMP0     0x00000001  // Digital Comparator 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_3_MINFLTPER
+// register.
+//
+//*****************************************************************************
+#define PWM_3_MINFLTPER_MFP_M   0x0000FFFF  // Minimum Fault Period
+#define PWM_3_MINFLTPER_MFP_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_FLTSEN register.
+//
+//*****************************************************************************
+#define PWM_0_FLTSEN_FAULT3     0x00000008  // Fault3 Sense
+#define PWM_0_FLTSEN_FAULT2     0x00000004  // Fault2 Sense
+#define PWM_0_FLTSEN_FAULT1     0x00000002  // Fault1 Sense
+#define PWM_0_FLTSEN_FAULT0     0x00000001  // Fault0 Sense
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_FLTSTAT0
+// register.
+//
+//*****************************************************************************
+#define PWM_0_FLTSTAT0_FAULT3   0x00000008  // Fault Input 3
+#define PWM_0_FLTSTAT0_FAULT2   0x00000004  // Fault Input 2
+#define PWM_0_FLTSTAT0_FAULT1   0x00000002  // Fault Input 1
+#define PWM_0_FLTSTAT0_FAULT0   0x00000001  // Fault Input 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_FLTSTAT1
+// register.
+//
+//*****************************************************************************
+#define PWM_0_FLTSTAT1_DCMP7    0x00000080  // Digital Comparator 7 Trigger
+#define PWM_0_FLTSTAT1_DCMP6    0x00000040  // Digital Comparator 6 Trigger
+#define PWM_0_FLTSTAT1_DCMP5    0x00000020  // Digital Comparator 5 Trigger
+#define PWM_0_FLTSTAT1_DCMP4    0x00000010  // Digital Comparator 4 Trigger
+#define PWM_0_FLTSTAT1_DCMP3    0x00000008  // Digital Comparator 3 Trigger
+#define PWM_0_FLTSTAT1_DCMP2    0x00000004  // Digital Comparator 2 Trigger
+#define PWM_0_FLTSTAT1_DCMP1    0x00000002  // Digital Comparator 1 Trigger
+#define PWM_0_FLTSTAT1_DCMP0    0x00000001  // Digital Comparator 0 Trigger
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_1_FLTSEN register.
+//
+//*****************************************************************************
+#define PWM_1_FLTSEN_FAULT3     0x00000008  // Fault3 Sense
+#define PWM_1_FLTSEN_FAULT2     0x00000004  // Fault2 Sense
+#define PWM_1_FLTSEN_FAULT1     0x00000002  // Fault1 Sense
+#define PWM_1_FLTSEN_FAULT0     0x00000001  // Fault0 Sense
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_1_FLTSTAT0
+// register.
+//
+//*****************************************************************************
+#define PWM_1_FLTSTAT0_FAULT3   0x00000008  // Fault Input 3
+#define PWM_1_FLTSTAT0_FAULT2   0x00000004  // Fault Input 2
+#define PWM_1_FLTSTAT0_FAULT1   0x00000002  // Fault Input 1
+#define PWM_1_FLTSTAT0_FAULT0   0x00000001  // Fault Input 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_1_FLTSTAT1
+// register.
+//
+//*****************************************************************************
+#define PWM_1_FLTSTAT1_DCMP7    0x00000080  // Digital Comparator 7 Trigger
+#define PWM_1_FLTSTAT1_DCMP6    0x00000040  // Digital Comparator 6 Trigger
+#define PWM_1_FLTSTAT1_DCMP5    0x00000020  // Digital Comparator 5 Trigger
+#define PWM_1_FLTSTAT1_DCMP4    0x00000010  // Digital Comparator 4 Trigger
+#define PWM_1_FLTSTAT1_DCMP3    0x00000008  // Digital Comparator 3 Trigger
+#define PWM_1_FLTSTAT1_DCMP2    0x00000004  // Digital Comparator 2 Trigger
+#define PWM_1_FLTSTAT1_DCMP1    0x00000002  // Digital Comparator 1 Trigger
+#define PWM_1_FLTSTAT1_DCMP0    0x00000001  // Digital Comparator 0 Trigger
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_2_FLTSEN register.
+//
+//*****************************************************************************
+#define PWM_2_FLTSEN_FAULT3     0x00000008  // Fault3 Sense
+#define PWM_2_FLTSEN_FAULT2     0x00000004  // Fault2 Sense
+#define PWM_2_FLTSEN_FAULT1     0x00000002  // Fault1 Sense
+#define PWM_2_FLTSEN_FAULT0     0x00000001  // Fault0 Sense
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_2_FLTSTAT0
+// register.
+//
+//*****************************************************************************
+#define PWM_2_FLTSTAT0_FAULT3   0x00000008  // Fault Input 3
+#define PWM_2_FLTSTAT0_FAULT2   0x00000004  // Fault Input 2
+#define PWM_2_FLTSTAT0_FAULT1   0x00000002  // Fault Input 1
+#define PWM_2_FLTSTAT0_FAULT0   0x00000001  // Fault Input 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_2_FLTSTAT1
+// register.
+//
+//*****************************************************************************
+#define PWM_2_FLTSTAT1_DCMP7    0x00000080  // Digital Comparator 7 Trigger
+#define PWM_2_FLTSTAT1_DCMP6    0x00000040  // Digital Comparator 6 Trigger
+#define PWM_2_FLTSTAT1_DCMP5    0x00000020  // Digital Comparator 5 Trigger
+#define PWM_2_FLTSTAT1_DCMP4    0x00000010  // Digital Comparator 4 Trigger
+#define PWM_2_FLTSTAT1_DCMP3    0x00000008  // Digital Comparator 3 Trigger
+#define PWM_2_FLTSTAT1_DCMP2    0x00000004  // Digital Comparator 2 Trigger
+#define PWM_2_FLTSTAT1_DCMP1    0x00000002  // Digital Comparator 1 Trigger
+#define PWM_2_FLTSTAT1_DCMP0    0x00000001  // Digital Comparator 0 Trigger
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_3_FLTSEN register.
+//
+//*****************************************************************************
+#define PWM_3_FLTSEN_FAULT3     0x00000008  // Fault3 Sense
+#define PWM_3_FLTSEN_FAULT2     0x00000004  // Fault2 Sense
+#define PWM_3_FLTSEN_FAULT1     0x00000002  // Fault1 Sense
+#define PWM_3_FLTSEN_FAULT0     0x00000001  // Fault0 Sense
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_3_FLTSTAT0
+// register.
+//
+//*****************************************************************************
+#define PWM_3_FLTSTAT0_FAULT3   0x00000008  // Fault Input 3
+#define PWM_3_FLTSTAT0_FAULT2   0x00000004  // Fault Input 2
+#define PWM_3_FLTSTAT0_FAULT1   0x00000002  // Fault Input 1
+#define PWM_3_FLTSTAT0_FAULT0   0x00000001  // Fault Input 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_3_FLTSTAT1
+// register.
+//
+//*****************************************************************************
+#define PWM_3_FLTSTAT1_DCMP7    0x00000080  // Digital Comparator 7 Trigger
+#define PWM_3_FLTSTAT1_DCMP6    0x00000040  // Digital Comparator 6 Trigger
+#define PWM_3_FLTSTAT1_DCMP5    0x00000020  // Digital Comparator 5 Trigger
+#define PWM_3_FLTSTAT1_DCMP4    0x00000010  // Digital Comparator 4 Trigger
+#define PWM_3_FLTSTAT1_DCMP3    0x00000008  // Digital Comparator 3 Trigger
+#define PWM_3_FLTSTAT1_DCMP2    0x00000004  // Digital Comparator 2 Trigger
+#define PWM_3_FLTSTAT1_DCMP1    0x00000002  // Digital Comparator 1 Trigger
+#define PWM_3_FLTSTAT1_DCMP0    0x00000001  // Digital Comparator 0 Trigger
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_PP register.
+//
+//*****************************************************************************
+#define PWM_PP_ONE              0x00000400  // One-Shot Mode
+#define PWM_PP_EFAULT           0x00000200  // Extended Fault
+#define PWM_PP_ESYNC            0x00000100  // Extended Synchronization
+#define PWM_PP_FCNT_M           0x000000F0  // Fault Inputs (per PWM unit)
+#define PWM_PP_GCNT_M           0x0000000F  // Generators
+#define PWM_PP_FCNT_S           4
+#define PWM_PP_GCNT_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_CC register.
+//
+//*****************************************************************************
+#define PWM_CC_USEPWM           0x00000100  // Use PWM Clock Divisor
+#define PWM_CC_PWMDIV_M         0x00000007  // PWM Clock Divider
+#define PWM_CC_PWMDIV_2         0x00000000  // /2
+#define PWM_CC_PWMDIV_4         0x00000001  // /4
+#define PWM_CC_PWMDIV_8         0x00000002  // /8
+#define PWM_CC_PWMDIV_16        0x00000003  // /16
+#define PWM_CC_PWMDIV_32        0x00000004  // /32
+#define PWM_CC_PWMDIV_64        0x00000005  // /64
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_CTL register.
+//
+//*****************************************************************************
+#define QEI_CTL_FILTCNT_M       0x000F0000  // Input Filter Prescale Count
+#define QEI_CTL_FILTEN          0x00002000  // Enable Input Filter
+#define QEI_CTL_STALLEN         0x00001000  // Stall QEI
+#define QEI_CTL_INVI            0x00000800  // Invert Index Pulse
+#define QEI_CTL_INVB            0x00000400  // Invert PhB
+#define QEI_CTL_INVA            0x00000200  // Invert PhA
+#define QEI_CTL_VELDIV_M        0x000001C0  // Predivide Velocity
+#define QEI_CTL_VELDIV_1        0x00000000  // QEI clock /1
+#define QEI_CTL_VELDIV_2        0x00000040  // QEI clock /2
+#define QEI_CTL_VELDIV_4        0x00000080  // QEI clock /4
+#define QEI_CTL_VELDIV_8        0x000000C0  // QEI clock /8
+#define QEI_CTL_VELDIV_16       0x00000100  // QEI clock /16
+#define QEI_CTL_VELDIV_32       0x00000140  // QEI clock /32
+#define QEI_CTL_VELDIV_64       0x00000180  // QEI clock /64
+#define QEI_CTL_VELDIV_128      0x000001C0  // QEI clock /128
+#define QEI_CTL_VELEN           0x00000020  // Capture Velocity
+#define QEI_CTL_RESMODE         0x00000010  // Reset Mode
+#define QEI_CTL_CAPMODE         0x00000008  // Capture Mode
+#define QEI_CTL_SIGMODE         0x00000004  // Signal Mode
+#define QEI_CTL_SWAP            0x00000002  // Swap Signals
+#define QEI_CTL_ENABLE          0x00000001  // Enable QEI
+#define QEI_CTL_FILTCNT_S       16
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_STAT register.
+//
+//*****************************************************************************
+#define QEI_STAT_DIRECTION      0x00000002  // Direction of Rotation
+#define QEI_STAT_ERROR          0x00000001  // Error Detected
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_POS register.
+//
+//*****************************************************************************
+#define QEI_POS_M               0xFFFFFFFF  // Current Position Integrator
+                                            // Value
+#define QEI_POS_S               0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_MAXPOS register.
+//
+//*****************************************************************************
+#define QEI_MAXPOS_M            0xFFFFFFFF  // Maximum Position Integrator
+                                            // Value
+#define QEI_MAXPOS_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_LOAD register.
+//
+//*****************************************************************************
+#define QEI_LOAD_M              0xFFFFFFFF  // Velocity Timer Load Value
+#define QEI_LOAD_S              0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_TIME register.
+//
+//*****************************************************************************
+#define QEI_TIME_M              0xFFFFFFFF  // Velocity Timer Current Value
+#define QEI_TIME_S              0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_COUNT register.
+//
+//*****************************************************************************
+#define QEI_COUNT_M             0xFFFFFFFF  // Velocity Pulse Count
+#define QEI_COUNT_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_SPEED register.
+//
+//*****************************************************************************
+#define QEI_SPEED_M             0xFFFFFFFF  // Velocity
+#define QEI_SPEED_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_INTEN register.
+//
+//*****************************************************************************
+#define QEI_INTEN_ERROR         0x00000008  // Phase Error Interrupt Enable
+#define QEI_INTEN_DIR           0x00000004  // Direction Change Interrupt
+                                            // Enable
+#define QEI_INTEN_TIMER         0x00000002  // Timer Expires Interrupt Enable
+#define QEI_INTEN_INDEX         0x00000001  // Index Pulse Detected Interrupt
+                                            // Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_RIS register.
+//
+//*****************************************************************************
+#define QEI_RIS_ERROR           0x00000008  // Phase Error Detected
+#define QEI_RIS_DIR             0x00000004  // Direction Change Detected
+#define QEI_RIS_TIMER           0x00000002  // Velocity Timer Expired
+#define QEI_RIS_INDEX           0x00000001  // Index Pulse Asserted
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_ISC register.
+//
+//*****************************************************************************
+#define QEI_ISC_ERROR           0x00000008  // Phase Error Interrupt
+#define QEI_ISC_DIR             0x00000004  // Direction Change Interrupt
+#define QEI_ISC_TIMER           0x00000002  // Velocity Timer Expired Interrupt
+#define QEI_ISC_INDEX           0x00000001  // Index Pulse Interrupt
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_CFG register.
+//
+//*****************************************************************************
+#define TIMER_CFG_M             0x00000007  // GPTM Configuration
+#define TIMER_CFG_32_BIT_TIMER  0x00000000  // For a 16/32-bit timer, this
+                                            // value selects the 32-bit timer
+                                            // configuration
+#define TIMER_CFG_32_BIT_RTC    0x00000001  // For a 16/32-bit timer, this
+                                            // value selects the 32-bit
+                                            // real-time clock (RTC) counter
+                                            // configuration
+#define TIMER_CFG_16_BIT        0x00000004  // For a 16/32-bit timer, this
+                                            // value selects the 16-bit timer
+                                            // configuration
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAMR register.
+//
+//*****************************************************************************
+#define TIMER_TAMR_TCACT_M      0x0000E000  // Timer Compare Action Select
+#define TIMER_TAMR_TCACT_NONE   0x00000000  // Disable compare operations
+#define TIMER_TAMR_TCACT_TOGGLE 0x00002000  // Toggle State on Time-Out
+#define TIMER_TAMR_TCACT_CLRTO  0x00004000  // Clear CCP on Time-Out
+#define TIMER_TAMR_TCACT_SETTO  0x00006000  // Set CCP on Time-Out
+#define TIMER_TAMR_TCACT_SETTOGTO                                             \
+                                0x00008000  // Set CCP immediately and toggle
+                                            // on Time-Out
+#define TIMER_TAMR_TCACT_CLRTOGTO                                             \
+                                0x0000A000  // Clear CCP immediately and toggle
+                                            // on Time-Out
+#define TIMER_TAMR_TCACT_SETCLRTO                                             \
+                                0x0000C000  // Set CCP immediately and clear on
+                                            // Time-Out
+#define TIMER_TAMR_TCACT_CLRSETTO                                             \
+                                0x0000E000  // Clear CCP immediately and set on
+                                            // Time-Out
+#define TIMER_TAMR_TACINTD      0x00001000  // One-shot/Periodic Interrupt
+                                            // Disable
+#define TIMER_TAMR_TAPLO        0x00000800  // GPTM Timer A PWM Legacy
+                                            // Operation
+#define TIMER_TAMR_TAMRSU       0x00000400  // GPTM Timer A Match Register
+                                            // Update
+#define TIMER_TAMR_TAPWMIE      0x00000200  // GPTM Timer A PWM Interrupt
+                                            // Enable
+#define TIMER_TAMR_TAILD        0x00000100  // GPTM Timer A Interval Load Write
+#define TIMER_TAMR_TASNAPS      0x00000080  // GPTM Timer A Snap-Shot Mode
+#define TIMER_TAMR_TAWOT        0x00000040  // GPTM Timer A Wait-on-Trigger
+#define TIMER_TAMR_TAMIE        0x00000020  // GPTM Timer A Match Interrupt
+                                            // Enable
+#define TIMER_TAMR_TACDIR       0x00000010  // GPTM Timer A Count Direction
+#define TIMER_TAMR_TAAMS        0x00000008  // GPTM Timer A Alternate Mode
+                                            // Select
+#define TIMER_TAMR_TACMR        0x00000004  // GPTM Timer A Capture Mode
+#define TIMER_TAMR_TAMR_M       0x00000003  // GPTM Timer A Mode
+#define TIMER_TAMR_TAMR_1_SHOT  0x00000001  // One-Shot Timer mode
+#define TIMER_TAMR_TAMR_PERIOD  0x00000002  // Periodic Timer mode
+#define TIMER_TAMR_TAMR_CAP     0x00000003  // Capture mode
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBMR register.
+//
+//*****************************************************************************
+#define TIMER_TBMR_TCACT_M      0x0000E000  // Timer Compare Action Select
+#define TIMER_TBMR_TCACT_NONE   0x00000000  // Disable compare operations
+#define TIMER_TBMR_TCACT_TOGGLE 0x00002000  // Toggle State on Time-Out
+#define TIMER_TBMR_TCACT_CLRTO  0x00004000  // Clear CCP on Time-Out
+#define TIMER_TBMR_TCACT_SETTO  0x00006000  // Set CCP on Time-Out
+#define TIMER_TBMR_TCACT_SETTOGTO                                             \
+                                0x00008000  // Set CCP immediately and toggle
+                                            // on Time-Out
+#define TIMER_TBMR_TCACT_CLRTOGTO                                             \
+                                0x0000A000  // Clear CCP immediately and toggle
+                                            // on Time-Out
+#define TIMER_TBMR_TCACT_SETCLRTO                                             \
+                                0x0000C000  // Set CCP immediately and clear on
+                                            // Time-Out
+#define TIMER_TBMR_TCACT_CLRSETTO                                             \
+                                0x0000E000  // Clear CCP immediately and set on
+                                            // Time-Out
+#define TIMER_TBMR_TBCINTD      0x00001000  // One-Shot/Periodic Interrupt
+                                            // Disable
+#define TIMER_TBMR_TBPLO        0x00000800  // GPTM Timer B PWM Legacy
+                                            // Operation
+#define TIMER_TBMR_TBMRSU       0x00000400  // GPTM Timer B Match Register
+                                            // Update
+#define TIMER_TBMR_TBPWMIE      0x00000200  // GPTM Timer B PWM Interrupt
+                                            // Enable
+#define TIMER_TBMR_TBILD        0x00000100  // GPTM Timer B Interval Load Write
+#define TIMER_TBMR_TBSNAPS      0x00000080  // GPTM Timer B Snap-Shot Mode
+#define TIMER_TBMR_TBWOT        0x00000040  // GPTM Timer B Wait-on-Trigger
+#define TIMER_TBMR_TBMIE        0x00000020  // GPTM Timer B Match Interrupt
+                                            // Enable
+#define TIMER_TBMR_TBCDIR       0x00000010  // GPTM Timer B Count Direction
+#define TIMER_TBMR_TBAMS        0x00000008  // GPTM Timer B Alternate Mode
+                                            // Select
+#define TIMER_TBMR_TBCMR        0x00000004  // GPTM Timer B Capture Mode
+#define TIMER_TBMR_TBMR_M       0x00000003  // GPTM Timer B Mode
+#define TIMER_TBMR_TBMR_1_SHOT  0x00000001  // One-Shot Timer mode
+#define TIMER_TBMR_TBMR_PERIOD  0x00000002  // Periodic Timer mode
+#define TIMER_TBMR_TBMR_CAP     0x00000003  // Capture mode
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_CTL register.
+//
+//*****************************************************************************
+#define TIMER_CTL_TBPWML        0x00004000  // GPTM Timer B PWM Output Level
+#define TIMER_CTL_TBOTE         0x00002000  // GPTM Timer B Output Trigger
+                                            // Enable
+#define TIMER_CTL_TBEVENT_M     0x00000C00  // GPTM Timer B Event Mode
+#define TIMER_CTL_TBEVENT_POS   0x00000000  // Positive edge
+#define TIMER_CTL_TBEVENT_NEG   0x00000400  // Negative edge
+#define TIMER_CTL_TBEVENT_BOTH  0x00000C00  // Both edges
+#define TIMER_CTL_TBSTALL       0x00000200  // GPTM Timer B Stall Enable
+#define TIMER_CTL_TBEN          0x00000100  // GPTM Timer B Enable
+#define TIMER_CTL_TAPWML        0x00000040  // GPTM Timer A PWM Output Level
+#define TIMER_CTL_TAOTE         0x00000020  // GPTM Timer A Output Trigger
+                                            // Enable
+#define TIMER_CTL_RTCEN         0x00000010  // GPTM RTC Stall Enable
+#define TIMER_CTL_TAEVENT_M     0x0000000C  // GPTM Timer A Event Mode
+#define TIMER_CTL_TAEVENT_POS   0x00000000  // Positive edge
+#define TIMER_CTL_TAEVENT_NEG   0x00000004  // Negative edge
+#define TIMER_CTL_TAEVENT_BOTH  0x0000000C  // Both edges
+#define TIMER_CTL_TASTALL       0x00000002  // GPTM Timer A Stall Enable
+#define TIMER_CTL_TAEN          0x00000001  // GPTM Timer A Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_SYNC register.
+//
+//*****************************************************************************
+#define TIMER_SYNC_SYNCT7_M     0x0000C000  // Synchronize GPTM Timer 7
+#define TIMER_SYNC_SYNCT7_NONE  0x00000000  // GPT7 is not affected
+#define TIMER_SYNC_SYNCT7_TA    0x00004000  // A timeout event for Timer A of
+                                            // GPTM7 is triggered
+#define TIMER_SYNC_SYNCT7_TB    0x00008000  // A timeout event for Timer B of
+                                            // GPTM7 is triggered
+#define TIMER_SYNC_SYNCT7_TATB  0x0000C000  // A timeout event for both Timer A
+                                            // and Timer B of GPTM7 is
+                                            // triggered
+#define TIMER_SYNC_SYNCT6_M     0x00003000  // Synchronize GPTM Timer 6
+#define TIMER_SYNC_SYNCT6_NONE  0x00000000  // GPTM6 is not affected
+#define TIMER_SYNC_SYNCT6_TA    0x00001000  // A timeout event for Timer A of
+                                            // GPTM6 is triggered
+#define TIMER_SYNC_SYNCT6_TB    0x00002000  // A timeout event for Timer B of
+                                            // GPTM6 is triggered
+#define TIMER_SYNC_SYNCT6_TATB  0x00003000  // A timeout event for both Timer A
+                                            // and Timer B of GPTM6 is
+                                            // triggered
+#define TIMER_SYNC_SYNCT5_M     0x00000C00  // Synchronize GPTM Timer 5
+#define TIMER_SYNC_SYNCT5_NONE  0x00000000  // GPTM5 is not affected
+#define TIMER_SYNC_SYNCT5_TA    0x00000400  // A timeout event for Timer A of
+                                            // GPTM5 is triggered
+#define TIMER_SYNC_SYNCT5_TB    0x00000800  // A timeout event for Timer B of
+                                            // GPTM5 is triggered
+#define TIMER_SYNC_SYNCT5_TATB  0x00000C00  // A timeout event for both Timer A
+                                            // and Timer B of GPTM5 is
+                                            // triggered
+#define TIMER_SYNC_SYNCT4_M     0x00000300  // Synchronize GPTM Timer 4
+#define TIMER_SYNC_SYNCT4_NONE  0x00000000  // GPTM4 is not affected
+#define TIMER_SYNC_SYNCT4_TA    0x00000100  // A timeout event for Timer A of
+                                            // GPTM4 is triggered
+#define TIMER_SYNC_SYNCT4_TB    0x00000200  // A timeout event for Timer B of
+                                            // GPTM4 is triggered
+#define TIMER_SYNC_SYNCT4_TATB  0x00000300  // A timeout event for both Timer A
+                                            // and Timer B of GPTM4 is
+                                            // triggered
+#define TIMER_SYNC_SYNCT3_M     0x000000C0  // Synchronize GPTM Timer 3
+#define TIMER_SYNC_SYNCT3_NONE  0x00000000  // GPTM3 is not affected
+#define TIMER_SYNC_SYNCT3_TA    0x00000040  // A timeout event for Timer A of
+                                            // GPTM3 is triggered
+#define TIMER_SYNC_SYNCT3_TB    0x00000080  // A timeout event for Timer B of
+                                            // GPTM3 is triggered
+#define TIMER_SYNC_SYNCT3_TATB  0x000000C0  // A timeout event for both Timer A
+                                            // and Timer B of GPTM3 is
+                                            // triggered
+#define TIMER_SYNC_SYNCT2_M     0x00000030  // Synchronize GPTM Timer 2
+#define TIMER_SYNC_SYNCT2_NONE  0x00000000  // GPTM2 is not affected
+#define TIMER_SYNC_SYNCT2_TA    0x00000010  // A timeout event for Timer A of
+                                            // GPTM2 is triggered
+#define TIMER_SYNC_SYNCT2_TB    0x00000020  // A timeout event for Timer B of
+                                            // GPTM2 is triggered
+#define TIMER_SYNC_SYNCT2_TATB  0x00000030  // A timeout event for both Timer A
+                                            // and Timer B of GPTM2 is
+                                            // triggered
+#define TIMER_SYNC_SYNCT1_M     0x0000000C  // Synchronize GPTM Timer 1
+#define TIMER_SYNC_SYNCT1_NONE  0x00000000  // GPTM1 is not affected
+#define TIMER_SYNC_SYNCT1_TA    0x00000004  // A timeout event for Timer A of
+                                            // GPTM1 is triggered
+#define TIMER_SYNC_SYNCT1_TB    0x00000008  // A timeout event for Timer B of
+                                            // GPTM1 is triggered
+#define TIMER_SYNC_SYNCT1_TATB  0x0000000C  // A timeout event for both Timer A
+                                            // and Timer B of GPTM1 is
+                                            // triggered
+#define TIMER_SYNC_SYNCT0_M     0x00000003  // Synchronize GPTM Timer 0
+#define TIMER_SYNC_SYNCT0_NONE  0x00000000  // GPTM0 is not affected
+#define TIMER_SYNC_SYNCT0_TA    0x00000001  // A timeout event for Timer A of
+                                            // GPTM0 is triggered
+#define TIMER_SYNC_SYNCT0_TB    0x00000002  // A timeout event for Timer B of
+                                            // GPTM0 is triggered
+#define TIMER_SYNC_SYNCT0_TATB  0x00000003  // A timeout event for both Timer A
+                                            // and Timer B of GPTM0 is
+                                            // triggered
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_IMR register.
+//
+//*****************************************************************************
+#define TIMER_IMR_DMABIM        0x00002000  // GPTM Timer B DMA Done Interrupt
+                                            // Mask
+#define TIMER_IMR_TBMIM         0x00000800  // GPTM Timer B Match Interrupt
+                                            // Mask
+#define TIMER_IMR_CBEIM         0x00000400  // GPTM Timer B Capture Mode Event
+                                            // Interrupt Mask
+#define TIMER_IMR_CBMIM         0x00000200  // GPTM Timer B Capture Mode Match
+                                            // Interrupt Mask
+#define TIMER_IMR_TBTOIM        0x00000100  // GPTM Timer B Time-Out Interrupt
+                                            // Mask
+#define TIMER_IMR_DMAAIM        0x00000020  // GPTM Timer A DMA Done Interrupt
+                                            // Mask
+#define TIMER_IMR_TAMIM         0x00000010  // GPTM Timer A Match Interrupt
+                                            // Mask
+#define TIMER_IMR_RTCIM         0x00000008  // GPTM RTC Interrupt Mask
+#define TIMER_IMR_CAEIM         0x00000004  // GPTM Timer A Capture Mode Event
+                                            // Interrupt Mask
+#define TIMER_IMR_CAMIM         0x00000002  // GPTM Timer A Capture Mode Match
+                                            // Interrupt Mask
+#define TIMER_IMR_TATOIM        0x00000001  // GPTM Timer A Time-Out Interrupt
+                                            // Mask
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_RIS register.
+//
+//*****************************************************************************
+#define TIMER_RIS_DMABRIS       0x00002000  // GPTM Timer B DMA Done Raw
+                                            // Interrupt Status
+#define TIMER_RIS_TBMRIS        0x00000800  // GPTM Timer B Match Raw Interrupt
+#define TIMER_RIS_CBERIS        0x00000400  // GPTM Timer B Capture Mode Event
+                                            // Raw Interrupt
+#define TIMER_RIS_CBMRIS        0x00000200  // GPTM Timer B Capture Mode Match
+                                            // Raw Interrupt
+#define TIMER_RIS_TBTORIS       0x00000100  // GPTM Timer B Time-Out Raw
+                                            // Interrupt
+#define TIMER_RIS_DMAARIS       0x00000020  // GPTM Timer A DMA Done Raw
+                                            // Interrupt Status
+#define TIMER_RIS_TAMRIS        0x00000010  // GPTM Timer A Match Raw Interrupt
+#define TIMER_RIS_RTCRIS        0x00000008  // GPTM RTC Raw Interrupt
+#define TIMER_RIS_CAERIS        0x00000004  // GPTM Timer A Capture Mode Event
+                                            // Raw Interrupt
+#define TIMER_RIS_CAMRIS        0x00000002  // GPTM Timer A Capture Mode Match
+                                            // Raw Interrupt
+#define TIMER_RIS_TATORIS       0x00000001  // GPTM Timer A Time-Out Raw
+                                            // Interrupt
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_MIS register.
+//
+//*****************************************************************************
+#define TIMER_MIS_DMABMIS       0x00002000  // GPTM Timer B DMA Done Masked
+                                            // Interrupt
+#define TIMER_MIS_TBMMIS        0x00000800  // GPTM Timer B Match Masked
+                                            // Interrupt
+#define TIMER_MIS_CBEMIS        0x00000400  // GPTM Timer B Capture Mode Event
+                                            // Masked Interrupt
+#define TIMER_MIS_CBMMIS        0x00000200  // GPTM Timer B Capture Mode Match
+                                            // Masked Interrupt
+#define TIMER_MIS_TBTOMIS       0x00000100  // GPTM Timer B Time-Out Masked
+                                            // Interrupt
+#define TIMER_MIS_DMAAMIS       0x00000020  // GPTM Timer A DMA Done Masked
+                                            // Interrupt
+#define TIMER_MIS_TAMMIS        0x00000010  // GPTM Timer A Match Masked
+                                            // Interrupt
+#define TIMER_MIS_RTCMIS        0x00000008  // GPTM RTC Masked Interrupt
+#define TIMER_MIS_CAEMIS        0x00000004  // GPTM Timer A Capture Mode Event
+                                            // Masked Interrupt
+#define TIMER_MIS_CAMMIS        0x00000002  // GPTM Timer A Capture Mode Match
+                                            // Masked Interrupt
+#define TIMER_MIS_TATOMIS       0x00000001  // GPTM Timer A Time-Out Masked
+                                            // Interrupt
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_ICR register.
+//
+//*****************************************************************************
+#define TIMER_ICR_DMABINT       0x00002000  // GPTM Timer B DMA Done Interrupt
+                                            // Clear
+#define TIMER_ICR_TBMCINT       0x00000800  // GPTM Timer B Match Interrupt
+                                            // Clear
+#define TIMER_ICR_CBECINT       0x00000400  // GPTM Timer B Capture Mode Event
+                                            // Interrupt Clear
+#define TIMER_ICR_CBMCINT       0x00000200  // GPTM Timer B Capture Mode Match
+                                            // Interrupt Clear
+#define TIMER_ICR_TBTOCINT      0x00000100  // GPTM Timer B Time-Out Interrupt
+                                            // Clear
+#define TIMER_ICR_DMAAINT       0x00000020  // GPTM Timer A DMA Done Interrupt
+                                            // Clear
+#define TIMER_ICR_TAMCINT       0x00000010  // GPTM Timer A Match Interrupt
+                                            // Clear
+#define TIMER_ICR_RTCCINT       0x00000008  // GPTM RTC Interrupt Clear
+#define TIMER_ICR_CAECINT       0x00000004  // GPTM Timer A Capture Mode Event
+                                            // Interrupt Clear
+#define TIMER_ICR_CAMCINT       0x00000002  // GPTM Timer A Capture Mode Match
+                                            // Interrupt Clear
+#define TIMER_ICR_TATOCINT      0x00000001  // GPTM Timer A Time-Out Raw
+                                            // Interrupt
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAILR register.
+//
+//*****************************************************************************
+#define TIMER_TAILR_M           0xFFFFFFFF  // GPTM Timer A Interval Load
+                                            // Register
+#define TIMER_TAILR_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBILR register.
+//
+//*****************************************************************************
+#define TIMER_TBILR_M           0xFFFFFFFF  // GPTM Timer B Interval Load
+                                            // Register
+#define TIMER_TBILR_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAMATCHR
+// register.
+//
+//*****************************************************************************
+#define TIMER_TAMATCHR_TAMR_M   0xFFFFFFFF  // GPTM Timer A Match Register
+#define TIMER_TAMATCHR_TAMR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBMATCHR
+// register.
+//
+//*****************************************************************************
+#define TIMER_TBMATCHR_TBMR_M   0xFFFFFFFF  // GPTM Timer B Match Register
+#define TIMER_TBMATCHR_TBMR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAPR register.
+//
+//*****************************************************************************
+#define TIMER_TAPR_TAPSR_M      0x000000FF  // GPTM Timer A Prescale
+#define TIMER_TAPR_TAPSR_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBPR register.
+//
+//*****************************************************************************
+#define TIMER_TBPR_TBPSR_M      0x000000FF  // GPTM Timer B Prescale
+#define TIMER_TBPR_TBPSR_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAPMR register.
+//
+//*****************************************************************************
+#define TIMER_TAPMR_TAPSMR_M    0x000000FF  // GPTM TimerA Prescale Match
+#define TIMER_TAPMR_TAPSMR_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBPMR register.
+//
+//*****************************************************************************
+#define TIMER_TBPMR_TBPSMR_M    0x000000FF  // GPTM TimerB Prescale Match
+#define TIMER_TBPMR_TBPSMR_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAR register.
+//
+//*****************************************************************************
+#define TIMER_TAR_M             0xFFFFFFFF  // GPTM Timer A Register
+#define TIMER_TAR_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBR register.
+//
+//*****************************************************************************
+#define TIMER_TBR_M             0xFFFFFFFF  // GPTM Timer B Register
+#define TIMER_TBR_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAV register.
+//
+//*****************************************************************************
+#define TIMER_TAV_M             0xFFFFFFFF  // GPTM Timer A Value
+#define TIMER_TAV_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBV register.
+//
+//*****************************************************************************
+#define TIMER_TBV_M             0xFFFFFFFF  // GPTM Timer B Value
+#define TIMER_TBV_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_RTCPD register.
+//
+//*****************************************************************************
+#define TIMER_RTCPD_RTCPD_M     0x0000FFFF  // RTC Predivide Counter Value
+#define TIMER_RTCPD_RTCPD_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAPS register.
+//
+//*****************************************************************************
+#define TIMER_TAPS_PSS_M        0x0000FFFF  // GPTM Timer A Prescaler Snapshot
+#define TIMER_TAPS_PSS_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBPS register.
+//
+//*****************************************************************************
+#define TIMER_TBPS_PSS_M        0x0000FFFF  // GPTM Timer A Prescaler Value
+#define TIMER_TBPS_PSS_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_DMAEV register.
+//
+//*****************************************************************************
+#define TIMER_DMAEV_TBMDMAEN    0x00000800  // GPTM B Mode Match Event DMA
+                                            // Trigger Enable
+#define TIMER_DMAEV_CBEDMAEN    0x00000400  // GPTM B Capture Event DMA Trigger
+                                            // Enable
+#define TIMER_DMAEV_CBMDMAEN    0x00000200  // GPTM B Capture Match Event DMA
+                                            // Trigger Enable
+#define TIMER_DMAEV_TBTODMAEN   0x00000100  // GPTM B Time-Out Event DMA
+                                            // Trigger Enable
+#define TIMER_DMAEV_TAMDMAEN    0x00000010  // GPTM A Mode Match Event DMA
+                                            // Trigger Enable
+#define TIMER_DMAEV_RTCDMAEN    0x00000008  // GPTM A RTC Match Event DMA
+                                            // Trigger Enable
+#define TIMER_DMAEV_CAEDMAEN    0x00000004  // GPTM A Capture Event DMA Trigger
+                                            // Enable
+#define TIMER_DMAEV_CAMDMAEN    0x00000002  // GPTM A Capture Match Event DMA
+                                            // Trigger Enable
+#define TIMER_DMAEV_TATODMAEN   0x00000001  // GPTM A Time-Out Event DMA
+                                            // Trigger Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_ADCEV register.
+//
+//*****************************************************************************
+#define TIMER_ADCEV_TBMADCEN    0x00000800  // GPTM B Mode Match Event ADC
+                                            // Trigger Enable
+#define TIMER_ADCEV_CBEADCEN    0x00000400  // GPTM B Capture Event ADC Trigger
+                                            // Enable
+#define TIMER_ADCEV_CBMADCEN    0x00000200  // GPTM B Capture Match Event ADC
+                                            // Trigger Enable
+#define TIMER_ADCEV_TBTOADCEN   0x00000100  // GPTM B Time-Out Event ADC
+                                            // Trigger Enable
+#define TIMER_ADCEV_TAMADCEN    0x00000010  // GPTM A Mode Match Event ADC
+                                            // Trigger Enable
+#define TIMER_ADCEV_RTCADCEN    0x00000008  // GPTM RTC Match Event ADC Trigger
+                                            // Enable
+#define TIMER_ADCEV_CAEADCEN    0x00000004  // GPTM A Capture Event ADC Trigger
+                                            // Enable
+#define TIMER_ADCEV_CAMADCEN    0x00000002  // GPTM A Capture Match Event ADC
+                                            // Trigger Enable
+#define TIMER_ADCEV_TATOADCEN   0x00000001  // GPTM A Time-Out Event ADC
+                                            // Trigger Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_PP register.
+//
+//*****************************************************************************
+#define TIMER_PP_ALTCLK         0x00000040  // Alternate Clock Source
+#define TIMER_PP_SYNCCNT        0x00000020  // Synchronize Start
+#define TIMER_PP_CHAIN          0x00000010  // Chain with Other Timers
+#define TIMER_PP_SIZE_M         0x0000000F  // Count Size
+#define TIMER_PP_SIZE_16        0x00000000  // Timer A and Timer B counters are
+                                            // 16 bits each with an 8-bit
+                                            // prescale counter
+#define TIMER_PP_SIZE_32        0x00000001  // Timer A and Timer B counters are
+                                            // 32 bits each with a 16-bit
+                                            // prescale counter
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_CC register.
+//
+//*****************************************************************************
+#define TIMER_CC_ALTCLK         0x00000001  // Alternate Clock Source
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_ACTSS register.
+//
+//*****************************************************************************
+#define ADC_ACTSS_BUSY          0x00010000  // ADC Busy
+#define ADC_ACTSS_ADEN3         0x00000800  // ADC SS3 DMA Enable
+#define ADC_ACTSS_ADEN2         0x00000400  // ADC SS2 DMA Enable
+#define ADC_ACTSS_ADEN1         0x00000200  // ADC SS1 DMA Enable
+#define ADC_ACTSS_ADEN0         0x00000100  // ADC SS1 DMA Enable
+#define ADC_ACTSS_ASEN3         0x00000008  // ADC SS3 Enable
+#define ADC_ACTSS_ASEN2         0x00000004  // ADC SS2 Enable
+#define ADC_ACTSS_ASEN1         0x00000002  // ADC SS1 Enable
+#define ADC_ACTSS_ASEN0         0x00000001  // ADC SS0 Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_RIS register.
+//
+//*****************************************************************************
+#define ADC_RIS_INRDC           0x00010000  // Digital Comparator Raw Interrupt
+                                            // Status
+#define ADC_RIS_DMAINR3         0x00000800  // SS3 DMA Raw Interrupt Status
+#define ADC_RIS_DMAINR2         0x00000400  // SS2 DMA Raw Interrupt Status
+#define ADC_RIS_DMAINR1         0x00000200  // SS1 DMA Raw Interrupt Status
+#define ADC_RIS_DMAINR0         0x00000100  // SS0 DMA Raw Interrupt Status
+#define ADC_RIS_INR3            0x00000008  // SS3 Raw Interrupt Status
+#define ADC_RIS_INR2            0x00000004  // SS2 Raw Interrupt Status
+#define ADC_RIS_INR1            0x00000002  // SS1 Raw Interrupt Status
+#define ADC_RIS_INR0            0x00000001  // SS0 Raw Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_IM register.
+//
+//*****************************************************************************
+#define ADC_IM_DCONSS3          0x00080000  // Digital Comparator Interrupt on
+                                            // SS3
+#define ADC_IM_DCONSS2          0x00040000  // Digital Comparator Interrupt on
+                                            // SS2
+#define ADC_IM_DCONSS1          0x00020000  // Digital Comparator Interrupt on
+                                            // SS1
+#define ADC_IM_DCONSS0          0x00010000  // Digital Comparator Interrupt on
+                                            // SS0
+#define ADC_IM_DMAMASK3         0x00000800  // SS3 DMA Interrupt Mask
+#define ADC_IM_DMAMASK2         0x00000400  // SS2 DMA Interrupt Mask
+#define ADC_IM_DMAMASK1         0x00000200  // SS1 DMA Interrupt Mask
+#define ADC_IM_DMAMASK0         0x00000100  // SS0 DMA Interrupt Mask
+#define ADC_IM_MASK3            0x00000008  // SS3 Interrupt Mask
+#define ADC_IM_MASK2            0x00000004  // SS2 Interrupt Mask
+#define ADC_IM_MASK1            0x00000002  // SS1 Interrupt Mask
+#define ADC_IM_MASK0            0x00000001  // SS0 Interrupt Mask
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_ISC register.
+//
+//*****************************************************************************
+#define ADC_ISC_DCINSS3         0x00080000  // Digital Comparator Interrupt
+                                            // Status on SS3
+#define ADC_ISC_DCINSS2         0x00040000  // Digital Comparator Interrupt
+                                            // Status on SS2
+#define ADC_ISC_DCINSS1         0x00020000  // Digital Comparator Interrupt
+                                            // Status on SS1
+#define ADC_ISC_DCINSS0         0x00010000  // Digital Comparator Interrupt
+                                            // Status on SS0
+#define ADC_ISC_DMAIN3          0x00000800  // SS3 DMA Interrupt Status and
+                                            // Clear
+#define ADC_ISC_DMAIN2          0x00000400  // SS2 DMA Interrupt Status and
+                                            // Clear
+#define ADC_ISC_DMAIN1          0x00000200  // SS1 DMA Interrupt Status and
+                                            // Clear
+#define ADC_ISC_DMAIN0          0x00000100  // SS0 DMA Interrupt Status and
+                                            // Clear
+#define ADC_ISC_IN3             0x00000008  // SS3 Interrupt Status and Clear
+#define ADC_ISC_IN2             0x00000004  // SS2 Interrupt Status and Clear
+#define ADC_ISC_IN1             0x00000002  // SS1 Interrupt Status and Clear
+#define ADC_ISC_IN0             0x00000001  // SS0 Interrupt Status and Clear
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_OSTAT register.
+//
+//*****************************************************************************
+#define ADC_OSTAT_OV3           0x00000008  // SS3 FIFO Overflow
+#define ADC_OSTAT_OV2           0x00000004  // SS2 FIFO Overflow
+#define ADC_OSTAT_OV1           0x00000002  // SS1 FIFO Overflow
+#define ADC_OSTAT_OV0           0x00000001  // SS0 FIFO Overflow
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_EMUX register.
+//
+//*****************************************************************************
+#define ADC_EMUX_EM3_M          0x0000F000  // SS3 Trigger Select
+#define ADC_EMUX_EM3_PROCESSOR  0x00000000  // Processor (default)
+#define ADC_EMUX_EM3_COMP0      0x00001000  // Analog Comparator 0
+#define ADC_EMUX_EM3_COMP1      0x00002000  // Analog Comparator 1
+#define ADC_EMUX_EM3_COMP2      0x00003000  // Analog Comparator 2
+#define ADC_EMUX_EM3_EXTERNAL   0x00004000  // External (GPIO Pins)
+#define ADC_EMUX_EM3_TIMER      0x00005000  // Timer
+#define ADC_EMUX_EM3_PWM0       0x00006000  // PWM generator 0
+#define ADC_EMUX_EM3_PWM1       0x00007000  // PWM generator 1
+#define ADC_EMUX_EM3_PWM2       0x00008000  // PWM generator 2
+#define ADC_EMUX_EM3_PWM3       0x00009000  // PWM generator 3
+#define ADC_EMUX_EM3_NEVER      0x0000E000  // Never Trigger
+#define ADC_EMUX_EM3_ALWAYS     0x0000F000  // Always (continuously sample)
+#define ADC_EMUX_EM2_M          0x00000F00  // SS2 Trigger Select
+#define ADC_EMUX_EM2_PROCESSOR  0x00000000  // Processor (default)
+#define ADC_EMUX_EM2_COMP0      0x00000100  // Analog Comparator 0
+#define ADC_EMUX_EM2_COMP1      0x00000200  // Analog Comparator 1
+#define ADC_EMUX_EM2_COMP2      0x00000300  // Analog Comparator 2
+#define ADC_EMUX_EM2_EXTERNAL   0x00000400  // External (GPIO Pins)
+#define ADC_EMUX_EM2_TIMER      0x00000500  // Timer
+#define ADC_EMUX_EM2_PWM0       0x00000600  // PWM generator 0
+#define ADC_EMUX_EM2_PWM1       0x00000700  // PWM generator 1
+#define ADC_EMUX_EM2_PWM2       0x00000800  // PWM generator 2
+#define ADC_EMUX_EM2_PWM3       0x00000900  // PWM generator 3
+#define ADC_EMUX_EM2_NEVER      0x00000E00  // Never Trigger
+#define ADC_EMUX_EM2_ALWAYS     0x00000F00  // Always (continuously sample)
+#define ADC_EMUX_EM1_M          0x000000F0  // SS1 Trigger Select
+#define ADC_EMUX_EM1_PROCESSOR  0x00000000  // Processor (default)
+#define ADC_EMUX_EM1_COMP0      0x00000010  // Analog Comparator 0
+#define ADC_EMUX_EM1_COMP1      0x00000020  // Analog Comparator 1
+#define ADC_EMUX_EM1_COMP2      0x00000030  // Analog Comparator 2
+#define ADC_EMUX_EM1_EXTERNAL   0x00000040  // External (GPIO Pins)
+#define ADC_EMUX_EM1_TIMER      0x00000050  // Timer
+#define ADC_EMUX_EM1_PWM0       0x00000060  // PWM generator 0
+#define ADC_EMUX_EM1_PWM1       0x00000070  // PWM generator 1
+#define ADC_EMUX_EM1_PWM2       0x00000080  // PWM generator 2
+#define ADC_EMUX_EM1_PWM3       0x00000090  // PWM generator 3
+#define ADC_EMUX_EM1_NEVER      0x000000E0  // Never Trigger
+#define ADC_EMUX_EM1_ALWAYS     0x000000F0  // Always (continuously sample)
+#define ADC_EMUX_EM0_M          0x0000000F  // SS0 Trigger Select
+#define ADC_EMUX_EM0_PROCESSOR  0x00000000  // Processor (default)
+#define ADC_EMUX_EM0_COMP0      0x00000001  // Analog Comparator 0
+#define ADC_EMUX_EM0_COMP1      0x00000002  // Analog Comparator 1
+#define ADC_EMUX_EM0_COMP2      0x00000003  // Analog Comparator 2
+#define ADC_EMUX_EM0_EXTERNAL   0x00000004  // External (GPIO Pins)
+#define ADC_EMUX_EM0_TIMER      0x00000005  // Timer
+#define ADC_EMUX_EM0_PWM0       0x00000006  // PWM generator 0
+#define ADC_EMUX_EM0_PWM1       0x00000007  // PWM generator 1
+#define ADC_EMUX_EM0_PWM2       0x00000008  // PWM generator 2
+#define ADC_EMUX_EM0_PWM3       0x00000009  // PWM generator 3
+#define ADC_EMUX_EM0_NEVER      0x0000000E  // Never Trigger
+#define ADC_EMUX_EM0_ALWAYS     0x0000000F  // Always (continuously sample)
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_USTAT register.
+//
+//*****************************************************************************
+#define ADC_USTAT_UV3           0x00000008  // SS3 FIFO Underflow
+#define ADC_USTAT_UV2           0x00000004  // SS2 FIFO Underflow
+#define ADC_USTAT_UV1           0x00000002  // SS1 FIFO Underflow
+#define ADC_USTAT_UV0           0x00000001  // SS0 FIFO Underflow
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_TSSEL register.
+//
+//*****************************************************************************
+#define ADC_TSSEL_PS3_M         0x30000000  // Generator 3 PWM Module Trigger
+                                            // Select
+#define ADC_TSSEL_PS3_0         0x00000000  // Use Generator 3 (and its
+                                            // trigger) in PWM module 0
+#define ADC_TSSEL_PS2_M         0x00300000  // Generator 2 PWM Module Trigger
+                                            // Select
+#define ADC_TSSEL_PS2_0         0x00000000  // Use Generator 2 (and its
+                                            // trigger) in PWM module 0
+#define ADC_TSSEL_PS1_M         0x00003000  // Generator 1 PWM Module Trigger
+                                            // Select
+#define ADC_TSSEL_PS1_0         0x00000000  // Use Generator 1 (and its
+                                            // trigger) in PWM module 0
+#define ADC_TSSEL_PS0_M         0x00000030  // Generator 0 PWM Module Trigger
+                                            // Select
+#define ADC_TSSEL_PS0_0         0x00000000  // Use Generator 0 (and its
+                                            // trigger) in PWM module 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSPRI register.
+//
+//*****************************************************************************
+#define ADC_SSPRI_SS3_M         0x00003000  // SS3 Priority
+#define ADC_SSPRI_SS2_M         0x00000300  // SS2 Priority
+#define ADC_SSPRI_SS1_M         0x00000030  // SS1 Priority
+#define ADC_SSPRI_SS0_M         0x00000003  // SS0 Priority
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SPC register.
+//
+//*****************************************************************************
+#define ADC_SPC_PHASE_M         0x0000000F  // Phase Difference
+#define ADC_SPC_PHASE_0         0x00000000  // ADC sample lags by 0.0
+#define ADC_SPC_PHASE_22_5      0x00000001  // ADC sample lags by 22.5
+#define ADC_SPC_PHASE_45        0x00000002  // ADC sample lags by 45.0
+#define ADC_SPC_PHASE_67_5      0x00000003  // ADC sample lags by 67.5
+#define ADC_SPC_PHASE_90        0x00000004  // ADC sample lags by 90.0
+#define ADC_SPC_PHASE_112_5     0x00000005  // ADC sample lags by 112.5
+#define ADC_SPC_PHASE_135       0x00000006  // ADC sample lags by 135.0
+#define ADC_SPC_PHASE_157_5     0x00000007  // ADC sample lags by 157.5
+#define ADC_SPC_PHASE_180       0x00000008  // ADC sample lags by 180.0
+#define ADC_SPC_PHASE_202_5     0x00000009  // ADC sample lags by 202.5
+#define ADC_SPC_PHASE_225       0x0000000A  // ADC sample lags by 225.0
+#define ADC_SPC_PHASE_247_5     0x0000000B  // ADC sample lags by 247.5
+#define ADC_SPC_PHASE_270       0x0000000C  // ADC sample lags by 270.0
+#define ADC_SPC_PHASE_292_5     0x0000000D  // ADC sample lags by 292.5
+#define ADC_SPC_PHASE_315       0x0000000E  // ADC sample lags by 315.0
+#define ADC_SPC_PHASE_337_5     0x0000000F  // ADC sample lags by 337.5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_PSSI register.
+//
+//*****************************************************************************
+#define ADC_PSSI_GSYNC          0x80000000  // Global Synchronize
+#define ADC_PSSI_SYNCWAIT       0x08000000  // Synchronize Wait
+#define ADC_PSSI_SS3            0x00000008  // SS3 Initiate
+#define ADC_PSSI_SS2            0x00000004  // SS2 Initiate
+#define ADC_PSSI_SS1            0x00000002  // SS1 Initiate
+#define ADC_PSSI_SS0            0x00000001  // SS0 Initiate
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SAC register.
+//
+//*****************************************************************************
+#define ADC_SAC_AVG_M           0x00000007  // Hardware Averaging Control
+#define ADC_SAC_AVG_OFF         0x00000000  // No hardware oversampling
+#define ADC_SAC_AVG_2X          0x00000001  // 2x hardware oversampling
+#define ADC_SAC_AVG_4X          0x00000002  // 4x hardware oversampling
+#define ADC_SAC_AVG_8X          0x00000003  // 8x hardware oversampling
+#define ADC_SAC_AVG_16X         0x00000004  // 16x hardware oversampling
+#define ADC_SAC_AVG_32X         0x00000005  // 32x hardware oversampling
+#define ADC_SAC_AVG_64X         0x00000006  // 64x hardware oversampling
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCISC register.
+//
+//*****************************************************************************
+#define ADC_DCISC_DCINT7        0x00000080  // Digital Comparator 7 Interrupt
+                                            // Status and Clear
+#define ADC_DCISC_DCINT6        0x00000040  // Digital Comparator 6 Interrupt
+                                            // Status and Clear
+#define ADC_DCISC_DCINT5        0x00000020  // Digital Comparator 5 Interrupt
+                                            // Status and Clear
+#define ADC_DCISC_DCINT4        0x00000010  // Digital Comparator 4 Interrupt
+                                            // Status and Clear
+#define ADC_DCISC_DCINT3        0x00000008  // Digital Comparator 3 Interrupt
+                                            // Status and Clear
+#define ADC_DCISC_DCINT2        0x00000004  // Digital Comparator 2 Interrupt
+                                            // Status and Clear
+#define ADC_DCISC_DCINT1        0x00000002  // Digital Comparator 1 Interrupt
+                                            // Status and Clear
+#define ADC_DCISC_DCINT0        0x00000001  // Digital Comparator 0 Interrupt
+                                            // Status and Clear
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_CTL register.
+//
+//*****************************************************************************
+#define ADC_CTL_DITHER          0x00000040  // Dither Mode Enable
+#define ADC_CTL_VREF_M          0x00000001  // Voltage Reference Select
+#define ADC_CTL_VREF_INTERNAL   0x00000000  // VDDA and GNDA are the voltage
+                                            // references
+#define ADC_CTL_VREF_EXT_3V     0x00000001  // The external VREFA+ and VREFA-
+                                            // inputs are the voltage
+                                            // references
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSMUX0 register.
+//
+//*****************************************************************************
+#define ADC_SSMUX0_MUX7_M       0xF0000000  // 8th Sample Input Select
+#define ADC_SSMUX0_MUX6_M       0x0F000000  // 7th Sample Input Select
+#define ADC_SSMUX0_MUX5_M       0x00F00000  // 6th Sample Input Select
+#define ADC_SSMUX0_MUX4_M       0x000F0000  // 5th Sample Input Select
+#define ADC_SSMUX0_MUX3_M       0x0000F000  // 4th Sample Input Select
+#define ADC_SSMUX0_MUX2_M       0x00000F00  // 3rd Sample Input Select
+#define ADC_SSMUX0_MUX1_M       0x000000F0  // 2nd Sample Input Select
+#define ADC_SSMUX0_MUX0_M       0x0000000F  // 1st Sample Input Select
+#define ADC_SSMUX0_MUX7_S       28
+#define ADC_SSMUX0_MUX6_S       24
+#define ADC_SSMUX0_MUX5_S       20
+#define ADC_SSMUX0_MUX4_S       16
+#define ADC_SSMUX0_MUX3_S       12
+#define ADC_SSMUX0_MUX2_S       8
+#define ADC_SSMUX0_MUX1_S       4
+#define ADC_SSMUX0_MUX0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSCTL0 register.
+//
+//*****************************************************************************
+#define ADC_SSCTL0_TS7          0x80000000  // 8th Sample Temp Sensor Select
+#define ADC_SSCTL0_IE7          0x40000000  // 8th Sample Interrupt Enable
+#define ADC_SSCTL0_END7         0x20000000  // 8th Sample is End of Sequence
+#define ADC_SSCTL0_D7           0x10000000  // 8th Sample Differential Input
+                                            // Select
+#define ADC_SSCTL0_TS6          0x08000000  // 7th Sample Temp Sensor Select
+#define ADC_SSCTL0_IE6          0x04000000  // 7th Sample Interrupt Enable
+#define ADC_SSCTL0_END6         0x02000000  // 7th Sample is End of Sequence
+#define ADC_SSCTL0_D6           0x01000000  // 7th Sample Differential Input
+                                            // Select
+#define ADC_SSCTL0_TS5          0x00800000  // 6th Sample Temp Sensor Select
+#define ADC_SSCTL0_IE5          0x00400000  // 6th Sample Interrupt Enable
+#define ADC_SSCTL0_END5         0x00200000  // 6th Sample is End of Sequence
+#define ADC_SSCTL0_D5           0x00100000  // 6th Sample Differential Input
+                                            // Select
+#define ADC_SSCTL0_TS4          0x00080000  // 5th Sample Temp Sensor Select
+#define ADC_SSCTL0_IE4          0x00040000  // 5th Sample Interrupt Enable
+#define ADC_SSCTL0_END4         0x00020000  // 5th Sample is End of Sequence
+#define ADC_SSCTL0_D4           0x00010000  // 5th Sample Differential Input
+                                            // Select
+#define ADC_SSCTL0_TS3          0x00008000  // 4th Sample Temp Sensor Select
+#define ADC_SSCTL0_IE3          0x00004000  // 4th Sample Interrupt Enable
+#define ADC_SSCTL0_END3         0x00002000  // 4th Sample is End of Sequence
+#define ADC_SSCTL0_D3           0x00001000  // 4th Sample Differential Input
+                                            // Select
+#define ADC_SSCTL0_TS2          0x00000800  // 3rd Sample Temp Sensor Select
+#define ADC_SSCTL0_IE2          0x00000400  // 3rd Sample Interrupt Enable
+#define ADC_SSCTL0_END2         0x00000200  // 3rd Sample is End of Sequence
+#define ADC_SSCTL0_D2           0x00000100  // 3rd Sample Differential Input
+                                            // Select
+#define ADC_SSCTL0_TS1          0x00000080  // 2nd Sample Temp Sensor Select
+#define ADC_SSCTL0_IE1          0x00000040  // 2nd Sample Interrupt Enable
+#define ADC_SSCTL0_END1         0x00000020  // 2nd Sample is End of Sequence
+#define ADC_SSCTL0_D1           0x00000010  // 2nd Sample Differential Input
+                                            // Select
+#define ADC_SSCTL0_TS0          0x00000008  // 1st Sample Temp Sensor Select
+#define ADC_SSCTL0_IE0          0x00000004  // 1st Sample Interrupt Enable
+#define ADC_SSCTL0_END0         0x00000002  // 1st Sample is End of Sequence
+#define ADC_SSCTL0_D0           0x00000001  // 1st Sample Differential Input
+                                            // Select
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFIFO0 register.
+//
+//*****************************************************************************
+#define ADC_SSFIFO0_DATA_M      0x00000FFF  // Conversion Result Data
+#define ADC_SSFIFO0_DATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFSTAT0 register.
+//
+//*****************************************************************************
+#define ADC_SSFSTAT0_FULL       0x00001000  // FIFO Full
+#define ADC_SSFSTAT0_EMPTY      0x00000100  // FIFO Empty
+#define ADC_SSFSTAT0_HPTR_M     0x000000F0  // FIFO Head Pointer
+#define ADC_SSFSTAT0_TPTR_M     0x0000000F  // FIFO Tail Pointer
+#define ADC_SSFSTAT0_HPTR_S     4
+#define ADC_SSFSTAT0_TPTR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSOP0 register.
+//
+//*****************************************************************************
+#define ADC_SSOP0_S7DCOP        0x10000000  // Sample 7 Digital Comparator
+                                            // Operation
+#define ADC_SSOP0_S6DCOP        0x01000000  // Sample 6 Digital Comparator
+                                            // Operation
+#define ADC_SSOP0_S5DCOP        0x00100000  // Sample 5 Digital Comparator
+                                            // Operation
+#define ADC_SSOP0_S4DCOP        0x00010000  // Sample 4 Digital Comparator
+                                            // Operation
+#define ADC_SSOP0_S3DCOP        0x00001000  // Sample 3 Digital Comparator
+                                            // Operation
+#define ADC_SSOP0_S2DCOP        0x00000100  // Sample 2 Digital Comparator
+                                            // Operation
+#define ADC_SSOP0_S1DCOP        0x00000010  // Sample 1 Digital Comparator
+                                            // Operation
+#define ADC_SSOP0_S0DCOP        0x00000001  // Sample 0 Digital Comparator
+                                            // Operation
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSDC0 register.
+//
+//*****************************************************************************
+#define ADC_SSDC0_S7DCSEL_M     0xF0000000  // Sample 7 Digital Comparator
+                                            // Select
+#define ADC_SSDC0_S6DCSEL_M     0x0F000000  // Sample 6 Digital Comparator
+                                            // Select
+#define ADC_SSDC0_S5DCSEL_M     0x00F00000  // Sample 5 Digital Comparator
+                                            // Select
+#define ADC_SSDC0_S4DCSEL_M     0x000F0000  // Sample 4 Digital Comparator
+                                            // Select
+#define ADC_SSDC0_S3DCSEL_M     0x0000F000  // Sample 3 Digital Comparator
+                                            // Select
+#define ADC_SSDC0_S2DCSEL_M     0x00000F00  // Sample 2 Digital Comparator
+                                            // Select
+#define ADC_SSDC0_S1DCSEL_M     0x000000F0  // Sample 1 Digital Comparator
+                                            // Select
+#define ADC_SSDC0_S0DCSEL_M     0x0000000F  // Sample 0 Digital Comparator
+                                            // Select
+#define ADC_SSDC0_S6DCSEL_S     24
+#define ADC_SSDC0_S5DCSEL_S     20
+#define ADC_SSDC0_S4DCSEL_S     16
+#define ADC_SSDC0_S3DCSEL_S     12
+#define ADC_SSDC0_S2DCSEL_S     8
+#define ADC_SSDC0_S1DCSEL_S     4
+#define ADC_SSDC0_S0DCSEL_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSEMUX0 register.
+//
+//*****************************************************************************
+#define ADC_SSEMUX0_EMUX7       0x10000000  // 8th Sample Input Select (Upper
+                                            // Bit)
+#define ADC_SSEMUX0_EMUX6       0x01000000  // 7th Sample Input Select (Upper
+                                            // Bit)
+#define ADC_SSEMUX0_EMUX5       0x00100000  // 6th Sample Input Select (Upper
+                                            // Bit)
+#define ADC_SSEMUX0_EMUX4       0x00010000  // 5th Sample Input Select (Upper
+                                            // Bit)
+#define ADC_SSEMUX0_EMUX3       0x00001000  // 4th Sample Input Select (Upper
+                                            // Bit)
+#define ADC_SSEMUX0_EMUX2       0x00000100  // 3rd Sample Input Select (Upper
+                                            // Bit)
+#define ADC_SSEMUX0_EMUX1       0x00000010  // 2th Sample Input Select (Upper
+                                            // Bit)
+#define ADC_SSEMUX0_EMUX0       0x00000001  // 1st Sample Input Select (Upper
+                                            // Bit)
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSTSH0 register.
+//
+//*****************************************************************************
+#define ADC_SSTSH0_TSH7_M       0xF0000000  // 8th Sample and Hold Period
+                                            // Select
+#define ADC_SSTSH0_TSH6_M       0x0F000000  // 7th Sample and Hold Period
+                                            // Select
+#define ADC_SSTSH0_TSH5_M       0x00F00000  // 6th Sample and Hold Period
+                                            // Select
+#define ADC_SSTSH0_TSH4_M       0x000F0000  // 5th Sample and Hold Period
+                                            // Select
+#define ADC_SSTSH0_TSH3_M       0x0000F000  // 4th Sample and Hold Period
+                                            // Select
+#define ADC_SSTSH0_TSH2_M       0x00000F00  // 3rd Sample and Hold Period
+                                            // Select
+#define ADC_SSTSH0_TSH1_M       0x000000F0  // 2nd Sample and Hold Period
+                                            // Select
+#define ADC_SSTSH0_TSH0_M       0x0000000F  // 1st Sample and Hold Period
+                                            // Select
+#define ADC_SSTSH0_TSH7_S       28
+#define ADC_SSTSH0_TSH6_S       24
+#define ADC_SSTSH0_TSH5_S       20
+#define ADC_SSTSH0_TSH4_S       16
+#define ADC_SSTSH0_TSH3_S       12
+#define ADC_SSTSH0_TSH2_S       8
+#define ADC_SSTSH0_TSH1_S       4
+#define ADC_SSTSH0_TSH0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSMUX1 register.
+//
+//*****************************************************************************
+#define ADC_SSMUX1_MUX3_M       0x0000F000  // 4th Sample Input Select
+#define ADC_SSMUX1_MUX2_M       0x00000F00  // 3rd Sample Input Select
+#define ADC_SSMUX1_MUX1_M       0x000000F0  // 2nd Sample Input Select
+#define ADC_SSMUX1_MUX0_M       0x0000000F  // 1st Sample Input Select
+#define ADC_SSMUX1_MUX3_S       12
+#define ADC_SSMUX1_MUX2_S       8
+#define ADC_SSMUX1_MUX1_S       4
+#define ADC_SSMUX1_MUX0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSCTL1 register.
+//
+//*****************************************************************************
+#define ADC_SSCTL1_TS3          0x00008000  // 4th Sample Temp Sensor Select
+#define ADC_SSCTL1_IE3          0x00004000  // 4th Sample Interrupt Enable
+#define ADC_SSCTL1_END3         0x00002000  // 4th Sample is End of Sequence
+#define ADC_SSCTL1_D3           0x00001000  // 4th Sample Differential Input
+                                            // Select
+#define ADC_SSCTL1_TS2          0x00000800  // 3rd Sample Temp Sensor Select
+#define ADC_SSCTL1_IE2          0x00000400  // 3rd Sample Interrupt Enable
+#define ADC_SSCTL1_END2         0x00000200  // 3rd Sample is End of Sequence
+#define ADC_SSCTL1_D2           0x00000100  // 3rd Sample Differential Input
+                                            // Select
+#define ADC_SSCTL1_TS1          0x00000080  // 2nd Sample Temp Sensor Select
+#define ADC_SSCTL1_IE1          0x00000040  // 2nd Sample Interrupt Enable
+#define ADC_SSCTL1_END1         0x00000020  // 2nd Sample is End of Sequence
+#define ADC_SSCTL1_D1           0x00000010  // 2nd Sample Differential Input
+                                            // Select
+#define ADC_SSCTL1_TS0          0x00000008  // 1st Sample Temp Sensor Select
+#define ADC_SSCTL1_IE0          0x00000004  // 1st Sample Interrupt Enable
+#define ADC_SSCTL1_END0         0x00000002  // 1st Sample is End of Sequence
+#define ADC_SSCTL1_D0           0x00000001  // 1st Sample Differential Input
+                                            // Select
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFIFO1 register.
+//
+//*****************************************************************************
+#define ADC_SSFIFO1_DATA_M      0x00000FFF  // Conversion Result Data
+#define ADC_SSFIFO1_DATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFSTAT1 register.
+//
+//*****************************************************************************
+#define ADC_SSFSTAT1_FULL       0x00001000  // FIFO Full
+#define ADC_SSFSTAT1_EMPTY      0x00000100  // FIFO Empty
+#define ADC_SSFSTAT1_HPTR_M     0x000000F0  // FIFO Head Pointer
+#define ADC_SSFSTAT1_TPTR_M     0x0000000F  // FIFO Tail Pointer
+#define ADC_SSFSTAT1_HPTR_S     4
+#define ADC_SSFSTAT1_TPTR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSOP1 register.
+//
+//*****************************************************************************
+#define ADC_SSOP1_S3DCOP        0x00001000  // Sample 3 Digital Comparator
+                                            // Operation
+#define ADC_SSOP1_S2DCOP        0x00000100  // Sample 2 Digital Comparator
+                                            // Operation
+#define ADC_SSOP1_S1DCOP        0x00000010  // Sample 1 Digital Comparator
+                                            // Operation
+#define ADC_SSOP1_S0DCOP        0x00000001  // Sample 0 Digital Comparator
+                                            // Operation
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSDC1 register.
+//
+//*****************************************************************************
+#define ADC_SSDC1_S3DCSEL_M     0x0000F000  // Sample 3 Digital Comparator
+                                            // Select
+#define ADC_SSDC1_S2DCSEL_M     0x00000F00  // Sample 2 Digital Comparator
+                                            // Select
+#define ADC_SSDC1_S1DCSEL_M     0x000000F0  // Sample 1 Digital Comparator
+                                            // Select
+#define ADC_SSDC1_S0DCSEL_M     0x0000000F  // Sample 0 Digital Comparator
+                                            // Select
+#define ADC_SSDC1_S2DCSEL_S     8
+#define ADC_SSDC1_S1DCSEL_S     4
+#define ADC_SSDC1_S0DCSEL_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSEMUX1 register.
+//
+//*****************************************************************************
+#define ADC_SSEMUX1_EMUX3       0x00001000  // 4th Sample Input Select (Upper
+                                            // Bit)
+#define ADC_SSEMUX1_EMUX2       0x00000100  // 3rd Sample Input Select (Upper
+                                            // Bit)
+#define ADC_SSEMUX1_EMUX1       0x00000010  // 2th Sample Input Select (Upper
+                                            // Bit)
+#define ADC_SSEMUX1_EMUX0       0x00000001  // 1st Sample Input Select (Upper
+                                            // Bit)
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSTSH1 register.
+//
+//*****************************************************************************
+#define ADC_SSTSH1_TSH3_M       0x0000F000  // 4th Sample and Hold Period
+                                            // Select
+#define ADC_SSTSH1_TSH2_M       0x00000F00  // 3rd Sample and Hold Period
+                                            // Select
+#define ADC_SSTSH1_TSH1_M       0x000000F0  // 2nd Sample and Hold Period
+                                            // Select
+#define ADC_SSTSH1_TSH0_M       0x0000000F  // 1st Sample and Hold Period
+                                            // Select
+#define ADC_SSTSH1_TSH3_S       12
+#define ADC_SSTSH1_TSH2_S       8
+#define ADC_SSTSH1_TSH1_S       4
+#define ADC_SSTSH1_TSH0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSMUX2 register.
+//
+//*****************************************************************************
+#define ADC_SSMUX2_MUX3_M       0x0000F000  // 4th Sample Input Select
+#define ADC_SSMUX2_MUX2_M       0x00000F00  // 3rd Sample Input Select
+#define ADC_SSMUX2_MUX1_M       0x000000F0  // 2nd Sample Input Select
+#define ADC_SSMUX2_MUX0_M       0x0000000F  // 1st Sample Input Select
+#define ADC_SSMUX2_MUX3_S       12
+#define ADC_SSMUX2_MUX2_S       8
+#define ADC_SSMUX2_MUX1_S       4
+#define ADC_SSMUX2_MUX0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSCTL2 register.
+//
+//*****************************************************************************
+#define ADC_SSCTL2_TS3          0x00008000  // 4th Sample Temp Sensor Select
+#define ADC_SSCTL2_IE3          0x00004000  // 4th Sample Interrupt Enable
+#define ADC_SSCTL2_END3         0x00002000  // 4th Sample is End of Sequence
+#define ADC_SSCTL2_D3           0x00001000  // 4th Sample Differential Input
+                                            // Select
+#define ADC_SSCTL2_TS2          0x00000800  // 3rd Sample Temp Sensor Select
+#define ADC_SSCTL2_IE2          0x00000400  // 3rd Sample Interrupt Enable
+#define ADC_SSCTL2_END2         0x00000200  // 3rd Sample is End of Sequence
+#define ADC_SSCTL2_D2           0x00000100  // 3rd Sample Differential Input
+                                            // Select
+#define ADC_SSCTL2_TS1          0x00000080  // 2nd Sample Temp Sensor Select
+#define ADC_SSCTL2_IE1          0x00000040  // 2nd Sample Interrupt Enable
+#define ADC_SSCTL2_END1         0x00000020  // 2nd Sample is End of Sequence
+#define ADC_SSCTL2_D1           0x00000010  // 2nd Sample Differential Input
+                                            // Select
+#define ADC_SSCTL2_TS0          0x00000008  // 1st Sample Temp Sensor Select
+#define ADC_SSCTL2_IE0          0x00000004  // 1st Sample Interrupt Enable
+#define ADC_SSCTL2_END0         0x00000002  // 1st Sample is End of Sequence
+#define ADC_SSCTL2_D0           0x00000001  // 1st Sample Differential Input
+                                            // Select
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFIFO2 register.
+//
+//*****************************************************************************
+#define ADC_SSFIFO2_DATA_M      0x00000FFF  // Conversion Result Data
+#define ADC_SSFIFO2_DATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFSTAT2 register.
+//
+//*****************************************************************************
+#define ADC_SSFSTAT2_FULL       0x00001000  // FIFO Full
+#define ADC_SSFSTAT2_EMPTY      0x00000100  // FIFO Empty
+#define ADC_SSFSTAT2_HPTR_M     0x000000F0  // FIFO Head Pointer
+#define ADC_SSFSTAT2_TPTR_M     0x0000000F  // FIFO Tail Pointer
+#define ADC_SSFSTAT2_HPTR_S     4
+#define ADC_SSFSTAT2_TPTR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSOP2 register.
+//
+//*****************************************************************************
+#define ADC_SSOP2_S3DCOP        0x00001000  // Sample 3 Digital Comparator
+                                            // Operation
+#define ADC_SSOP2_S2DCOP        0x00000100  // Sample 2 Digital Comparator
+                                            // Operation
+#define ADC_SSOP2_S1DCOP        0x00000010  // Sample 1 Digital Comparator
+                                            // Operation
+#define ADC_SSOP2_S0DCOP        0x00000001  // Sample 0 Digital Comparator
+                                            // Operation
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSDC2 register.
+//
+//*****************************************************************************
+#define ADC_SSDC2_S3DCSEL_M     0x0000F000  // Sample 3 Digital Comparator
+                                            // Select
+#define ADC_SSDC2_S2DCSEL_M     0x00000F00  // Sample 2 Digital Comparator
+                                            // Select
+#define ADC_SSDC2_S1DCSEL_M     0x000000F0  // Sample 1 Digital Comparator
+                                            // Select
+#define ADC_SSDC2_S0DCSEL_M     0x0000000F  // Sample 0 Digital Comparator
+                                            // Select
+#define ADC_SSDC2_S2DCSEL_S     8
+#define ADC_SSDC2_S1DCSEL_S     4
+#define ADC_SSDC2_S0DCSEL_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSEMUX2 register.
+//
+//*****************************************************************************
+#define ADC_SSEMUX2_EMUX3       0x00001000  // 4th Sample Input Select (Upper
+                                            // Bit)
+#define ADC_SSEMUX2_EMUX2       0x00000100  // 3rd Sample Input Select (Upper
+                                            // Bit)
+#define ADC_SSEMUX2_EMUX1       0x00000010  // 2th Sample Input Select (Upper
+                                            // Bit)
+#define ADC_SSEMUX2_EMUX0       0x00000001  // 1st Sample Input Select (Upper
+                                            // Bit)
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSTSH2 register.
+//
+//*****************************************************************************
+#define ADC_SSTSH2_TSH3_M       0x0000F000  // 4th Sample and Hold Period
+                                            // Select
+#define ADC_SSTSH2_TSH2_M       0x00000F00  // 3rd Sample and Hold Period
+                                            // Select
+#define ADC_SSTSH2_TSH1_M       0x000000F0  // 2nd Sample and Hold Period
+                                            // Select
+#define ADC_SSTSH2_TSH0_M       0x0000000F  // 1st Sample and Hold Period
+                                            // Select
+#define ADC_SSTSH2_TSH3_S       12
+#define ADC_SSTSH2_TSH2_S       8
+#define ADC_SSTSH2_TSH1_S       4
+#define ADC_SSTSH2_TSH0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSMUX3 register.
+//
+//*****************************************************************************
+#define ADC_SSMUX3_MUX0_M       0x0000000F  // 1st Sample Input Select
+#define ADC_SSMUX3_MUX0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSCTL3 register.
+//
+//*****************************************************************************
+#define ADC_SSCTL3_TS0          0x00000008  // 1st Sample Temp Sensor Select
+#define ADC_SSCTL3_IE0          0x00000004  // Sample Interrupt Enable
+#define ADC_SSCTL3_END0         0x00000002  // End of Sequence
+#define ADC_SSCTL3_D0           0x00000001  // Sample Differential Input Select
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFIFO3 register.
+//
+//*****************************************************************************
+#define ADC_SSFIFO3_DATA_M      0x00000FFF  // Conversion Result Data
+#define ADC_SSFIFO3_DATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFSTAT3 register.
+//
+//*****************************************************************************
+#define ADC_SSFSTAT3_FULL       0x00001000  // FIFO Full
+#define ADC_SSFSTAT3_EMPTY      0x00000100  // FIFO Empty
+#define ADC_SSFSTAT3_HPTR_M     0x000000F0  // FIFO Head Pointer
+#define ADC_SSFSTAT3_TPTR_M     0x0000000F  // FIFO Tail Pointer
+#define ADC_SSFSTAT3_HPTR_S     4
+#define ADC_SSFSTAT3_TPTR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSOP3 register.
+//
+//*****************************************************************************
+#define ADC_SSOP3_S0DCOP        0x00000001  // Sample 0 Digital Comparator
+                                            // Operation
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSDC3 register.
+//
+//*****************************************************************************
+#define ADC_SSDC3_S0DCSEL_M     0x0000000F  // Sample 0 Digital Comparator
+                                            // Select
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSEMUX3 register.
+//
+//*****************************************************************************
+#define ADC_SSEMUX3_EMUX0       0x00000001  // 1st Sample Input Select (Upper
+                                            // Bit)
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSTSH3 register.
+//
+//*****************************************************************************
+#define ADC_SSTSH3_TSH0_M       0x0000000F  // 1st Sample and Hold Period
+                                            // Select
+#define ADC_SSTSH3_TSH0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCRIC register.
+//
+//*****************************************************************************
+#define ADC_DCRIC_DCTRIG7       0x00800000  // Digital Comparator Trigger 7
+#define ADC_DCRIC_DCTRIG6       0x00400000  // Digital Comparator Trigger 6
+#define ADC_DCRIC_DCTRIG5       0x00200000  // Digital Comparator Trigger 5
+#define ADC_DCRIC_DCTRIG4       0x00100000  // Digital Comparator Trigger 4
+#define ADC_DCRIC_DCTRIG3       0x00080000  // Digital Comparator Trigger 3
+#define ADC_DCRIC_DCTRIG2       0x00040000  // Digital Comparator Trigger 2
+#define ADC_DCRIC_DCTRIG1       0x00020000  // Digital Comparator Trigger 1
+#define ADC_DCRIC_DCTRIG0       0x00010000  // Digital Comparator Trigger 0
+#define ADC_DCRIC_DCINT7        0x00000080  // Digital Comparator Interrupt 7
+#define ADC_DCRIC_DCINT6        0x00000040  // Digital Comparator Interrupt 6
+#define ADC_DCRIC_DCINT5        0x00000020  // Digital Comparator Interrupt 5
+#define ADC_DCRIC_DCINT4        0x00000010  // Digital Comparator Interrupt 4
+#define ADC_DCRIC_DCINT3        0x00000008  // Digital Comparator Interrupt 3
+#define ADC_DCRIC_DCINT2        0x00000004  // Digital Comparator Interrupt 2
+#define ADC_DCRIC_DCINT1        0x00000002  // Digital Comparator Interrupt 1
+#define ADC_DCRIC_DCINT0        0x00000001  // Digital Comparator Interrupt 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCTL0 register.
+//
+//*****************************************************************************
+#define ADC_DCCTL0_CTE          0x00001000  // Comparison Trigger Enable
+#define ADC_DCCTL0_CTC_M        0x00000C00  // Comparison Trigger Condition
+#define ADC_DCCTL0_CTC_LOW      0x00000000  // Low Band
+#define ADC_DCCTL0_CTC_MID      0x00000400  // Mid Band
+#define ADC_DCCTL0_CTC_HIGH     0x00000C00  // High Band
+#define ADC_DCCTL0_CTM_M        0x00000300  // Comparison Trigger Mode
+#define ADC_DCCTL0_CTM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL0_CTM_ONCE     0x00000100  // Once
+#define ADC_DCCTL0_CTM_HALWAYS  0x00000200  // Hysteresis Always
+#define ADC_DCCTL0_CTM_HONCE    0x00000300  // Hysteresis Once
+#define ADC_DCCTL0_CIE          0x00000010  // Comparison Interrupt Enable
+#define ADC_DCCTL0_CIC_M        0x0000000C  // Comparison Interrupt Condition
+#define ADC_DCCTL0_CIC_LOW      0x00000000  // Low Band
+#define ADC_DCCTL0_CIC_MID      0x00000004  // Mid Band
+#define ADC_DCCTL0_CIC_HIGH     0x0000000C  // High Band
+#define ADC_DCCTL0_CIM_M        0x00000003  // Comparison Interrupt Mode
+#define ADC_DCCTL0_CIM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL0_CIM_ONCE     0x00000001  // Once
+#define ADC_DCCTL0_CIM_HALWAYS  0x00000002  // Hysteresis Always
+#define ADC_DCCTL0_CIM_HONCE    0x00000003  // Hysteresis Once
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCTL1 register.
+//
+//*****************************************************************************
+#define ADC_DCCTL1_CTE          0x00001000  // Comparison Trigger Enable
+#define ADC_DCCTL1_CTC_M        0x00000C00  // Comparison Trigger Condition
+#define ADC_DCCTL1_CTC_LOW      0x00000000  // Low Band
+#define ADC_DCCTL1_CTC_MID      0x00000400  // Mid Band
+#define ADC_DCCTL1_CTC_HIGH     0x00000C00  // High Band
+#define ADC_DCCTL1_CTM_M        0x00000300  // Comparison Trigger Mode
+#define ADC_DCCTL1_CTM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL1_CTM_ONCE     0x00000100  // Once
+#define ADC_DCCTL1_CTM_HALWAYS  0x00000200  // Hysteresis Always
+#define ADC_DCCTL1_CTM_HONCE    0x00000300  // Hysteresis Once
+#define ADC_DCCTL1_CIE          0x00000010  // Comparison Interrupt Enable
+#define ADC_DCCTL1_CIC_M        0x0000000C  // Comparison Interrupt Condition
+#define ADC_DCCTL1_CIC_LOW      0x00000000  // Low Band
+#define ADC_DCCTL1_CIC_MID      0x00000004  // Mid Band
+#define ADC_DCCTL1_CIC_HIGH     0x0000000C  // High Band
+#define ADC_DCCTL1_CIM_M        0x00000003  // Comparison Interrupt Mode
+#define ADC_DCCTL1_CIM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL1_CIM_ONCE     0x00000001  // Once
+#define ADC_DCCTL1_CIM_HALWAYS  0x00000002  // Hysteresis Always
+#define ADC_DCCTL1_CIM_HONCE    0x00000003  // Hysteresis Once
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCTL2 register.
+//
+//*****************************************************************************
+#define ADC_DCCTL2_CTE          0x00001000  // Comparison Trigger Enable
+#define ADC_DCCTL2_CTC_M        0x00000C00  // Comparison Trigger Condition
+#define ADC_DCCTL2_CTC_LOW      0x00000000  // Low Band
+#define ADC_DCCTL2_CTC_MID      0x00000400  // Mid Band
+#define ADC_DCCTL2_CTC_HIGH     0x00000C00  // High Band
+#define ADC_DCCTL2_CTM_M        0x00000300  // Comparison Trigger Mode
+#define ADC_DCCTL2_CTM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL2_CTM_ONCE     0x00000100  // Once
+#define ADC_DCCTL2_CTM_HALWAYS  0x00000200  // Hysteresis Always
+#define ADC_DCCTL2_CTM_HONCE    0x00000300  // Hysteresis Once
+#define ADC_DCCTL2_CIE          0x00000010  // Comparison Interrupt Enable
+#define ADC_DCCTL2_CIC_M        0x0000000C  // Comparison Interrupt Condition
+#define ADC_DCCTL2_CIC_LOW      0x00000000  // Low Band
+#define ADC_DCCTL2_CIC_MID      0x00000004  // Mid Band
+#define ADC_DCCTL2_CIC_HIGH     0x0000000C  // High Band
+#define ADC_DCCTL2_CIM_M        0x00000003  // Comparison Interrupt Mode
+#define ADC_DCCTL2_CIM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL2_CIM_ONCE     0x00000001  // Once
+#define ADC_DCCTL2_CIM_HALWAYS  0x00000002  // Hysteresis Always
+#define ADC_DCCTL2_CIM_HONCE    0x00000003  // Hysteresis Once
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCTL3 register.
+//
+//*****************************************************************************
+#define ADC_DCCTL3_CTE          0x00001000  // Comparison Trigger Enable
+#define ADC_DCCTL3_CTC_M        0x00000C00  // Comparison Trigger Condition
+#define ADC_DCCTL3_CTC_LOW      0x00000000  // Low Band
+#define ADC_DCCTL3_CTC_MID      0x00000400  // Mid Band
+#define ADC_DCCTL3_CTC_HIGH     0x00000C00  // High Band
+#define ADC_DCCTL3_CTM_M        0x00000300  // Comparison Trigger Mode
+#define ADC_DCCTL3_CTM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL3_CTM_ONCE     0x00000100  // Once
+#define ADC_DCCTL3_CTM_HALWAYS  0x00000200  // Hysteresis Always
+#define ADC_DCCTL3_CTM_HONCE    0x00000300  // Hysteresis Once
+#define ADC_DCCTL3_CIE          0x00000010  // Comparison Interrupt Enable
+#define ADC_DCCTL3_CIC_M        0x0000000C  // Comparison Interrupt Condition
+#define ADC_DCCTL3_CIC_LOW      0x00000000  // Low Band
+#define ADC_DCCTL3_CIC_MID      0x00000004  // Mid Band
+#define ADC_DCCTL3_CIC_HIGH     0x0000000C  // High Band
+#define ADC_DCCTL3_CIM_M        0x00000003  // Comparison Interrupt Mode
+#define ADC_DCCTL3_CIM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL3_CIM_ONCE     0x00000001  // Once
+#define ADC_DCCTL3_CIM_HALWAYS  0x00000002  // Hysteresis Always
+#define ADC_DCCTL3_CIM_HONCE    0x00000003  // Hysteresis Once
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCTL4 register.
+//
+//*****************************************************************************
+#define ADC_DCCTL4_CTE          0x00001000  // Comparison Trigger Enable
+#define ADC_DCCTL4_CTC_M        0x00000C00  // Comparison Trigger Condition
+#define ADC_DCCTL4_CTC_LOW      0x00000000  // Low Band
+#define ADC_DCCTL4_CTC_MID      0x00000400  // Mid Band
+#define ADC_DCCTL4_CTC_HIGH     0x00000C00  // High Band
+#define ADC_DCCTL4_CTM_M        0x00000300  // Comparison Trigger Mode
+#define ADC_DCCTL4_CTM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL4_CTM_ONCE     0x00000100  // Once
+#define ADC_DCCTL4_CTM_HALWAYS  0x00000200  // Hysteresis Always
+#define ADC_DCCTL4_CTM_HONCE    0x00000300  // Hysteresis Once
+#define ADC_DCCTL4_CIE          0x00000010  // Comparison Interrupt Enable
+#define ADC_DCCTL4_CIC_M        0x0000000C  // Comparison Interrupt Condition
+#define ADC_DCCTL4_CIC_LOW      0x00000000  // Low Band
+#define ADC_DCCTL4_CIC_MID      0x00000004  // Mid Band
+#define ADC_DCCTL4_CIC_HIGH     0x0000000C  // High Band
+#define ADC_DCCTL4_CIM_M        0x00000003  // Comparison Interrupt Mode
+#define ADC_DCCTL4_CIM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL4_CIM_ONCE     0x00000001  // Once
+#define ADC_DCCTL4_CIM_HALWAYS  0x00000002  // Hysteresis Always
+#define ADC_DCCTL4_CIM_HONCE    0x00000003  // Hysteresis Once
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCTL5 register.
+//
+//*****************************************************************************
+#define ADC_DCCTL5_CTE          0x00001000  // Comparison Trigger Enable
+#define ADC_DCCTL5_CTC_M        0x00000C00  // Comparison Trigger Condition
+#define ADC_DCCTL5_CTC_LOW      0x00000000  // Low Band
+#define ADC_DCCTL5_CTC_MID      0x00000400  // Mid Band
+#define ADC_DCCTL5_CTC_HIGH     0x00000C00  // High Band
+#define ADC_DCCTL5_CTM_M        0x00000300  // Comparison Trigger Mode
+#define ADC_DCCTL5_CTM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL5_CTM_ONCE     0x00000100  // Once
+#define ADC_DCCTL5_CTM_HALWAYS  0x00000200  // Hysteresis Always
+#define ADC_DCCTL5_CTM_HONCE    0x00000300  // Hysteresis Once
+#define ADC_DCCTL5_CIE          0x00000010  // Comparison Interrupt Enable
+#define ADC_DCCTL5_CIC_M        0x0000000C  // Comparison Interrupt Condition
+#define ADC_DCCTL5_CIC_LOW      0x00000000  // Low Band
+#define ADC_DCCTL5_CIC_MID      0x00000004  // Mid Band
+#define ADC_DCCTL5_CIC_HIGH     0x0000000C  // High Band
+#define ADC_DCCTL5_CIM_M        0x00000003  // Comparison Interrupt Mode
+#define ADC_DCCTL5_CIM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL5_CIM_ONCE     0x00000001  // Once
+#define ADC_DCCTL5_CIM_HALWAYS  0x00000002  // Hysteresis Always
+#define ADC_DCCTL5_CIM_HONCE    0x00000003  // Hysteresis Once
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCTL6 register.
+//
+//*****************************************************************************
+#define ADC_DCCTL6_CTE          0x00001000  // Comparison Trigger Enable
+#define ADC_DCCTL6_CTC_M        0x00000C00  // Comparison Trigger Condition
+#define ADC_DCCTL6_CTC_LOW      0x00000000  // Low Band
+#define ADC_DCCTL6_CTC_MID      0x00000400  // Mid Band
+#define ADC_DCCTL6_CTC_HIGH     0x00000C00  // High Band
+#define ADC_DCCTL6_CTM_M        0x00000300  // Comparison Trigger Mode
+#define ADC_DCCTL6_CTM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL6_CTM_ONCE     0x00000100  // Once
+#define ADC_DCCTL6_CTM_HALWAYS  0x00000200  // Hysteresis Always
+#define ADC_DCCTL6_CTM_HONCE    0x00000300  // Hysteresis Once
+#define ADC_DCCTL6_CIE          0x00000010  // Comparison Interrupt Enable
+#define ADC_DCCTL6_CIC_M        0x0000000C  // Comparison Interrupt Condition
+#define ADC_DCCTL6_CIC_LOW      0x00000000  // Low Band
+#define ADC_DCCTL6_CIC_MID      0x00000004  // Mid Band
+#define ADC_DCCTL6_CIC_HIGH     0x0000000C  // High Band
+#define ADC_DCCTL6_CIM_M        0x00000003  // Comparison Interrupt Mode
+#define ADC_DCCTL6_CIM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL6_CIM_ONCE     0x00000001  // Once
+#define ADC_DCCTL6_CIM_HALWAYS  0x00000002  // Hysteresis Always
+#define ADC_DCCTL6_CIM_HONCE    0x00000003  // Hysteresis Once
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCTL7 register.
+//
+//*****************************************************************************
+#define ADC_DCCTL7_CTE          0x00001000  // Comparison Trigger Enable
+#define ADC_DCCTL7_CTC_M        0x00000C00  // Comparison Trigger Condition
+#define ADC_DCCTL7_CTC_LOW      0x00000000  // Low Band
+#define ADC_DCCTL7_CTC_MID      0x00000400  // Mid Band
+#define ADC_DCCTL7_CTC_HIGH     0x00000C00  // High Band
+#define ADC_DCCTL7_CTM_M        0x00000300  // Comparison Trigger Mode
+#define ADC_DCCTL7_CTM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL7_CTM_ONCE     0x00000100  // Once
+#define ADC_DCCTL7_CTM_HALWAYS  0x00000200  // Hysteresis Always
+#define ADC_DCCTL7_CTM_HONCE    0x00000300  // Hysteresis Once
+#define ADC_DCCTL7_CIE          0x00000010  // Comparison Interrupt Enable
+#define ADC_DCCTL7_CIC_M        0x0000000C  // Comparison Interrupt Condition
+#define ADC_DCCTL7_CIC_LOW      0x00000000  // Low Band
+#define ADC_DCCTL7_CIC_MID      0x00000004  // Mid Band
+#define ADC_DCCTL7_CIC_HIGH     0x0000000C  // High Band
+#define ADC_DCCTL7_CIM_M        0x00000003  // Comparison Interrupt Mode
+#define ADC_DCCTL7_CIM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL7_CIM_ONCE     0x00000001  // Once
+#define ADC_DCCTL7_CIM_HALWAYS  0x00000002  // Hysteresis Always
+#define ADC_DCCTL7_CIM_HONCE    0x00000003  // Hysteresis Once
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCMP0 register.
+//
+//*****************************************************************************
+#define ADC_DCCMP0_COMP1_M      0x0FFF0000  // Compare 1
+#define ADC_DCCMP0_COMP0_M      0x00000FFF  // Compare 0
+#define ADC_DCCMP0_COMP1_S      16
+#define ADC_DCCMP0_COMP0_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCMP1 register.
+//
+//*****************************************************************************
+#define ADC_DCCMP1_COMP1_M      0x0FFF0000  // Compare 1
+#define ADC_DCCMP1_COMP0_M      0x00000FFF  // Compare 0
+#define ADC_DCCMP1_COMP1_S      16
+#define ADC_DCCMP1_COMP0_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCMP2 register.
+//
+//*****************************************************************************
+#define ADC_DCCMP2_COMP1_M      0x0FFF0000  // Compare 1
+#define ADC_DCCMP2_COMP0_M      0x00000FFF  // Compare 0
+#define ADC_DCCMP2_COMP1_S      16
+#define ADC_DCCMP2_COMP0_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCMP3 register.
+//
+//*****************************************************************************
+#define ADC_DCCMP3_COMP1_M      0x0FFF0000  // Compare 1
+#define ADC_DCCMP3_COMP0_M      0x00000FFF  // Compare 0
+#define ADC_DCCMP3_COMP1_S      16
+#define ADC_DCCMP3_COMP0_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCMP4 register.
+//
+//*****************************************************************************
+#define ADC_DCCMP4_COMP1_M      0x0FFF0000  // Compare 1
+#define ADC_DCCMP4_COMP0_M      0x00000FFF  // Compare 0
+#define ADC_DCCMP4_COMP1_S      16
+#define ADC_DCCMP4_COMP0_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCMP5 register.
+//
+//*****************************************************************************
+#define ADC_DCCMP5_COMP1_M      0x0FFF0000  // Compare 1
+#define ADC_DCCMP5_COMP0_M      0x00000FFF  // Compare 0
+#define ADC_DCCMP5_COMP1_S      16
+#define ADC_DCCMP5_COMP0_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCMP6 register.
+//
+//*****************************************************************************
+#define ADC_DCCMP6_COMP1_M      0x0FFF0000  // Compare 1
+#define ADC_DCCMP6_COMP0_M      0x00000FFF  // Compare 0
+#define ADC_DCCMP6_COMP1_S      16
+#define ADC_DCCMP6_COMP0_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCMP7 register.
+//
+//*****************************************************************************
+#define ADC_DCCMP7_COMP1_M      0x0FFF0000  // Compare 1
+#define ADC_DCCMP7_COMP0_M      0x00000FFF  // Compare 0
+#define ADC_DCCMP7_COMP1_S      16
+#define ADC_DCCMP7_COMP0_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_PP register.
+//
+//*****************************************************************************
+#define ADC_PP_APSHT            0x01000000  // Application-Programmable
+                                            // Sample-and-Hold Time
+#define ADC_PP_TS               0x00800000  // Temperature Sensor
+#define ADC_PP_RSL_M            0x007C0000  // Resolution
+#define ADC_PP_TYPE_M           0x00030000  // ADC Architecture
+#define ADC_PP_TYPE_SAR         0x00000000  // SAR
+#define ADC_PP_DC_M             0x0000FC00  // Digital Comparator Count
+#define ADC_PP_CH_M             0x000003F0  // ADC Channel Count
+#define ADC_PP_MCR_M            0x0000000F  // Maximum Conversion Rate
+#define ADC_PP_MCR_FULL         0x00000007  // Full conversion rate (FCONV) as
+                                            // defined by TADC and NSH
+#define ADC_PP_RSL_S            18
+#define ADC_PP_DC_S             10
+#define ADC_PP_CH_S             4
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_PC register.
+//
+//*****************************************************************************
+#define ADC_PC_MCR_M            0x0000000F  // Conversion Rate
+#define ADC_PC_MCR_1_8          0x00000001  // Eighth conversion rate. After a
+                                            // conversion completes, the logic
+                                            // pauses for 112 TADC periods
+                                            // before starting the next
+                                            // conversion
+#define ADC_PC_MCR_1_4          0x00000003  // Quarter conversion rate. After a
+                                            // conversion completes, the logic
+                                            // pauses for 48 TADC periods
+                                            // before starting the next
+                                            // conversion
+#define ADC_PC_MCR_1_2          0x00000005  // Half conversion rate. After a
+                                            // conversion completes, the logic
+                                            // pauses for 16 TADC periods
+                                            // before starting the next
+                                            // conversion
+#define ADC_PC_MCR_FULL         0x00000007  // Full conversion rate (FCONV) as
+                                            // defined by TADC and NSH
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_CC register.
+//
+//*****************************************************************************
+#define ADC_CC_CLKDIV_M         0x000003F0  // PLL VCO Clock Divisor
+#define ADC_CC_CS_M             0x0000000F  // ADC Clock Source
+#define ADC_CC_CS_SYSPLL        0x00000000  // PLL VCO divided by CLKDIV
+#define ADC_CC_CS_PIOSC         0x00000001  // PIOSC
+#define ADC_CC_CS_MOSC          0x00000002  // MOSC
+#define ADC_CC_CLKDIV_S         4
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACMIS register.
+//
+//*****************************************************************************
+#define COMP_ACMIS_IN2          0x00000004  // Comparator 2 Masked Interrupt
+                                            // Status
+#define COMP_ACMIS_IN1          0x00000002  // Comparator 1 Masked Interrupt
+                                            // Status
+#define COMP_ACMIS_IN0          0x00000001  // Comparator 0 Masked Interrupt
+                                            // Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACRIS register.
+//
+//*****************************************************************************
+#define COMP_ACRIS_IN2          0x00000004  // Comparator 2 Interrupt Status
+#define COMP_ACRIS_IN1          0x00000002  // Comparator 1 Interrupt Status
+#define COMP_ACRIS_IN0          0x00000001  // Comparator 0 Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACINTEN register.
+//
+//*****************************************************************************
+#define COMP_ACINTEN_IN2        0x00000004  // Comparator 2 Interrupt Enable
+#define COMP_ACINTEN_IN1        0x00000002  // Comparator 1 Interrupt Enable
+#define COMP_ACINTEN_IN0        0x00000001  // Comparator 0 Interrupt Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACREFCTL
+// register.
+//
+//*****************************************************************************
+#define COMP_ACREFCTL_EN        0x00000200  // Resistor Ladder Enable
+#define COMP_ACREFCTL_RNG       0x00000100  // Resistor Ladder Range
+#define COMP_ACREFCTL_VREF_M    0x0000000F  // Resistor Ladder Voltage Ref
+#define COMP_ACREFCTL_VREF_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACSTAT0 register.
+//
+//*****************************************************************************
+#define COMP_ACSTAT0_OVAL       0x00000002  // Comparator Output Value
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACCTL0 register.
+//
+//*****************************************************************************
+#define COMP_ACCTL0_TOEN        0x00000800  // Trigger Output Enable
+#define COMP_ACCTL0_ASRCP_M     0x00000600  // Analog Source Positive
+#define COMP_ACCTL0_ASRCP_PIN   0x00000000  // Pin value of Cn+
+#define COMP_ACCTL0_ASRCP_PIN0  0x00000200  // Pin value of C0+
+#define COMP_ACCTL0_ASRCP_REF   0x00000400  // Internal voltage reference
+#define COMP_ACCTL0_TSLVAL      0x00000080  // Trigger Sense Level Value
+#define COMP_ACCTL0_TSEN_M      0x00000060  // Trigger Sense
+#define COMP_ACCTL0_TSEN_LEVEL  0x00000000  // Level sense, see TSLVAL
+#define COMP_ACCTL0_TSEN_FALL   0x00000020  // Falling edge
+#define COMP_ACCTL0_TSEN_RISE   0x00000040  // Rising edge
+#define COMP_ACCTL0_TSEN_BOTH   0x00000060  // Either edge
+#define COMP_ACCTL0_ISLVAL      0x00000010  // Interrupt Sense Level Value
+#define COMP_ACCTL0_ISEN_M      0x0000000C  // Interrupt Sense
+#define COMP_ACCTL0_ISEN_LEVEL  0x00000000  // Level sense, see ISLVAL
+#define COMP_ACCTL0_ISEN_FALL   0x00000004  // Falling edge
+#define COMP_ACCTL0_ISEN_RISE   0x00000008  // Rising edge
+#define COMP_ACCTL0_ISEN_BOTH   0x0000000C  // Either edge
+#define COMP_ACCTL0_CINV        0x00000002  // Comparator Output Invert
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACSTAT1 register.
+//
+//*****************************************************************************
+#define COMP_ACSTAT1_OVAL       0x00000002  // Comparator Output Value
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACCTL1 register.
+//
+//*****************************************************************************
+#define COMP_ACCTL1_TOEN        0x00000800  // Trigger Output Enable
+#define COMP_ACCTL1_ASRCP_M     0x00000600  // Analog Source Positive
+#define COMP_ACCTL1_ASRCP_PIN   0x00000000  // Pin value of Cn+
+#define COMP_ACCTL1_ASRCP_PIN0  0x00000200  // Pin value of C0+
+#define COMP_ACCTL1_ASRCP_REF   0x00000400  // Internal voltage reference
+#define COMP_ACCTL1_TSLVAL      0x00000080  // Trigger Sense Level Value
+#define COMP_ACCTL1_TSEN_M      0x00000060  // Trigger Sense
+#define COMP_ACCTL1_TSEN_LEVEL  0x00000000  // Level sense, see TSLVAL
+#define COMP_ACCTL1_TSEN_FALL   0x00000020  // Falling edge
+#define COMP_ACCTL1_TSEN_RISE   0x00000040  // Rising edge
+#define COMP_ACCTL1_TSEN_BOTH   0x00000060  // Either edge
+#define COMP_ACCTL1_ISLVAL      0x00000010  // Interrupt Sense Level Value
+#define COMP_ACCTL1_ISEN_M      0x0000000C  // Interrupt Sense
+#define COMP_ACCTL1_ISEN_LEVEL  0x00000000  // Level sense, see ISLVAL
+#define COMP_ACCTL1_ISEN_FALL   0x00000004  // Falling edge
+#define COMP_ACCTL1_ISEN_RISE   0x00000008  // Rising edge
+#define COMP_ACCTL1_ISEN_BOTH   0x0000000C  // Either edge
+#define COMP_ACCTL1_CINV        0x00000002  // Comparator Output Invert
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACSTAT2 register.
+//
+//*****************************************************************************
+#define COMP_ACSTAT2_OVAL       0x00000002  // Comparator Output Value
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACCTL2 register.
+//
+//*****************************************************************************
+#define COMP_ACCTL2_TOEN        0x00000800  // Trigger Output Enable
+#define COMP_ACCTL2_ASRCP_M     0x00000600  // Analog Source Positive
+#define COMP_ACCTL2_ASRCP_PIN   0x00000000  // Pin value of Cn+
+#define COMP_ACCTL2_ASRCP_PIN0  0x00000200  // Pin value of C0+
+#define COMP_ACCTL2_ASRCP_REF   0x00000400  // Internal voltage reference
+#define COMP_ACCTL2_TSLVAL      0x00000080  // Trigger Sense Level Value
+#define COMP_ACCTL2_TSEN_M      0x00000060  // Trigger Sense
+#define COMP_ACCTL2_TSEN_LEVEL  0x00000000  // Level sense, see TSLVAL
+#define COMP_ACCTL2_TSEN_FALL   0x00000020  // Falling edge
+#define COMP_ACCTL2_TSEN_RISE   0x00000040  // Rising edge
+#define COMP_ACCTL2_TSEN_BOTH   0x00000060  // Either edge
+#define COMP_ACCTL2_ISLVAL      0x00000010  // Interrupt Sense Level Value
+#define COMP_ACCTL2_ISEN_M      0x0000000C  // Interrupt Sense
+#define COMP_ACCTL2_ISEN_LEVEL  0x00000000  // Level sense, see ISLVAL
+#define COMP_ACCTL2_ISEN_FALL   0x00000004  // Falling edge
+#define COMP_ACCTL2_ISEN_RISE   0x00000008  // Rising edge
+#define COMP_ACCTL2_ISEN_BOTH   0x0000000C  // Either edge
+#define COMP_ACCTL2_CINV        0x00000002  // Comparator Output Invert
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_PP register.
+//
+//*****************************************************************************
+#define COMP_PP_C2O             0x00040000  // Comparator Output 2 Present
+#define COMP_PP_C1O             0x00020000  // Comparator Output 1 Present
+#define COMP_PP_C0O             0x00010000  // Comparator Output 0 Present
+#define COMP_PP_CMP2            0x00000004  // Comparator 2 Present
+#define COMP_PP_CMP1            0x00000002  // Comparator 1 Present
+#define COMP_PP_CMP0            0x00000001  // Comparator 0 Present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_CTL register.
+//
+//*****************************************************************************
+#define CAN_CTL_TEST            0x00000080  // Test Mode Enable
+#define CAN_CTL_CCE             0x00000040  // Configuration Change Enable
+#define CAN_CTL_DAR             0x00000020  // Disable Automatic-Retransmission
+#define CAN_CTL_EIE             0x00000008  // Error Interrupt Enable
+#define CAN_CTL_SIE             0x00000004  // Status Interrupt Enable
+#define CAN_CTL_IE              0x00000002  // CAN Interrupt Enable
+#define CAN_CTL_INIT            0x00000001  // Initialization
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_STS register.
+//
+//*****************************************************************************
+#define CAN_STS_BOFF            0x00000080  // Bus-Off Status
+#define CAN_STS_EWARN           0x00000040  // Warning Status
+#define CAN_STS_EPASS           0x00000020  // Error Passive
+#define CAN_STS_RXOK            0x00000010  // Received a Message Successfully
+#define CAN_STS_TXOK            0x00000008  // Transmitted a Message
+                                            // Successfully
+#define CAN_STS_LEC_M           0x00000007  // Last Error Code
+#define CAN_STS_LEC_NONE        0x00000000  // No Error
+#define CAN_STS_LEC_STUFF       0x00000001  // Stuff Error
+#define CAN_STS_LEC_FORM        0x00000002  // Format Error
+#define CAN_STS_LEC_ACK         0x00000003  // ACK Error
+#define CAN_STS_LEC_BIT1        0x00000004  // Bit 1 Error
+#define CAN_STS_LEC_BIT0        0x00000005  // Bit 0 Error
+#define CAN_STS_LEC_CRC         0x00000006  // CRC Error
+#define CAN_STS_LEC_NOEVENT     0x00000007  // No Event
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_ERR register.
+//
+//*****************************************************************************
+#define CAN_ERR_RP              0x00008000  // Received Error Passive
+#define CAN_ERR_REC_M           0x00007F00  // Receive Error Counter
+#define CAN_ERR_TEC_M           0x000000FF  // Transmit Error Counter
+#define CAN_ERR_REC_S           8
+#define CAN_ERR_TEC_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_BIT register.
+//
+//*****************************************************************************
+#define CAN_BIT_TSEG2_M         0x00007000  // Time Segment after Sample Point
+#define CAN_BIT_TSEG1_M         0x00000F00  // Time Segment Before Sample Point
+#define CAN_BIT_SJW_M           0x000000C0  // (Re)Synchronization Jump Width
+#define CAN_BIT_BRP_M           0x0000003F  // Baud Rate Prescaler
+#define CAN_BIT_TSEG2_S         12
+#define CAN_BIT_TSEG1_S         8
+#define CAN_BIT_SJW_S           6
+#define CAN_BIT_BRP_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_INT register.
+//
+//*****************************************************************************
+#define CAN_INT_INTID_M         0x0000FFFF  // Interrupt Identifier
+#define CAN_INT_INTID_NONE      0x00000000  // No interrupt pending
+#define CAN_INT_INTID_STATUS    0x00008000  // Status Interrupt
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_TST register.
+//
+//*****************************************************************************
+#define CAN_TST_RX              0x00000080  // Receive Observation
+#define CAN_TST_TX_M            0x00000060  // Transmit Control
+#define CAN_TST_TX_CANCTL       0x00000000  // CAN Module Control
+#define CAN_TST_TX_SAMPLE       0x00000020  // Sample Point
+#define CAN_TST_TX_DOMINANT     0x00000040  // Driven Low
+#define CAN_TST_TX_RECESSIVE    0x00000060  // Driven High
+#define CAN_TST_LBACK           0x00000010  // Loopback Mode
+#define CAN_TST_SILENT          0x00000008  // Silent Mode
+#define CAN_TST_BASIC           0x00000004  // Basic Mode
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_BRPE register.
+//
+//*****************************************************************************
+#define CAN_BRPE_BRPE_M         0x0000000F  // Baud Rate Prescaler Extension
+#define CAN_BRPE_BRPE_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1CRQ register.
+//
+//*****************************************************************************
+#define CAN_IF1CRQ_BUSY         0x00008000  // Busy Flag
+#define CAN_IF1CRQ_MNUM_M       0x0000003F  // Message Number
+#define CAN_IF1CRQ_MNUM_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1CMSK register.
+//
+//*****************************************************************************
+#define CAN_IF1CMSK_WRNRD       0x00000080  // Write, Not Read
+#define CAN_IF1CMSK_MASK        0x00000040  // Access Mask Bits
+#define CAN_IF1CMSK_ARB         0x00000020  // Access Arbitration Bits
+#define CAN_IF1CMSK_CONTROL     0x00000010  // Access Control Bits
+#define CAN_IF1CMSK_CLRINTPND   0x00000008  // Clear Interrupt Pending Bit
+#define CAN_IF1CMSK_NEWDAT      0x00000004  // Access New Data
+#define CAN_IF1CMSK_TXRQST      0x00000004  // Access Transmission Request
+#define CAN_IF1CMSK_DATAA       0x00000002  // Access Data Byte 0 to 3
+#define CAN_IF1CMSK_DATAB       0x00000001  // Access Data Byte 4 to 7
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1MSK1 register.
+//
+//*****************************************************************************
+#define CAN_IF1MSK1_IDMSK_M     0x0000FFFF  // Identifier Mask
+#define CAN_IF1MSK1_IDMSK_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1MSK2 register.
+//
+//*****************************************************************************
+#define CAN_IF1MSK2_MXTD        0x00008000  // Mask Extended Identifier
+#define CAN_IF1MSK2_MDIR        0x00004000  // Mask Message Direction
+#define CAN_IF1MSK2_IDMSK_M     0x00001FFF  // Identifier Mask
+#define CAN_IF1MSK2_IDMSK_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1ARB1 register.
+//
+//*****************************************************************************
+#define CAN_IF1ARB1_ID_M        0x0000FFFF  // Message Identifier
+#define CAN_IF1ARB1_ID_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1ARB2 register.
+//
+//*****************************************************************************
+#define CAN_IF1ARB2_MSGVAL      0x00008000  // Message Valid
+#define CAN_IF1ARB2_XTD         0x00004000  // Extended Identifier
+#define CAN_IF1ARB2_DIR         0x00002000  // Message Direction
+#define CAN_IF1ARB2_ID_M        0x00001FFF  // Message Identifier
+#define CAN_IF1ARB2_ID_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1MCTL register.
+//
+//*****************************************************************************
+#define CAN_IF1MCTL_NEWDAT      0x00008000  // New Data
+#define CAN_IF1MCTL_MSGLST      0x00004000  // Message Lost
+#define CAN_IF1MCTL_INTPND      0x00002000  // Interrupt Pending
+#define CAN_IF1MCTL_UMASK       0x00001000  // Use Acceptance Mask
+#define CAN_IF1MCTL_TXIE        0x00000800  // Transmit Interrupt Enable
+#define CAN_IF1MCTL_RXIE        0x00000400  // Receive Interrupt Enable
+#define CAN_IF1MCTL_RMTEN       0x00000200  // Remote Enable
+#define CAN_IF1MCTL_TXRQST      0x00000100  // Transmit Request
+#define CAN_IF1MCTL_EOB         0x00000080  // End of Buffer
+#define CAN_IF1MCTL_DLC_M       0x0000000F  // Data Length Code
+#define CAN_IF1MCTL_DLC_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1DA1 register.
+//
+//*****************************************************************************
+#define CAN_IF1DA1_DATA_M       0x0000FFFF  // Data
+#define CAN_IF1DA1_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1DA2 register.
+//
+//*****************************************************************************
+#define CAN_IF1DA2_DATA_M       0x0000FFFF  // Data
+#define CAN_IF1DA2_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1DB1 register.
+//
+//*****************************************************************************
+#define CAN_IF1DB1_DATA_M       0x0000FFFF  // Data
+#define CAN_IF1DB1_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1DB2 register.
+//
+//*****************************************************************************
+#define CAN_IF1DB2_DATA_M       0x0000FFFF  // Data
+#define CAN_IF1DB2_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2CRQ register.
+//
+//*****************************************************************************
+#define CAN_IF2CRQ_BUSY         0x00008000  // Busy Flag
+#define CAN_IF2CRQ_MNUM_M       0x0000003F  // Message Number
+#define CAN_IF2CRQ_MNUM_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2CMSK register.
+//
+//*****************************************************************************
+#define CAN_IF2CMSK_WRNRD       0x00000080  // Write, Not Read
+#define CAN_IF2CMSK_MASK        0x00000040  // Access Mask Bits
+#define CAN_IF2CMSK_ARB         0x00000020  // Access Arbitration Bits
+#define CAN_IF2CMSK_CONTROL     0x00000010  // Access Control Bits
+#define CAN_IF2CMSK_CLRINTPND   0x00000008  // Clear Interrupt Pending Bit
+#define CAN_IF2CMSK_NEWDAT      0x00000004  // Access New Data
+#define CAN_IF2CMSK_TXRQST      0x00000004  // Access Transmission Request
+#define CAN_IF2CMSK_DATAA       0x00000002  // Access Data Byte 0 to 3
+#define CAN_IF2CMSK_DATAB       0x00000001  // Access Data Byte 4 to 7
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2MSK1 register.
+//
+//*****************************************************************************
+#define CAN_IF2MSK1_IDMSK_M     0x0000FFFF  // Identifier Mask
+#define CAN_IF2MSK1_IDMSK_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2MSK2 register.
+//
+//*****************************************************************************
+#define CAN_IF2MSK2_MXTD        0x00008000  // Mask Extended Identifier
+#define CAN_IF2MSK2_MDIR        0x00004000  // Mask Message Direction
+#define CAN_IF2MSK2_IDMSK_M     0x00001FFF  // Identifier Mask
+#define CAN_IF2MSK2_IDMSK_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2ARB1 register.
+//
+//*****************************************************************************
+#define CAN_IF2ARB1_ID_M        0x0000FFFF  // Message Identifier
+#define CAN_IF2ARB1_ID_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2ARB2 register.
+//
+//*****************************************************************************
+#define CAN_IF2ARB2_MSGVAL      0x00008000  // Message Valid
+#define CAN_IF2ARB2_XTD         0x00004000  // Extended Identifier
+#define CAN_IF2ARB2_DIR         0x00002000  // Message Direction
+#define CAN_IF2ARB2_ID_M        0x00001FFF  // Message Identifier
+#define CAN_IF2ARB2_ID_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2MCTL register.
+//
+//*****************************************************************************
+#define CAN_IF2MCTL_NEWDAT      0x00008000  // New Data
+#define CAN_IF2MCTL_MSGLST      0x00004000  // Message Lost
+#define CAN_IF2MCTL_INTPND      0x00002000  // Interrupt Pending
+#define CAN_IF2MCTL_UMASK       0x00001000  // Use Acceptance Mask
+#define CAN_IF2MCTL_TXIE        0x00000800  // Transmit Interrupt Enable
+#define CAN_IF2MCTL_RXIE        0x00000400  // Receive Interrupt Enable
+#define CAN_IF2MCTL_RMTEN       0x00000200  // Remote Enable
+#define CAN_IF2MCTL_TXRQST      0x00000100  // Transmit Request
+#define CAN_IF2MCTL_EOB         0x00000080  // End of Buffer
+#define CAN_IF2MCTL_DLC_M       0x0000000F  // Data Length Code
+#define CAN_IF2MCTL_DLC_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2DA1 register.
+//
+//*****************************************************************************
+#define CAN_IF2DA1_DATA_M       0x0000FFFF  // Data
+#define CAN_IF2DA1_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2DA2 register.
+//
+//*****************************************************************************
+#define CAN_IF2DA2_DATA_M       0x0000FFFF  // Data
+#define CAN_IF2DA2_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2DB1 register.
+//
+//*****************************************************************************
+#define CAN_IF2DB1_DATA_M       0x0000FFFF  // Data
+#define CAN_IF2DB1_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2DB2 register.
+//
+//*****************************************************************************
+#define CAN_IF2DB2_DATA_M       0x0000FFFF  // Data
+#define CAN_IF2DB2_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_TXRQ1 register.
+//
+//*****************************************************************************
+#define CAN_TXRQ1_TXRQST_M      0x0000FFFF  // Transmission Request Bits
+#define CAN_TXRQ1_TXRQST_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_TXRQ2 register.
+//
+//*****************************************************************************
+#define CAN_TXRQ2_TXRQST_M      0x0000FFFF  // Transmission Request Bits
+#define CAN_TXRQ2_TXRQST_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_NWDA1 register.
+//
+//*****************************************************************************
+#define CAN_NWDA1_NEWDAT_M      0x0000FFFF  // New Data Bits
+#define CAN_NWDA1_NEWDAT_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_NWDA2 register.
+//
+//*****************************************************************************
+#define CAN_NWDA2_NEWDAT_M      0x0000FFFF  // New Data Bits
+#define CAN_NWDA2_NEWDAT_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_MSG1INT register.
+//
+//*****************************************************************************
+#define CAN_MSG1INT_INTPND_M    0x0000FFFF  // Interrupt Pending Bits
+#define CAN_MSG1INT_INTPND_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_MSG2INT register.
+//
+//*****************************************************************************
+#define CAN_MSG2INT_INTPND_M    0x0000FFFF  // Interrupt Pending Bits
+#define CAN_MSG2INT_INTPND_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_MSG1VAL register.
+//
+//*****************************************************************************
+#define CAN_MSG1VAL_MSGVAL_M    0x0000FFFF  // Message Valid Bits
+#define CAN_MSG1VAL_MSGVAL_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_MSG2VAL register.
+//
+//*****************************************************************************
+#define CAN_MSG2VAL_MSGVAL_M    0x0000FFFF  // Message Valid Bits
+#define CAN_MSG2VAL_MSGVAL_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FADDR register.
+//
+//*****************************************************************************
+#define USB_FADDR_M             0x0000007F  // Function Address
+#define USB_FADDR_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_POWER register.
+//
+//*****************************************************************************
+#define USB_POWER_ISOUP         0x00000080  // Isochronous Update
+#define USB_POWER_SOFTCONN      0x00000040  // Soft Connect/Disconnect
+#define USB_POWER_HSENAB        0x00000020  // High Speed Enable
+#define USB_POWER_HSMODE        0x00000010  // High Speed Enable
+#define USB_POWER_RESET         0x00000008  // RESET Signaling
+#define USB_POWER_RESUME        0x00000004  // RESUME Signaling
+#define USB_POWER_SUSPEND       0x00000002  // SUSPEND Mode
+#define USB_POWER_PWRDNPHY      0x00000001  // Power Down PHY
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXIS register.
+//
+//*****************************************************************************
+#define USB_TXIS_EP7            0x00000080  // TX Endpoint 7 Interrupt
+#define USB_TXIS_EP6            0x00000040  // TX Endpoint 6 Interrupt
+#define USB_TXIS_EP5            0x00000020  // TX Endpoint 5 Interrupt
+#define USB_TXIS_EP4            0x00000010  // TX Endpoint 4 Interrupt
+#define USB_TXIS_EP3            0x00000008  // TX Endpoint 3 Interrupt
+#define USB_TXIS_EP2            0x00000004  // TX Endpoint 2 Interrupt
+#define USB_TXIS_EP1            0x00000002  // TX Endpoint 1 Interrupt
+#define USB_TXIS_EP0            0x00000001  // TX and RX Endpoint 0 Interrupt
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXIS register.
+//
+//*****************************************************************************
+#define USB_RXIS_EP7            0x00000080  // RX Endpoint 7 Interrupt
+#define USB_RXIS_EP6            0x00000040  // RX Endpoint 6 Interrupt
+#define USB_RXIS_EP5            0x00000020  // RX Endpoint 5 Interrupt
+#define USB_RXIS_EP4            0x00000010  // RX Endpoint 4 Interrupt
+#define USB_RXIS_EP3            0x00000008  // RX Endpoint 3 Interrupt
+#define USB_RXIS_EP2            0x00000004  // RX Endpoint 2 Interrupt
+#define USB_RXIS_EP1            0x00000002  // RX Endpoint 1 Interrupt
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXIE register.
+//
+//*****************************************************************************
+#define USB_TXIE_EP7            0x00000080  // TX Endpoint 7 Interrupt Enable
+#define USB_TXIE_EP6            0x00000040  // TX Endpoint 6 Interrupt Enable
+#define USB_TXIE_EP5            0x00000020  // TX Endpoint 5 Interrupt Enable
+#define USB_TXIE_EP4            0x00000010  // TX Endpoint 4 Interrupt Enable
+#define USB_TXIE_EP3            0x00000008  // TX Endpoint 3 Interrupt Enable
+#define USB_TXIE_EP2            0x00000004  // TX Endpoint 2 Interrupt Enable
+#define USB_TXIE_EP1            0x00000002  // TX Endpoint 1 Interrupt Enable
+#define USB_TXIE_EP0            0x00000001  // TX and RX Endpoint 0 Interrupt
+                                            // Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXIE register.
+//
+//*****************************************************************************
+#define USB_RXIE_EP7            0x00000080  // RX Endpoint 7 Interrupt Enable
+#define USB_RXIE_EP6            0x00000040  // RX Endpoint 6 Interrupt Enable
+#define USB_RXIE_EP5            0x00000020  // RX Endpoint 5 Interrupt Enable
+#define USB_RXIE_EP4            0x00000010  // RX Endpoint 4 Interrupt Enable
+#define USB_RXIE_EP3            0x00000008  // RX Endpoint 3 Interrupt Enable
+#define USB_RXIE_EP2            0x00000004  // RX Endpoint 2 Interrupt Enable
+#define USB_RXIE_EP1            0x00000002  // RX Endpoint 1 Interrupt Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_IS register.
+//
+//*****************************************************************************
+#define USB_IS_VBUSERR          0x00000080  // VBUS Error (OTG only)
+#define USB_IS_SESREQ           0x00000040  // SESSION REQUEST (OTG only)
+#define USB_IS_DISCON           0x00000020  // Session Disconnect (OTG only)
+#define USB_IS_CONN             0x00000010  // Session Connect
+#define USB_IS_SOF              0x00000008  // Start of Frame
+#define USB_IS_BABBLE           0x00000004  // Babble Detected
+#define USB_IS_RESET            0x00000004  // RESET Signaling Detected
+#define USB_IS_RESUME           0x00000002  // RESUME Signaling Detected
+#define USB_IS_SUSPEND          0x00000001  // SUSPEND Signaling Detected
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_IE register.
+//
+//*****************************************************************************
+#define USB_IE_VBUSERR          0x00000080  // Enable VBUS Error Interrupt (OTG
+                                            // only)
+#define USB_IE_SESREQ           0x00000040  // Enable Session Request (OTG
+                                            // only)
+#define USB_IE_DISCON           0x00000020  // Enable Disconnect Interrupt
+#define USB_IE_CONN             0x00000010  // Enable Connect Interrupt
+#define USB_IE_SOF              0x00000008  // Enable Start-of-Frame Interrupt
+#define USB_IE_BABBLE           0x00000004  // Enable Babble Interrupt
+#define USB_IE_RESET            0x00000004  // Enable RESET Interrupt
+#define USB_IE_RESUME           0x00000002  // Enable RESUME Interrupt
+#define USB_IE_SUSPND           0x00000001  // Enable SUSPEND Interrupt
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FRAME register.
+//
+//*****************************************************************************
+#define USB_FRAME_M             0x000007FF  // Frame Number
+#define USB_FRAME_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_EPIDX register.
+//
+//*****************************************************************************
+#define USB_EPIDX_EPIDX_M       0x0000000F  // Endpoint Index
+#define USB_EPIDX_EPIDX_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TEST register.
+//
+//*****************************************************************************
+#define USB_TEST_FORCEH         0x00000080  // Force Host Mode
+#define USB_TEST_FIFOACC        0x00000040  // FIFO Access
+#define USB_TEST_FORCEFS        0x00000020  // Force Full-Speed Mode
+#define USB_TEST_FORCEHS        0x00000010  // Force High-Speed Mode
+#define USB_TEST_TESTPKT        0x00000008  // Test Packet Mode Enable
+#define USB_TEST_TESTK          0x00000004  // Test_K Mode Enable
+#define USB_TEST_TESTJ          0x00000002  // Test_J Mode Enable
+#define USB_TEST_TESTSE0NAK     0x00000001  // Test_SE0_NAK Test Mode Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO0 register.
+//
+//*****************************************************************************
+#define USB_FIFO0_EPDATA_M      0xFFFFFFFF  // Endpoint Data
+#define USB_FIFO0_EPDATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO1 register.
+//
+//*****************************************************************************
+#define USB_FIFO1_EPDATA_M      0xFFFFFFFF  // Endpoint Data
+#define USB_FIFO1_EPDATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO2 register.
+//
+//*****************************************************************************
+#define USB_FIFO2_EPDATA_M      0xFFFFFFFF  // Endpoint Data
+#define USB_FIFO2_EPDATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO3 register.
+//
+//*****************************************************************************
+#define USB_FIFO3_EPDATA_M      0xFFFFFFFF  // Endpoint Data
+#define USB_FIFO3_EPDATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO4 register.
+//
+//*****************************************************************************
+#define USB_FIFO4_EPDATA_M      0xFFFFFFFF  // Endpoint Data
+#define USB_FIFO4_EPDATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO5 register.
+//
+//*****************************************************************************
+#define USB_FIFO5_EPDATA_M      0xFFFFFFFF  // Endpoint Data
+#define USB_FIFO5_EPDATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO6 register.
+//
+//*****************************************************************************
+#define USB_FIFO6_EPDATA_M      0xFFFFFFFF  // Endpoint Data
+#define USB_FIFO6_EPDATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO7 register.
+//
+//*****************************************************************************
+#define USB_FIFO7_EPDATA_M      0xFFFFFFFF  // Endpoint Data
+#define USB_FIFO7_EPDATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DEVCTL register.
+//
+//*****************************************************************************
+#define USB_DEVCTL_DEV          0x00000080  // Device Mode (OTG only)
+#define USB_DEVCTL_FSDEV        0x00000040  // Full-Speed Device Detected
+#define USB_DEVCTL_LSDEV        0x00000020  // Low-Speed Device Detected
+#define USB_DEVCTL_VBUS_M       0x00000018  // VBUS Level (OTG only)
+#define USB_DEVCTL_VBUS_NONE    0x00000000  // Below SessionEnd
+#define USB_DEVCTL_VBUS_SEND    0x00000008  // Above SessionEnd, below AValid
+#define USB_DEVCTL_VBUS_AVALID  0x00000010  // Above AValid, below VBUSValid
+#define USB_DEVCTL_VBUS_VALID   0x00000018  // Above VBUSValid
+#define USB_DEVCTL_HOST         0x00000004  // Host Mode
+#define USB_DEVCTL_HOSTREQ      0x00000002  // Host Request (OTG only)
+#define USB_DEVCTL_SESSION      0x00000001  // Session Start/End (OTG only)
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_CCONF register.
+//
+//*****************************************************************************
+#define USB_CCONF_TXEDMA        0x00000002  // TX Early DMA Enable
+#define USB_CCONF_RXEDMA        0x00000001  // TX Early DMA Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFIFOSZ register.
+//
+//*****************************************************************************
+#define USB_TXFIFOSZ_DPB        0x00000010  // Double Packet Buffer Support
+#define USB_TXFIFOSZ_SIZE_M     0x0000000F  // Max Packet Size
+#define USB_TXFIFOSZ_SIZE_8     0x00000000  // 8
+#define USB_TXFIFOSZ_SIZE_16    0x00000001  // 16
+#define USB_TXFIFOSZ_SIZE_32    0x00000002  // 32
+#define USB_TXFIFOSZ_SIZE_64    0x00000003  // 64
+#define USB_TXFIFOSZ_SIZE_128   0x00000004  // 128
+#define USB_TXFIFOSZ_SIZE_256   0x00000005  // 256
+#define USB_TXFIFOSZ_SIZE_512   0x00000006  // 512
+#define USB_TXFIFOSZ_SIZE_1024  0x00000007  // 1024
+#define USB_TXFIFOSZ_SIZE_2048  0x00000008  // 2048
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFIFOSZ register.
+//
+//*****************************************************************************
+#define USB_RXFIFOSZ_DPB        0x00000010  // Double Packet Buffer Support
+#define USB_RXFIFOSZ_SIZE_M     0x0000000F  // Max Packet Size
+#define USB_RXFIFOSZ_SIZE_8     0x00000000  // 8
+#define USB_RXFIFOSZ_SIZE_16    0x00000001  // 16
+#define USB_RXFIFOSZ_SIZE_32    0x00000002  // 32
+#define USB_RXFIFOSZ_SIZE_64    0x00000003  // 64
+#define USB_RXFIFOSZ_SIZE_128   0x00000004  // 128
+#define USB_RXFIFOSZ_SIZE_256   0x00000005  // 256
+#define USB_RXFIFOSZ_SIZE_512   0x00000006  // 512
+#define USB_RXFIFOSZ_SIZE_1024  0x00000007  // 1024
+#define USB_RXFIFOSZ_SIZE_2048  0x00000008  // 2048
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFIFOADD
+// register.
+//
+//*****************************************************************************
+#define USB_TXFIFOADD_ADDR_M    0x000001FF  // Transmit/Receive Start Address
+#define USB_TXFIFOADD_ADDR_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFIFOADD
+// register.
+//
+//*****************************************************************************
+#define USB_RXFIFOADD_ADDR_M    0x000001FF  // Transmit/Receive Start Address
+#define USB_RXFIFOADD_ADDR_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_ULPIVBUSCTL
+// register.
+//
+//*****************************************************************************
+#define USB_ULPIVBUSCTL_USEEXTVBUSIND                                         \
+                                0x00000002  // Use External VBUS Indicator
+#define USB_ULPIVBUSCTL_USEEXTVBUS                                            \
+                                0x00000001  // Use External VBUS
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_ULPIREGDATA
+// register.
+//
+//*****************************************************************************
+#define USB_ULPIREGDATA_REGDATA_M                                             \
+                                0x000000FF  // Register Data
+#define USB_ULPIREGDATA_REGDATA_S                                             \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_ULPIREGADDR
+// register.
+//
+//*****************************************************************************
+#define USB_ULPIREGADDR_ADDR_M  0x000000FF  // Register Address
+#define USB_ULPIREGADDR_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_ULPIREGCTL
+// register.
+//
+//*****************************************************************************
+#define USB_ULPIREGCTL_RDWR     0x00000004  // Read/Write Control
+#define USB_ULPIREGCTL_REGCMPLT 0x00000002  // Register Access Complete
+#define USB_ULPIREGCTL_REGACC   0x00000001  // Initiate Register Access
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_EPINFO register.
+//
+//*****************************************************************************
+#define USB_EPINFO_RXEP_M       0x000000F0  // RX Endpoints
+#define USB_EPINFO_TXEP_M       0x0000000F  // TX Endpoints
+#define USB_EPINFO_RXEP_S       4
+#define USB_EPINFO_TXEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RAMINFO register.
+//
+//*****************************************************************************
+#define USB_RAMINFO_DMACHAN_M   0x000000F0  // DMA Channels
+#define USB_RAMINFO_RAMBITS_M   0x0000000F  // RAM Address Bus Width
+#define USB_RAMINFO_DMACHAN_S   4
+#define USB_RAMINFO_RAMBITS_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_CONTIM register.
+//
+//*****************************************************************************
+#define USB_CONTIM_WTCON_M      0x000000F0  // Connect Wait
+#define USB_CONTIM_WTID_M       0x0000000F  // Wait ID
+#define USB_CONTIM_WTCON_S      4
+#define USB_CONTIM_WTID_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_VPLEN register.
+//
+//*****************************************************************************
+#define USB_VPLEN_VPLEN_M       0x000000FF  // VBUS Pulse Length
+#define USB_VPLEN_VPLEN_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_HSEOF register.
+//
+//*****************************************************************************
+#define USB_HSEOF_HSEOFG_M      0x000000FF  // HIgh-Speed End-of-Frame Gap
+#define USB_HSEOF_HSEOFG_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FSEOF register.
+//
+//*****************************************************************************
+#define USB_FSEOF_FSEOFG_M      0x000000FF  // Full-Speed End-of-Frame Gap
+#define USB_FSEOF_FSEOFG_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_LSEOF register.
+//
+//*****************************************************************************
+#define USB_LSEOF_LSEOFG_M      0x000000FF  // Low-Speed End-of-Frame Gap
+#define USB_LSEOF_LSEOFG_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR0
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR0_ADDR_M  0x0000007F  // Device Address
+#define USB_TXFUNCADDR0_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR0
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR0_ADDR_M   0x0000007F  // Hub Address
+#define USB_TXHUBADDR0_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT0
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT0_PORT_M   0x0000007F  // Hub Port
+#define USB_TXHUBPORT0_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR1
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR1_ADDR_M  0x0000007F  // Device Address
+#define USB_TXFUNCADDR1_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR1
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR1_ADDR_M   0x0000007F  // Hub Address
+#define USB_TXHUBADDR1_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT1
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT1_PORT_M   0x0000007F  // Hub Port
+#define USB_TXHUBPORT1_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR1
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR1_ADDR_M  0x0000007F  // Device Address
+#define USB_RXFUNCADDR1_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR1
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR1_ADDR_M   0x0000007F  // Hub Address
+#define USB_RXHUBADDR1_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT1
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT1_PORT_M   0x0000007F  // Hub Port
+#define USB_RXHUBPORT1_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR2
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR2_ADDR_M  0x0000007F  // Device Address
+#define USB_TXFUNCADDR2_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR2
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR2_ADDR_M   0x0000007F  // Hub Address
+#define USB_TXHUBADDR2_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT2
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT2_PORT_M   0x0000007F  // Hub Port
+#define USB_TXHUBPORT2_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR2
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR2_ADDR_M  0x0000007F  // Device Address
+#define USB_RXFUNCADDR2_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR2
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR2_ADDR_M   0x0000007F  // Hub Address
+#define USB_RXHUBADDR2_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT2
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT2_PORT_M   0x0000007F  // Hub Port
+#define USB_RXHUBPORT2_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR3
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR3_ADDR_M  0x0000007F  // Device Address
+#define USB_TXFUNCADDR3_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR3
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR3_ADDR_M   0x0000007F  // Hub Address
+#define USB_TXHUBADDR3_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT3
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT3_PORT_M   0x0000007F  // Hub Port
+#define USB_TXHUBPORT3_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR3
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR3_ADDR_M  0x0000007F  // Device Address
+#define USB_RXFUNCADDR3_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR3
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR3_ADDR_M   0x0000007F  // Hub Address
+#define USB_RXHUBADDR3_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT3
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT3_PORT_M   0x0000007F  // Hub Port
+#define USB_RXHUBPORT3_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR4
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR4_ADDR_M  0x0000007F  // Device Address
+#define USB_TXFUNCADDR4_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR4
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR4_ADDR_M   0x0000007F  // Hub Address
+#define USB_TXHUBADDR4_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT4
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT4_PORT_M   0x0000007F  // Hub Port
+#define USB_TXHUBPORT4_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR4
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR4_ADDR_M  0x0000007F  // Device Address
+#define USB_RXFUNCADDR4_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR4
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR4_ADDR_M   0x0000007F  // Hub Address
+#define USB_RXHUBADDR4_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT4
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT4_PORT_M   0x0000007F  // Hub Port
+#define USB_RXHUBPORT4_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR5
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR5_ADDR_M  0x0000007F  // Device Address
+#define USB_TXFUNCADDR5_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR5
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR5_ADDR_M   0x0000007F  // Hub Address
+#define USB_TXHUBADDR5_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT5
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT5_PORT_M   0x0000007F  // Hub Port
+#define USB_TXHUBPORT5_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR5
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR5_ADDR_M  0x0000007F  // Device Address
+#define USB_RXFUNCADDR5_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR5
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR5_ADDR_M   0x0000007F  // Hub Address
+#define USB_RXHUBADDR5_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT5
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT5_PORT_M   0x0000007F  // Hub Port
+#define USB_RXHUBPORT5_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR6
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR6_ADDR_M  0x0000007F  // Device Address
+#define USB_TXFUNCADDR6_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR6
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR6_ADDR_M   0x0000007F  // Hub Address
+#define USB_TXHUBADDR6_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT6
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT6_PORT_M   0x0000007F  // Hub Port
+#define USB_TXHUBPORT6_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR6
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR6_ADDR_M  0x0000007F  // Device Address
+#define USB_RXFUNCADDR6_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR6
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR6_ADDR_M   0x0000007F  // Hub Address
+#define USB_RXHUBADDR6_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT6
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT6_PORT_M   0x0000007F  // Hub Port
+#define USB_RXHUBPORT6_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR7
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR7_ADDR_M  0x0000007F  // Device Address
+#define USB_TXFUNCADDR7_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR7
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR7_ADDR_M   0x0000007F  // Hub Address
+#define USB_TXHUBADDR7_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT7
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT7_PORT_M   0x0000007F  // Hub Port
+#define USB_TXHUBPORT7_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR7
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR7_ADDR_M  0x0000007F  // Device Address
+#define USB_RXFUNCADDR7_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR7
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR7_ADDR_M   0x0000007F  // Hub Address
+#define USB_RXHUBADDR7_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT7
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT7_PORT_M   0x0000007F  // Hub Port
+#define USB_RXHUBPORT7_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_CSRL0 register.
+//
+//*****************************************************************************
+#define USB_CSRL0_NAKTO         0x00000080  // NAK Timeout
+#define USB_CSRL0_SETENDC       0x00000080  // Setup End Clear
+#define USB_CSRL0_STATUS        0x00000040  // STATUS Packet
+#define USB_CSRL0_RXRDYC        0x00000040  // RXRDY Clear
+#define USB_CSRL0_REQPKT        0x00000020  // Request Packet
+#define USB_CSRL0_STALL         0x00000020  // Send Stall
+#define USB_CSRL0_SETEND        0x00000010  // Setup End
+#define USB_CSRL0_ERROR         0x00000010  // Error
+#define USB_CSRL0_DATAEND       0x00000008  // Data End
+#define USB_CSRL0_SETUP         0x00000008  // Setup Packet
+#define USB_CSRL0_STALLED       0x00000004  // Endpoint Stalled
+#define USB_CSRL0_TXRDY         0x00000002  // Transmit Packet Ready
+#define USB_CSRL0_RXRDY         0x00000001  // Receive Packet Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_CSRH0 register.
+//
+//*****************************************************************************
+#define USB_CSRH0_DISPING       0x00000008  // PING Disable
+#define USB_CSRH0_DTWE          0x00000004  // Data Toggle Write Enable
+#define USB_CSRH0_DT            0x00000002  // Data Toggle
+#define USB_CSRH0_FLUSH         0x00000001  // Flush FIFO
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_COUNT0 register.
+//
+//*****************************************************************************
+#define USB_COUNT0_COUNT_M      0x0000007F  // FIFO Count
+#define USB_COUNT0_COUNT_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TYPE0 register.
+//
+//*****************************************************************************
+#define USB_TYPE0_SPEED_M       0x000000C0  // Operating Speed
+#define USB_TYPE0_SPEED_HIGH    0x00000040  // High
+#define USB_TYPE0_SPEED_FULL    0x00000080  // Full
+#define USB_TYPE0_SPEED_LOW     0x000000C0  // Low
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_NAKLMT register.
+//
+//*****************************************************************************
+#define USB_NAKLMT_NAKLMT_M     0x0000001F  // EP0 NAK Limit
+#define USB_NAKLMT_NAKLMT_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP1 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP1_MAXLOAD_M   0x000007FF  // Maximum Payload
+#define USB_TXMAXP1_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL1 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL1_NAKTO       0x00000080  // NAK Timeout
+#define USB_TXCSRL1_CLRDT       0x00000040  // Clear Data Toggle
+#define USB_TXCSRL1_STALLED     0x00000020  // Endpoint Stalled
+#define USB_TXCSRL1_STALL       0x00000010  // Send STALL
+#define USB_TXCSRL1_SETUP       0x00000010  // Setup Packet
+#define USB_TXCSRL1_FLUSH       0x00000008  // Flush FIFO
+#define USB_TXCSRL1_ERROR       0x00000004  // Error
+#define USB_TXCSRL1_UNDRN       0x00000004  // Underrun
+#define USB_TXCSRL1_FIFONE      0x00000002  // FIFO Not Empty
+#define USB_TXCSRL1_TXRDY       0x00000001  // Transmit Packet Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH1 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH1_AUTOSET     0x00000080  // Auto Set
+#define USB_TXCSRH1_ISO         0x00000040  // Isochronous Transfers
+#define USB_TXCSRH1_MODE        0x00000020  // Mode
+#define USB_TXCSRH1_DMAEN       0x00000010  // DMA Request Enable
+#define USB_TXCSRH1_FDT         0x00000008  // Force Data Toggle
+#define USB_TXCSRH1_DMAMOD      0x00000004  // DMA Request Mode
+#define USB_TXCSRH1_DTWE        0x00000002  // Data Toggle Write Enable
+#define USB_TXCSRH1_DT          0x00000001  // Data Toggle
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP1 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP1_MAXLOAD_M   0x000007FF  // Maximum Payload
+#define USB_RXMAXP1_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL1 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL1_CLRDT       0x00000080  // Clear Data Toggle
+#define USB_RXCSRL1_STALLED     0x00000040  // Endpoint Stalled
+#define USB_RXCSRL1_STALL       0x00000020  // Send STALL
+#define USB_RXCSRL1_REQPKT      0x00000020  // Request Packet
+#define USB_RXCSRL1_FLUSH       0x00000010  // Flush FIFO
+#define USB_RXCSRL1_DATAERR     0x00000008  // Data Error
+#define USB_RXCSRL1_NAKTO       0x00000008  // NAK Timeout
+#define USB_RXCSRL1_OVER        0x00000004  // Overrun
+#define USB_RXCSRL1_ERROR       0x00000004  // Error
+#define USB_RXCSRL1_FULL        0x00000002  // FIFO Full
+#define USB_RXCSRL1_RXRDY       0x00000001  // Receive Packet Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH1 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH1_AUTOCL      0x00000080  // Auto Clear
+#define USB_RXCSRH1_AUTORQ      0x00000040  // Auto Request
+#define USB_RXCSRH1_ISO         0x00000040  // Isochronous Transfers
+#define USB_RXCSRH1_DMAEN       0x00000020  // DMA Request Enable
+#define USB_RXCSRH1_DISNYET     0x00000010  // Disable NYET
+#define USB_RXCSRH1_PIDERR      0x00000010  // PID Error
+#define USB_RXCSRH1_DMAMOD      0x00000008  // DMA Request Mode
+#define USB_RXCSRH1_DTWE        0x00000004  // Data Toggle Write Enable
+#define USB_RXCSRH1_DT          0x00000002  // Data Toggle
+#define USB_RXCSRH1_INCOMPRX    0x00000001  // Incomplete RX Transmission
+                                            // Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT1 register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT1_COUNT_M    0x00001FFF  // Receive Packet Count
+#define USB_RXCOUNT1_COUNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE1 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE1_SPEED_M     0x000000C0  // Operating Speed
+#define USB_TXTYPE1_SPEED_DFLT  0x00000000  // Default
+#define USB_TXTYPE1_SPEED_HIGH  0x00000040  // High
+#define USB_TXTYPE1_SPEED_FULL  0x00000080  // Full
+#define USB_TXTYPE1_SPEED_LOW   0x000000C0  // Low
+#define USB_TXTYPE1_PROTO_M     0x00000030  // Protocol
+#define USB_TXTYPE1_PROTO_CTRL  0x00000000  // Control
+#define USB_TXTYPE1_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_TXTYPE1_PROTO_BULK  0x00000020  // Bulk
+#define USB_TXTYPE1_PROTO_INT   0x00000030  // Interrupt
+#define USB_TXTYPE1_TEP_M       0x0000000F  // Target Endpoint Number
+#define USB_TXTYPE1_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL1
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL1_NAKLMT_M                                              \
+                                0x000000FF  // NAK Limit
+#define USB_TXINTERVAL1_TXPOLL_M                                              \
+                                0x000000FF  // TX Polling
+#define USB_TXINTERVAL1_TXPOLL_S                                              \
+                                0
+#define USB_TXINTERVAL1_NAKLMT_S                                              \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE1 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE1_SPEED_M     0x000000C0  // Operating Speed
+#define USB_RXTYPE1_SPEED_DFLT  0x00000000  // Default
+#define USB_RXTYPE1_SPEED_HIGH  0x00000040  // High
+#define USB_RXTYPE1_SPEED_FULL  0x00000080  // Full
+#define USB_RXTYPE1_SPEED_LOW   0x000000C0  // Low
+#define USB_RXTYPE1_PROTO_M     0x00000030  // Protocol
+#define USB_RXTYPE1_PROTO_CTRL  0x00000000  // Control
+#define USB_RXTYPE1_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_RXTYPE1_PROTO_BULK  0x00000020  // Bulk
+#define USB_RXTYPE1_PROTO_INT   0x00000030  // Interrupt
+#define USB_RXTYPE1_TEP_M       0x0000000F  // Target Endpoint Number
+#define USB_RXTYPE1_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL1
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL1_TXPOLL_M                                              \
+                                0x000000FF  // RX Polling
+#define USB_RXINTERVAL1_NAKLMT_M                                              \
+                                0x000000FF  // NAK Limit
+#define USB_RXINTERVAL1_TXPOLL_S                                              \
+                                0
+#define USB_RXINTERVAL1_NAKLMT_S                                              \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP2 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP2_MAXLOAD_M   0x000007FF  // Maximum Payload
+#define USB_TXMAXP2_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL2 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL2_NAKTO       0x00000080  // NAK Timeout
+#define USB_TXCSRL2_CLRDT       0x00000040  // Clear Data Toggle
+#define USB_TXCSRL2_STALLED     0x00000020  // Endpoint Stalled
+#define USB_TXCSRL2_SETUP       0x00000010  // Setup Packet
+#define USB_TXCSRL2_STALL       0x00000010  // Send STALL
+#define USB_TXCSRL2_FLUSH       0x00000008  // Flush FIFO
+#define USB_TXCSRL2_ERROR       0x00000004  // Error
+#define USB_TXCSRL2_UNDRN       0x00000004  // Underrun
+#define USB_TXCSRL2_FIFONE      0x00000002  // FIFO Not Empty
+#define USB_TXCSRL2_TXRDY       0x00000001  // Transmit Packet Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH2 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH2_AUTOSET     0x00000080  // Auto Set
+#define USB_TXCSRH2_ISO         0x00000040  // Isochronous Transfers
+#define USB_TXCSRH2_MODE        0x00000020  // Mode
+#define USB_TXCSRH2_DMAEN       0x00000010  // DMA Request Enable
+#define USB_TXCSRH2_FDT         0x00000008  // Force Data Toggle
+#define USB_TXCSRH2_DMAMOD      0x00000004  // DMA Request Mode
+#define USB_TXCSRH2_DTWE        0x00000002  // Data Toggle Write Enable
+#define USB_TXCSRH2_DT          0x00000001  // Data Toggle
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP2 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP2_MAXLOAD_M   0x000007FF  // Maximum Payload
+#define USB_RXMAXP2_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL2 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL2_CLRDT       0x00000080  // Clear Data Toggle
+#define USB_RXCSRL2_STALLED     0x00000040  // Endpoint Stalled
+#define USB_RXCSRL2_REQPKT      0x00000020  // Request Packet
+#define USB_RXCSRL2_STALL       0x00000020  // Send STALL
+#define USB_RXCSRL2_FLUSH       0x00000010  // Flush FIFO
+#define USB_RXCSRL2_DATAERR     0x00000008  // Data Error
+#define USB_RXCSRL2_NAKTO       0x00000008  // NAK Timeout
+#define USB_RXCSRL2_ERROR       0x00000004  // Error
+#define USB_RXCSRL2_OVER        0x00000004  // Overrun
+#define USB_RXCSRL2_FULL        0x00000002  // FIFO Full
+#define USB_RXCSRL2_RXRDY       0x00000001  // Receive Packet Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH2 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH2_AUTOCL      0x00000080  // Auto Clear
+#define USB_RXCSRH2_AUTORQ      0x00000040  // Auto Request
+#define USB_RXCSRH2_ISO         0x00000040  // Isochronous Transfers
+#define USB_RXCSRH2_DMAEN       0x00000020  // DMA Request Enable
+#define USB_RXCSRH2_DISNYET     0x00000010  // Disable NYET
+#define USB_RXCSRH2_PIDERR      0x00000010  // PID Error
+#define USB_RXCSRH2_DMAMOD      0x00000008  // DMA Request Mode
+#define USB_RXCSRH2_DTWE        0x00000004  // Data Toggle Write Enable
+#define USB_RXCSRH2_DT          0x00000002  // Data Toggle
+#define USB_RXCSRH2_INCOMPRX    0x00000001  // Incomplete RX Transmission
+                                            // Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT2 register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT2_COUNT_M    0x00001FFF  // Receive Packet Count
+#define USB_RXCOUNT2_COUNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE2 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE2_SPEED_M     0x000000C0  // Operating Speed
+#define USB_TXTYPE2_SPEED_DFLT  0x00000000  // Default
+#define USB_TXTYPE2_SPEED_HIGH  0x00000040  // High
+#define USB_TXTYPE2_SPEED_FULL  0x00000080  // Full
+#define USB_TXTYPE2_SPEED_LOW   0x000000C0  // Low
+#define USB_TXTYPE2_PROTO_M     0x00000030  // Protocol
+#define USB_TXTYPE2_PROTO_CTRL  0x00000000  // Control
+#define USB_TXTYPE2_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_TXTYPE2_PROTO_BULK  0x00000020  // Bulk
+#define USB_TXTYPE2_PROTO_INT   0x00000030  // Interrupt
+#define USB_TXTYPE2_TEP_M       0x0000000F  // Target Endpoint Number
+#define USB_TXTYPE2_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL2
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL2_TXPOLL_M                                              \
+                                0x000000FF  // TX Polling
+#define USB_TXINTERVAL2_NAKLMT_M                                              \
+                                0x000000FF  // NAK Limit
+#define USB_TXINTERVAL2_NAKLMT_S                                              \
+                                0
+#define USB_TXINTERVAL2_TXPOLL_S                                              \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE2 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE2_SPEED_M     0x000000C0  // Operating Speed
+#define USB_RXTYPE2_SPEED_DFLT  0x00000000  // Default
+#define USB_RXTYPE2_SPEED_HIGH  0x00000040  // High
+#define USB_RXTYPE2_SPEED_FULL  0x00000080  // Full
+#define USB_RXTYPE2_SPEED_LOW   0x000000C0  // Low
+#define USB_RXTYPE2_PROTO_M     0x00000030  // Protocol
+#define USB_RXTYPE2_PROTO_CTRL  0x00000000  // Control
+#define USB_RXTYPE2_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_RXTYPE2_PROTO_BULK  0x00000020  // Bulk
+#define USB_RXTYPE2_PROTO_INT   0x00000030  // Interrupt
+#define USB_RXTYPE2_TEP_M       0x0000000F  // Target Endpoint Number
+#define USB_RXTYPE2_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL2
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL2_TXPOLL_M                                              \
+                                0x000000FF  // RX Polling
+#define USB_RXINTERVAL2_NAKLMT_M                                              \
+                                0x000000FF  // NAK Limit
+#define USB_RXINTERVAL2_TXPOLL_S                                              \
+                                0
+#define USB_RXINTERVAL2_NAKLMT_S                                              \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP3 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP3_MAXLOAD_M   0x000007FF  // Maximum Payload
+#define USB_TXMAXP3_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL3 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL3_NAKTO       0x00000080  // NAK Timeout
+#define USB_TXCSRL3_CLRDT       0x00000040  // Clear Data Toggle
+#define USB_TXCSRL3_STALLED     0x00000020  // Endpoint Stalled
+#define USB_TXCSRL3_SETUP       0x00000010  // Setup Packet
+#define USB_TXCSRL3_STALL       0x00000010  // Send STALL
+#define USB_TXCSRL3_FLUSH       0x00000008  // Flush FIFO
+#define USB_TXCSRL3_ERROR       0x00000004  // Error
+#define USB_TXCSRL3_UNDRN       0x00000004  // Underrun
+#define USB_TXCSRL3_FIFONE      0x00000002  // FIFO Not Empty
+#define USB_TXCSRL3_TXRDY       0x00000001  // Transmit Packet Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH3 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH3_AUTOSET     0x00000080  // Auto Set
+#define USB_TXCSRH3_ISO         0x00000040  // Isochronous Transfers
+#define USB_TXCSRH3_MODE        0x00000020  // Mode
+#define USB_TXCSRH3_DMAEN       0x00000010  // DMA Request Enable
+#define USB_TXCSRH3_FDT         0x00000008  // Force Data Toggle
+#define USB_TXCSRH3_DMAMOD      0x00000004  // DMA Request Mode
+#define USB_TXCSRH3_DTWE        0x00000002  // Data Toggle Write Enable
+#define USB_TXCSRH3_DT          0x00000001  // Data Toggle
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP3 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP3_MAXLOAD_M   0x000007FF  // Maximum Payload
+#define USB_RXMAXP3_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL3 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL3_CLRDT       0x00000080  // Clear Data Toggle
+#define USB_RXCSRL3_STALLED     0x00000040  // Endpoint Stalled
+#define USB_RXCSRL3_STALL       0x00000020  // Send STALL
+#define USB_RXCSRL3_REQPKT      0x00000020  // Request Packet
+#define USB_RXCSRL3_FLUSH       0x00000010  // Flush FIFO
+#define USB_RXCSRL3_DATAERR     0x00000008  // Data Error
+#define USB_RXCSRL3_NAKTO       0x00000008  // NAK Timeout
+#define USB_RXCSRL3_ERROR       0x00000004  // Error
+#define USB_RXCSRL3_OVER        0x00000004  // Overrun
+#define USB_RXCSRL3_FULL        0x00000002  // FIFO Full
+#define USB_RXCSRL3_RXRDY       0x00000001  // Receive Packet Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH3 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH3_AUTOCL      0x00000080  // Auto Clear
+#define USB_RXCSRH3_AUTORQ      0x00000040  // Auto Request
+#define USB_RXCSRH3_ISO         0x00000040  // Isochronous Transfers
+#define USB_RXCSRH3_DMAEN       0x00000020  // DMA Request Enable
+#define USB_RXCSRH3_DISNYET     0x00000010  // Disable NYET
+#define USB_RXCSRH3_PIDERR      0x00000010  // PID Error
+#define USB_RXCSRH3_DMAMOD      0x00000008  // DMA Request Mode
+#define USB_RXCSRH3_DTWE        0x00000004  // Data Toggle Write Enable
+#define USB_RXCSRH3_DT          0x00000002  // Data Toggle
+#define USB_RXCSRH3_INCOMPRX    0x00000001  // Incomplete RX Transmission
+                                            // Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT3 register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT3_COUNT_M    0x00001FFF  // Receive Packet Count
+#define USB_RXCOUNT3_COUNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE3 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE3_SPEED_M     0x000000C0  // Operating Speed
+#define USB_TXTYPE3_SPEED_DFLT  0x00000000  // Default
+#define USB_TXTYPE3_SPEED_HIGH  0x00000040  // High
+#define USB_TXTYPE3_SPEED_FULL  0x00000080  // Full
+#define USB_TXTYPE3_SPEED_LOW   0x000000C0  // Low
+#define USB_TXTYPE3_PROTO_M     0x00000030  // Protocol
+#define USB_TXTYPE3_PROTO_CTRL  0x00000000  // Control
+#define USB_TXTYPE3_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_TXTYPE3_PROTO_BULK  0x00000020  // Bulk
+#define USB_TXTYPE3_PROTO_INT   0x00000030  // Interrupt
+#define USB_TXTYPE3_TEP_M       0x0000000F  // Target Endpoint Number
+#define USB_TXTYPE3_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL3
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL3_TXPOLL_M                                              \
+                                0x000000FF  // TX Polling
+#define USB_TXINTERVAL3_NAKLMT_M                                              \
+                                0x000000FF  // NAK Limit
+#define USB_TXINTERVAL3_TXPOLL_S                                              \
+                                0
+#define USB_TXINTERVAL3_NAKLMT_S                                              \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE3 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE3_SPEED_M     0x000000C0  // Operating Speed
+#define USB_RXTYPE3_SPEED_DFLT  0x00000000  // Default
+#define USB_RXTYPE3_SPEED_HIGH  0x00000040  // High
+#define USB_RXTYPE3_SPEED_FULL  0x00000080  // Full
+#define USB_RXTYPE3_SPEED_LOW   0x000000C0  // Low
+#define USB_RXTYPE3_PROTO_M     0x00000030  // Protocol
+#define USB_RXTYPE3_PROTO_CTRL  0x00000000  // Control
+#define USB_RXTYPE3_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_RXTYPE3_PROTO_BULK  0x00000020  // Bulk
+#define USB_RXTYPE3_PROTO_INT   0x00000030  // Interrupt
+#define USB_RXTYPE3_TEP_M       0x0000000F  // Target Endpoint Number
+#define USB_RXTYPE3_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL3
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL3_TXPOLL_M                                              \
+                                0x000000FF  // RX Polling
+#define USB_RXINTERVAL3_NAKLMT_M                                              \
+                                0x000000FF  // NAK Limit
+#define USB_RXINTERVAL3_TXPOLL_S                                              \
+                                0
+#define USB_RXINTERVAL3_NAKLMT_S                                              \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP4 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP4_MAXLOAD_M   0x000007FF  // Maximum Payload
+#define USB_TXMAXP4_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL4 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL4_NAKTO       0x00000080  // NAK Timeout
+#define USB_TXCSRL4_CLRDT       0x00000040  // Clear Data Toggle
+#define USB_TXCSRL4_STALLED     0x00000020  // Endpoint Stalled
+#define USB_TXCSRL4_SETUP       0x00000010  // Setup Packet
+#define USB_TXCSRL4_STALL       0x00000010  // Send STALL
+#define USB_TXCSRL4_FLUSH       0x00000008  // Flush FIFO
+#define USB_TXCSRL4_ERROR       0x00000004  // Error
+#define USB_TXCSRL4_UNDRN       0x00000004  // Underrun
+#define USB_TXCSRL4_FIFONE      0x00000002  // FIFO Not Empty
+#define USB_TXCSRL4_TXRDY       0x00000001  // Transmit Packet Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH4 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH4_AUTOSET     0x00000080  // Auto Set
+#define USB_TXCSRH4_ISO         0x00000040  // Isochronous Transfers
+#define USB_TXCSRH4_MODE        0x00000020  // Mode
+#define USB_TXCSRH4_DMAEN       0x00000010  // DMA Request Enable
+#define USB_TXCSRH4_FDT         0x00000008  // Force Data Toggle
+#define USB_TXCSRH4_DMAMOD      0x00000004  // DMA Request Mode
+#define USB_TXCSRH4_DTWE        0x00000002  // Data Toggle Write Enable
+#define USB_TXCSRH4_DT          0x00000001  // Data Toggle
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP4 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP4_MAXLOAD_M   0x000007FF  // Maximum Payload
+#define USB_RXMAXP4_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL4 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL4_CLRDT       0x00000080  // Clear Data Toggle
+#define USB_RXCSRL4_STALLED     0x00000040  // Endpoint Stalled
+#define USB_RXCSRL4_STALL       0x00000020  // Send STALL
+#define USB_RXCSRL4_REQPKT      0x00000020  // Request Packet
+#define USB_RXCSRL4_FLUSH       0x00000010  // Flush FIFO
+#define USB_RXCSRL4_NAKTO       0x00000008  // NAK Timeout
+#define USB_RXCSRL4_DATAERR     0x00000008  // Data Error
+#define USB_RXCSRL4_OVER        0x00000004  // Overrun
+#define USB_RXCSRL4_ERROR       0x00000004  // Error
+#define USB_RXCSRL4_FULL        0x00000002  // FIFO Full
+#define USB_RXCSRL4_RXRDY       0x00000001  // Receive Packet Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH4 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH4_AUTOCL      0x00000080  // Auto Clear
+#define USB_RXCSRH4_AUTORQ      0x00000040  // Auto Request
+#define USB_RXCSRH4_ISO         0x00000040  // Isochronous Transfers
+#define USB_RXCSRH4_DMAEN       0x00000020  // DMA Request Enable
+#define USB_RXCSRH4_DISNYET     0x00000010  // Disable NYET
+#define USB_RXCSRH4_PIDERR      0x00000010  // PID Error
+#define USB_RXCSRH4_DMAMOD      0x00000008  // DMA Request Mode
+#define USB_RXCSRH4_DTWE        0x00000004  // Data Toggle Write Enable
+#define USB_RXCSRH4_DT          0x00000002  // Data Toggle
+#define USB_RXCSRH4_INCOMPRX    0x00000001  // Incomplete RX Transmission
+                                            // Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT4 register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT4_COUNT_M    0x00001FFF  // Receive Packet Count
+#define USB_RXCOUNT4_COUNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE4 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE4_SPEED_M     0x000000C0  // Operating Speed
+#define USB_TXTYPE4_SPEED_DFLT  0x00000000  // Default
+#define USB_TXTYPE4_SPEED_HIGH  0x00000040  // High
+#define USB_TXTYPE4_SPEED_FULL  0x00000080  // Full
+#define USB_TXTYPE4_SPEED_LOW   0x000000C0  // Low
+#define USB_TXTYPE4_PROTO_M     0x00000030  // Protocol
+#define USB_TXTYPE4_PROTO_CTRL  0x00000000  // Control
+#define USB_TXTYPE4_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_TXTYPE4_PROTO_BULK  0x00000020  // Bulk
+#define USB_TXTYPE4_PROTO_INT   0x00000030  // Interrupt
+#define USB_TXTYPE4_TEP_M       0x0000000F  // Target Endpoint Number
+#define USB_TXTYPE4_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL4
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL4_TXPOLL_M                                              \
+                                0x000000FF  // TX Polling
+#define USB_TXINTERVAL4_NAKLMT_M                                              \
+                                0x000000FF  // NAK Limit
+#define USB_TXINTERVAL4_NAKLMT_S                                              \
+                                0
+#define USB_TXINTERVAL4_TXPOLL_S                                              \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE4 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE4_SPEED_M     0x000000C0  // Operating Speed
+#define USB_RXTYPE4_SPEED_DFLT  0x00000000  // Default
+#define USB_RXTYPE4_SPEED_HIGH  0x00000040  // High
+#define USB_RXTYPE4_SPEED_FULL  0x00000080  // Full
+#define USB_RXTYPE4_SPEED_LOW   0x000000C0  // Low
+#define USB_RXTYPE4_PROTO_M     0x00000030  // Protocol
+#define USB_RXTYPE4_PROTO_CTRL  0x00000000  // Control
+#define USB_RXTYPE4_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_RXTYPE4_PROTO_BULK  0x00000020  // Bulk
+#define USB_RXTYPE4_PROTO_INT   0x00000030  // Interrupt
+#define USB_RXTYPE4_TEP_M       0x0000000F  // Target Endpoint Number
+#define USB_RXTYPE4_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL4
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL4_TXPOLL_M                                              \
+                                0x000000FF  // RX Polling
+#define USB_RXINTERVAL4_NAKLMT_M                                              \
+                                0x000000FF  // NAK Limit
+#define USB_RXINTERVAL4_NAKLMT_S                                              \
+                                0
+#define USB_RXINTERVAL4_TXPOLL_S                                              \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP5 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP5_MAXLOAD_M   0x000007FF  // Maximum Payload
+#define USB_TXMAXP5_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL5 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL5_NAKTO       0x00000080  // NAK Timeout
+#define USB_TXCSRL5_CLRDT       0x00000040  // Clear Data Toggle
+#define USB_TXCSRL5_STALLED     0x00000020  // Endpoint Stalled
+#define USB_TXCSRL5_SETUP       0x00000010  // Setup Packet
+#define USB_TXCSRL5_STALL       0x00000010  // Send STALL
+#define USB_TXCSRL5_FLUSH       0x00000008  // Flush FIFO
+#define USB_TXCSRL5_ERROR       0x00000004  // Error
+#define USB_TXCSRL5_UNDRN       0x00000004  // Underrun
+#define USB_TXCSRL5_FIFONE      0x00000002  // FIFO Not Empty
+#define USB_TXCSRL5_TXRDY       0x00000001  // Transmit Packet Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH5 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH5_AUTOSET     0x00000080  // Auto Set
+#define USB_TXCSRH5_ISO         0x00000040  // Isochronous Transfers
+#define USB_TXCSRH5_MODE        0x00000020  // Mode
+#define USB_TXCSRH5_DMAEN       0x00000010  // DMA Request Enable
+#define USB_TXCSRH5_FDT         0x00000008  // Force Data Toggle
+#define USB_TXCSRH5_DMAMOD      0x00000004  // DMA Request Mode
+#define USB_TXCSRH5_DTWE        0x00000002  // Data Toggle Write Enable
+#define USB_TXCSRH5_DT          0x00000001  // Data Toggle
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP5 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP5_MAXLOAD_M   0x000007FF  // Maximum Payload
+#define USB_RXMAXP5_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL5 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL5_CLRDT       0x00000080  // Clear Data Toggle
+#define USB_RXCSRL5_STALLED     0x00000040  // Endpoint Stalled
+#define USB_RXCSRL5_STALL       0x00000020  // Send STALL
+#define USB_RXCSRL5_REQPKT      0x00000020  // Request Packet
+#define USB_RXCSRL5_FLUSH       0x00000010  // Flush FIFO
+#define USB_RXCSRL5_NAKTO       0x00000008  // NAK Timeout
+#define USB_RXCSRL5_DATAERR     0x00000008  // Data Error
+#define USB_RXCSRL5_ERROR       0x00000004  // Error
+#define USB_RXCSRL5_OVER        0x00000004  // Overrun
+#define USB_RXCSRL5_FULL        0x00000002  // FIFO Full
+#define USB_RXCSRL5_RXRDY       0x00000001  // Receive Packet Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH5 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH5_AUTOCL      0x00000080  // Auto Clear
+#define USB_RXCSRH5_AUTORQ      0x00000040  // Auto Request
+#define USB_RXCSRH5_ISO         0x00000040  // Isochronous Transfers
+#define USB_RXCSRH5_DMAEN       0x00000020  // DMA Request Enable
+#define USB_RXCSRH5_DISNYET     0x00000010  // Disable NYET
+#define USB_RXCSRH5_PIDERR      0x00000010  // PID Error
+#define USB_RXCSRH5_DMAMOD      0x00000008  // DMA Request Mode
+#define USB_RXCSRH5_DTWE        0x00000004  // Data Toggle Write Enable
+#define USB_RXCSRH5_DT          0x00000002  // Data Toggle
+#define USB_RXCSRH5_INCOMPRX    0x00000001  // Incomplete RX Transmission
+                                            // Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT5 register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT5_COUNT_M    0x00001FFF  // Receive Packet Count
+#define USB_RXCOUNT5_COUNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE5 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE5_SPEED_M     0x000000C0  // Operating Speed
+#define USB_TXTYPE5_SPEED_DFLT  0x00000000  // Default
+#define USB_TXTYPE5_SPEED_HIGH  0x00000040  // High
+#define USB_TXTYPE5_SPEED_FULL  0x00000080  // Full
+#define USB_TXTYPE5_SPEED_LOW   0x000000C0  // Low
+#define USB_TXTYPE5_PROTO_M     0x00000030  // Protocol
+#define USB_TXTYPE5_PROTO_CTRL  0x00000000  // Control
+#define USB_TXTYPE5_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_TXTYPE5_PROTO_BULK  0x00000020  // Bulk
+#define USB_TXTYPE5_PROTO_INT   0x00000030  // Interrupt
+#define USB_TXTYPE5_TEP_M       0x0000000F  // Target Endpoint Number
+#define USB_TXTYPE5_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL5
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL5_TXPOLL_M                                              \
+                                0x000000FF  // TX Polling
+#define USB_TXINTERVAL5_NAKLMT_M                                              \
+                                0x000000FF  // NAK Limit
+#define USB_TXINTERVAL5_NAKLMT_S                                              \
+                                0
+#define USB_TXINTERVAL5_TXPOLL_S                                              \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE5 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE5_SPEED_M     0x000000C0  // Operating Speed
+#define USB_RXTYPE5_SPEED_DFLT  0x00000000  // Default
+#define USB_RXTYPE5_SPEED_HIGH  0x00000040  // High
+#define USB_RXTYPE5_SPEED_FULL  0x00000080  // Full
+#define USB_RXTYPE5_SPEED_LOW   0x000000C0  // Low
+#define USB_RXTYPE5_PROTO_M     0x00000030  // Protocol
+#define USB_RXTYPE5_PROTO_CTRL  0x00000000  // Control
+#define USB_RXTYPE5_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_RXTYPE5_PROTO_BULK  0x00000020  // Bulk
+#define USB_RXTYPE5_PROTO_INT   0x00000030  // Interrupt
+#define USB_RXTYPE5_TEP_M       0x0000000F  // Target Endpoint Number
+#define USB_RXTYPE5_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL5
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL5_TXPOLL_M                                              \
+                                0x000000FF  // RX Polling
+#define USB_RXINTERVAL5_NAKLMT_M                                              \
+                                0x000000FF  // NAK Limit
+#define USB_RXINTERVAL5_TXPOLL_S                                              \
+                                0
+#define USB_RXINTERVAL5_NAKLMT_S                                              \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP6 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP6_MAXLOAD_M   0x000007FF  // Maximum Payload
+#define USB_TXMAXP6_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL6 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL6_NAKTO       0x00000080  // NAK Timeout
+#define USB_TXCSRL6_CLRDT       0x00000040  // Clear Data Toggle
+#define USB_TXCSRL6_STALLED     0x00000020  // Endpoint Stalled
+#define USB_TXCSRL6_STALL       0x00000010  // Send STALL
+#define USB_TXCSRL6_SETUP       0x00000010  // Setup Packet
+#define USB_TXCSRL6_FLUSH       0x00000008  // Flush FIFO
+#define USB_TXCSRL6_ERROR       0x00000004  // Error
+#define USB_TXCSRL6_UNDRN       0x00000004  // Underrun
+#define USB_TXCSRL6_FIFONE      0x00000002  // FIFO Not Empty
+#define USB_TXCSRL6_TXRDY       0x00000001  // Transmit Packet Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH6 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH6_AUTOSET     0x00000080  // Auto Set
+#define USB_TXCSRH6_ISO         0x00000040  // Isochronous Transfers
+#define USB_TXCSRH6_MODE        0x00000020  // Mode
+#define USB_TXCSRH6_DMAEN       0x00000010  // DMA Request Enable
+#define USB_TXCSRH6_FDT         0x00000008  // Force Data Toggle
+#define USB_TXCSRH6_DMAMOD      0x00000004  // DMA Request Mode
+#define USB_TXCSRH6_DTWE        0x00000002  // Data Toggle Write Enable
+#define USB_TXCSRH6_DT          0x00000001  // Data Toggle
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP6 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP6_MAXLOAD_M   0x000007FF  // Maximum Payload
+#define USB_RXMAXP6_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL6 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL6_CLRDT       0x00000080  // Clear Data Toggle
+#define USB_RXCSRL6_STALLED     0x00000040  // Endpoint Stalled
+#define USB_RXCSRL6_REQPKT      0x00000020  // Request Packet
+#define USB_RXCSRL6_STALL       0x00000020  // Send STALL
+#define USB_RXCSRL6_FLUSH       0x00000010  // Flush FIFO
+#define USB_RXCSRL6_NAKTO       0x00000008  // NAK Timeout
+#define USB_RXCSRL6_DATAERR     0x00000008  // Data Error
+#define USB_RXCSRL6_ERROR       0x00000004  // Error
+#define USB_RXCSRL6_OVER        0x00000004  // Overrun
+#define USB_RXCSRL6_FULL        0x00000002  // FIFO Full
+#define USB_RXCSRL6_RXRDY       0x00000001  // Receive Packet Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH6 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH6_AUTOCL      0x00000080  // Auto Clear
+#define USB_RXCSRH6_AUTORQ      0x00000040  // Auto Request
+#define USB_RXCSRH6_ISO         0x00000040  // Isochronous Transfers
+#define USB_RXCSRH6_DMAEN       0x00000020  // DMA Request Enable
+#define USB_RXCSRH6_DISNYET     0x00000010  // Disable NYET
+#define USB_RXCSRH6_PIDERR      0x00000010  // PID Error
+#define USB_RXCSRH6_DMAMOD      0x00000008  // DMA Request Mode
+#define USB_RXCSRH6_DTWE        0x00000004  // Data Toggle Write Enable
+#define USB_RXCSRH6_DT          0x00000002  // Data Toggle
+#define USB_RXCSRH6_INCOMPRX    0x00000001  // Incomplete RX Transmission
+                                            // Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT6 register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT6_COUNT_M    0x00001FFF  // Receive Packet Count
+#define USB_RXCOUNT6_COUNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE6 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE6_SPEED_M     0x000000C0  // Operating Speed
+#define USB_TXTYPE6_SPEED_DFLT  0x00000000  // Default
+#define USB_TXTYPE6_SPEED_HIGH  0x00000040  // High
+#define USB_TXTYPE6_SPEED_FULL  0x00000080  // Full
+#define USB_TXTYPE6_SPEED_LOW   0x000000C0  // Low
+#define USB_TXTYPE6_PROTO_M     0x00000030  // Protocol
+#define USB_TXTYPE6_PROTO_CTRL  0x00000000  // Control
+#define USB_TXTYPE6_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_TXTYPE6_PROTO_BULK  0x00000020  // Bulk
+#define USB_TXTYPE6_PROTO_INT   0x00000030  // Interrupt
+#define USB_TXTYPE6_TEP_M       0x0000000F  // Target Endpoint Number
+#define USB_TXTYPE6_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL6
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL6_TXPOLL_M                                              \
+                                0x000000FF  // TX Polling
+#define USB_TXINTERVAL6_NAKLMT_M                                              \
+                                0x000000FF  // NAK Limit
+#define USB_TXINTERVAL6_TXPOLL_S                                              \
+                                0
+#define USB_TXINTERVAL6_NAKLMT_S                                              \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE6 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE6_SPEED_M     0x000000C0  // Operating Speed
+#define USB_RXTYPE6_SPEED_DFLT  0x00000000  // Default
+#define USB_RXTYPE6_SPEED_HIGH  0x00000040  // High
+#define USB_RXTYPE6_SPEED_FULL  0x00000080  // Full
+#define USB_RXTYPE6_SPEED_LOW   0x000000C0  // Low
+#define USB_RXTYPE6_PROTO_M     0x00000030  // Protocol
+#define USB_RXTYPE6_PROTO_CTRL  0x00000000  // Control
+#define USB_RXTYPE6_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_RXTYPE6_PROTO_BULK  0x00000020  // Bulk
+#define USB_RXTYPE6_PROTO_INT   0x00000030  // Interrupt
+#define USB_RXTYPE6_TEP_M       0x0000000F  // Target Endpoint Number
+#define USB_RXTYPE6_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL6
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL6_TXPOLL_M                                              \
+                                0x000000FF  // RX Polling
+#define USB_RXINTERVAL6_NAKLMT_M                                              \
+                                0x000000FF  // NAK Limit
+#define USB_RXINTERVAL6_NAKLMT_S                                              \
+                                0
+#define USB_RXINTERVAL6_TXPOLL_S                                              \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP7 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP7_MAXLOAD_M   0x000007FF  // Maximum Payload
+#define USB_TXMAXP7_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL7 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL7_NAKTO       0x00000080  // NAK Timeout
+#define USB_TXCSRL7_CLRDT       0x00000040  // Clear Data Toggle
+#define USB_TXCSRL7_STALLED     0x00000020  // Endpoint Stalled
+#define USB_TXCSRL7_STALL       0x00000010  // Send STALL
+#define USB_TXCSRL7_SETUP       0x00000010  // Setup Packet
+#define USB_TXCSRL7_FLUSH       0x00000008  // Flush FIFO
+#define USB_TXCSRL7_ERROR       0x00000004  // Error
+#define USB_TXCSRL7_UNDRN       0x00000004  // Underrun
+#define USB_TXCSRL7_FIFONE      0x00000002  // FIFO Not Empty
+#define USB_TXCSRL7_TXRDY       0x00000001  // Transmit Packet Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH7 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH7_AUTOSET     0x00000080  // Auto Set
+#define USB_TXCSRH7_ISO         0x00000040  // Isochronous Transfers
+#define USB_TXCSRH7_MODE        0x00000020  // Mode
+#define USB_TXCSRH7_DMAEN       0x00000010  // DMA Request Enable
+#define USB_TXCSRH7_FDT         0x00000008  // Force Data Toggle
+#define USB_TXCSRH7_DMAMOD      0x00000004  // DMA Request Mode
+#define USB_TXCSRH7_DTWE        0x00000002  // Data Toggle Write Enable
+#define USB_TXCSRH7_DT          0x00000001  // Data Toggle
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP7 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP7_MAXLOAD_M   0x000007FF  // Maximum Payload
+#define USB_RXMAXP7_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL7 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL7_CLRDT       0x00000080  // Clear Data Toggle
+#define USB_RXCSRL7_STALLED     0x00000040  // Endpoint Stalled
+#define USB_RXCSRL7_REQPKT      0x00000020  // Request Packet
+#define USB_RXCSRL7_STALL       0x00000020  // Send STALL
+#define USB_RXCSRL7_FLUSH       0x00000010  // Flush FIFO
+#define USB_RXCSRL7_DATAERR     0x00000008  // Data Error
+#define USB_RXCSRL7_NAKTO       0x00000008  // NAK Timeout
+#define USB_RXCSRL7_ERROR       0x00000004  // Error
+#define USB_RXCSRL7_OVER        0x00000004  // Overrun
+#define USB_RXCSRL7_FULL        0x00000002  // FIFO Full
+#define USB_RXCSRL7_RXRDY       0x00000001  // Receive Packet Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH7 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH7_AUTOCL      0x00000080  // Auto Clear
+#define USB_RXCSRH7_ISO         0x00000040  // Isochronous Transfers
+#define USB_RXCSRH7_AUTORQ      0x00000040  // Auto Request
+#define USB_RXCSRH7_DMAEN       0x00000020  // DMA Request Enable
+#define USB_RXCSRH7_PIDERR      0x00000010  // PID Error
+#define USB_RXCSRH7_DISNYET     0x00000010  // Disable NYET
+#define USB_RXCSRH7_DMAMOD      0x00000008  // DMA Request Mode
+#define USB_RXCSRH7_DTWE        0x00000004  // Data Toggle Write Enable
+#define USB_RXCSRH7_DT          0x00000002  // Data Toggle
+#define USB_RXCSRH7_INCOMPRX    0x00000001  // Incomplete RX Transmission
+                                            // Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT7 register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT7_COUNT_M    0x00001FFF  // Receive Packet Count
+#define USB_RXCOUNT7_COUNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE7 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE7_SPEED_M     0x000000C0  // Operating Speed
+#define USB_TXTYPE7_SPEED_DFLT  0x00000000  // Default
+#define USB_TXTYPE7_SPEED_HIGH  0x00000040  // High
+#define USB_TXTYPE7_SPEED_FULL  0x00000080  // Full
+#define USB_TXTYPE7_SPEED_LOW   0x000000C0  // Low
+#define USB_TXTYPE7_PROTO_M     0x00000030  // Protocol
+#define USB_TXTYPE7_PROTO_CTRL  0x00000000  // Control
+#define USB_TXTYPE7_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_TXTYPE7_PROTO_BULK  0x00000020  // Bulk
+#define USB_TXTYPE7_PROTO_INT   0x00000030  // Interrupt
+#define USB_TXTYPE7_TEP_M       0x0000000F  // Target Endpoint Number
+#define USB_TXTYPE7_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL7
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL7_TXPOLL_M                                              \
+                                0x000000FF  // TX Polling
+#define USB_TXINTERVAL7_NAKLMT_M                                              \
+                                0x000000FF  // NAK Limit
+#define USB_TXINTERVAL7_NAKLMT_S                                              \
+                                0
+#define USB_TXINTERVAL7_TXPOLL_S                                              \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE7 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE7_SPEED_M     0x000000C0  // Operating Speed
+#define USB_RXTYPE7_SPEED_DFLT  0x00000000  // Default
+#define USB_RXTYPE7_SPEED_HIGH  0x00000040  // High
+#define USB_RXTYPE7_SPEED_FULL  0x00000080  // Full
+#define USB_RXTYPE7_SPEED_LOW   0x000000C0  // Low
+#define USB_RXTYPE7_PROTO_M     0x00000030  // Protocol
+#define USB_RXTYPE7_PROTO_CTRL  0x00000000  // Control
+#define USB_RXTYPE7_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_RXTYPE7_PROTO_BULK  0x00000020  // Bulk
+#define USB_RXTYPE7_PROTO_INT   0x00000030  // Interrupt
+#define USB_RXTYPE7_TEP_M       0x0000000F  // Target Endpoint Number
+#define USB_RXTYPE7_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL7
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL7_TXPOLL_M                                              \
+                                0x000000FF  // RX Polling
+#define USB_RXINTERVAL7_NAKLMT_M                                              \
+                                0x000000FF  // NAK Limit
+#define USB_RXINTERVAL7_NAKLMT_S                                              \
+                                0
+#define USB_RXINTERVAL7_TXPOLL_S                                              \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DMAINTR register.
+//
+//*****************************************************************************
+#define USB_DMAINTR_CH7         0x00000080  // Channel 7 DMA Interrupt
+#define USB_DMAINTR_CH6         0x00000040  // Channel 6 DMA Interrupt
+#define USB_DMAINTR_CH5         0x00000020  // Channel 5 DMA Interrupt
+#define USB_DMAINTR_CH4         0x00000010  // Channel 4 DMA Interrupt
+#define USB_DMAINTR_CH3         0x00000008  // Channel 3 DMA Interrupt
+#define USB_DMAINTR_CH2         0x00000004  // Channel 2 DMA Interrupt
+#define USB_DMAINTR_CH1         0x00000002  // Channel 1 DMA Interrupt
+#define USB_DMAINTR_CH0         0x00000001  // Channel 0 DMA Interrupt
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DMACTL0 register.
+//
+//*****************************************************************************
+#define USB_DMACTL0_BRSTM_M     0x00000600  // Burst Mode
+#define USB_DMACTL0_BRSTM_ANY   0x00000000  // Bursts of unspecified length
+#define USB_DMACTL0_BRSTM_INC4  0x00000200  // INCR4 or unspecified length
+#define USB_DMACTL0_BRSTM_INC8  0x00000400  // INCR8, INCR4 or unspecified
+                                            // length
+#define USB_DMACTL0_BRSTM_INC16 0x00000600  // INCR16, INCR8, INCR4 or
+                                            // unspecified length
+#define USB_DMACTL0_ERR         0x00000100  // Bus Error Bit
+#define USB_DMACTL0_EP_M        0x000000F0  // Endpoint number
+#define USB_DMACTL0_IE          0x00000008  // DMA Interrupt Enable
+#define USB_DMACTL0_MODE        0x00000004  // DMA Transfer Mode
+#define USB_DMACTL0_DIR         0x00000002  // DMA Direction
+#define USB_DMACTL0_ENABLE      0x00000001  // DMA Transfer Enable
+#define USB_DMACTL0_EP_S        4
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DMAADDR0 register.
+//
+//*****************************************************************************
+#define USB_DMAADDR0_ADDR_M     0xFFFFFFFC  // DMA Address
+#define USB_DMAADDR0_ADDR_S     2
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DMACOUNT0
+// register.
+//
+//*****************************************************************************
+#define USB_DMACOUNT0_COUNT_M   0xFFFFFFFC  // DMA Count
+#define USB_DMACOUNT0_COUNT_S   2
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DMACTL1 register.
+//
+//*****************************************************************************
+#define USB_DMACTL1_BRSTM_M     0x00000600  // Burst Mode
+#define USB_DMACTL1_BRSTM_ANY   0x00000000  // Bursts of unspecified length
+#define USB_DMACTL1_BRSTM_INC4  0x00000200  // INCR4 or unspecified length
+#define USB_DMACTL1_BRSTM_INC8  0x00000400  // INCR8, INCR4 or unspecified
+                                            // length
+#define USB_DMACTL1_BRSTM_INC16 0x00000600  // INCR16, INCR8, INCR4 or
+                                            // unspecified length
+#define USB_DMACTL1_ERR         0x00000100  // Bus Error Bit
+#define USB_DMACTL1_EP_M        0x000000F0  // Endpoint number
+#define USB_DMACTL1_IE          0x00000008  // DMA Interrupt Enable
+#define USB_DMACTL1_MODE        0x00000004  // DMA Transfer Mode
+#define USB_DMACTL1_DIR         0x00000002  // DMA Direction
+#define USB_DMACTL1_ENABLE      0x00000001  // DMA Transfer Enable
+#define USB_DMACTL1_EP_S        4
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DMAADDR1 register.
+//
+//*****************************************************************************
+#define USB_DMAADDR1_ADDR_M     0xFFFFFFFC  // DMA Address
+#define USB_DMAADDR1_ADDR_S     2
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DMACOUNT1
+// register.
+//
+//*****************************************************************************
+#define USB_DMACOUNT1_COUNT_M   0xFFFFFFFC  // DMA Count
+#define USB_DMACOUNT1_COUNT_S   2
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DMACTL2 register.
+//
+//*****************************************************************************
+#define USB_DMACTL2_BRSTM_M     0x00000600  // Burst Mode
+#define USB_DMACTL2_BRSTM_ANY   0x00000000  // Bursts of unspecified length
+#define USB_DMACTL2_BRSTM_INC4  0x00000200  // INCR4 or unspecified length
+#define USB_DMACTL2_BRSTM_INC8  0x00000400  // INCR8, INCR4 or unspecified
+                                            // length
+#define USB_DMACTL2_BRSTM_INC16 0x00000600  // INCR16, INCR8, INCR4 or
+                                            // unspecified length
+#define USB_DMACTL2_ERR         0x00000100  // Bus Error Bit
+#define USB_DMACTL2_EP_M        0x000000F0  // Endpoint number
+#define USB_DMACTL2_IE          0x00000008  // DMA Interrupt Enable
+#define USB_DMACTL2_MODE        0x00000004  // DMA Transfer Mode
+#define USB_DMACTL2_DIR         0x00000002  // DMA Direction
+#define USB_DMACTL2_ENABLE      0x00000001  // DMA Transfer Enable
+#define USB_DMACTL2_EP_S        4
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DMAADDR2 register.
+//
+//*****************************************************************************
+#define USB_DMAADDR2_ADDR_M     0xFFFFFFFC  // DMA Address
+#define USB_DMAADDR2_ADDR_S     2
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DMACOUNT2
+// register.
+//
+//*****************************************************************************
+#define USB_DMACOUNT2_COUNT_M   0xFFFFFFFC  // DMA Count
+#define USB_DMACOUNT2_COUNT_S   2
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DMACTL3 register.
+//
+//*****************************************************************************
+#define USB_DMACTL3_BRSTM_M     0x00000600  // Burst Mode
+#define USB_DMACTL3_BRSTM_ANY   0x00000000  // Bursts of unspecified length
+#define USB_DMACTL3_BRSTM_INC4  0x00000200  // INCR4 or unspecified length
+#define USB_DMACTL3_BRSTM_INC8  0x00000400  // INCR8, INCR4 or unspecified
+                                            // length
+#define USB_DMACTL3_BRSTM_INC16 0x00000600  // INCR16, INCR8, INCR4 or
+                                            // unspecified length
+#define USB_DMACTL3_ERR         0x00000100  // Bus Error Bit
+#define USB_DMACTL3_EP_M        0x000000F0  // Endpoint number
+#define USB_DMACTL3_IE          0x00000008  // DMA Interrupt Enable
+#define USB_DMACTL3_MODE        0x00000004  // DMA Transfer Mode
+#define USB_DMACTL3_DIR         0x00000002  // DMA Direction
+#define USB_DMACTL3_ENABLE      0x00000001  // DMA Transfer Enable
+#define USB_DMACTL3_EP_S        4
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DMAADDR3 register.
+//
+//*****************************************************************************
+#define USB_DMAADDR3_ADDR_M     0xFFFFFFFC  // DMA Address
+#define USB_DMAADDR3_ADDR_S     2
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DMACOUNT3
+// register.
+//
+//*****************************************************************************
+#define USB_DMACOUNT3_COUNT_M   0xFFFFFFFC  // DMA Count
+#define USB_DMACOUNT3_COUNT_S   2
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DMACTL4 register.
+//
+//*****************************************************************************
+#define USB_DMACTL4_BRSTM_M     0x00000600  // Burst Mode
+#define USB_DMACTL4_BRSTM_ANY   0x00000000  // Bursts of unspecified length
+#define USB_DMACTL4_BRSTM_INC4  0x00000200  // INCR4 or unspecified length
+#define USB_DMACTL4_BRSTM_INC8  0x00000400  // INCR8, INCR4 or unspecified
+                                            // length
+#define USB_DMACTL4_BRSTM_INC16 0x00000600  // INCR16, INCR8, INCR4 or
+                                            // unspecified length
+#define USB_DMACTL4_ERR         0x00000100  // Bus Error Bit
+#define USB_DMACTL4_EP_M        0x000000F0  // Endpoint number
+#define USB_DMACTL4_IE          0x00000008  // DMA Interrupt Enable
+#define USB_DMACTL4_MODE        0x00000004  // DMA Transfer Mode
+#define USB_DMACTL4_DIR         0x00000002  // DMA Direction
+#define USB_DMACTL4_ENABLE      0x00000001  // DMA Transfer Enable
+#define USB_DMACTL4_EP_S        4
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DMAADDR4 register.
+//
+//*****************************************************************************
+#define USB_DMAADDR4_ADDR_M     0xFFFFFFFC  // DMA Address
+#define USB_DMAADDR4_ADDR_S     2
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DMACOUNT4
+// register.
+//
+//*****************************************************************************
+#define USB_DMACOUNT4_COUNT_M   0xFFFFFFFC  // DMA Count
+#define USB_DMACOUNT4_COUNT_S   2
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DMACTL5 register.
+//
+//*****************************************************************************
+#define USB_DMACTL5_BRSTM_M     0x00000600  // Burst Mode
+#define USB_DMACTL5_BRSTM_ANY   0x00000000  // Bursts of unspecified length
+#define USB_DMACTL5_BRSTM_INC4  0x00000200  // INCR4 or unspecified length
+#define USB_DMACTL5_BRSTM_INC8  0x00000400  // INCR8, INCR4 or unspecified
+                                            // length
+#define USB_DMACTL5_BRSTM_INC16 0x00000600  // INCR16, INCR8, INCR4 or
+                                            // unspecified length
+#define USB_DMACTL5_ERR         0x00000100  // Bus Error Bit
+#define USB_DMACTL5_EP_M        0x000000F0  // Endpoint number
+#define USB_DMACTL5_IE          0x00000008  // DMA Interrupt Enable
+#define USB_DMACTL5_MODE        0x00000004  // DMA Transfer Mode
+#define USB_DMACTL5_DIR         0x00000002  // DMA Direction
+#define USB_DMACTL5_ENABLE      0x00000001  // DMA Transfer Enable
+#define USB_DMACTL5_EP_S        4
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DMAADDR5 register.
+//
+//*****************************************************************************
+#define USB_DMAADDR5_ADDR_M     0xFFFFFFFC  // DMA Address
+#define USB_DMAADDR5_ADDR_S     2
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DMACOUNT5
+// register.
+//
+//*****************************************************************************
+#define USB_DMACOUNT5_COUNT_M   0xFFFFFFFC  // DMA Count
+#define USB_DMACOUNT5_COUNT_S   2
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DMACTL6 register.
+//
+//*****************************************************************************
+#define USB_DMACTL6_BRSTM_M     0x00000600  // Burst Mode
+#define USB_DMACTL6_BRSTM_ANY   0x00000000  // Bursts of unspecified length
+#define USB_DMACTL6_BRSTM_INC4  0x00000200  // INCR4 or unspecified length
+#define USB_DMACTL6_BRSTM_INC8  0x00000400  // INCR8, INCR4 or unspecified
+                                            // length
+#define USB_DMACTL6_BRSTM_INC16 0x00000600  // INCR16, INCR8, INCR4 or
+                                            // unspecified length
+#define USB_DMACTL6_ERR         0x00000100  // Bus Error Bit
+#define USB_DMACTL6_EP_M        0x000000F0  // Endpoint number
+#define USB_DMACTL6_IE          0x00000008  // DMA Interrupt Enable
+#define USB_DMACTL6_MODE        0x00000004  // DMA Transfer Mode
+#define USB_DMACTL6_DIR         0x00000002  // DMA Direction
+#define USB_DMACTL6_ENABLE      0x00000001  // DMA Transfer Enable
+#define USB_DMACTL6_EP_S        4
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DMAADDR6 register.
+//
+//*****************************************************************************
+#define USB_DMAADDR6_ADDR_M     0xFFFFFFFC  // DMA Address
+#define USB_DMAADDR6_ADDR_S     2
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DMACOUNT6
+// register.
+//
+//*****************************************************************************
+#define USB_DMACOUNT6_COUNT_M   0xFFFFFFFC  // DMA Count
+#define USB_DMACOUNT6_COUNT_S   2
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DMACTL7 register.
+//
+//*****************************************************************************
+#define USB_DMACTL7_BRSTM_M     0x00000600  // Burst Mode
+#define USB_DMACTL7_BRSTM_ANY   0x00000000  // Bursts of unspecified length
+#define USB_DMACTL7_BRSTM_INC4  0x00000200  // INCR4 or unspecified length
+#define USB_DMACTL7_BRSTM_INC8  0x00000400  // INCR8, INCR4 or unspecified
+                                            // length
+#define USB_DMACTL7_BRSTM_INC16 0x00000600  // INCR16, INCR8, INCR4 or
+                                            // unspecified length
+#define USB_DMACTL7_ERR         0x00000100  // Bus Error Bit
+#define USB_DMACTL7_EP_M        0x000000F0  // Endpoint number
+#define USB_DMACTL7_IE          0x00000008  // DMA Interrupt Enable
+#define USB_DMACTL7_MODE        0x00000004  // DMA Transfer Mode
+#define USB_DMACTL7_DIR         0x00000002  // DMA Direction
+#define USB_DMACTL7_ENABLE      0x00000001  // DMA Transfer Enable
+#define USB_DMACTL7_EP_S        4
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DMAADDR7 register.
+//
+//*****************************************************************************
+#define USB_DMAADDR7_ADDR_M     0xFFFFFFFC  // DMA Address
+#define USB_DMAADDR7_ADDR_S     2
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DMACOUNT7
+// register.
+//
+//*****************************************************************************
+#define USB_DMACOUNT7_COUNT_M   0xFFFFFFFC  // DMA Count
+#define USB_DMACOUNT7_COUNT_S   2
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT1
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT1_M       0x0000FFFF  // Block Transfer Packet Count
+#define USB_RQPKTCOUNT1_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT2
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT2_M       0x0000FFFF  // Block Transfer Packet Count
+#define USB_RQPKTCOUNT2_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT3
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT3_M       0x0000FFFF  // Block Transfer Packet Count
+#define USB_RQPKTCOUNT3_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT4
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT4_COUNT_M 0x0000FFFF  // Block Transfer Packet Count
+#define USB_RQPKTCOUNT4_COUNT_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT5
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT5_COUNT_M 0x0000FFFF  // Block Transfer Packet Count
+#define USB_RQPKTCOUNT5_COUNT_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT6
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT6_COUNT_M 0x0000FFFF  // Block Transfer Packet Count
+#define USB_RQPKTCOUNT6_COUNT_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT7
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT7_COUNT_M 0x0000FFFF  // Block Transfer Packet Count
+#define USB_RQPKTCOUNT7_COUNT_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXDPKTBUFDIS
+// register.
+//
+//*****************************************************************************
+#define USB_RXDPKTBUFDIS_EP7    0x00000080  // EP7 RX Double-Packet Buffer
+                                            // Disable
+#define USB_RXDPKTBUFDIS_EP6    0x00000040  // EP6 RX Double-Packet Buffer
+                                            // Disable
+#define USB_RXDPKTBUFDIS_EP5    0x00000020  // EP5 RX Double-Packet Buffer
+                                            // Disable
+#define USB_RXDPKTBUFDIS_EP4    0x00000010  // EP4 RX Double-Packet Buffer
+                                            // Disable
+#define USB_RXDPKTBUFDIS_EP3    0x00000008  // EP3 RX Double-Packet Buffer
+                                            // Disable
+#define USB_RXDPKTBUFDIS_EP2    0x00000004  // EP2 RX Double-Packet Buffer
+                                            // Disable
+#define USB_RXDPKTBUFDIS_EP1    0x00000002  // EP1 RX Double-Packet Buffer
+                                            // Disable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXDPKTBUFDIS
+// register.
+//
+//*****************************************************************************
+#define USB_TXDPKTBUFDIS_EP7    0x00000080  // EP7 TX Double-Packet Buffer
+                                            // Disable
+#define USB_TXDPKTBUFDIS_EP6    0x00000040  // EP6 TX Double-Packet Buffer
+                                            // Disable
+#define USB_TXDPKTBUFDIS_EP5    0x00000020  // EP5 TX Double-Packet Buffer
+                                            // Disable
+#define USB_TXDPKTBUFDIS_EP4    0x00000010  // EP4 TX Double-Packet Buffer
+                                            // Disable
+#define USB_TXDPKTBUFDIS_EP3    0x00000008  // EP3 TX Double-Packet Buffer
+                                            // Disable
+#define USB_TXDPKTBUFDIS_EP2    0x00000004  // EP2 TX Double-Packet Buffer
+                                            // Disable
+#define USB_TXDPKTBUFDIS_EP1    0x00000002  // EP1 TX Double-Packet Buffer
+                                            // Disable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_CTO register.
+//
+//*****************************************************************************
+#define USB_CTO_CCTV_M          0x0000FFFF  // Configurable Chirp Timeout Value
+#define USB_CTO_CCTV_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_HHSRTN register.
+//
+//*****************************************************************************
+#define USB_HHSRTN_HHSRTN_M     0x0000FFFF  // HIgh Speed to UTM Operating
+                                            // Delay
+#define USB_HHSRTN_HHSRTN_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_HSBT register.
+//
+//*****************************************************************************
+#define USB_HSBT_HSBT_M         0x0000000F  // High Speed Timeout Adder
+#define USB_HSBT_HSBT_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_LPMATTR register.
+//
+//*****************************************************************************
+#define USB_LPMATTR_ENDPT_M     0x0000F000  // Endpoint
+#define USB_LPMATTR_RMTWAK      0x00000100  // Remote Wake
+#define USB_LPMATTR_HIRD_M      0x000000F0  // Host Initiated Resume Duration
+#define USB_LPMATTR_LS_M        0x0000000F  // Link State
+#define USB_LPMATTR_LS_L1       0x00000001  // Sleep State (L1)
+#define USB_LPMATTR_ENDPT_S     12
+#define USB_LPMATTR_HIRD_S      4
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_LPMCNTRL register.
+//
+//*****************************************************************************
+#define USB_LPMCNTRL_NAK        0x00000010  // LPM NAK
+#define USB_LPMCNTRL_EN_M       0x0000000C  // LPM Enable
+#define USB_LPMCNTRL_EN_NONE    0x00000000  // LPM and Extended transactions
+                                            // are not supported. In this case,
+                                            // the USB does not respond to LPM
+                                            // transactions and LPM
+                                            // transactions cause a timeout
+#define USB_LPMCNTRL_EN_EXT     0x00000004  // LPM is not supported but
+                                            // extended transactions are
+                                            // supported. In this case, the USB
+                                            // does respond to an LPM
+                                            // transaction with a STALL
+#define USB_LPMCNTRL_EN_LPMEXT  0x0000000C  // The USB supports LPM extended
+                                            // transactions. In this case, the
+                                            // USB responds with a NYET or an
+                                            // ACK as determined by the value
+                                            // of TXLPM and other conditions
+#define USB_LPMCNTRL_RES        0x00000002  // LPM Resume
+#define USB_LPMCNTRL_TXLPM      0x00000001  // Transmit LPM Transaction Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_LPMIM register.
+//
+//*****************************************************************************
+#define USB_LPMIM_ERR           0x00000020  // LPM Error Interrupt Mask
+#define USB_LPMIM_RES           0x00000010  // LPM Resume Interrupt Mask
+#define USB_LPMIM_NC            0x00000008  // LPM NC Interrupt Mask
+#define USB_LPMIM_ACK           0x00000004  // LPM ACK Interrupt Mask
+#define USB_LPMIM_NY            0x00000002  // LPM NY Interrupt Mask
+#define USB_LPMIM_STALL         0x00000001  // LPM STALL Interrupt Mask
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_LPMRIS register.
+//
+//*****************************************************************************
+#define USB_LPMRIS_ERR          0x00000020  // LPM Interrupt Status
+#define USB_LPMRIS_RES          0x00000010  // LPM Resume Interrupt Status
+#define USB_LPMRIS_NC           0x00000008  // LPM NC Interrupt Status
+#define USB_LPMRIS_ACK          0x00000004  // LPM ACK Interrupt Status
+#define USB_LPMRIS_NY           0x00000002  // LPM NY Interrupt Status
+#define USB_LPMRIS_LPMST        0x00000001  // LPM STALL Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_LPMFADDR register.
+//
+//*****************************************************************************
+#define USB_LPMFADDR_ADDR_M     0x0000007F  // LPM Function Address
+#define USB_LPMFADDR_ADDR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_EPC register.
+//
+//*****************************************************************************
+#define USB_EPC_PFLTACT_M       0x00000300  // Power Fault Action
+#define USB_EPC_PFLTACT_UNCHG   0x00000000  // Unchanged
+#define USB_EPC_PFLTACT_TRIS    0x00000100  // Tristate
+#define USB_EPC_PFLTACT_LOW     0x00000200  // Low
+#define USB_EPC_PFLTACT_HIGH    0x00000300  // High
+#define USB_EPC_PFLTAEN         0x00000040  // Power Fault Action Enable
+#define USB_EPC_PFLTSEN_HIGH    0x00000020  // Power Fault Sense
+#define USB_EPC_PFLTEN          0x00000010  // Power Fault Input Enable
+#define USB_EPC_EPENDE          0x00000004  // EPEN Drive Enable
+#define USB_EPC_EPEN_M          0x00000003  // External Power Supply Enable
+                                            // Configuration
+#define USB_EPC_EPEN_LOW        0x00000000  // Power Enable Active Low
+#define USB_EPC_EPEN_HIGH       0x00000001  // Power Enable Active High
+#define USB_EPC_EPEN_VBLOW      0x00000002  // Power Enable High if VBUS Low
+                                            // (OTG only)
+#define USB_EPC_EPEN_VBHIGH     0x00000003  // Power Enable High if VBUS High
+                                            // (OTG only)
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_EPCRIS register.
+//
+//*****************************************************************************
+#define USB_EPCRIS_PF           0x00000001  // USB Power Fault Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_EPCIM register.
+//
+//*****************************************************************************
+#define USB_EPCIM_PF            0x00000001  // USB Power Fault Interrupt Mask
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_EPCISC register.
+//
+//*****************************************************************************
+#define USB_EPCISC_PF           0x00000001  // USB Power Fault Interrupt Status
+                                            // and Clear
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DRRIS register.
+//
+//*****************************************************************************
+#define USB_DRRIS_RESUME        0x00000001  // RESUME Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DRIM register.
+//
+//*****************************************************************************
+#define USB_DRIM_RESUME         0x00000001  // RESUME Interrupt Mask
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DRISC register.
+//
+//*****************************************************************************
+#define USB_DRISC_RESUME        0x00000001  // RESUME Interrupt Status and
+                                            // Clear
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_GPCS register.
+//
+//*****************************************************************************
+#define USB_GPCS_DEVMOD_M       0x00000007  // Device Mode
+#define USB_GPCS_DEVMOD_OTG     0x00000000  // Use USB0VBUS and USB0ID pin
+#define USB_GPCS_DEVMOD_HOST    0x00000002  // Force USB0VBUS and USB0ID low
+#define USB_GPCS_DEVMOD_DEV     0x00000003  // Force USB0VBUS and USB0ID high
+#define USB_GPCS_DEVMOD_HOSTVBUS                                              \
+                                0x00000004  // Use USB0VBUS and force USB0ID
+                                            // low
+#define USB_GPCS_DEVMOD_DEVVBUS 0x00000005  // Use USB0VBUS and force USB0ID
+                                            // high
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_VDC register.
+//
+//*****************************************************************************
+#define USB_VDC_VBDEN           0x00000001  // VBUS Droop Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_VDCRIS register.
+//
+//*****************************************************************************
+#define USB_VDCRIS_VD           0x00000001  // VBUS Droop Raw Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_VDCIM register.
+//
+//*****************************************************************************
+#define USB_VDCIM_VD            0x00000001  // VBUS Droop Interrupt Mask
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_VDCISC register.
+//
+//*****************************************************************************
+#define USB_VDCISC_VD           0x00000001  // VBUS Droop Interrupt Status and
+                                            // Clear
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_PP register.
+//
+//*****************************************************************************
+#define USB_PP_ECNT_M           0x0000FF00  // Endpoint Count
+#define USB_PP_USB_M            0x000000C0  // USB Capability
+#define USB_PP_USB_DEVICE       0x00000040  // DEVICE
+#define USB_PP_USB_HOSTDEVICE   0x00000080  // HOST
+#define USB_PP_USB_OTG          0x000000C0  // OTG
+#define USB_PP_ULPI             0x00000020  // ULPI Present
+#define USB_PP_PHY              0x00000010  // PHY Present
+#define USB_PP_TYPE_M           0x0000000F  // Controller Type
+#define USB_PP_TYPE_0           0x00000000  // The first-generation USB
+                                            // controller
+#define USB_PP_TYPE_1           0x00000001  // Second-generation USB
+                                            // controller.The controller
+                                            // implemented in post Icestorm
+                                            // devices that use the 3.0 version
+                                            // of the Mentor controller
+#define USB_PP_ECNT_S           8
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_PC register.
+//
+//*****************************************************************************
+#define USB_PC_ULPIEN           0x00010000  // ULPI Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_CC register.
+//
+//*****************************************************************************
+#define USB_CC_CLKEN            0x00000200  // USB Clock Enable
+#define USB_CC_CSD              0x00000100  // Clock Source/Direction
+#define USB_CC_CLKDIV_M         0x0000000F  // PLL Clock Divisor
+#define USB_CC_CLKDIV_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EEPROM_EESIZE register.
+//
+//*****************************************************************************
+#define EEPROM_EESIZE_BLKCNT_M  0x07FF0000  // Number of 16-Word Blocks
+#define EEPROM_EESIZE_WORDCNT_M 0x0000FFFF  // Number of 32-Bit Words
+#define EEPROM_EESIZE_BLKCNT_S  16
+#define EEPROM_EESIZE_WORDCNT_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EEPROM_EEBLOCK register.
+//
+//*****************************************************************************
+#define EEPROM_EEBLOCK_BLOCK_M  0x0000FFFF  // Current Block
+#define EEPROM_EEBLOCK_BLOCK_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EEPROM_EEOFFSET
+// register.
+//
+//*****************************************************************************
+#define EEPROM_EEOFFSET_OFFSET_M                                              \
+                                0x0000000F  // Current Address Offset
+#define EEPROM_EEOFFSET_OFFSET_S                                              \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EEPROM_EERDWR register.
+//
+//*****************************************************************************
+#define EEPROM_EERDWR_VALUE_M   0xFFFFFFFF  // EEPROM Read or Write Data
+#define EEPROM_EERDWR_VALUE_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EEPROM_EERDWRINC
+// register.
+//
+//*****************************************************************************
+#define EEPROM_EERDWRINC_VALUE_M                                              \
+                                0xFFFFFFFF  // EEPROM Read or Write Data with
+                                            // Increment
+#define EEPROM_EERDWRINC_VALUE_S                                              \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EEPROM_EEDONE register.
+//
+//*****************************************************************************
+#define EEPROM_EEDONE_WRBUSY    0x00000020  // Write Busy
+#define EEPROM_EEDONE_NOPERM    0x00000010  // Write Without Permission
+#define EEPROM_EEDONE_WKCOPY    0x00000008  // Working on a Copy
+#define EEPROM_EEDONE_WKERASE   0x00000004  // Working on an Erase
+#define EEPROM_EEDONE_WORKING   0x00000001  // EEPROM Working
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EEPROM_EESUPP register.
+//
+//*****************************************************************************
+#define EEPROM_EESUPP_PRETRY    0x00000008  // Programming Must Be Retried
+#define EEPROM_EESUPP_ERETRY    0x00000004  // Erase Must Be Retried
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EEPROM_EEUNLOCK
+// register.
+//
+//*****************************************************************************
+#define EEPROM_EEUNLOCK_UNLOCK_M                                              \
+                                0xFFFFFFFF  // EEPROM Unlock
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EEPROM_EEPROT register.
+//
+//*****************************************************************************
+#define EEPROM_EEPROT_ACC       0x00000008  // Access Control
+#define EEPROM_EEPROT_PROT_M    0x00000007  // Protection Control
+#define EEPROM_EEPROT_PROT_RWNPW                                              \
+                                0x00000000  // This setting is the default. If
+                                            // there is no password, the block
+                                            // is not protected and is readable
+                                            // and writable
+#define EEPROM_EEPROT_PROT_RWPW 0x00000001  // If there is a password, the
+                                            // block is readable or writable
+                                            // only when unlocked
+#define EEPROM_EEPROT_PROT_RONPW                                              \
+                                0x00000002  // If there is no password, the
+                                            // block is readable, not writable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EEPROM_EEPASS0 register.
+//
+//*****************************************************************************
+#define EEPROM_EEPASS0_PASS_M   0xFFFFFFFF  // Password
+#define EEPROM_EEPASS0_PASS_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EEPROM_EEPASS1 register.
+//
+//*****************************************************************************
+#define EEPROM_EEPASS1_PASS_M   0xFFFFFFFF  // Password
+#define EEPROM_EEPASS1_PASS_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EEPROM_EEPASS2 register.
+//
+//*****************************************************************************
+#define EEPROM_EEPASS2_PASS_M   0xFFFFFFFF  // Password
+#define EEPROM_EEPASS2_PASS_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EEPROM_EEINT register.
+//
+//*****************************************************************************
+#define EEPROM_EEINT_INT        0x00000001  // Interrupt Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EEPROM_EEHIDE0 register.
+//
+//*****************************************************************************
+#define EEPROM_EEHIDE0_HN_M     0xFFFFFFFE  // Hide Block
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EEPROM_EEHIDE1 register.
+//
+//*****************************************************************************
+#define EEPROM_EEHIDE1_HN_M     0xFFFFFFFF  // Hide Block
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EEPROM_EEHIDE2 register.
+//
+//*****************************************************************************
+#define EEPROM_EEHIDE2_HN_M     0xFFFFFFFF  // Hide Block
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EEPROM_EEDBGME register.
+//
+//*****************************************************************************
+#define EEPROM_EEDBGME_KEY_M    0xFFFF0000  // Erase Key
+#define EEPROM_EEDBGME_ME       0x00000001  // Mass Erase
+#define EEPROM_EEDBGME_KEY_S    16
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EEPROM_PP register.
+//
+//*****************************************************************************
+#define EEPROM_PP_SIZE_M        0x0000FFFF  // EEPROM Size
+#define EEPROM_PP_SIZE_64       0x00000000  // 64 bytes of EEPROM
+#define EEPROM_PP_SIZE_128      0x00000001  // 128 bytes of EEPROM
+#define EEPROM_PP_SIZE_256      0x00000003  // 256 bytes of EEPROM
+#define EEPROM_PP_SIZE_512      0x00000007  // 512 bytes of EEPROM
+#define EEPROM_PP_SIZE_1K       0x0000000F  // 1 KB of EEPROM
+#define EEPROM_PP_SIZE_2K       0x0000001F  // 2 KB of EEPROM
+#define EEPROM_PP_SIZE_3K       0x0000003F  // 3 KB of EEPROM
+#define EEPROM_PP_SIZE_4K       0x0000007F  // 4 KB of EEPROM
+#define EEPROM_PP_SIZE_5K       0x000000FF  // 5 KB of EEPROM
+#define EEPROM_PP_SIZE_6K       0x000001FF  // 6 KB of EEPROM
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_CFG register.
+//
+//*****************************************************************************
+#define EPI_CFG_INTDIV          0x00000100  // Integer Clock Divider Enable
+#define EPI_CFG_BLKEN           0x00000010  // Block Enable
+#define EPI_CFG_MODE_M          0x0000000F  // Mode Select
+#define EPI_CFG_MODE_NONE       0x00000000  // General Purpose
+#define EPI_CFG_MODE_SDRAM      0x00000001  // SDRAM
+#define EPI_CFG_MODE_HB8        0x00000002  // 8-Bit Host-Bus (HB8)
+#define EPI_CFG_MODE_HB16       0x00000003  // 16-Bit Host-Bus (HB16)
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_BAUD register.
+//
+//*****************************************************************************
+#define EPI_BAUD_COUNT1_M       0xFFFF0000  // Baud Rate Counter 1
+#define EPI_BAUD_COUNT0_M       0x0000FFFF  // Baud Rate Counter 0
+#define EPI_BAUD_COUNT1_S       16
+#define EPI_BAUD_COUNT0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_BAUD2 register.
+//
+//*****************************************************************************
+#define EPI_BAUD2_COUNT1_M      0xFFFF0000  // CS3n Baud Rate Counter 1
+#define EPI_BAUD2_COUNT0_M      0x0000FFFF  // CS2n Baud Rate Counter 0
+#define EPI_BAUD2_COUNT1_S      16
+#define EPI_BAUD2_COUNT0_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_HB16CFG register.
+//
+//*****************************************************************************
+#define EPI_HB16CFG_CLKGATE     0x80000000  // Clock Gated
+#define EPI_HB16CFG_CLKGATEI    0x40000000  // Clock Gated Idle
+#define EPI_HB16CFG_CLKINV      0x20000000  // Invert Output Clock Enable
+#define EPI_HB16CFG_RDYEN       0x10000000  // Input Ready Enable
+#define EPI_HB16CFG_IRDYINV     0x08000000  // Input Ready Invert
+#define EPI_HB16CFG_XFFEN       0x00800000  // External FIFO FULL Enable
+#define EPI_HB16CFG_XFEEN       0x00400000  // External FIFO EMPTY Enable
+#define EPI_HB16CFG_WRHIGH      0x00200000  // WRITE Strobe Polarity
+#define EPI_HB16CFG_RDHIGH      0x00100000  // READ Strobe Polarity
+#define EPI_HB16CFG_ALEHIGH     0x00080000  // ALE Strobe Polarity
+#define EPI_HB16CFG_WRCRE       0x00040000  // PSRAM Configuration Register
+                                            // Write
+#define EPI_HB16CFG_RDCRE       0x00020000  // PSRAM Configuration Register
+                                            // Read
+#define EPI_HB16CFG_BURST       0x00010000  // Burst Mode
+#define EPI_HB16CFG_MAXWAIT_M   0x0000FF00  // Maximum Wait
+#define EPI_HB16CFG_WRWS_M      0x000000C0  // Write Wait States
+#define EPI_HB16CFG_WRWS_2      0x00000000  // Active WRn is 2 EPI clocks
+#define EPI_HB16CFG_WRWS_4      0x00000040  // Active WRn is 4 EPI clocks
+#define EPI_HB16CFG_WRWS_6      0x00000080  // Active WRn is 6 EPI clocks
+#define EPI_HB16CFG_WRWS_8      0x000000C0  // Active WRn is 8 EPI clocks
+#define EPI_HB16CFG_RDWS_M      0x00000030  // Read Wait States
+#define EPI_HB16CFG_RDWS_2      0x00000000  // Active RDn is 2 EPI clocks
+#define EPI_HB16CFG_RDWS_4      0x00000010  // Active RDn is 4 EPI clocks
+#define EPI_HB16CFG_RDWS_6      0x00000020  // Active RDn is 6 EPI clocks
+#define EPI_HB16CFG_RDWS_8      0x00000030  // Active RDn is 8 EPI clocks
+#define EPI_HB16CFG_BSEL        0x00000004  // Byte Select Configuration
+#define EPI_HB16CFG_MODE_M      0x00000003  // Host Bus Sub-Mode
+#define EPI_HB16CFG_MODE_ADMUX  0x00000000  // ADMUX - AD[15:0]
+#define EPI_HB16CFG_MODE_ADNMUX 0x00000001  // ADNONMUX - D[15:0]
+#define EPI_HB16CFG_MODE_SRAM   0x00000002  // Continuous Read - D[15:0]
+#define EPI_HB16CFG_MODE_XFIFO  0x00000003  // XFIFO - D[15:0]
+#define EPI_HB16CFG_MAXWAIT_S   8
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_GPCFG register.
+//
+//*****************************************************************************
+#define EPI_GPCFG_CLKPIN        0x80000000  // Clock Pin
+#define EPI_GPCFG_CLKGATE       0x40000000  // Clock Gated
+#define EPI_GPCFG_FRM50         0x04000000  // 50/50 Frame
+#define EPI_GPCFG_FRMCNT_M      0x03C00000  // Frame Count
+#define EPI_GPCFG_WR2CYC        0x00080000  // 2-Cycle Writes
+#define EPI_GPCFG_ASIZE_M       0x00000030  // Address Bus Size
+#define EPI_GPCFG_ASIZE_NONE    0x00000000  // No address
+#define EPI_GPCFG_ASIZE_4BIT    0x00000010  // Up to 4 bits wide
+#define EPI_GPCFG_ASIZE_12BIT   0x00000020  // Up to 12 bits wide. This size
+                                            // cannot be used with 24-bit data
+#define EPI_GPCFG_ASIZE_20BIT   0x00000030  // Up to 20 bits wide. This size
+                                            // cannot be used with data sizes
+                                            // other than 8
+#define EPI_GPCFG_DSIZE_M       0x00000003  // Size of Data Bus
+#define EPI_GPCFG_DSIZE_4BIT    0x00000000  // 8 Bits Wide (EPI0S0 to EPI0S7)
+#define EPI_GPCFG_DSIZE_16BIT   0x00000001  // 16 Bits Wide (EPI0S0 to EPI0S15)
+#define EPI_GPCFG_DSIZE_24BIT   0x00000002  // 24 Bits Wide (EPI0S0 to EPI0S23)
+#define EPI_GPCFG_DSIZE_32BIT   0x00000003  // 32 Bits Wide (EPI0S0 to EPI0S31)
+#define EPI_GPCFG_FRMCNT_S      22
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_SDRAMCFG register.
+//
+//*****************************************************************************
+#define EPI_SDRAMCFG_FREQ_M     0xC0000000  // EPI Frequency Range
+#define EPI_SDRAMCFG_FREQ_NONE  0x00000000  // 0 - 15 MHz
+#define EPI_SDRAMCFG_FREQ_15MHZ 0x40000000  // 15 - 30 MHz
+#define EPI_SDRAMCFG_FREQ_30MHZ 0x80000000  // 30 - 50 MHz
+#define EPI_SDRAMCFG_RFSH_M     0x07FF0000  // Refresh Counter
+#define EPI_SDRAMCFG_SLEEP      0x00000200  // Sleep Mode
+#define EPI_SDRAMCFG_SIZE_M     0x00000003  // Size of SDRAM
+#define EPI_SDRAMCFG_SIZE_8MB   0x00000000  // 64 megabits (8MB)
+#define EPI_SDRAMCFG_SIZE_16MB  0x00000001  // 128 megabits (16MB)
+#define EPI_SDRAMCFG_SIZE_32MB  0x00000002  // 256 megabits (32MB)
+#define EPI_SDRAMCFG_SIZE_64MB  0x00000003  // 512 megabits (64MB)
+#define EPI_SDRAMCFG_RFSH_S     16
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_HB8CFG register.
+//
+//*****************************************************************************
+#define EPI_HB8CFG_CLKGATE      0x80000000  // Clock Gated
+#define EPI_HB8CFG_CLKGATEI     0x40000000  // Clock Gated when Idle
+#define EPI_HB8CFG_CLKINV       0x20000000  // Invert Output Clock Enable
+#define EPI_HB8CFG_RDYEN        0x10000000  // Input Ready Enable
+#define EPI_HB8CFG_IRDYINV      0x08000000  // Input Ready Invert
+#define EPI_HB8CFG_XFFEN        0x00800000  // External FIFO FULL Enable
+#define EPI_HB8CFG_XFEEN        0x00400000  // External FIFO EMPTY Enable
+#define EPI_HB8CFG_WRHIGH       0x00200000  // WRITE Strobe Polarity
+#define EPI_HB8CFG_RDHIGH       0x00100000  // READ Strobe Polarity
+#define EPI_HB8CFG_ALEHIGH      0x00080000  // ALE Strobe Polarity
+#define EPI_HB8CFG_MAXWAIT_M    0x0000FF00  // Maximum Wait
+#define EPI_HB8CFG_WRWS_M       0x000000C0  // Write Wait States
+#define EPI_HB8CFG_WRWS_2       0x00000000  // Active WRn is 2 EPI clocks
+#define EPI_HB8CFG_WRWS_4       0x00000040  // Active WRn is 4 EPI clocks
+#define EPI_HB8CFG_WRWS_6       0x00000080  // Active WRn is 6 EPI clocks
+#define EPI_HB8CFG_WRWS_8       0x000000C0  // Active WRn is 8 EPI clocks
+#define EPI_HB8CFG_RDWS_M       0x00000030  // Read Wait States
+#define EPI_HB8CFG_RDWS_2       0x00000000  // Active RDn is 2 EPI clocks
+#define EPI_HB8CFG_RDWS_4       0x00000010  // Active RDn is 4 EPI clocks
+#define EPI_HB8CFG_RDWS_6       0x00000020  // Active RDn is 6 EPI clocks
+#define EPI_HB8CFG_RDWS_8       0x00000030  // Active RDn is 8 EPI clocks
+#define EPI_HB8CFG_MODE_M       0x00000003  // Host Bus Sub-Mode
+#define EPI_HB8CFG_MODE_MUX     0x00000000  // ADMUX - AD[7:0]
+#define EPI_HB8CFG_MODE_NMUX    0x00000001  // ADNONMUX - D[7:0]
+#define EPI_HB8CFG_MODE_SRAM    0x00000002  // Continuous Read - D[7:0]
+#define EPI_HB8CFG_MODE_FIFO    0x00000003  // XFIFO - D[7:0]
+#define EPI_HB8CFG_MAXWAIT_S    8
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_HB8CFG2 register.
+//
+//*****************************************************************************
+#define EPI_HB8CFG2_CSCFGEXT    0x08000000  // Chip Select Extended
+                                            // Configuration
+#define EPI_HB8CFG2_CSBAUD      0x04000000  // Chip Select Baud Rate and
+                                            // Multiple Sub-Mode Configuration
+                                            // enable
+#define EPI_HB8CFG2_CSCFG_M     0x03000000  // Chip Select Configuration
+#define EPI_HB8CFG2_CSCFG_ALE   0x00000000  // ALE Configuration
+#define EPI_HB8CFG2_CSCFG_CS    0x01000000  // CSn Configuration
+#define EPI_HB8CFG2_CSCFG_DCS   0x02000000  // Dual CSn Configuration
+#define EPI_HB8CFG2_CSCFG_ADCS  0x03000000  // ALE with Dual CSn Configuration
+#define EPI_HB8CFG2_WRHIGH      0x00200000  // CS1n WRITE Strobe Polarity
+#define EPI_HB8CFG2_RDHIGH      0x00100000  // CS1n READ Strobe Polarity
+#define EPI_HB8CFG2_ALEHIGH     0x00080000  // CS1n ALE Strobe Polarity
+#define EPI_HB8CFG2_WRWS_M      0x000000C0  // CS1n Write Wait States
+#define EPI_HB8CFG2_WRWS_2      0x00000000  // Active WRn is 2 EPI clocks
+#define EPI_HB8CFG2_WRWS_4      0x00000040  // Active WRn is 4 EPI clocks
+#define EPI_HB8CFG2_WRWS_6      0x00000080  // Active WRn is 6 EPI clocks
+#define EPI_HB8CFG2_WRWS_8      0x000000C0  // Active WRn is 8 EPI clocks
+#define EPI_HB8CFG2_RDWS_M      0x00000030  // CS1n Read Wait States
+#define EPI_HB8CFG2_RDWS_2      0x00000000  // Active RDn is 2 EPI clocks
+#define EPI_HB8CFG2_RDWS_4      0x00000010  // Active RDn is 4 EPI clocks
+#define EPI_HB8CFG2_RDWS_6      0x00000020  // Active RDn is 6 EPI clocks
+#define EPI_HB8CFG2_RDWS_8      0x00000030  // Active RDn is 8 EPI clocks
+#define EPI_HB8CFG2_MODE_M      0x00000003  // CS1n Host Bus Sub-Mode
+#define EPI_HB8CFG2_MODE_ADMUX  0x00000000  // ADMUX - AD[7:0]
+#define EPI_HB8CFG2_MODE_AD     0x00000001  // ADNONMUX - D[7:0]
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_HB16CFG2 register.
+//
+//*****************************************************************************
+#define EPI_HB16CFG2_CSCFGEXT   0x08000000  // Chip Select Extended
+                                            // Configuration
+#define EPI_HB16CFG2_CSBAUD     0x04000000  // Chip Select Baud Rate and
+                                            // Multiple Sub-Mode Configuration
+                                            // enable
+#define EPI_HB16CFG2_CSCFG_M    0x03000000  // Chip Select Configuration
+#define EPI_HB16CFG2_CSCFG_ALE  0x00000000  // ALE Configuration
+#define EPI_HB16CFG2_CSCFG_CS   0x01000000  // CSn Configuration
+#define EPI_HB16CFG2_CSCFG_DCS  0x02000000  // Dual CSn Configuration
+#define EPI_HB16CFG2_CSCFG_ADCS 0x03000000  // ALE with Dual CSn Configuration
+#define EPI_HB16CFG2_WRHIGH     0x00200000  // CS1n WRITE Strobe Polarity
+#define EPI_HB16CFG2_RDHIGH     0x00100000  // CS1n READ Strobe Polarity
+#define EPI_HB16CFG2_ALEHIGH    0x00080000  // CS1n ALE Strobe Polarity
+#define EPI_HB16CFG2_WRCRE      0x00040000  // CS1n PSRAM Configuration
+                                            // Register Write
+#define EPI_HB16CFG2_RDCRE      0x00020000  // CS1n PSRAM Configuration
+                                            // Register Read
+#define EPI_HB16CFG2_BURST      0x00010000  // CS1n Burst Mode
+#define EPI_HB16CFG2_WRWS_M     0x000000C0  // CS1n Write Wait States
+#define EPI_HB16CFG2_WRWS_2     0x00000000  // Active WRn is 2 EPI clocks
+#define EPI_HB16CFG2_WRWS_4     0x00000040  // Active WRn is 4 EPI clocks
+#define EPI_HB16CFG2_WRWS_6     0x00000080  // Active WRn is 6 EPI clocks
+#define EPI_HB16CFG2_WRWS_8     0x000000C0  // Active WRn is 8 EPI clocks
+#define EPI_HB16CFG2_RDWS_M     0x00000030  // CS1n Read Wait States
+#define EPI_HB16CFG2_RDWS_2     0x00000000  // Active RDn is 2 EPI clocks
+#define EPI_HB16CFG2_RDWS_4     0x00000010  // Active RDn is 4 EPI clocks
+#define EPI_HB16CFG2_RDWS_6     0x00000020  // Active RDn is 6 EPI clocks
+#define EPI_HB16CFG2_RDWS_8     0x00000030  // Active RDn is 8 EPI clocks
+#define EPI_HB16CFG2_MODE_M     0x00000003  // CS1n Host Bus Sub-Mode
+#define EPI_HB16CFG2_MODE_ADMUX 0x00000000  // ADMUX - AD[15:0]
+#define EPI_HB16CFG2_MODE_AD    0x00000001  // ADNONMUX - D[15:0]
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_ADDRMAP register.
+//
+//*****************************************************************************
+#define EPI_ADDRMAP_ECSZ_M      0x00000C00  // External Code Size
+#define EPI_ADDRMAP_ECSZ_256B   0x00000000  // 256 bytes; lower address range:
+                                            // 0x00 to 0xFF
+#define EPI_ADDRMAP_ECSZ_64KB   0x00000400  // 64 KB; lower address range:
+                                            // 0x0000 to 0xFFFF
+#define EPI_ADDRMAP_ECSZ_16MB   0x00000800  // 16 MB; lower address range:
+                                            // 0x00.0000 to 0xFF.FFFF
+#define EPI_ADDRMAP_ECSZ_256MB  0x00000C00  // 256MB; lower address range:
+                                            // 0x000.0000 to 0x0FFF.FFFF
+#define EPI_ADDRMAP_ECADR_M     0x00000300  // External Code Address
+#define EPI_ADDRMAP_ECADR_NONE  0x00000000  // Not mapped
+#define EPI_ADDRMAP_ECADR_1000  0x00000100  // At 0x1000.0000
+#define EPI_ADDRMAP_EPSZ_M      0x000000C0  // External Peripheral Size
+#define EPI_ADDRMAP_EPSZ_256B   0x00000000  // 256 bytes; lower address range:
+                                            // 0x00 to 0xFF
+#define EPI_ADDRMAP_EPSZ_64KB   0x00000040  // 64 KB; lower address range:
+                                            // 0x0000 to 0xFFFF
+#define EPI_ADDRMAP_EPSZ_16MB   0x00000080  // 16 MB; lower address range:
+                                            // 0x00.0000 to 0xFF.FFFF
+#define EPI_ADDRMAP_EPSZ_256MB  0x000000C0  // 256 MB; lower address range:
+                                            // 0x000.0000 to 0xFFF.FFFF
+#define EPI_ADDRMAP_EPADR_M     0x00000030  // External Peripheral Address
+#define EPI_ADDRMAP_EPADR_NONE  0x00000000  // Not mapped
+#define EPI_ADDRMAP_EPADR_A000  0x00000010  // At 0xA000.0000
+#define EPI_ADDRMAP_EPADR_C000  0x00000020  // At 0xC000.0000
+#define EPI_ADDRMAP_EPADR_HBQS  0x00000030  // Only to be used with Host Bus
+                                            // quad chip select. In quad chip
+                                            // select mode, CS2n maps to
+                                            // 0xA000.0000 and CS3n maps to
+                                            // 0xC000.0000
+#define EPI_ADDRMAP_ERSZ_M      0x0000000C  // External RAM Size
+#define EPI_ADDRMAP_ERSZ_256B   0x00000000  // 256 bytes; lower address range:
+                                            // 0x00 to 0xFF
+#define EPI_ADDRMAP_ERSZ_64KB   0x00000004  // 64 KB; lower address range:
+                                            // 0x0000 to 0xFFFF
+#define EPI_ADDRMAP_ERSZ_16MB   0x00000008  // 16 MB; lower address range:
+                                            // 0x00.0000 to 0xFF.FFFF
+#define EPI_ADDRMAP_ERSZ_256MB  0x0000000C  // 256 MB; lower address range:
+                                            // 0x000.0000 to 0xFFF.FFFF
+#define EPI_ADDRMAP_ERADR_M     0x00000003  // External RAM Address
+#define EPI_ADDRMAP_ERADR_NONE  0x00000000  // Not mapped
+#define EPI_ADDRMAP_ERADR_6000  0x00000001  // At 0x6000.0000
+#define EPI_ADDRMAP_ERADR_8000  0x00000002  // At 0x8000.0000
+#define EPI_ADDRMAP_ERADR_HBQS  0x00000003  // Only to be used with Host Bus
+                                            // quad chip select. In quad chip
+                                            // select mode, CS0n maps to
+                                            // 0x6000.0000 and CS1n maps to
+                                            // 0x8000.0000
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_RSIZE0 register.
+//
+//*****************************************************************************
+#define EPI_RSIZE0_SIZE_M       0x00000003  // Current Size
+#define EPI_RSIZE0_SIZE_8BIT    0x00000001  // Byte (8 bits)
+#define EPI_RSIZE0_SIZE_16BIT   0x00000002  // Half-word (16 bits)
+#define EPI_RSIZE0_SIZE_32BIT   0x00000003  // Word (32 bits)
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_RADDR0 register.
+//
+//*****************************************************************************
+#define EPI_RADDR0_ADDR_M       0xFFFFFFFF  // Current Address
+#define EPI_RADDR0_ADDR_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_RPSTD0 register.
+//
+//*****************************************************************************
+#define EPI_RPSTD0_POSTCNT_M    0x00001FFF  // Post Count
+#define EPI_RPSTD0_POSTCNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_RSIZE1 register.
+//
+//*****************************************************************************
+#define EPI_RSIZE1_SIZE_M       0x00000003  // Current Size
+#define EPI_RSIZE1_SIZE_8BIT    0x00000001  // Byte (8 bits)
+#define EPI_RSIZE1_SIZE_16BIT   0x00000002  // Half-word (16 bits)
+#define EPI_RSIZE1_SIZE_32BIT   0x00000003  // Word (32 bits)
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_RADDR1 register.
+//
+//*****************************************************************************
+#define EPI_RADDR1_ADDR_M       0xFFFFFFFF  // Current Address
+#define EPI_RADDR1_ADDR_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_RPSTD1 register.
+//
+//*****************************************************************************
+#define EPI_RPSTD1_POSTCNT_M    0x00001FFF  // Post Count
+#define EPI_RPSTD1_POSTCNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_STAT register.
+//
+//*****************************************************************************
+#define EPI_STAT_XFFULL         0x00000100  // External FIFO Full
+#define EPI_STAT_XFEMPTY        0x00000080  // External FIFO Empty
+#define EPI_STAT_INITSEQ        0x00000040  // Initialization Sequence
+#define EPI_STAT_WBUSY          0x00000020  // Write Busy
+#define EPI_STAT_NBRBUSY        0x00000010  // Non-Blocking Read Busy
+#define EPI_STAT_ACTIVE         0x00000001  // Register Active
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_RFIFOCNT register.
+//
+//*****************************************************************************
+#define EPI_RFIFOCNT_COUNT_M    0x0000000F  // FIFO Count
+#define EPI_RFIFOCNT_COUNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_READFIFO0
+// register.
+//
+//*****************************************************************************
+#define EPI_READFIFO0_DATA_M    0xFFFFFFFF  // Reads Data
+#define EPI_READFIFO0_DATA_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_READFIFO1
+// register.
+//
+//*****************************************************************************
+#define EPI_READFIFO1_DATA_M    0xFFFFFFFF  // Reads Data
+#define EPI_READFIFO1_DATA_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_READFIFO2
+// register.
+//
+//*****************************************************************************
+#define EPI_READFIFO2_DATA_M    0xFFFFFFFF  // Reads Data
+#define EPI_READFIFO2_DATA_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_READFIFO3
+// register.
+//
+//*****************************************************************************
+#define EPI_READFIFO3_DATA_M    0xFFFFFFFF  // Reads Data
+#define EPI_READFIFO3_DATA_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_READFIFO4
+// register.
+//
+//*****************************************************************************
+#define EPI_READFIFO4_DATA_M    0xFFFFFFFF  // Reads Data
+#define EPI_READFIFO4_DATA_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_READFIFO5
+// register.
+//
+//*****************************************************************************
+#define EPI_READFIFO5_DATA_M    0xFFFFFFFF  // Reads Data
+#define EPI_READFIFO5_DATA_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_READFIFO6
+// register.
+//
+//*****************************************************************************
+#define EPI_READFIFO6_DATA_M    0xFFFFFFFF  // Reads Data
+#define EPI_READFIFO6_DATA_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_READFIFO7
+// register.
+//
+//*****************************************************************************
+#define EPI_READFIFO7_DATA_M    0xFFFFFFFF  // Reads Data
+#define EPI_READFIFO7_DATA_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_FIFOLVL register.
+//
+//*****************************************************************************
+#define EPI_FIFOLVL_WFERR       0x00020000  // Write Full Error
+#define EPI_FIFOLVL_RSERR       0x00010000  // Read Stall Error
+#define EPI_FIFOLVL_WRFIFO_M    0x00000070  // Write FIFO
+#define EPI_FIFOLVL_WRFIFO_EMPT 0x00000000  // Interrupt is triggered while
+                                            // WRFIFO is empty.
+#define EPI_FIFOLVL_WRFIFO_2    0x00000020  // Interrupt is triggered until
+                                            // there are only two slots
+                                            // available. Thus, trigger is
+                                            // deasserted when there are two
+                                            // WRFIFO entries present. This
+                                            // configuration is optimized for
+                                            // bursts of 2
+#define EPI_FIFOLVL_WRFIFO_1    0x00000030  // Interrupt is triggered until
+                                            // there is one WRFIFO entry
+                                            // available. This configuration
+                                            // expects only single writes
+#define EPI_FIFOLVL_WRFIFO_NFULL                                              \
+                                0x00000040  // Trigger interrupt when WRFIFO is
+                                            // not full, meaning trigger will
+                                            // continue to assert until there
+                                            // are four entries in the WRFIFO
+#define EPI_FIFOLVL_RDFIFO_M    0x00000007  // Read FIFO
+#define EPI_FIFOLVL_RDFIFO_1    0x00000001  // Trigger when there are 1 or more
+                                            // entries in the NBRFIFO
+#define EPI_FIFOLVL_RDFIFO_2    0x00000002  // Trigger when there are 2 or more
+                                            // entries in the NBRFIFO
+#define EPI_FIFOLVL_RDFIFO_4    0x00000003  // Trigger when there are 4 or more
+                                            // entries in the NBRFIFO
+#define EPI_FIFOLVL_RDFIFO_6    0x00000004  // Trigger when there are 6 or more
+                                            // entries in the NBRFIFO
+#define EPI_FIFOLVL_RDFIFO_7    0x00000005  // Trigger when there are 7 or more
+                                            // entries in the NBRFIFO
+#define EPI_FIFOLVL_RDFIFO_8    0x00000006  // Trigger when there are 8 entries
+                                            // in the NBRFIFO
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_WFIFOCNT register.
+//
+//*****************************************************************************
+#define EPI_WFIFOCNT_WTAV_M     0x00000007  // Available Write Transactions
+#define EPI_WFIFOCNT_WTAV_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_DMATXCNT register.
+//
+//*****************************************************************************
+#define EPI_DMATXCNT_TXCNT_M    0x0000FFFF  // DMA Count
+#define EPI_DMATXCNT_TXCNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_IM register.
+//
+//*****************************************************************************
+#define EPI_IM_DMAWRIM          0x00000010  // Write uDMA Interrupt Mask
+#define EPI_IM_DMARDIM          0x00000008  // Read uDMA Interrupt Mask
+#define EPI_IM_WRIM             0x00000004  // Write FIFO Empty Interrupt Mask
+#define EPI_IM_RDIM             0x00000002  // Read FIFO Full Interrupt Mask
+#define EPI_IM_ERRIM            0x00000001  // Error Interrupt Mask
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_RIS register.
+//
+//*****************************************************************************
+#define EPI_RIS_DMAWRRIS        0x00000010  // Write uDMA Raw Interrupt Status
+#define EPI_RIS_DMARDRIS        0x00000008  // Read uDMA Raw Interrupt Status
+#define EPI_RIS_WRRIS           0x00000004  // Write Raw Interrupt Status
+#define EPI_RIS_RDRIS           0x00000002  // Read Raw Interrupt Status
+#define EPI_RIS_ERRRIS          0x00000001  // Error Raw Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_MIS register.
+//
+//*****************************************************************************
+#define EPI_MIS_DMAWRMIS        0x00000010  // Write uDMA Masked Interrupt
+                                            // Status
+#define EPI_MIS_DMARDMIS        0x00000008  // Read uDMA Masked Interrupt
+                                            // Status
+#define EPI_MIS_WRMIS           0x00000004  // Write Masked Interrupt Status
+#define EPI_MIS_RDMIS           0x00000002  // Read Masked Interrupt Status
+#define EPI_MIS_ERRMIS          0x00000001  // Error Masked Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_EISC register.
+//
+//*****************************************************************************
+#define EPI_EISC_DMAWRIC        0x00000010  // Write uDMA Interrupt Clear
+#define EPI_EISC_DMARDIC        0x00000008  // Read uDMA Interrupt Clear
+#define EPI_EISC_WTFULL         0x00000004  // Write FIFO Full Error
+#define EPI_EISC_RSTALL         0x00000002  // Read Stalled Error
+#define EPI_EISC_TOUT           0x00000001  // Timeout Error
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_HB8CFG3 register.
+//
+//*****************************************************************************
+#define EPI_HB8CFG3_WRHIGH      0x00200000  // CS2n WRITE Strobe Polarity
+#define EPI_HB8CFG3_RDHIGH      0x00100000  // CS2n READ Strobe Polarity
+#define EPI_HB8CFG3_ALEHIGH     0x00080000  // CS2n ALE Strobe Polarity
+#define EPI_HB8CFG3_WRWS_M      0x000000C0  // CS2n Write Wait States
+#define EPI_HB8CFG3_WRWS_2      0x00000000  // Active WRn is 2 EPI clocks
+#define EPI_HB8CFG3_WRWS_4      0x00000040  // Active WRn is 4 EPI clocks
+#define EPI_HB8CFG3_WRWS_6      0x00000080  // Active WRn is 6 EPI clocks
+#define EPI_HB8CFG3_WRWS_8      0x000000C0  // Active WRn is 8 EPI clocks
+#define EPI_HB8CFG3_RDWS_M      0x00000030  // CS2n Read Wait States
+#define EPI_HB8CFG3_RDWS_2      0x00000000  // Active RDn is 2 EPI clocks
+#define EPI_HB8CFG3_RDWS_4      0x00000010  // Active RDn is 4 EPI clocks
+#define EPI_HB8CFG3_RDWS_6      0x00000020  // Active RDn is 6 EPI clocks
+#define EPI_HB8CFG3_RDWS_8      0x00000030  // Active RDn is 8 EPI clocks
+#define EPI_HB8CFG3_MODE_M      0x00000003  // CS2n Host Bus Sub-Mode
+#define EPI_HB8CFG3_MODE_ADMUX  0x00000000  // ADMUX - AD[7:0]
+#define EPI_HB8CFG3_MODE_AD     0x00000001  // ADNONMUX - D[7:0]
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_HB16CFG3 register.
+//
+//*****************************************************************************
+#define EPI_HB16CFG3_WRHIGH     0x00200000  // CS2n WRITE Strobe Polarity
+#define EPI_HB16CFG3_RDHIGH     0x00100000  // CS2n READ Strobe Polarity
+#define EPI_HB16CFG3_ALEHIGH    0x00080000  // CS2n ALE Strobe Polarity
+#define EPI_HB16CFG3_WRCRE      0x00040000  // CS2n PSRAM Configuration
+                                            // Register Write
+#define EPI_HB16CFG3_RDCRE      0x00020000  // CS2n PSRAM Configuration
+                                            // Register Read
+#define EPI_HB16CFG3_BURST      0x00010000  // CS2n Burst Mode
+#define EPI_HB16CFG3_WRWS_M     0x000000C0  // CS2n Write Wait States
+#define EPI_HB16CFG3_WRWS_2     0x00000000  // Active WRn is 2 EPI clocks
+#define EPI_HB16CFG3_WRWS_4     0x00000040  // Active WRn is 4 EPI clocks
+#define EPI_HB16CFG3_WRWS_6     0x00000080  // Active WRn is 6 EPI clocks
+#define EPI_HB16CFG3_WRWS_8     0x000000C0  // Active WRn is 8 EPI clocks
+#define EPI_HB16CFG3_RDWS_M     0x00000030  // CS2n Read Wait States
+#define EPI_HB16CFG3_RDWS_2     0x00000000  // Active RDn is 2 EPI clocks
+#define EPI_HB16CFG3_RDWS_4     0x00000010  // Active RDn is 4 EPI clocks
+#define EPI_HB16CFG3_RDWS_6     0x00000020  // Active RDn is 6 EPI clocks
+#define EPI_HB16CFG3_RDWS_8     0x00000030  // Active RDn is 8 EPI clocks
+#define EPI_HB16CFG3_MODE_M     0x00000003  // CS2n Host Bus Sub-Mode
+#define EPI_HB16CFG3_MODE_ADMUX 0x00000000  // ADMUX - AD[15:0]
+#define EPI_HB16CFG3_MODE_AD    0x00000001  // ADNONMUX - D[15:0]
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_HB16CFG4 register.
+//
+//*****************************************************************************
+#define EPI_HB16CFG4_WRHIGH     0x00200000  // CS3n WRITE Strobe Polarity
+#define EPI_HB16CFG4_RDHIGH     0x00100000  // CS3n READ Strobe Polarity
+#define EPI_HB16CFG4_ALEHIGH    0x00080000  // CS3n ALE Strobe Polarity
+#define EPI_HB16CFG4_WRCRE      0x00040000  // CS3n PSRAM Configuration
+                                            // Register Write
+#define EPI_HB16CFG4_RDCRE      0x00020000  // CS3n PSRAM Configuration
+                                            // Register Read
+#define EPI_HB16CFG4_BURST      0x00010000  // CS3n Burst Mode
+#define EPI_HB16CFG4_WRWS_M     0x000000C0  // CS3n Write Wait States
+#define EPI_HB16CFG4_WRWS_2     0x00000000  // Active WRn is 2 EPI clocks
+#define EPI_HB16CFG4_WRWS_4     0x00000040  // Active WRn is 4 EPI clocks
+#define EPI_HB16CFG4_WRWS_6     0x00000080  // Active WRn is 6 EPI clocks
+#define EPI_HB16CFG4_WRWS_8     0x000000C0  // Active WRn is 8 EPI clocks
+#define EPI_HB16CFG4_RDWS_M     0x00000030  // CS3n Read Wait States
+#define EPI_HB16CFG4_RDWS_2     0x00000000  // Active RDn is 2 EPI clocks
+#define EPI_HB16CFG4_RDWS_4     0x00000010  // Active RDn is 4 EPI clocks
+#define EPI_HB16CFG4_RDWS_6     0x00000020  // Active RDn is 6 EPI clocks
+#define EPI_HB16CFG4_RDWS_8     0x00000030  // Active RDn is 8 EPI clocks
+#define EPI_HB16CFG4_MODE_M     0x00000003  // CS3n Host Bus Sub-Mode
+#define EPI_HB16CFG4_MODE_ADMUX 0x00000000  // ADMUX - AD[15:0]
+#define EPI_HB16CFG4_MODE_AD    0x00000001  // ADNONMUX - D[15:0]
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_HB8CFG4 register.
+//
+//*****************************************************************************
+#define EPI_HB8CFG4_WRHIGH      0x00200000  // CS3n WRITE Strobe Polarity
+#define EPI_HB8CFG4_RDHIGH      0x00100000  // CS2n READ Strobe Polarity
+#define EPI_HB8CFG4_ALEHIGH     0x00080000  // CS3n ALE Strobe Polarity
+#define EPI_HB8CFG4_WRWS_M      0x000000C0  // CS3n Write Wait States
+#define EPI_HB8CFG4_WRWS_2      0x00000000  // Active WRn is 2 EPI clocks
+#define EPI_HB8CFG4_WRWS_4      0x00000040  // Active WRn is 4 EPI clocks
+#define EPI_HB8CFG4_WRWS_6      0x00000080  // Active WRn is 6 EPI clocks
+#define EPI_HB8CFG4_WRWS_8      0x000000C0  // Active WRn is 8 EPI clocks
+#define EPI_HB8CFG4_RDWS_M      0x00000030  // CS3n Read Wait States
+#define EPI_HB8CFG4_RDWS_2      0x00000000  // Active RDn is 2 EPI clocks
+#define EPI_HB8CFG4_RDWS_4      0x00000010  // Active RDn is 4 EPI clocks
+#define EPI_HB8CFG4_RDWS_6      0x00000020  // Active RDn is 6 EPI clocks
+#define EPI_HB8CFG4_RDWS_8      0x00000030  // Active RDn is 8 EPI clocks
+#define EPI_HB8CFG4_MODE_M      0x00000003  // CS3n Host Bus Sub-Mode
+#define EPI_HB8CFG4_MODE_ADMUX  0x00000000  // ADMUX - AD[7:0]
+#define EPI_HB8CFG4_MODE_AD     0x00000001  // ADNONMUX - D[7:0]
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_HB8TIME register.
+//
+//*****************************************************************************
+#define EPI_HB8TIME_IRDYDLY_M   0x03000000  // CS0n Input Ready Delay
+#define EPI_HB8TIME_CAPWIDTH_M  0x00003000  // CS0n Inter-transfer Capture
+                                            // Width
+#define EPI_HB8TIME_WRWSM       0x00000010  // Write Wait State Minus One
+#define EPI_HB8TIME_RDWSM       0x00000001  // Read Wait State Minus One
+#define EPI_HB8TIME_IRDYDLY_S   24
+#define EPI_HB8TIME_CAPWIDTH_S  12
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_HB16TIME register.
+//
+//*****************************************************************************
+#define EPI_HB16TIME_IRDYDLY_M  0x03000000  // CS0n Input Ready Delay
+#define EPI_HB16TIME_PSRAMSZ_M  0x00070000  // PSRAM Row Size
+#define EPI_HB16TIME_PSRAMSZ_0  0x00000000  // No row size limitation
+#define EPI_HB16TIME_PSRAMSZ_128B                                             \
+                                0x00010000  // 128 B
+#define EPI_HB16TIME_PSRAMSZ_256B                                             \
+                                0x00020000  // 256 B
+#define EPI_HB16TIME_PSRAMSZ_512B                                             \
+                                0x00030000  // 512 B
+#define EPI_HB16TIME_PSRAMSZ_1KB                                              \
+                                0x00040000  // 1024 B
+#define EPI_HB16TIME_PSRAMSZ_2KB                                              \
+                                0x00050000  // 2048 B
+#define EPI_HB16TIME_PSRAMSZ_4KB                                              \
+                                0x00060000  // 4096 B
+#define EPI_HB16TIME_PSRAMSZ_8KB                                              \
+                                0x00070000  // 8192 B
+#define EPI_HB16TIME_CAPWIDTH_M 0x00003000  // CS0n Inter-transfer Capture
+                                            // Width
+#define EPI_HB16TIME_WRWSM      0x00000010  // Write Wait State Minus One
+#define EPI_HB16TIME_RDWSM      0x00000001  // Read Wait State Minus One
+#define EPI_HB16TIME_IRDYDLY_S  24
+#define EPI_HB16TIME_CAPWIDTH_S 12
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_HB8TIME2 register.
+//
+//*****************************************************************************
+#define EPI_HB8TIME2_IRDYDLY_M  0x03000000  // CS1n Input Ready Delay
+#define EPI_HB8TIME2_CAPWIDTH_M 0x00003000  // CS1n Inter-transfer Capture
+                                            // Width
+#define EPI_HB8TIME2_WRWSM      0x00000010  // CS1n Write Wait State Minus One
+#define EPI_HB8TIME2_RDWSM      0x00000001  // CS1n Read Wait State Minus One
+#define EPI_HB8TIME2_IRDYDLY_S  24
+#define EPI_HB8TIME2_CAPWIDTH_S 12
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_HB16TIME2
+// register.
+//
+//*****************************************************************************
+#define EPI_HB16TIME2_IRDYDLY_M 0x03000000  // CS1n Input Ready Delay
+#define EPI_HB16TIME2_PSRAMSZ_M 0x00070000  // PSRAM Row Size
+#define EPI_HB16TIME2_PSRAMSZ_0 0x00000000  // No row size limitation
+#define EPI_HB16TIME2_PSRAMSZ_128B                                            \
+                                0x00010000  // 128 B
+#define EPI_HB16TIME2_PSRAMSZ_256B                                            \
+                                0x00020000  // 256 B
+#define EPI_HB16TIME2_PSRAMSZ_512B                                            \
+                                0x00030000  // 512 B
+#define EPI_HB16TIME2_PSRAMSZ_1KB                                             \
+                                0x00040000  // 1024 B
+#define EPI_HB16TIME2_PSRAMSZ_2KB                                             \
+                                0x00050000  // 2048 B
+#define EPI_HB16TIME2_PSRAMSZ_4KB                                             \
+                                0x00060000  // 4096 B
+#define EPI_HB16TIME2_PSRAMSZ_8KB                                             \
+                                0x00070000  // 8192 B
+#define EPI_HB16TIME2_CAPWIDTH_M                                              \
+                                0x00003000  // CS1n Inter-transfer Capture
+                                            // Width
+#define EPI_HB16TIME2_WRWSM     0x00000010  // CS1n Write Wait State Minus One
+#define EPI_HB16TIME2_RDWSM     0x00000001  // CS1n Read Wait State Minus One
+#define EPI_HB16TIME2_IRDYDLY_S 24
+#define EPI_HB16TIME2_CAPWIDTH_S                                              \
+                                12
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_HB16TIME3
+// register.
+//
+//*****************************************************************************
+#define EPI_HB16TIME3_IRDYDLY_M 0x03000000  // CS2n Input Ready Delay
+#define EPI_HB16TIME3_PSRAMSZ_M 0x00070000  // PSRAM Row Size
+#define EPI_HB16TIME3_PSRAMSZ_0 0x00000000  // No row size limitation
+#define EPI_HB16TIME3_PSRAMSZ_128B                                            \
+                                0x00010000  // 128 B
+#define EPI_HB16TIME3_PSRAMSZ_256B                                            \
+                                0x00020000  // 256 B
+#define EPI_HB16TIME3_PSRAMSZ_512B                                            \
+                                0x00030000  // 512 B
+#define EPI_HB16TIME3_PSRAMSZ_1KB                                             \
+                                0x00040000  // 1024 B
+#define EPI_HB16TIME3_PSRAMSZ_2KB                                             \
+                                0x00050000  // 2048 B
+#define EPI_HB16TIME3_PSRAMSZ_4KB                                             \
+                                0x00060000  // 4096 B
+#define EPI_HB16TIME3_PSRAMSZ_8KB                                             \
+                                0x00070000  // 8192 B
+#define EPI_HB16TIME3_CAPWIDTH_M                                              \
+                                0x00003000  // CS2n Inter-transfer Capture
+                                            // Width
+#define EPI_HB16TIME3_WRWSM     0x00000010  // CS2n Write Wait State Minus One
+#define EPI_HB16TIME3_RDWSM     0x00000001  // CS2n Read Wait State Minus One
+#define EPI_HB16TIME3_IRDYDLY_S 24
+#define EPI_HB16TIME3_CAPWIDTH_S                                              \
+                                12
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_HB8TIME3 register.
+//
+//*****************************************************************************
+#define EPI_HB8TIME3_IRDYDLY_M  0x03000000  // CS2n Input Ready Delay
+#define EPI_HB8TIME3_CAPWIDTH_M 0x00003000  // CS2n Inter-transfer Capture
+                                            // Width
+#define EPI_HB8TIME3_WRWSM      0x00000010  // CS2n Write Wait State Minus One
+#define EPI_HB8TIME3_RDWSM      0x00000001  // CS2n Read Wait State Minus One
+#define EPI_HB8TIME3_IRDYDLY_S  24
+#define EPI_HB8TIME3_CAPWIDTH_S 12
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_HB8TIME4 register.
+//
+//*****************************************************************************
+#define EPI_HB8TIME4_IRDYDLY_M  0x03000000  // CS3n Input Ready Delay
+#define EPI_HB8TIME4_CAPWIDTH_M 0x00003000  // CS3n Inter-transfer Capture
+                                            // Width
+#define EPI_HB8TIME4_WRWSM      0x00000010  // CS3n Write Wait State Minus One
+#define EPI_HB8TIME4_RDWSM      0x00000001  // CS3n Read Wait State Minus One
+#define EPI_HB8TIME4_IRDYDLY_S  24
+#define EPI_HB8TIME4_CAPWIDTH_S 12
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_HB16TIME4
+// register.
+//
+//*****************************************************************************
+#define EPI_HB16TIME4_IRDYDLY_M 0x03000000  // CS3n Input Ready Delay
+#define EPI_HB16TIME4_PSRAMSZ_M 0x00070000  // PSRAM Row Size
+#define EPI_HB16TIME4_PSRAMSZ_0 0x00000000  // No row size limitation
+#define EPI_HB16TIME4_PSRAMSZ_128B                                            \
+                                0x00010000  // 128 B
+#define EPI_HB16TIME4_PSRAMSZ_256B                                            \
+                                0x00020000  // 256 B
+#define EPI_HB16TIME4_PSRAMSZ_512B                                            \
+                                0x00030000  // 512 B
+#define EPI_HB16TIME4_PSRAMSZ_1KB                                             \
+                                0x00040000  // 1024 B
+#define EPI_HB16TIME4_PSRAMSZ_2KB                                             \
+                                0x00050000  // 2048 B
+#define EPI_HB16TIME4_PSRAMSZ_4KB                                             \
+                                0x00060000  // 4096 B
+#define EPI_HB16TIME4_PSRAMSZ_8KB                                             \
+                                0x00070000  // 8192 B
+#define EPI_HB16TIME4_CAPWIDTH_M                                              \
+                                0x00003000  // CS3n Inter-transfer Capture
+                                            // Width
+#define EPI_HB16TIME4_WRWSM     0x00000010  // CS3n Write Wait State Minus One
+#define EPI_HB16TIME4_RDWSM     0x00000001  // CS3n Read Wait State Minus One
+#define EPI_HB16TIME4_IRDYDLY_S 24
+#define EPI_HB16TIME4_CAPWIDTH_S                                              \
+                                12
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_HBPSRAM register.
+//
+//*****************************************************************************
+#define EPI_HBPSRAM_CR_M        0x001FFFFF  // PSRAM Config Register
+#define EPI_HBPSRAM_CR_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSEXC_RIS register.
+//
+//*****************************************************************************
+#define SYSEXC_RIS_FPIXCRIS     0x00000020  // Floating-Point Inexact Exception
+                                            // Raw Interrupt Status
+#define SYSEXC_RIS_FPOFCRIS     0x00000010  // Floating-Point Overflow
+                                            // Exception Raw Interrupt Status
+#define SYSEXC_RIS_FPUFCRIS     0x00000008  // Floating-Point Underflow
+                                            // Exception Raw Interrupt Status
+#define SYSEXC_RIS_FPIOCRIS     0x00000004  // Floating-Point Invalid Operation
+                                            // Raw Interrupt Status
+#define SYSEXC_RIS_FPDZCRIS     0x00000002  // Floating-Point Divide By 0
+                                            // Exception Raw Interrupt Status
+#define SYSEXC_RIS_FPIDCRIS     0x00000001  // Floating-Point Input Denormal
+                                            // Exception Raw Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSEXC_IM register.
+//
+//*****************************************************************************
+#define SYSEXC_IM_FPIXCIM       0x00000020  // Floating-Point Inexact Exception
+                                            // Interrupt Mask
+#define SYSEXC_IM_FPOFCIM       0x00000010  // Floating-Point Overflow
+                                            // Exception Interrupt Mask
+#define SYSEXC_IM_FPUFCIM       0x00000008  // Floating-Point Underflow
+                                            // Exception Interrupt Mask
+#define SYSEXC_IM_FPIOCIM       0x00000004  // Floating-Point Invalid Operation
+                                            // Interrupt Mask
+#define SYSEXC_IM_FPDZCIM       0x00000002  // Floating-Point Divide By 0
+                                            // Exception Interrupt Mask
+#define SYSEXC_IM_FPIDCIM       0x00000001  // Floating-Point Input Denormal
+                                            // Exception Interrupt Mask
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSEXC_MIS register.
+//
+//*****************************************************************************
+#define SYSEXC_MIS_FPIXCMIS     0x00000020  // Floating-Point Inexact Exception
+                                            // Masked Interrupt Status
+#define SYSEXC_MIS_FPOFCMIS     0x00000010  // Floating-Point Overflow
+                                            // Exception Masked Interrupt
+                                            // Status
+#define SYSEXC_MIS_FPUFCMIS     0x00000008  // Floating-Point Underflow
+                                            // Exception Masked Interrupt
+                                            // Status
+#define SYSEXC_MIS_FPIOCMIS     0x00000004  // Floating-Point Invalid Operation
+                                            // Masked Interrupt Status
+#define SYSEXC_MIS_FPDZCMIS     0x00000002  // Floating-Point Divide By 0
+                                            // Exception Masked Interrupt
+                                            // Status
+#define SYSEXC_MIS_FPIDCMIS     0x00000001  // Floating-Point Input Denormal
+                                            // Exception Masked Interrupt
+                                            // Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSEXC_IC register.
+//
+//*****************************************************************************
+#define SYSEXC_IC_FPIXCIC       0x00000020  // Floating-Point Inexact Exception
+                                            // Interrupt Clear
+#define SYSEXC_IC_FPOFCIC       0x00000010  // Floating-Point Overflow
+                                            // Exception Interrupt Clear
+#define SYSEXC_IC_FPUFCIC       0x00000008  // Floating-Point Underflow
+                                            // Exception Interrupt Clear
+#define SYSEXC_IC_FPIOCIC       0x00000004  // Floating-Point Invalid Operation
+                                            // Interrupt Clear
+#define SYSEXC_IC_FPDZCIC       0x00000002  // Floating-Point Divide By 0
+                                            // Exception Interrupt Clear
+#define SYSEXC_IC_FPIDCIC       0x00000001  // Floating-Point Input Denormal
+                                            // Exception Interrupt Clear
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_RTCC register.
+//
+//*****************************************************************************
+#define HIB_RTCC_M              0xFFFFFFFF  // RTC Counter
+#define HIB_RTCC_S              0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_RTCM0 register.
+//
+//*****************************************************************************
+#define HIB_RTCM0_M             0xFFFFFFFF  // RTC Match 0
+#define HIB_RTCM0_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_RTCLD register.
+//
+//*****************************************************************************
+#define HIB_RTCLD_M             0xFFFFFFFF  // RTC Load
+#define HIB_RTCLD_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_CTL register.
+//
+//*****************************************************************************
+#define HIB_CTL_WRC             0x80000000  // Write Complete/Capable
+#define HIB_CTL_RETCLR          0x40000000  // GPIO Retention/Clear
+#define HIB_CTL_OSCSEL          0x00080000  // Oscillator Select
+#define HIB_CTL_OSCDRV          0x00020000  // Oscillator Drive Capability
+#define HIB_CTL_OSCBYP          0x00010000  // Oscillator Bypass
+#define HIB_CTL_VBATSEL_M       0x00006000  // Select for Low-Battery
+                                            // Comparator
+#define HIB_CTL_VBATSEL_1_9V    0x00000000  // 1.9 Volts
+#define HIB_CTL_VBATSEL_2_1V    0x00002000  // 2.1 Volts (default)
+#define HIB_CTL_VBATSEL_2_3V    0x00004000  // 2.3 Volts
+#define HIB_CTL_VBATSEL_2_5V    0x00006000  // 2.5 Volts
+#define HIB_CTL_BATCHK          0x00000400  // Check Battery Status
+#define HIB_CTL_BATWKEN         0x00000200  // Wake on Low Battery
+#define HIB_CTL_VDD3ON          0x00000100  // VDD Powered
+#define HIB_CTL_VABORT          0x00000080  // Power Cut Abort Enable
+#define HIB_CTL_CLK32EN         0x00000040  // Clocking Enable
+#define HIB_CTL_PINWEN          0x00000010  // External Wake Pin Enable
+#define HIB_CTL_RTCWEN          0x00000008  // RTC Wake-up Enable
+#define HIB_CTL_HIBREQ          0x00000002  // Hibernation Request
+#define HIB_CTL_RTCEN           0x00000001  // RTC Timer Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_IM register.
+//
+//*****************************************************************************
+#define HIB_IM_VDDFAIL          0x00000080  // VDD Fail Interrupt Mask
+#define HIB_IM_RSTWK            0x00000040  // Reset Pad I/O Wake-Up Interrupt
+                                            // Mask
+#define HIB_IM_PADIOWK          0x00000020  // Pad I/O Wake-Up Interrupt Mask
+#define HIB_IM_WC               0x00000010  // External Write Complete/Capable
+                                            // Interrupt Mask
+#define HIB_IM_EXTW             0x00000008  // External Wake-Up Interrupt Mask
+#define HIB_IM_LOWBAT           0x00000004  // Low Battery Voltage Interrupt
+                                            // Mask
+#define HIB_IM_RTCALT0          0x00000001  // RTC Alert 0 Interrupt Mask
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_RIS register.
+//
+//*****************************************************************************
+#define HIB_RIS_VDDFAIL         0x00000080  // VDD Fail Raw Interrupt Status
+#define HIB_RIS_RSTWK           0x00000040  // Reset Pad I/O Wake-Up Raw
+                                            // Interrupt Status
+#define HIB_RIS_PADIOWK         0x00000020  // Pad I/O Wake-Up Raw Interrupt
+                                            // Status
+#define HIB_RIS_WC              0x00000010  // Write Complete/Capable Raw
+                                            // Interrupt Status
+#define HIB_RIS_EXTW            0x00000008  // External Wake-Up Raw Interrupt
+                                            // Status
+#define HIB_RIS_LOWBAT          0x00000004  // Low Battery Voltage Raw
+                                            // Interrupt Status
+#define HIB_RIS_RTCALT0         0x00000001  // RTC Alert 0 Raw Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_MIS register.
+//
+//*****************************************************************************
+#define HIB_MIS_VDDFAIL         0x00000080  // VDD Fail Interrupt Mask
+#define HIB_MIS_RSTWK           0x00000040  // Reset Pad I/O Wake-Up Interrupt
+                                            // Mask
+#define HIB_MIS_PADIOWK         0x00000020  // Pad I/O Wake-Up Interrupt Mask
+#define HIB_MIS_WC              0x00000010  // Write Complete/Capable Masked
+                                            // Interrupt Status
+#define HIB_MIS_EXTW            0x00000008  // External Wake-Up Masked
+                                            // Interrupt Status
+#define HIB_MIS_LOWBAT          0x00000004  // Low Battery Voltage Masked
+                                            // Interrupt Status
+#define HIB_MIS_RTCALT0         0x00000001  // RTC Alert 0 Masked Interrupt
+                                            // Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_IC register.
+//
+//*****************************************************************************
+#define HIB_IC_VDDFAIL          0x00000080  // VDD Fail Interrupt Clear
+#define HIB_IC_RSTWK            0x00000040  // Reset Pad I/O Wake-Up Interrupt
+                                            // Clear
+#define HIB_IC_PADIOWK          0x00000020  // Pad I/O Wake-Up Interrupt Clear
+#define HIB_IC_WC               0x00000010  // Write Complete/Capable Interrupt
+                                            // Clear
+#define HIB_IC_EXTW             0x00000008  // External Wake-Up Interrupt Clear
+#define HIB_IC_LOWBAT           0x00000004  // Low Battery Voltage Interrupt
+                                            // Clear
+#define HIB_IC_RTCALT0          0x00000001  // RTC Alert0 Masked Interrupt
+                                            // Clear
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_RTCT register.
+//
+//*****************************************************************************
+#define HIB_RTCT_TRIM_M         0x0000FFFF  // RTC Trim Value
+#define HIB_RTCT_TRIM_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_RTCSS register.
+//
+//*****************************************************************************
+#define HIB_RTCSS_RTCSSM_M      0x7FFF0000  // RTC Sub Seconds Match
+#define HIB_RTCSS_RTCSSC_M      0x00007FFF  // RTC Sub Seconds Count
+#define HIB_RTCSS_RTCSSM_S      16
+#define HIB_RTCSS_RTCSSC_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_IO register.
+//
+//*****************************************************************************
+#define HIB_IO_IOWRC            0x80000000  // I/O Write Complete
+#define HIB_IO_WURSTEN          0x00000010  // Reset Wake Source Enable
+#define HIB_IO_WUUNLK           0x00000001  // I/O Wake Pad Configuration
+                                            // Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_DATA register.
+//
+//*****************************************************************************
+#define HIB_DATA_RTD_M          0xFFFFFFFF  // Hibernation Module NV Data
+#define HIB_DATA_RTD_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_CALCTL register.
+//
+//*****************************************************************************
+#define HIB_CALCTL_CAL24        0x00000004  // Calendar Mode
+#define HIB_CALCTL_CALEN        0x00000001  // RTC Calendar/Counter Mode Select
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_CAL0 register.
+//
+//*****************************************************************************
+#define HIB_CAL0_VALID          0x80000000  // Valid Calendar Load
+#define HIB_CAL0_AMPM           0x00400000  // AM/PM Designation
+#define HIB_CAL0_HR_M           0x001F0000  // Hours
+#define HIB_CAL0_MIN_M          0x00003F00  // Minutes
+#define HIB_CAL0_SEC_M          0x0000003F  // Seconds
+#define HIB_CAL0_HR_S           16
+#define HIB_CAL0_MIN_S          8
+#define HIB_CAL0_SEC_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_CAL1 register.
+//
+//*****************************************************************************
+#define HIB_CAL1_VALID          0x80000000  // Valid Calendar Load
+#define HIB_CAL1_DOW_M          0x07000000  // Day of Week
+#define HIB_CAL1_YEAR_M         0x007F0000  // Year Value
+#define HIB_CAL1_MON_M          0x00000F00  // Month
+#define HIB_CAL1_DOM_M          0x0000001F  // Day of Month
+#define HIB_CAL1_DOW_S          24
+#define HIB_CAL1_YEAR_S         16
+#define HIB_CAL1_MON_S          8
+#define HIB_CAL1_DOM_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_CALLD0 register.
+//
+//*****************************************************************************
+#define HIB_CALLD0_AMPM         0x00400000  // AM/PM Designation
+#define HIB_CALLD0_HR_M         0x001F0000  // Hours
+#define HIB_CALLD0_MIN_M        0x00003F00  // Minutes
+#define HIB_CALLD0_SEC_M        0x0000003F  // Seconds
+#define HIB_CALLD0_HR_S         16
+#define HIB_CALLD0_MIN_S        8
+#define HIB_CALLD0_SEC_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_CALLD1 register.
+//
+//*****************************************************************************
+#define HIB_CALLD1_DOW_M        0x07000000  // Day of Week
+#define HIB_CALLD1_YEAR_M       0x007F0000  // Year Value
+#define HIB_CALLD1_MON_M        0x00000F00  // Month
+#define HIB_CALLD1_DOM_M        0x0000001F  // Day of Month
+#define HIB_CALLD1_DOW_S        24
+#define HIB_CALLD1_YEAR_S       16
+#define HIB_CALLD1_MON_S        8
+#define HIB_CALLD1_DOM_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_CALM0 register.
+//
+//*****************************************************************************
+#define HIB_CALM0_AMPM          0x00400000  // AM/PM Designation
+#define HIB_CALM0_HR_M          0x001F0000  // Hours
+#define HIB_CALM0_MIN_M         0x00003F00  // Minutes
+#define HIB_CALM0_SEC_M         0x0000003F  // Seconds
+#define HIB_CALM0_HR_S          16
+#define HIB_CALM0_MIN_S         8
+#define HIB_CALM0_SEC_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_CALM1 register.
+//
+//*****************************************************************************
+#define HIB_CALM1_DOM_M         0x0000001F  // Day of Month
+#define HIB_CALM1_DOM_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_LOCK register.
+//
+//*****************************************************************************
+#define HIB_LOCK_HIBLOCK_M      0xFFFFFFFF  // HIbernate Lock
+#define HIB_LOCK_HIBLOCK_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_TPCTL register.
+//
+//*****************************************************************************
+#define HIB_TPCTL_WAKE          0x00000800  // Wake from Hibernate on a Tamper
+                                            // Event
+#define HIB_TPCTL_MEMCLR_M      0x00000300  // HIB Memory Clear on Tamper Event
+#define HIB_TPCTL_MEMCLR_NONE   0x00000000  // Do not Clear HIB memory on
+                                            // tamper event
+#define HIB_TPCTL_MEMCLR_LOW32  0x00000100  // Clear Lower 32 Bytes of HIB
+                                            // memory on tamper event
+#define HIB_TPCTL_MEMCLR_HIGH32 0x00000200  // Clear upper 32 Bytes of HIB
+                                            // memory on tamper event
+#define HIB_TPCTL_MEMCLR_ALL    0x00000300  // Clear all HIB memory on tamper
+                                            // event
+#define HIB_TPCTL_TPCLR         0x00000010  // Tamper Event Clear
+#define HIB_TPCTL_TPEN          0x00000001  // Tamper Module Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_TPSTAT register.
+//
+//*****************************************************************************
+#define HIB_TPSTAT_STATE_M      0x0000000C  // Tamper Module Status
+#define HIB_TPSTAT_STATE_DISABLED                                             \
+                                0x00000000  // Tamper disabled
+#define HIB_TPSTAT_STATE_CONFIGED                                             \
+                                0x00000004  // Tamper configured
+#define HIB_TPSTAT_STATE_ERROR  0x00000008  // Tamper pin event occurred
+#define HIB_TPSTAT_XOSCST       0x00000002  // External Oscillator Status
+#define HIB_TPSTAT_XOSCFAIL     0x00000001  // External Oscillator Failure
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_TPIO register.
+//
+//*****************************************************************************
+#define HIB_TPIO_GFLTR3         0x08000000  // TMPR3 Glitch Filtering
+#define HIB_TPIO_PUEN3          0x04000000  // TMPR3 Internal Weak Pull-up
+                                            // Enable
+#define HIB_TPIO_LEV3           0x02000000  // TMPR3 Trigger Level
+#define HIB_TPIO_EN3            0x01000000  // TMPR3 Enable
+#define HIB_TPIO_GFLTR2         0x00080000  // TMPR2 Glitch Filtering
+#define HIB_TPIO_PUEN2          0x00040000  // TMPR2 Internal Weak Pull-up
+                                            // Enable
+#define HIB_TPIO_LEV2           0x00020000  // TMPR2 Trigger Level
+#define HIB_TPIO_EN2            0x00010000  // TMPR2 Enable
+#define HIB_TPIO_GFLTR1         0x00000800  // TMPR1 Glitch Filtering
+#define HIB_TPIO_PUEN1          0x00000400  // TMPR1 Internal Weak Pull-up
+                                            // Enable
+#define HIB_TPIO_LEV1           0x00000200  // TMPR1 Trigger Level
+#define HIB_TPIO_EN1            0x00000100  // TMPR1Enable
+#define HIB_TPIO_GFLTR0         0x00000008  // TMPR0 Glitch Filtering
+#define HIB_TPIO_PUEN0          0x00000004  // TMPR0 Internal Weak Pull-up
+                                            // Enable
+#define HIB_TPIO_LEV0           0x00000002  // TMPR0 Trigger Level
+#define HIB_TPIO_EN0            0x00000001  // TMPR0 Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_TPLOG0 register.
+//
+//*****************************************************************************
+#define HIB_TPLOG0_TIME_M       0xFFFFFFFF  // Tamper Log Calendar Information
+#define HIB_TPLOG0_TIME_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_TPLOG1 register.
+//
+//*****************************************************************************
+#define HIB_TPLOG1_XOSC         0x00010000  // Status of external 32
+#define HIB_TPLOG1_TRIG3        0x00000008  // Status of TMPR[3] Trigger
+#define HIB_TPLOG1_TRIG2        0x00000004  // Status of TMPR[2] Trigger
+#define HIB_TPLOG1_TRIG1        0x00000002  // Status of TMPR[1] Trigger
+#define HIB_TPLOG1_TRIG0        0x00000001  // Status of TMPR[0] Trigger
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_TPLOG2 register.
+//
+//*****************************************************************************
+#define HIB_TPLOG2_TIME_M       0xFFFFFFFF  // Tamper Log Calendar Information
+#define HIB_TPLOG2_TIME_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_TPLOG3 register.
+//
+//*****************************************************************************
+#define HIB_TPLOG3_XOSC         0x00010000  // Status of external 32
+#define HIB_TPLOG3_TRIG3        0x00000008  // Status of TMPR[3] Trigger
+#define HIB_TPLOG3_TRIG2        0x00000004  // Status of TMPR[2] Trigger
+#define HIB_TPLOG3_TRIG1        0x00000002  // Status of TMPR[1] Trigger
+#define HIB_TPLOG3_TRIG0        0x00000001  // Status of TMPR[0] Trigger
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_TPLOG4 register.
+//
+//*****************************************************************************
+#define HIB_TPLOG4_TIME_M       0xFFFFFFFF  // Tamper Log Calendar Information
+#define HIB_TPLOG4_TIME_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_TPLOG5 register.
+//
+//*****************************************************************************
+#define HIB_TPLOG5_XOSC         0x00010000  // Status of external 32
+#define HIB_TPLOG5_TRIG3        0x00000008  // Status of TMPR[3] Trigger
+#define HIB_TPLOG5_TRIG2        0x00000004  // Status of TMPR[2] Trigger
+#define HIB_TPLOG5_TRIG1        0x00000002  // Status of TMPR[1] Trigger
+#define HIB_TPLOG5_TRIG0        0x00000001  // Status of TMPR[0] Trigger
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_TPLOG6 register.
+//
+//*****************************************************************************
+#define HIB_TPLOG6_TIME_M       0xFFFFFFFF  // Tamper Log Calendar Information
+#define HIB_TPLOG6_TIME_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_TPLOG7 register.
+//
+//*****************************************************************************
+#define HIB_TPLOG7_XOSC         0x00010000  // Status of external 32
+#define HIB_TPLOG7_TRIG3        0x00000008  // Status of TMPR[3] Trigger
+#define HIB_TPLOG7_TRIG2        0x00000004  // Status of TMPR[2] Trigger
+#define HIB_TPLOG7_TRIG1        0x00000002  // Status of TMPR[1] Trigger
+#define HIB_TPLOG7_TRIG0        0x00000001  // Status of TMPR[0] Trigger
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_PP register.
+//
+//*****************************************************************************
+#define HIB_PP_TAMPER           0x00000002  // Tamper Pin Presence
+#define HIB_PP_WAKENC           0x00000001  // Wake Pin Presence
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_CC register.
+//
+//*****************************************************************************
+#define HIB_CC_SYSCLKEN         0x00000001  // RTCOSC to System Clock Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMA register.
+//
+//*****************************************************************************
+#define FLASH_FMA_OFFSET_M      0x000FFFFF  // Address Offset
+#define FLASH_FMA_OFFSET_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMD register.
+//
+//*****************************************************************************
+#define FLASH_FMD_DATA_M        0xFFFFFFFF  // Data Value
+#define FLASH_FMD_DATA_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMC register.
+//
+//*****************************************************************************
+#define FLASH_FMC_WRKEY         0xA4420000  // FLASH write key
+#define FLASH_FMC_COMT          0x00000008  // Commit Register Value
+#define FLASH_FMC_MERASE        0x00000004  // Mass Erase Flash Memory
+#define FLASH_FMC_ERASE         0x00000002  // Erase a Page of Flash Memory
+#define FLASH_FMC_WRITE         0x00000001  // Write a Word into Flash Memory
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FCRIS register.
+//
+//*****************************************************************************
+#define FLASH_FCRIS_PROGRIS     0x00002000  // Program Verify Error Raw
+                                            // Interrupt Status
+#define FLASH_FCRIS_ERRIS       0x00000800  // Erase Verify Error Raw Interrupt
+                                            // Status
+#define FLASH_FCRIS_INVDRIS     0x00000400  // Invalid Data Raw Interrupt
+                                            // Status
+#define FLASH_FCRIS_VOLTRIS     0x00000200  // Pump Voltage Raw Interrupt
+                                            // Status
+#define FLASH_FCRIS_ERIS        0x00000004  // EEPROM Raw Interrupt Status
+#define FLASH_FCRIS_PRIS        0x00000002  // Programming Raw Interrupt Status
+#define FLASH_FCRIS_ARIS        0x00000001  // Access Raw Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FCIM register.
+//
+//*****************************************************************************
+#define FLASH_FCIM_PROGMASK     0x00002000  // PROGVER Interrupt Mask
+#define FLASH_FCIM_ERMASK       0x00000800  // ERVER Interrupt Mask
+#define FLASH_FCIM_INVDMASK     0x00000400  // Invalid Data Interrupt Mask
+#define FLASH_FCIM_VOLTMASK     0x00000200  // VOLT Interrupt Mask
+#define FLASH_FCIM_EMASK        0x00000004  // EEPROM Interrupt Mask
+#define FLASH_FCIM_PMASK        0x00000002  // Programming Interrupt Mask
+#define FLASH_FCIM_AMASK        0x00000001  // Access Interrupt Mask
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FCMISC register.
+//
+//*****************************************************************************
+#define FLASH_FCMISC_PROGMISC   0x00002000  // PROGVER Masked Interrupt Status
+                                            // and Clear
+#define FLASH_FCMISC_ERMISC     0x00000800  // ERVER Masked Interrupt Status
+                                            // and Clear
+#define FLASH_FCMISC_INVDMISC   0x00000400  // Invalid Data Masked Interrupt
+                                            // Status and Clear
+#define FLASH_FCMISC_VOLTMISC   0x00000200  // VOLT Masked Interrupt Status and
+                                            // Clear
+#define FLASH_FCMISC_EMISC      0x00000004  // EEPROM Masked Interrupt Status
+                                            // and Clear
+#define FLASH_FCMISC_PMISC      0x00000002  // Programming Masked Interrupt
+                                            // Status and Clear
+#define FLASH_FCMISC_AMISC      0x00000001  // Access Masked Interrupt Status
+                                            // and Clear
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMC2 register.
+//
+//*****************************************************************************
+#define FLASH_FMC2_WRBUF        0x00000001  // Buffered Flash Memory Write
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FWBVAL register.
+//
+//*****************************************************************************
+#define FLASH_FWBVAL_FWB_M      0xFFFFFFFF  // Flash Memory Write Buffer
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FLPEKEY register.
+//
+//*****************************************************************************
+#define FLASH_FLPEKEY_PEKEY_M   0x0000FFFF  // Key Value
+#define FLASH_FLPEKEY_PEKEY_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FWBN register.
+//
+//*****************************************************************************
+#define FLASH_FWBN_DATA_M       0xFFFFFFFF  // Data
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_PP register.
+//
+//*****************************************************************************
+#define FLASH_PP_PFC            0x40000000  // Prefetch Buffer Mode
+#define FLASH_PP_FMM            0x20000000  // Flash Mirror Mode
+#define FLASH_PP_DFA            0x10000000  // DMA Flash Access
+#define FLASH_PP_EESS_M         0x00780000  // EEPROM Sector Size of the
+                                            // physical bank
+#define FLASH_PP_EESS_1KB       0x00000000  // 1 KB
+#define FLASH_PP_EESS_2KB       0x00080000  // 2 KB
+#define FLASH_PP_EESS_4KB       0x00100000  // 4 KB
+#define FLASH_PP_EESS_8KB       0x00180000  // 8 KB
+#define FLASH_PP_MAINSS_M       0x00070000  // Flash Sector Size of the
+                                            // physical bank
+#define FLASH_PP_MAINSS_1KB     0x00000000  // 1 KB
+#define FLASH_PP_MAINSS_2KB     0x00010000  // 2 KB
+#define FLASH_PP_MAINSS_4KB     0x00020000  // 4 KB
+#define FLASH_PP_MAINSS_8KB     0x00030000  // 8 KB
+#define FLASH_PP_MAINSS_16KB    0x00040000  // 16 KB
+#define FLASH_PP_SIZE_M         0x0000FFFF  // Flash Size
+#define FLASH_PP_SIZE_1MB       0x000001FF  // 1024 KB of Flash
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_SSIZE register.
+//
+//*****************************************************************************
+#define FLASH_SSIZE_SIZE_M      0x0000FFFF  // SRAM Size
+#define FLASH_SSIZE_SIZE_256KB  0x000003FF  // 256 KB of SRAM
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_CONF register.
+//
+//*****************************************************************************
+#define FLASH_CONF_FMME         0x40000000  // Flash Mirror Mode Enable
+#define FLASH_CONF_SPFE         0x20000000  // Single Prefetch Mode Enable
+#define FLASH_CONF_CLRTV        0x00100000  // Clear Valid Tags
+#define FLASH_CONF_FPFON        0x00020000  // Force Prefetch On
+#define FLASH_CONF_FPFOFF       0x00010000  // Force Prefetch Off
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_ROMSWMAP register.
+//
+//*****************************************************************************
+#define FLASH_ROMSWMAP_SW7EN_M  0x0000C000  // ROM SW Region 7 Availability
+#define FLASH_ROMSWMAP_SW7EN_NOTVIS                                           \
+                                0x00000000  // Software region not available to
+                                            // the core
+#define FLASH_ROMSWMAP_SW7EN_CORE                                             \
+                                0x00004000  // Region available to core
+#define FLASH_ROMSWMAP_SW6EN_M  0x00003000  // ROM SW Region 6 Availability
+#define FLASH_ROMSWMAP_SW6EN_NOTVIS                                           \
+                                0x00000000  // Software region not available to
+                                            // the core
+#define FLASH_ROMSWMAP_SW6EN_CORE                                             \
+                                0x00001000  // Region available to core
+#define FLASH_ROMSWMAP_SW5EN_M  0x00000C00  // ROM SW Region 5 Availability
+#define FLASH_ROMSWMAP_SW5EN_NOTVIS                                           \
+                                0x00000000  // Software region not available to
+                                            // the core
+#define FLASH_ROMSWMAP_SW5EN_CORE                                             \
+                                0x00000400  // Region available to core
+#define FLASH_ROMSWMAP_SW4EN_M  0x00000300  // ROM SW Region 4 Availability
+#define FLASH_ROMSWMAP_SW4EN_NOTVIS                                           \
+                                0x00000000  // Software region not available to
+                                            // the core
+#define FLASH_ROMSWMAP_SW4EN_CORE                                             \
+                                0x00000100  // Region available to core
+#define FLASH_ROMSWMAP_SW3EN_M  0x000000C0  // ROM SW Region 3 Availability
+#define FLASH_ROMSWMAP_SW3EN_NOTVIS                                           \
+                                0x00000000  // Software region not available to
+                                            // the core
+#define FLASH_ROMSWMAP_SW3EN_CORE                                             \
+                                0x00000040  // Region available to core
+#define FLASH_ROMSWMAP_SW2EN_M  0x00000030  // ROM SW Region 2 Availability
+#define FLASH_ROMSWMAP_SW2EN_NOTVIS                                           \
+                                0x00000000  // Software region not available to
+                                            // the core
+#define FLASH_ROMSWMAP_SW2EN_CORE                                             \
+                                0x00000010  // Region available to core
+#define FLASH_ROMSWMAP_SW1EN_M  0x0000000C  // ROM SW Region 1 Availability
+#define FLASH_ROMSWMAP_SW1EN_NOTVIS                                           \
+                                0x00000000  // Software region not available to
+                                            // the core
+#define FLASH_ROMSWMAP_SW1EN_CORE                                             \
+                                0x00000004  // Region available to core
+#define FLASH_ROMSWMAP_SW0EN_M  0x00000003  // ROM SW Region 0 Availability
+#define FLASH_ROMSWMAP_SW0EN_NOTVIS                                           \
+                                0x00000000  // Software region not available to
+                                            // the core
+#define FLASH_ROMSWMAP_SW0EN_CORE                                             \
+                                0x00000001  // Region available to core
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_DMASZ register.
+//
+//*****************************************************************************
+#define FLASH_DMASZ_SIZE_M      0x0003FFFF  // uDMA-accessible Memory Size
+#define FLASH_DMASZ_SIZE_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_DMAST register.
+//
+//*****************************************************************************
+#define FLASH_DMAST_ADDR_M      0x1FFFF800  // Contains the starting address of
+                                            // the flash region accessible by
+                                            // uDMA if the FLASHPP register DFA
+                                            // bit is set
+#define FLASH_DMAST_ADDR_S      11
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_RVP register.
+//
+//*****************************************************************************
+#define FLASH_RVP_RV_M          0xFFFFFFFF  // Reset Vector Pointer Address
+#define FLASH_RVP_RV_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_BOOTCFG register.
+//
+//*****************************************************************************
+#define FLASH_BOOTCFG_NW        0x80000000  // Not Written
+#define FLASH_BOOTCFG_PORT_M    0x0000E000  // Boot GPIO Port
+#define FLASH_BOOTCFG_PORT_A    0x00000000  // Port A
+#define FLASH_BOOTCFG_PORT_B    0x00002000  // Port B
+#define FLASH_BOOTCFG_PORT_C    0x00004000  // Port C
+#define FLASH_BOOTCFG_PORT_D    0x00006000  // Port D
+#define FLASH_BOOTCFG_PORT_E    0x00008000  // Port E
+#define FLASH_BOOTCFG_PORT_F    0x0000A000  // Port F
+#define FLASH_BOOTCFG_PORT_G    0x0000C000  // Port G
+#define FLASH_BOOTCFG_PORT_H    0x0000E000  // Port H
+#define FLASH_BOOTCFG_PIN_M     0x00001C00  // Boot GPIO Pin
+#define FLASH_BOOTCFG_PIN_0     0x00000000  // Pin 0
+#define FLASH_BOOTCFG_PIN_1     0x00000400  // Pin 1
+#define FLASH_BOOTCFG_PIN_2     0x00000800  // Pin 2
+#define FLASH_BOOTCFG_PIN_3     0x00000C00  // Pin 3
+#define FLASH_BOOTCFG_PIN_4     0x00001000  // Pin 4
+#define FLASH_BOOTCFG_PIN_5     0x00001400  // Pin 5
+#define FLASH_BOOTCFG_PIN_6     0x00001800  // Pin 6
+#define FLASH_BOOTCFG_PIN_7     0x00001C00  // Pin 7
+#define FLASH_BOOTCFG_POL       0x00000200  // Boot GPIO Polarity
+#define FLASH_BOOTCFG_EN        0x00000100  // Boot GPIO Enable
+#define FLASH_BOOTCFG_KEY       0x00000010  // KEY Select
+#define FLASH_BOOTCFG_DBG1      0x00000002  // Debug Control 1
+#define FLASH_BOOTCFG_DBG0      0x00000001  // Debug Control 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USERREG0 register.
+//
+//*****************************************************************************
+#define FLASH_USERREG0_DATA_M   0xFFFFFFFF  // User Data
+#define FLASH_USERREG0_DATA_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USERREG1 register.
+//
+//*****************************************************************************
+#define FLASH_USERREG1_DATA_M   0xFFFFFFFF  // User Data
+#define FLASH_USERREG1_DATA_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USERREG2 register.
+//
+//*****************************************************************************
+#define FLASH_USERREG2_DATA_M   0xFFFFFFFF  // User Data
+#define FLASH_USERREG2_DATA_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USERREG3 register.
+//
+//*****************************************************************************
+#define FLASH_USERREG3_DATA_M   0xFFFFFFFF  // User Data
+#define FLASH_USERREG3_DATA_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMPRE8 register.
+//
+//*****************************************************************************
+#define FLASH_FMPRE8_READ_ENABLE_M                                            \
+                                0xFFFFFFFF  // Flash Read Enable
+#define FLASH_FMPRE8_READ_ENABLE_S                                            \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMPRE9 register.
+//
+//*****************************************************************************
+#define FLASH_FMPRE9_READ_ENABLE_M                                            \
+                                0xFFFFFFFF  // Flash Read Enable
+#define FLASH_FMPRE9_READ_ENABLE_S                                            \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMPRE10 register.
+//
+//*****************************************************************************
+#define FLASH_FMPRE10_READ_ENABLE_M                                           \
+                                0xFFFFFFFF  // Flash Read Enable
+#define FLASH_FMPRE10_READ_ENABLE_S                                           \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMPRE11 register.
+//
+//*****************************************************************************
+#define FLASH_FMPRE11_READ_ENABLE_M                                           \
+                                0xFFFFFFFF  // Flash Read Enable
+#define FLASH_FMPRE11_READ_ENABLE_S                                           \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMPRE12 register.
+//
+//*****************************************************************************
+#define FLASH_FMPRE12_READ_ENABLE_M                                           \
+                                0xFFFFFFFF  // Flash Read Enable
+#define FLASH_FMPRE12_READ_ENABLE_S                                           \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMPRE13 register.
+//
+//*****************************************************************************
+#define FLASH_FMPRE13_READ_ENABLE_M                                           \
+                                0xFFFFFFFF  // Flash Read Enable
+#define FLASH_FMPRE13_READ_ENABLE_S                                           \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMPRE14 register.
+//
+//*****************************************************************************
+#define FLASH_FMPRE14_READ_ENABLE_M                                           \
+                                0xFFFFFFFF  // Flash Read Enable
+#define FLASH_FMPRE14_READ_ENABLE_S                                           \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMPRE15 register.
+//
+//*****************************************************************************
+#define FLASH_FMPRE15_READ_ENABLE_M                                           \
+                                0xFFFFFFFF  // Flash Read Enable
+#define FLASH_FMPRE15_READ_ENABLE_S                                           \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMPPE8 register.
+//
+//*****************************************************************************
+#define FLASH_FMPPE8_PROG_ENABLE_M                                            \
+                                0xFFFFFFFF  // Flash Programming Enable
+#define FLASH_FMPPE8_PROG_ENABLE_S                                            \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMPPE9 register.
+//
+//*****************************************************************************
+#define FLASH_FMPPE9_PROG_ENABLE_M                                            \
+                                0xFFFFFFFF  // Flash Programming Enable
+#define FLASH_FMPPE9_PROG_ENABLE_S                                            \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMPPE10 register.
+//
+//*****************************************************************************
+#define FLASH_FMPPE10_PROG_ENABLE_M                                           \
+                                0xFFFFFFFF  // Flash Programming Enable
+#define FLASH_FMPPE10_PROG_ENABLE_S                                           \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMPPE11 register.
+//
+//*****************************************************************************
+#define FLASH_FMPPE11_PROG_ENABLE_M                                           \
+                                0xFFFFFFFF  // Flash Programming Enable
+#define FLASH_FMPPE11_PROG_ENABLE_S                                           \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMPPE12 register.
+//
+//*****************************************************************************
+#define FLASH_FMPPE12_PROG_ENABLE_M                                           \
+                                0xFFFFFFFF  // Flash Programming Enable
+#define FLASH_FMPPE12_PROG_ENABLE_S                                           \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMPPE13 register.
+//
+//*****************************************************************************
+#define FLASH_FMPPE13_PROG_ENABLE_M                                           \
+                                0xFFFFFFFF  // Flash Programming Enable
+#define FLASH_FMPPE13_PROG_ENABLE_S                                           \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMPPE14 register.
+//
+//*****************************************************************************
+#define FLASH_FMPPE14_PROG_ENABLE_M                                           \
+                                0xFFFFFFFF  // Flash Programming Enable
+#define FLASH_FMPPE14_PROG_ENABLE_S                                           \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMPPE15 register.
+//
+//*****************************************************************************
+#define FLASH_FMPPE15_PROG_ENABLE_M                                           \
+                                0xFFFFFFFF  // Flash Programming Enable
+#define FLASH_FMPPE15_PROG_ENABLE_S                                           \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DID0 register.
+//
+//*****************************************************************************
+#define SYSCTL_DID0_VER_M       0x70000000  // DID0 Version
+#define SYSCTL_DID0_VER_1       0x10000000  // Second version of the DID0
+                                            // register format.
+#define SYSCTL_DID0_CLASS_M     0x00FF0000  // Device Class
+#define SYSCTL_DID0_CLASS_TM4C129                                             \
+                                0x000A0000  // Tiva(TM) TM4C129-class
+                                            // microcontrollers
+#define SYSCTL_DID0_MAJ_M       0x0000FF00  // Major Revision
+#define SYSCTL_DID0_MAJ_REVA    0x00000000  // Revision A (initial device)
+#define SYSCTL_DID0_MAJ_REVB    0x00000100  // Revision B (first base layer
+                                            // revision)
+#define SYSCTL_DID0_MAJ_REVC    0x00000200  // Revision C (second base layer
+                                            // revision)
+#define SYSCTL_DID0_MIN_M       0x000000FF  // Minor Revision
+#define SYSCTL_DID0_MIN_0       0x00000000  // Initial device, or a major
+                                            // revision update
+#define SYSCTL_DID0_MIN_1       0x00000001  // First metal layer change
+#define SYSCTL_DID0_MIN_2       0x00000002  // Second metal layer change
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DID1 register.
+//
+//*****************************************************************************
+#define SYSCTL_DID1_VER_M       0xF0000000  // DID1 Version
+#define SYSCTL_DID1_VER_1       0x10000000  // fury_ib
+#define SYSCTL_DID1_FAM_M       0x0F000000  // Family
+#define SYSCTL_DID1_FAM_TIVA    0x00000000  // Tiva family of microcontollers
+#define SYSCTL_DID1_PRTNO_M     0x00FF0000  // Part Number
+#define SYSCTL_DID1_PRTNO_TM4C129XNCZAD                                       \
+                                0x00320000  // TM4C129XNCZAD
+#define SYSCTL_DID1_PINCNT_M    0x0000E000  // Package Pin Count
+#define SYSCTL_DID1_PINCNT_100  0x00004000  // 100-pin LQFP package
+#define SYSCTL_DID1_PINCNT_64   0x00006000  // 64-pin LQFP package
+#define SYSCTL_DID1_PINCNT_144  0x00008000  // 144-pin LQFP package
+#define SYSCTL_DID1_PINCNT_157  0x0000A000  // 157-pin BGA package
+#define SYSCTL_DID1_PINCNT_128  0x0000C000  // 128-pin TQFP package
+#define SYSCTL_DID1_TEMP_M      0x000000E0  // Temperature Range
+#define SYSCTL_DID1_TEMP_C      0x00000000  // Commercial temperature range
+#define SYSCTL_DID1_TEMP_I      0x00000020  // Industrial temperature range
+#define SYSCTL_DID1_TEMP_E      0x00000040  // Extended temperature range
+#define SYSCTL_DID1_PKG_M       0x00000018  // Package Type
+#define SYSCTL_DID1_PKG_QFP     0x00000008  // QFP package
+#define SYSCTL_DID1_PKG_BGA     0x00000010  // BGA package
+#define SYSCTL_DID1_ROHS        0x00000004  // RoHS-Compliance
+#define SYSCTL_DID1_QUAL_M      0x00000003  // Qualification Status
+#define SYSCTL_DID1_QUAL_ES     0x00000000  // Engineering Sample (unqualified)
+#define SYSCTL_DID1_QUAL_PP     0x00000001  // Pilot Production (unqualified)
+#define SYSCTL_DID1_QUAL_FQ     0x00000002  // Fully Qualified
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PTBOCTL register.
+//
+//*****************************************************************************
+#define SYSCTL_PTBOCTL_VDDA_UBOR_M                                            \
+                                0x00000300  // VDDA under BOR Event Action
+#define SYSCTL_PTBOCTL_VDDA_UBOR_NONE                                         \
+                                0x00000000  // No Action
+#define SYSCTL_PTBOCTL_VDDA_UBOR_SYSINT                                       \
+                                0x00000100  // System control interrupt
+#define SYSCTL_PTBOCTL_VDDA_UBOR_NMI                                          \
+                                0x00000200  // NMI
+#define SYSCTL_PTBOCTL_VDDA_UBOR_RST                                          \
+                                0x00000300  // Reset
+#define SYSCTL_PTBOCTL_VDD_UBOR_M                                             \
+                                0x00000003  // VDD (VDDS) under BOR Event
+                                            // Action
+#define SYSCTL_PTBOCTL_VDD_UBOR_NONE                                          \
+                                0x00000000  // No Action
+#define SYSCTL_PTBOCTL_VDD_UBOR_SYSINT                                        \
+                                0x00000001  // System control interrupt
+#define SYSCTL_PTBOCTL_VDD_UBOR_NMI                                           \
+                                0x00000002  // NMI
+#define SYSCTL_PTBOCTL_VDD_UBOR_RST                                           \
+                                0x00000003  // Reset
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RIS register.
+//
+//*****************************************************************************
+#define SYSCTL_RIS_MOSCPUPRIS   0x00000100  // MOSC Power Up Raw Interrupt
+                                            // Status
+#define SYSCTL_RIS_PLLLRIS      0x00000040  // PLL Lock Raw Interrupt Status
+#define SYSCTL_RIS_MOFRIS       0x00000008  // Main Oscillator Failure Raw
+                                            // Interrupt Status
+#define SYSCTL_RIS_BORRIS       0x00000002  // Brown-Out Reset Raw Interrupt
+                                            // Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_IMC register.
+//
+//*****************************************************************************
+#define SYSCTL_IMC_MOSCPUPIM    0x00000100  // MOSC Power Up Interrupt Mask
+#define SYSCTL_IMC_PLLLIM       0x00000040  // PLL Lock Interrupt Mask
+#define SYSCTL_IMC_MOFIM        0x00000008  // Main Oscillator Failure
+                                            // Interrupt Mask
+#define SYSCTL_IMC_BORIM        0x00000002  // Brown-Out Reset Interrupt Mask
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_MISC register.
+//
+//*****************************************************************************
+#define SYSCTL_MISC_MOSCPUPMIS  0x00000100  // MOSC Power Up Masked Interrupt
+                                            // Status
+#define SYSCTL_MISC_PLLLMIS     0x00000040  // PLL Lock Masked Interrupt Status
+#define SYSCTL_MISC_MOFMIS      0x00000008  // Main Oscillator Failure Masked
+                                            // Interrupt Status
+#define SYSCTL_MISC_BORMIS      0x00000002  // BOR Masked Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RESC register.
+//
+//*****************************************************************************
+#define SYSCTL_RESC_MOSCFAIL    0x00010000  // MOSC Failure Reset
+#define SYSCTL_RESC_HSSR        0x00001000  // HSSR Reset
+#define SYSCTL_RESC_HIB         0x00000040  // HIB Reset
+#define SYSCTL_RESC_WDT1        0x00000020  // Watchdog Timer 1 Reset
+#define SYSCTL_RESC_SW          0x00000010  // Software Reset
+#define SYSCTL_RESC_WDT0        0x00000008  // Watchdog Timer 0 Reset
+#define SYSCTL_RESC_BOR         0x00000004  // Brown-Out Reset
+#define SYSCTL_RESC_POR         0x00000002  // Power-On Reset
+#define SYSCTL_RESC_EXT         0x00000001  // External Reset
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PWRTC register.
+//
+//*****************************************************************************
+#define SYSCTL_PWRTC_VDDA_UBOR  0x00000010  // VDDA Under BOR Status
+#define SYSCTL_PWRTC_VDD_UBOR   0x00000001  // VDD Under BOR Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_NMIC register.
+//
+//*****************************************************************************
+#define SYSCTL_NMIC_MOSCFAIL    0x00010000  // MOSC Failure NMI
+#define SYSCTL_NMIC_TAMPER      0x00000200  // Tamper Event NMI
+#define SYSCTL_NMIC_WDT1        0x00000020  // Watch Dog Timer (WDT) 1 NMI
+#define SYSCTL_NMIC_WDT0        0x00000008  // Watch Dog Timer (WDT) 0 NMI
+#define SYSCTL_NMIC_POWER       0x00000004  // Power/Brown Out Event NMI
+#define SYSCTL_NMIC_EXTERNAL    0x00000001  // External Pin NMI
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_MOSCCTL register.
+//
+//*****************************************************************************
+#define SYSCTL_MOSCCTL_OSCRNG   0x00000010  // Oscillator Range
+#define SYSCTL_MOSCCTL_PWRDN    0x00000008  // Power Down
+#define SYSCTL_MOSCCTL_NOXTAL   0x00000004  // No Crystal Connected
+#define SYSCTL_MOSCCTL_MOSCIM   0x00000002  // MOSC Failure Action
+#define SYSCTL_MOSCCTL_CVAL     0x00000001  // Clock Validation for MOSC
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RSCLKCFG
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_RSCLKCFG_MEMTIMU 0x80000000  // Memory Timing Register Update
+#define SYSCTL_RSCLKCFG_NEWFREQ 0x40000000  // New PLLFREQ Accept
+#define SYSCTL_RSCLKCFG_ACG     0x20000000  // Auto Clock Gating
+#define SYSCTL_RSCLKCFG_USEPLL  0x10000000  // Use PLL
+#define SYSCTL_RSCLKCFG_PLLSRC_M                                              \
+                                0x0F000000  // PLL Source
+#define SYSCTL_RSCLKCFG_PLLSRC_PIOSC                                          \
+                                0x00000000  // PIOSC is PLL input clock source
+#define SYSCTL_RSCLKCFG_PLLSRC_MOSC                                           \
+                                0x03000000  // MOSC is the PLL input clock
+                                            // source
+#define SYSCTL_RSCLKCFG_OSCSRC_M                                              \
+                                0x00F00000  // Oscillator Source
+#define SYSCTL_RSCLKCFG_OSCSRC_PIOSC                                          \
+                                0x00000000  // PIOSC is oscillator source
+#define SYSCTL_RSCLKCFG_OSCSRC_LFIOSC                                         \
+                                0x00200000  // LFIOSC is oscillator source
+#define SYSCTL_RSCLKCFG_OSCSRC_MOSC                                           \
+                                0x00300000  // MOSC is oscillator source
+#define SYSCTL_RSCLKCFG_OSCSRC_RTC                                            \
+                                0x00400000  // Hibernation Module RTC
+                                            // Oscillator (RTCOSC)
+#define SYSCTL_RSCLKCFG_OSYSDIV_M                                             \
+                                0x000FFC00  // Oscillator System Clock Divisor
+#define SYSCTL_RSCLKCFG_PSYSDIV_M                                             \
+                                0x000003FF  // PLL System Clock Divisor
+#define SYSCTL_RSCLKCFG_OSYSDIV_S                                             \
+                                10
+#define SYSCTL_RSCLKCFG_PSYSDIV_S                                             \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_MEMTIM0 register.
+//
+//*****************************************************************************
+#define SYSCTL_MEMTIM0_EBCHT_M  0x03C00000  // EEPROM Clock High Time
+#define SYSCTL_MEMTIM0_EBCHT_0_5                                              \
+                                0x00000000  // 1/2 system clock period
+#define SYSCTL_MEMTIM0_EBCHT_1  0x00400000  // 1 system clock period
+#define SYSCTL_MEMTIM0_EBCHT_1_5                                              \
+                                0x00800000  // 1.5 system clock periods
+#define SYSCTL_MEMTIM0_EBCHT_2  0x00C00000  // 2 system clock periods
+#define SYSCTL_MEMTIM0_EBCHT_2_5                                              \
+                                0x01000000  // 2.5 system clock periods
+#define SYSCTL_MEMTIM0_EBCHT_3  0x01400000  // 3 system clock periods
+#define SYSCTL_MEMTIM0_EBCHT_3_5                                              \
+                                0x01800000  // 3.5 system clock periods
+#define SYSCTL_MEMTIM0_EBCHT_4  0x01C00000  // 4 system clock periods
+#define SYSCTL_MEMTIM0_EBCHT_4_5                                              \
+                                0x02000000  // 4.5 system clock periods
+#define SYSCTL_MEMTIM0_EBCE     0x00200000  // EEPROM Bank Clock Edge
+#define SYSCTL_MEMTIM0_EWS_M    0x000F0000  // EEPROM Wait States
+#define SYSCTL_MEMTIM0_FBCHT_M  0x000003C0  // Flash Bank Clock High Time
+#define SYSCTL_MEMTIM0_FBCHT_0_5                                              \
+                                0x00000000  // 1/2 system clock period
+#define SYSCTL_MEMTIM0_FBCHT_1  0x00000040  // 1 system clock period
+#define SYSCTL_MEMTIM0_FBCHT_1_5                                              \
+                                0x00000080  // 1.5 system clock periods
+#define SYSCTL_MEMTIM0_FBCHT_2  0x000000C0  // 2 system clock periods
+#define SYSCTL_MEMTIM0_FBCHT_2_5                                              \
+                                0x00000100  // 2.5 system clock periods
+#define SYSCTL_MEMTIM0_FBCHT_3  0x00000140  // 3 system clock periods
+#define SYSCTL_MEMTIM0_FBCHT_3_5                                              \
+                                0x00000180  // 3.5 system clock periods
+#define SYSCTL_MEMTIM0_FBCHT_4  0x000001C0  // 4 system clock periods
+#define SYSCTL_MEMTIM0_FBCHT_4_5                                              \
+                                0x00000200  // 4.5 system clock periods
+#define SYSCTL_MEMTIM0_FBCE     0x00000020  // Flash Bank Clock Edge
+#define SYSCTL_MEMTIM0_FWS_M    0x0000000F  // Flash Wait State
+#define SYSCTL_MEMTIM0_EWS_S    16
+#define SYSCTL_MEMTIM0_FWS_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_ALTCLKCFG
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_ALTCLKCFG_ALTCLK_M                                             \
+                                0x0000000F  // Alternate Clock Source
+#define SYSCTL_ALTCLKCFG_ALTCLK_PIOSC                                         \
+                                0x00000000  // PIOSC
+#define SYSCTL_ALTCLKCFG_ALTCLK_RTCOSC                                        \
+                                0x00000003  // Hibernation Module Real-time
+                                            // clock output (RTCOSC)
+#define SYSCTL_ALTCLKCFG_ALTCLK_LFIOSC                                        \
+                                0x00000004  // Low-frequency internal
+                                            // oscillator (LFIOSC)
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DSCLKCFG
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_DSCLKCFG_PIOSCPD 0x80000000  // PIOSC Power Down
+#define SYSCTL_DSCLKCFG_MOSCDPD 0x40000000  // MOSC Disable Power Down
+#define SYSCTL_DSCLKCFG_DSOSCSRC_M                                            \
+                                0x00F00000  // Deep Sleep Oscillator Source
+#define SYSCTL_DSCLKCFG_DSOSCSRC_PIOSC                                        \
+                                0x00000000  // PIOSC
+#define SYSCTL_DSCLKCFG_DSOSCSRC_LFIOSC                                       \
+                                0x00200000  // LFIOSC
+#define SYSCTL_DSCLKCFG_DSOSCSRC_MOSC                                         \
+                                0x00300000  // MOSC
+#define SYSCTL_DSCLKCFG_DSOSCSRC_RTC                                          \
+                                0x00400000  // Hibernation Module RTCOSC
+#define SYSCTL_DSCLKCFG_DSSYSDIV_M                                            \
+                                0x000003FF  // Deep Sleep Clock Divisor
+#define SYSCTL_DSCLKCFG_DSSYSDIV_S                                            \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DIVSCLK register.
+//
+//*****************************************************************************
+#define SYSCTL_DIVSCLK_EN       0x80000000  // DIVSCLK Enable
+#define SYSCTL_DIVSCLK_SRC_M    0x00030000  // Clock Source
+#define SYSCTL_DIVSCLK_SRC_SYSCLK                                             \
+                                0x00000000  // System Clock
+#define SYSCTL_DIVSCLK_SRC_PIOSC                                              \
+                                0x00010000  // PIOSC
+#define SYSCTL_DIVSCLK_SRC_MOSC 0x00020000  // MOSC
+#define SYSCTL_DIVSCLK_DIV_M    0x000000FF  // Divisor Value
+#define SYSCTL_DIVSCLK_DIV_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SYSPROP register.
+//
+//*****************************************************************************
+#define SYSCTL_SYSPROP_FPU      0x00000001  // FPU Present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PIOSCCAL
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_PIOSCCAL_UTEN    0x80000000  // Use User Trim Value
+#define SYSCTL_PIOSCCAL_CAL     0x00000200  // Start Calibration
+#define SYSCTL_PIOSCCAL_UPDATE  0x00000100  // Update Trim
+#define SYSCTL_PIOSCCAL_UT_M    0x0000007F  // User Trim Value
+#define SYSCTL_PIOSCCAL_UT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PIOSCSTAT
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_PIOSCSTAT_DT_M   0x007F0000  // Default Trim Value
+#define SYSCTL_PIOSCSTAT_CR_M   0x00000300  // Calibration Result
+#define SYSCTL_PIOSCSTAT_CRNONE 0x00000000  // Calibration has not been
+                                            // attempted
+#define SYSCTL_PIOSCSTAT_CRPASS 0x00000100  // The last calibration operation
+                                            // completed to meet 1% accuracy
+#define SYSCTL_PIOSCSTAT_CRFAIL 0x00000200  // The last calibration operation
+                                            // failed to meet 1% accuracy
+#define SYSCTL_PIOSCSTAT_CT_M   0x0000007F  // Calibration Trim Value
+#define SYSCTL_PIOSCSTAT_DT_S   16
+#define SYSCTL_PIOSCSTAT_CT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PLLFREQ0
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_PLLFREQ0_PLLPWR  0x00800000  // PLL Power
+#define SYSCTL_PLLFREQ0_MFRAC_M 0x000FFC00  // PLL M Fractional Value
+#define SYSCTL_PLLFREQ0_MINT_M  0x000003FF  // PLL M Integer Value
+#define SYSCTL_PLLFREQ0_MFRAC_S 10
+#define SYSCTL_PLLFREQ0_MINT_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PLLFREQ1
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_PLLFREQ1_Q_M     0x00001F00  // PLL Q Value
+#define SYSCTL_PLLFREQ1_N_M     0x0000001F  // PLL N Value
+#define SYSCTL_PLLFREQ1_Q_S     8
+#define SYSCTL_PLLFREQ1_N_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PLLSTAT register.
+//
+//*****************************************************************************
+#define SYSCTL_PLLSTAT_LOCK     0x00000001  // PLL Lock
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SLPPWRCFG
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_SLPPWRCFG_FLASHPM_M                                            \
+                                0x00000030  // Flash Power Modes
+#define SYSCTL_SLPPWRCFG_FLASHPM_NRM                                          \
+                                0x00000000  // Active Mode
+#define SYSCTL_SLPPWRCFG_FLASHPM_SLP                                          \
+                                0x00000020  // Low Power Mode
+#define SYSCTL_SLPPWRCFG_SRAMPM_M                                             \
+                                0x00000003  // SRAM Power Modes
+#define SYSCTL_SLPPWRCFG_SRAMPM_NRM                                           \
+                                0x00000000  // Active Mode
+#define SYSCTL_SLPPWRCFG_SRAMPM_SBY                                           \
+                                0x00000001  // Standby Mode
+#define SYSCTL_SLPPWRCFG_SRAMPM_LP                                            \
+                                0x00000003  // Low Power Mode
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DSLPPWRCFG
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_DSLPPWRCFG_LDOSM 0x00000200  // LDO Sleep Mode
+#define SYSCTL_DSLPPWRCFG_TSPD  0x00000100  // Temperature Sense Power Down
+#define SYSCTL_DSLPPWRCFG_FLASHPM_M                                           \
+                                0x00000030  // Flash Power Modes
+#define SYSCTL_DSLPPWRCFG_FLASHPM_NRM                                         \
+                                0x00000000  // Active Mode
+#define SYSCTL_DSLPPWRCFG_FLASHPM_SLP                                         \
+                                0x00000020  // Low Power Mode
+#define SYSCTL_DSLPPWRCFG_SRAMPM_M                                            \
+                                0x00000003  // SRAM Power Modes
+#define SYSCTL_DSLPPWRCFG_SRAMPM_NRM                                          \
+                                0x00000000  // Active Mode
+#define SYSCTL_DSLPPWRCFG_SRAMPM_SBY                                          \
+                                0x00000001  // Standby Mode
+#define SYSCTL_DSLPPWRCFG_SRAMPM_LP                                           \
+                                0x00000003  // Low Power Mode
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_NVMSTAT register.
+//
+//*****************************************************************************
+#define SYSCTL_NVMSTAT_FWB      0x00000001  // 32 Word Flash Write Buffer
+                                            // Available
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_LDOSPCTL
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_LDOSPCTL_VADJEN  0x80000000  // Voltage Adjust Enable
+#define SYSCTL_LDOSPCTL_VLDO_M  0x000000FF  // LDO Output Voltage
+#define SYSCTL_LDOSPCTL_VLDO_0_90V                                            \
+                                0x00000012  // 0.90 V
+#define SYSCTL_LDOSPCTL_VLDO_0_95V                                            \
+                                0x00000013  // 0.95 V
+#define SYSCTL_LDOSPCTL_VLDO_1_00V                                            \
+                                0x00000014  // 1.00 V
+#define SYSCTL_LDOSPCTL_VLDO_1_05V                                            \
+                                0x00000015  // 1.05 V
+#define SYSCTL_LDOSPCTL_VLDO_1_10V                                            \
+                                0x00000016  // 1.10 V
+#define SYSCTL_LDOSPCTL_VLDO_1_15V                                            \
+                                0x00000017  // 1.15 V
+#define SYSCTL_LDOSPCTL_VLDO_1_20V                                            \
+                                0x00000018  // 1.20 V
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_LDODPCTL
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_LDODPCTL_VADJEN  0x80000000  // Voltage Adjust Enable
+#define SYSCTL_LDODPCTL_VLDO_M  0x000000FF  // LDO Output Voltage
+#define SYSCTL_LDODPCTL_VLDO_0_90V                                            \
+                                0x00000012  // 0.90 V
+#define SYSCTL_LDODPCTL_VLDO_0_95V                                            \
+                                0x00000013  // 0.95 V
+#define SYSCTL_LDODPCTL_VLDO_1_00V                                            \
+                                0x00000014  // 1.00 V
+#define SYSCTL_LDODPCTL_VLDO_1_05V                                            \
+                                0x00000015  // 1.05 V
+#define SYSCTL_LDODPCTL_VLDO_1_10V                                            \
+                                0x00000016  // 1.10 V
+#define SYSCTL_LDODPCTL_VLDO_1_15V                                            \
+                                0x00000017  // 1.15 V
+#define SYSCTL_LDODPCTL_VLDO_1_20V                                            \
+                                0x00000018  // 1.20 V
+#define SYSCTL_LDODPCTL_VLDO_1_25V                                            \
+                                0x00000019  // 1.25 V
+#define SYSCTL_LDODPCTL_VLDO_1_30V                                            \
+                                0x0000001A  // 1.30 V
+#define SYSCTL_LDODPCTL_VLDO_1_35V                                            \
+                                0x0000001B  // 1.35 V
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RESBEHAVCTL
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_RESBEHAVCTL_WDOG1_M                                            \
+                                0x000000C0  // Watchdog 1 Reset Operation
+#define SYSCTL_RESBEHAVCTL_WDOG1_SYSRST                                       \
+                                0x00000080  // Watchdog 1 issues a system
+                                            // reset. The application starts
+                                            // within 10 us
+#define SYSCTL_RESBEHAVCTL_WDOG1_POR                                          \
+                                0x000000C0  // Watchdog 1 issues a simulated
+                                            // POR sequence. Application starts
+                                            // less than 500 us after
+                                            // deassertion (Default)
+#define SYSCTL_RESBEHAVCTL_WDOG0_M                                            \
+                                0x00000030  // Watchdog 0 Reset Operation
+#define SYSCTL_RESBEHAVCTL_WDOG0_SYSRST                                       \
+                                0x00000020  // Watchdog 0 issues a system
+                                            // reset. The application starts
+                                            // within 10 us
+#define SYSCTL_RESBEHAVCTL_WDOG0_POR                                          \
+                                0x00000030  // Watchdog 0 issues a simulated
+                                            // POR sequence. Application starts
+                                            // less than 500 us after
+                                            // deassertion (Default)
+#define SYSCTL_RESBEHAVCTL_BOR_M                                              \
+                                0x0000000C  // BOR Reset operation
+#define SYSCTL_RESBEHAVCTL_BOR_SYSRST                                         \
+                                0x00000008  // Brown Out Reset issues system
+                                            // reset. The application starts
+                                            // within 10 us
+#define SYSCTL_RESBEHAVCTL_BOR_POR                                            \
+                                0x0000000C  // Brown Out Reset issues a
+                                            // simulated POR sequence. The
+                                            // application starts less than 500
+                                            // us after deassertion (Default)
+#define SYSCTL_RESBEHAVCTL_EXTRES_M                                           \
+                                0x00000003  // External RST Pin Operation
+#define SYSCTL_RESBEHAVCTL_EXTRES_SYSRST                                      \
+                                0x00000002  // External RST assertion issues a
+                                            // system reset. The application
+                                            // starts within 10 us
+#define SYSCTL_RESBEHAVCTL_EXTRES_POR                                         \
+                                0x00000003  // External RST assertion issues a
+                                            // simulated POR sequence.
+                                            // Application starts less than 500
+                                            // us after deassertion (Default)
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_HSSR register.
+//
+//*****************************************************************************
+#define SYSCTL_HSSR_KEY_M       0xFF000000  // Write Key
+#define SYSCTL_HSSR_CDOFF_M     0x00FFFFFF  // Command Descriptor Pointer
+#define SYSCTL_HSSR_KEY_S       24
+#define SYSCTL_HSSR_CDOFF_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_USBPDS register.
+//
+//*****************************************************************************
+#define SYSCTL_USBPDS_MEMSTAT_M 0x0000000C  // Memory Array Power Status
+#define SYSCTL_USBPDS_MEMSTAT_OFF                                             \
+                                0x00000000  // Array OFF
+#define SYSCTL_USBPDS_MEMSTAT_RETAIN                                          \
+                                0x00000004  // SRAM Retention
+#define SYSCTL_USBPDS_MEMSTAT_ON                                              \
+                                0x0000000C  // Array On
+#define SYSCTL_USBPDS_PWRSTAT_M 0x00000003  // Power Domain Status
+#define SYSCTL_USBPDS_PWRSTAT_OFF                                             \
+                                0x00000000  // OFF
+#define SYSCTL_USBPDS_PWRSTAT_ON                                              \
+                                0x00000003  // ON
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_USBMPC register.
+//
+//*****************************************************************************
+#define SYSCTL_USBMPC_PWRCTL_M  0x00000003  // Memory Array Power Control
+#define SYSCTL_USBMPC_PWRCTL_OFF                                              \
+                                0x00000000  // Array OFF
+#define SYSCTL_USBMPC_PWRCTL_RETAIN                                           \
+                                0x00000001  // SRAM Retention
+#define SYSCTL_USBMPC_PWRCTL_ON 0x00000003  // Array On
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_EMACPDS register.
+//
+//*****************************************************************************
+#define SYSCTL_EMACPDS_MEMSTAT_M                                              \
+                                0x0000000C  // Memory Array Power Status
+#define SYSCTL_EMACPDS_MEMSTAT_OFF                                            \
+                                0x00000000  // Array OFF
+#define SYSCTL_EMACPDS_MEMSTAT_ON                                             \
+                                0x0000000C  // Array On
+#define SYSCTL_EMACPDS_PWRSTAT_M                                              \
+                                0x00000003  // Power Domain Status
+#define SYSCTL_EMACPDS_PWRSTAT_OFF                                            \
+                                0x00000000  // OFF
+#define SYSCTL_EMACPDS_PWRSTAT_ON                                             \
+                                0x00000003  // ON
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_EMACMPC register.
+//
+//*****************************************************************************
+#define SYSCTL_EMACMPC_PWRCTL_M 0x00000003  // Memory Array Power Control
+#define SYSCTL_EMACMPC_PWRCTL_OFF                                             \
+                                0x00000000  // Array OFF
+#define SYSCTL_EMACMPC_PWRCTL_ON                                              \
+                                0x00000003  // Array On
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_LCDMPC register.
+//
+//*****************************************************************************
+#define SYSCTL_LCDMPC_PWRCTL_M  0x00000003  // Memory Array Power Control
+#define SYSCTL_LCDMPC_PWRCTL_OFF                                              \
+                                0x00000000  // Array OFF
+#define SYSCTL_LCDMPC_PWRCTL_ON 0x00000003  // Array On
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PPWD register.
+//
+//*****************************************************************************
+#define SYSCTL_PPWD_P1          0x00000002  // Watchdog Timer 1 Present
+#define SYSCTL_PPWD_P0          0x00000001  // Watchdog Timer 0 Present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PPTIMER register.
+//
+//*****************************************************************************
+#define SYSCTL_PPTIMER_P7       0x00000080  // 16/32-Bit General-Purpose Timer
+                                            // 7 Present
+#define SYSCTL_PPTIMER_P6       0x00000040  // 16/32-Bit General-Purpose Timer
+                                            // 6 Present
+#define SYSCTL_PPTIMER_P5       0x00000020  // 16/32-Bit General-Purpose Timer
+                                            // 5 Present
+#define SYSCTL_PPTIMER_P4       0x00000010  // 16/32-Bit General-Purpose Timer
+                                            // 4 Present
+#define SYSCTL_PPTIMER_P3       0x00000008  // 16/32-Bit General-Purpose Timer
+                                            // 3 Present
+#define SYSCTL_PPTIMER_P2       0x00000004  // 16/32-Bit General-Purpose Timer
+                                            // 2 Present
+#define SYSCTL_PPTIMER_P1       0x00000002  // 16/32-Bit General-Purpose Timer
+                                            // 1 Present
+#define SYSCTL_PPTIMER_P0       0x00000001  // 16/32-Bit General-Purpose Timer
+                                            // 0 Present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PPGPIO register.
+//
+//*****************************************************************************
+#define SYSCTL_PPGPIO_P17       0x00020000  // GPIO Port T Present
+#define SYSCTL_PPGPIO_P16       0x00010000  // GPIO Port S Present
+#define SYSCTL_PPGPIO_P15       0x00008000  // GPIO Port R Present
+#define SYSCTL_PPGPIO_P14       0x00004000  // GPIO Port Q Present
+#define SYSCTL_PPGPIO_P13       0x00002000  // GPIO Port P Present
+#define SYSCTL_PPGPIO_P12       0x00001000  // GPIO Port N Present
+#define SYSCTL_PPGPIO_P11       0x00000800  // GPIO Port M Present
+#define SYSCTL_PPGPIO_P10       0x00000400  // GPIO Port L Present
+#define SYSCTL_PPGPIO_P9        0x00000200  // GPIO Port K Present
+#define SYSCTL_PPGPIO_P8        0x00000100  // GPIO Port J Present
+#define SYSCTL_PPGPIO_P7        0x00000080  // GPIO Port H Present
+#define SYSCTL_PPGPIO_P6        0x00000040  // GPIO Port G Present
+#define SYSCTL_PPGPIO_P5        0x00000020  // GPIO Port F Present
+#define SYSCTL_PPGPIO_P4        0x00000010  // GPIO Port E Present
+#define SYSCTL_PPGPIO_P3        0x00000008  // GPIO Port D Present
+#define SYSCTL_PPGPIO_P2        0x00000004  // GPIO Port C Present
+#define SYSCTL_PPGPIO_P1        0x00000002  // GPIO Port B Present
+#define SYSCTL_PPGPIO_P0        0x00000001  // GPIO Port A Present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PPDMA register.
+//
+//*****************************************************************************
+#define SYSCTL_PPDMA_P0         0x00000001  // uDMA Module Present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PPEPI register.
+//
+//*****************************************************************************
+#define SYSCTL_PPEPI_P0         0x00000001  // EPI Module Present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PPHIB register.
+//
+//*****************************************************************************
+#define SYSCTL_PPHIB_P0         0x00000001  // Hibernation Module Present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PPUART register.
+//
+//*****************************************************************************
+#define SYSCTL_PPUART_P7        0x00000080  // UART Module 7 Present
+#define SYSCTL_PPUART_P6        0x00000040  // UART Module 6 Present
+#define SYSCTL_PPUART_P5        0x00000020  // UART Module 5 Present
+#define SYSCTL_PPUART_P4        0x00000010  // UART Module 4 Present
+#define SYSCTL_PPUART_P3        0x00000008  // UART Module 3 Present
+#define SYSCTL_PPUART_P2        0x00000004  // UART Module 2 Present
+#define SYSCTL_PPUART_P1        0x00000002  // UART Module 1 Present
+#define SYSCTL_PPUART_P0        0x00000001  // UART Module 0 Present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PPSSI register.
+//
+//*****************************************************************************
+#define SYSCTL_PPSSI_P3         0x00000008  // SSI Module 3 Present
+#define SYSCTL_PPSSI_P2         0x00000004  // SSI Module 2 Present
+#define SYSCTL_PPSSI_P1         0x00000002  // SSI Module 1 Present
+#define SYSCTL_PPSSI_P0         0x00000001  // SSI Module 0 Present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PPI2C register.
+//
+//*****************************************************************************
+#define SYSCTL_PPI2C_P9         0x00000200  // I2C Module 9 Present
+#define SYSCTL_PPI2C_P8         0x00000100  // I2C Module 8 Present
+#define SYSCTL_PPI2C_P7         0x00000080  // I2C Module 7 Present
+#define SYSCTL_PPI2C_P6         0x00000040  // I2C Module 6 Present
+#define SYSCTL_PPI2C_P5         0x00000020  // I2C Module 5 Present
+#define SYSCTL_PPI2C_P4         0x00000010  // I2C Module 4 Present
+#define SYSCTL_PPI2C_P3         0x00000008  // I2C Module 3 Present
+#define SYSCTL_PPI2C_P2         0x00000004  // I2C Module 2 Present
+#define SYSCTL_PPI2C_P1         0x00000002  // I2C Module 1 Present
+#define SYSCTL_PPI2C_P0         0x00000001  // I2C Module 0 Present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PPUSB register.
+//
+//*****************************************************************************
+#define SYSCTL_PPUSB_P0         0x00000001  // USB Module Present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PPEPHY register.
+//
+//*****************************************************************************
+#define SYSCTL_PPEPHY_P0        0x00000001  // Ethernet PHY Module Present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PPCAN register.
+//
+//*****************************************************************************
+#define SYSCTL_PPCAN_P1         0x00000002  // CAN Module 1 Present
+#define SYSCTL_PPCAN_P0         0x00000001  // CAN Module 0 Present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PPADC register.
+//
+//*****************************************************************************
+#define SYSCTL_PPADC_P1         0x00000002  // ADC Module 1 Present
+#define SYSCTL_PPADC_P0         0x00000001  // ADC Module 0 Present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PPACMP register.
+//
+//*****************************************************************************
+#define SYSCTL_PPACMP_P0        0x00000001  // Analog Comparator Module Present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PPPWM register.
+//
+//*****************************************************************************
+#define SYSCTL_PPPWM_P0         0x00000001  // PWM Module 0 Present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PPQEI register.
+//
+//*****************************************************************************
+#define SYSCTL_PPQEI_P0         0x00000001  // QEI Module 0 Present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PPLPC register.
+//
+//*****************************************************************************
+#define SYSCTL_PPLPC_P0         0x00000001  // LPC Module Present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PPPECI register.
+//
+//*****************************************************************************
+#define SYSCTL_PPPECI_P0        0x00000001  // PECI Module Present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PPFAN register.
+//
+//*****************************************************************************
+#define SYSCTL_PPFAN_P0         0x00000001  // FAN Module 0 Present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PPEEPROM
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_PPEEPROM_P0      0x00000001  // EEPROM Module Present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PPWTIMER
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_PPWTIMER_P0      0x00000001  // 32/64-Bit Wide General-Purpose
+                                            // Timer 0 Present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PPRTS register.
+//
+//*****************************************************************************
+#define SYSCTL_PPRTS_P0         0x00000001  // RTS Module Present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PPCCM register.
+//
+//*****************************************************************************
+#define SYSCTL_PPCCM_P0         0x00000001  // CRC and Cryptographic Modules
+                                            // Present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PPLCD register.
+//
+//*****************************************************************************
+#define SYSCTL_PPLCD_P0         0x00000001  // LCD Module Present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PPOWIRE register.
+//
+//*****************************************************************************
+#define SYSCTL_PPOWIRE_P0       0x00000001  // 1-Wire Module Present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PPEMAC register.
+//
+//*****************************************************************************
+#define SYSCTL_PPEMAC_P0        0x00000001  // Ethernet Controller Module
+                                            // Present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PPHIM register.
+//
+//*****************************************************************************
+#define SYSCTL_PPHIM_P0         0x00000001  // HIM Module Present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SRWD register.
+//
+//*****************************************************************************
+#define SYSCTL_SRWD_R1          0x00000002  // Watchdog Timer 1 Software Reset
+#define SYSCTL_SRWD_R0          0x00000001  // Watchdog Timer 0 Software Reset
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SRTIMER register.
+//
+//*****************************************************************************
+#define SYSCTL_SRTIMER_R7       0x00000080  // 16/32-Bit General-Purpose Timer
+                                            // 7 Software Reset
+#define SYSCTL_SRTIMER_R6       0x00000040  // 16/32-Bit General-Purpose Timer
+                                            // 6 Software Reset
+#define SYSCTL_SRTIMER_R5       0x00000020  // 16/32-Bit General-Purpose Timer
+                                            // 5 Software Reset
+#define SYSCTL_SRTIMER_R4       0x00000010  // 16/32-Bit General-Purpose Timer
+                                            // 4 Software Reset
+#define SYSCTL_SRTIMER_R3       0x00000008  // 16/32-Bit General-Purpose Timer
+                                            // 3 Software Reset
+#define SYSCTL_SRTIMER_R2       0x00000004  // 16/32-Bit General-Purpose Timer
+                                            // 2 Software Reset
+#define SYSCTL_SRTIMER_R1       0x00000002  // 16/32-Bit General-Purpose Timer
+                                            // 1 Software Reset
+#define SYSCTL_SRTIMER_R0       0x00000001  // 16/32-Bit General-Purpose Timer
+                                            // 0 Software Reset
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SRGPIO register.
+//
+//*****************************************************************************
+#define SYSCTL_SRGPIO_R17       0x00020000  // GPIO Port T Software Reset
+#define SYSCTL_SRGPIO_R16       0x00010000  // GPIO Port S Software Reset
+#define SYSCTL_SRGPIO_R15       0x00008000  // GPIO Port R Software Reset
+#define SYSCTL_SRGPIO_R14       0x00004000  // GPIO Port Q Software Reset
+#define SYSCTL_SRGPIO_R13       0x00002000  // GPIO Port P Software Reset
+#define SYSCTL_SRGPIO_R12       0x00001000  // GPIO Port N Software Reset
+#define SYSCTL_SRGPIO_R11       0x00000800  // GPIO Port M Software Reset
+#define SYSCTL_SRGPIO_R10       0x00000400  // GPIO Port L Software Reset
+#define SYSCTL_SRGPIO_R9        0x00000200  // GPIO Port K Software Reset
+#define SYSCTL_SRGPIO_R8        0x00000100  // GPIO Port J Software Reset
+#define SYSCTL_SRGPIO_R7        0x00000080  // GPIO Port H Software Reset
+#define SYSCTL_SRGPIO_R6        0x00000040  // GPIO Port G Software Reset
+#define SYSCTL_SRGPIO_R5        0x00000020  // GPIO Port F Software Reset
+#define SYSCTL_SRGPIO_R4        0x00000010  // GPIO Port E Software Reset
+#define SYSCTL_SRGPIO_R3        0x00000008  // GPIO Port D Software Reset
+#define SYSCTL_SRGPIO_R2        0x00000004  // GPIO Port C Software Reset
+#define SYSCTL_SRGPIO_R1        0x00000002  // GPIO Port B Software Reset
+#define SYSCTL_SRGPIO_R0        0x00000001  // GPIO Port A Software Reset
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SRDMA register.
+//
+//*****************************************************************************
+#define SYSCTL_SRDMA_R0         0x00000001  // uDMA Module Software Reset
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SREPI register.
+//
+//*****************************************************************************
+#define SYSCTL_SREPI_R0         0x00000001  // EPI Module Software Reset
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SRHIB register.
+//
+//*****************************************************************************
+#define SYSCTL_SRHIB_R0         0x00000001  // Hibernation Module Software
+                                            // Reset
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SRUART register.
+//
+//*****************************************************************************
+#define SYSCTL_SRUART_R7        0x00000080  // UART Module 7 Software Reset
+#define SYSCTL_SRUART_R6        0x00000040  // UART Module 6 Software Reset
+#define SYSCTL_SRUART_R5        0x00000020  // UART Module 5 Software Reset
+#define SYSCTL_SRUART_R4        0x00000010  // UART Module 4 Software Reset
+#define SYSCTL_SRUART_R3        0x00000008  // UART Module 3 Software Reset
+#define SYSCTL_SRUART_R2        0x00000004  // UART Module 2 Software Reset
+#define SYSCTL_SRUART_R1        0x00000002  // UART Module 1 Software Reset
+#define SYSCTL_SRUART_R0        0x00000001  // UART Module 0 Software Reset
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SRSSI register.
+//
+//*****************************************************************************
+#define SYSCTL_SRSSI_R3         0x00000008  // SSI Module 3 Software Reset
+#define SYSCTL_SRSSI_R2         0x00000004  // SSI Module 2 Software Reset
+#define SYSCTL_SRSSI_R1         0x00000002  // SSI Module 1 Software Reset
+#define SYSCTL_SRSSI_R0         0x00000001  // SSI Module 0 Software Reset
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SRI2C register.
+//
+//*****************************************************************************
+#define SYSCTL_SRI2C_R9         0x00000200  // I2C Module 9 Software Reset
+#define SYSCTL_SRI2C_R8         0x00000100  // I2C Module 8 Software Reset
+#define SYSCTL_SRI2C_R7         0x00000080  // I2C Module 7 Software Reset
+#define SYSCTL_SRI2C_R6         0x00000040  // I2C Module 6 Software Reset
+#define SYSCTL_SRI2C_R5         0x00000020  // I2C Module 5 Software Reset
+#define SYSCTL_SRI2C_R4         0x00000010  // I2C Module 4 Software Reset
+#define SYSCTL_SRI2C_R3         0x00000008  // I2C Module 3 Software Reset
+#define SYSCTL_SRI2C_R2         0x00000004  // I2C Module 2 Software Reset
+#define SYSCTL_SRI2C_R1         0x00000002  // I2C Module 1 Software Reset
+#define SYSCTL_SRI2C_R0         0x00000001  // I2C Module 0 Software Reset
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SRUSB register.
+//
+//*****************************************************************************
+#define SYSCTL_SRUSB_R0         0x00000001  // USB Module Software Reset
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SREPHY register.
+//
+//*****************************************************************************
+#define SYSCTL_SREPHY_R0        0x00000001  // Ethernet PHY Module Software
+                                            // Reset
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SRCAN register.
+//
+//*****************************************************************************
+#define SYSCTL_SRCAN_R1         0x00000002  // CAN Module 1 Software Reset
+#define SYSCTL_SRCAN_R0         0x00000001  // CAN Module 0 Software Reset
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SRADC register.
+//
+//*****************************************************************************
+#define SYSCTL_SRADC_R1         0x00000002  // ADC Module 1 Software Reset
+#define SYSCTL_SRADC_R0         0x00000001  // ADC Module 0 Software Reset
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SRACMP register.
+//
+//*****************************************************************************
+#define SYSCTL_SRACMP_R0        0x00000001  // Analog Comparator Module 0
+                                            // Software Reset
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SRPWM register.
+//
+//*****************************************************************************
+#define SYSCTL_SRPWM_R0         0x00000001  // PWM Module 0 Software Reset
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SRQEI register.
+//
+//*****************************************************************************
+#define SYSCTL_SRQEI_R0         0x00000001  // QEI Module 0 Software Reset
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SREEPROM
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_SREEPROM_R0      0x00000001  // EEPROM Module Software Reset
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SRCCM register.
+//
+//*****************************************************************************
+#define SYSCTL_SRCCM_R0         0x00000001  // CRC and Cryptographic Modules
+                                            // Software Reset
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SRLCD register.
+//
+//*****************************************************************************
+#define SYSCTL_SRLCD_R0         0x00000001  // LCD Module 0 Software Reset
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SROWIRE register.
+//
+//*****************************************************************************
+#define SYSCTL_SROWIRE_R0       0x00000001  // 1-Wire Module Software Reset
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SREMAC register.
+//
+//*****************************************************************************
+#define SYSCTL_SREMAC_R0        0x00000001  // Ethernet Controller MAC Module 0
+                                            // Software Reset
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGCWD register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGCWD_R1        0x00000002  // Watchdog Timer 1 Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCWD_R0        0x00000001  // Watchdog Timer 0 Run Mode Clock
+                                            // Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGCTIMER
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGCTIMER_R7     0x00000080  // 16/32-Bit General-Purpose Timer
+                                            // 7 Run Mode Clock Gating Control
+#define SYSCTL_RCGCTIMER_R6     0x00000040  // 16/32-Bit General-Purpose Timer
+                                            // 6 Run Mode Clock Gating Control
+#define SYSCTL_RCGCTIMER_R5     0x00000020  // 16/32-Bit General-Purpose Timer
+                                            // 5 Run Mode Clock Gating Control
+#define SYSCTL_RCGCTIMER_R4     0x00000010  // 16/32-Bit General-Purpose Timer
+                                            // 4 Run Mode Clock Gating Control
+#define SYSCTL_RCGCTIMER_R3     0x00000008  // 16/32-Bit General-Purpose Timer
+                                            // 3 Run Mode Clock Gating Control
+#define SYSCTL_RCGCTIMER_R2     0x00000004  // 16/32-Bit General-Purpose Timer
+                                            // 2 Run Mode Clock Gating Control
+#define SYSCTL_RCGCTIMER_R1     0x00000002  // 16/32-Bit General-Purpose Timer
+                                            // 1 Run Mode Clock Gating Control
+#define SYSCTL_RCGCTIMER_R0     0x00000001  // 16/32-Bit General-Purpose Timer
+                                            // 0 Run Mode Clock Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGCGPIO
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGCGPIO_R17     0x00020000  // GPIO Port T Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCGPIO_R16     0x00010000  // GPIO Port S Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCGPIO_R15     0x00008000  // GPIO Port R Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCGPIO_R14     0x00004000  // GPIO Port Q Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCGPIO_R13     0x00002000  // GPIO Port P Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCGPIO_R12     0x00001000  // GPIO Port N Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCGPIO_R11     0x00000800  // GPIO Port M Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCGPIO_R10     0x00000400  // GPIO Port L Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCGPIO_R9      0x00000200  // GPIO Port K Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCGPIO_R8      0x00000100  // GPIO Port J Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCGPIO_R7      0x00000080  // GPIO Port H Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCGPIO_R6      0x00000040  // GPIO Port G Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCGPIO_R5      0x00000020  // GPIO Port F Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCGPIO_R4      0x00000010  // GPIO Port E Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCGPIO_R3      0x00000008  // GPIO Port D Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCGPIO_R2      0x00000004  // GPIO Port C Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCGPIO_R1      0x00000002  // GPIO Port B Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCGPIO_R0      0x00000001  // GPIO Port A Run Mode Clock
+                                            // Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGCDMA register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGCDMA_R0       0x00000001  // uDMA Module Run Mode Clock
+                                            // Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGCEPI register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGCEPI_R0       0x00000001  // EPI Module Run Mode Clock Gating
+                                            // Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGCHIB register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGCHIB_R0       0x00000001  // Hibernation Module Run Mode
+                                            // Clock Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGCUART
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGCUART_R7      0x00000080  // UART Module 7 Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCUART_R6      0x00000040  // UART Module 6 Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCUART_R5      0x00000020  // UART Module 5 Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCUART_R4      0x00000010  // UART Module 4 Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCUART_R3      0x00000008  // UART Module 3 Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCUART_R2      0x00000004  // UART Module 2 Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCUART_R1      0x00000002  // UART Module 1 Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCUART_R0      0x00000001  // UART Module 0 Run Mode Clock
+                                            // Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGCSSI register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGCSSI_R3       0x00000008  // SSI Module 3 Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCSSI_R2       0x00000004  // SSI Module 2 Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCSSI_R1       0x00000002  // SSI Module 1 Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCSSI_R0       0x00000001  // SSI Module 0 Run Mode Clock
+                                            // Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGCI2C register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGCI2C_R9       0x00000200  // I2C Module 9 Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCI2C_R8       0x00000100  // I2C Module 8 Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCI2C_R7       0x00000080  // I2C Module 7 Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCI2C_R6       0x00000040  // I2C Module 6 Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCI2C_R5       0x00000020  // I2C Module 5 Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCI2C_R4       0x00000010  // I2C Module 4 Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCI2C_R3       0x00000008  // I2C Module 3 Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCI2C_R2       0x00000004  // I2C Module 2 Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCI2C_R1       0x00000002  // I2C Module 1 Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCI2C_R0       0x00000001  // I2C Module 0 Run Mode Clock
+                                            // Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGCUSB register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGCUSB_R0       0x00000001  // USB Module Run Mode Clock Gating
+                                            // Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGCEPHY
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGCEPHY_R0      0x00000001  // Ethernet PHY Module Run Mode
+                                            // Clock Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGCCAN register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGCCAN_R1       0x00000002  // CAN Module 1 Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCCAN_R0       0x00000001  // CAN Module 0 Run Mode Clock
+                                            // Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGCADC register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGCADC_R1       0x00000002  // ADC Module 1 Run Mode Clock
+                                            // Gating Control
+#define SYSCTL_RCGCADC_R0       0x00000001  // ADC Module 0 Run Mode Clock
+                                            // Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGCACMP
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGCACMP_R0      0x00000001  // Analog Comparator Module 0 Run
+                                            // Mode Clock Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGCPWM register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGCPWM_R0       0x00000001  // PWM Module 0 Run Mode Clock
+                                            // Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGCQEI register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGCQEI_R0       0x00000001  // QEI Module 0 Run Mode Clock
+                                            // Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGCEEPROM
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGCEEPROM_R0    0x00000001  // EEPROM Module Run Mode Clock
+                                            // Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGCCCM register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGCCCM_R0       0x00000001  // CRC and Cryptographic Modules
+                                            // Run Mode Clock Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGCLCD register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGCLCD_R0       0x00000001  // LCD Controller Module 0 Run Mode
+                                            // Clock Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGCOWIRE
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGCOWIRE_R0     0x00000001  // 1-Wire Module 0 Run Mode Clock
+                                            // Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGCEMAC
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGCEMAC_R0      0x00000001  // Ethernet MAC Module 0 Run Mode
+                                            // Clock Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGCWD register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGCWD_S1        0x00000002  // Watchdog Timer 1 Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_SCGCWD_S0        0x00000001  // Watchdog Timer 0 Sleep Mode
+                                            // Clock Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGCTIMER
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGCTIMER_S7     0x00000080  // 16/32-Bit General-Purpose Timer
+                                            // 7 Sleep Mode Clock Gating
+                                            // Control
+#define SYSCTL_SCGCTIMER_S6     0x00000040  // 16/32-Bit General-Purpose Timer
+                                            // 6 Sleep Mode Clock Gating
+                                            // Control
+#define SYSCTL_SCGCTIMER_S5     0x00000020  // 16/32-Bit General-Purpose Timer
+                                            // 5 Sleep Mode Clock Gating
+                                            // Control
+#define SYSCTL_SCGCTIMER_S4     0x00000010  // 16/32-Bit General-Purpose Timer
+                                            // 4 Sleep Mode Clock Gating
+                                            // Control
+#define SYSCTL_SCGCTIMER_S3     0x00000008  // 16/32-Bit General-Purpose Timer
+                                            // 3 Sleep Mode Clock Gating
+                                            // Control
+#define SYSCTL_SCGCTIMER_S2     0x00000004  // 16/32-Bit General-Purpose Timer
+                                            // 2 Sleep Mode Clock Gating
+                                            // Control
+#define SYSCTL_SCGCTIMER_S1     0x00000002  // 16/32-Bit General-Purpose Timer
+                                            // 1 Sleep Mode Clock Gating
+                                            // Control
+#define SYSCTL_SCGCTIMER_S0     0x00000001  // 16/32-Bit General-Purpose Timer
+                                            // 0 Sleep Mode Clock Gating
+                                            // Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGCGPIO
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGCGPIO_S17     0x00020000  // GPIO Port T Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCGPIO_S16     0x00010000  // GPIO Port S Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCGPIO_S15     0x00008000  // GPIO Port R Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCGPIO_S14     0x00004000  // GPIO Port Q Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCGPIO_S13     0x00002000  // GPIO Port P Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCGPIO_S12     0x00001000  // GPIO Port N Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCGPIO_S11     0x00000800  // GPIO Port M Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCGPIO_S10     0x00000400  // GPIO Port L Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCGPIO_S9      0x00000200  // GPIO Port K Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCGPIO_S8      0x00000100  // GPIO Port J Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCGPIO_S7      0x00000080  // GPIO Port H Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCGPIO_S6      0x00000040  // GPIO Port G Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCGPIO_S5      0x00000020  // GPIO Port F Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCGPIO_S4      0x00000010  // GPIO Port E Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCGPIO_S3      0x00000008  // GPIO Port D Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCGPIO_S2      0x00000004  // GPIO Port C Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCGPIO_S1      0x00000002  // GPIO Port B Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCGPIO_S0      0x00000001  // GPIO Port A Sleep Mode Clock
+                                            // Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGCDMA register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGCDMA_S0       0x00000001  // uDMA Module Sleep Mode Clock
+                                            // Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGCEPI register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGCEPI_S0       0x00000001  // EPI Module Sleep Mode Clock
+                                            // Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGCHIB register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGCHIB_S0       0x00000001  // Hibernation Module Sleep Mode
+                                            // Clock Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGCUART
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGCUART_S7      0x00000080  // UART Module 7 Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCUART_S6      0x00000040  // UART Module 6 Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCUART_S5      0x00000020  // UART Module 5 Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCUART_S4      0x00000010  // UART Module 4 Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCUART_S3      0x00000008  // UART Module 3 Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCUART_S2      0x00000004  // UART Module 2 Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCUART_S1      0x00000002  // UART Module 1 Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCUART_S0      0x00000001  // UART Module 0 Sleep Mode Clock
+                                            // Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGCSSI register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGCSSI_S3       0x00000008  // SSI Module 3 Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCSSI_S2       0x00000004  // SSI Module 2 Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCSSI_S1       0x00000002  // SSI Module 1 Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCSSI_S0       0x00000001  // SSI Module 0 Sleep Mode Clock
+                                            // Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGCI2C register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGCI2C_S9       0x00000200  // I2C Module 9 Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCI2C_S8       0x00000100  // I2C Module 8 Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCI2C_S7       0x00000080  // I2C Module 7 Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCI2C_S6       0x00000040  // I2C Module 6 Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCI2C_S5       0x00000020  // I2C Module 5 Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCI2C_S4       0x00000010  // I2C Module 4 Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCI2C_S3       0x00000008  // I2C Module 3 Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCI2C_S2       0x00000004  // I2C Module 2 Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCI2C_S1       0x00000002  // I2C Module 1 Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCI2C_S0       0x00000001  // I2C Module 0 Sleep Mode Clock
+                                            // Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGCUSB register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGCUSB_S0       0x00000001  // USB Module Sleep Mode Clock
+                                            // Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGCEPHY
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGCEPHY_S0      0x00000001  // PHY Module Sleep Mode Clock
+                                            // Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGCCAN register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGCCAN_S1       0x00000002  // CAN Module 1 Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCCAN_S0       0x00000001  // CAN Module 0 Sleep Mode Clock
+                                            // Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGCADC register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGCADC_S1       0x00000002  // ADC Module 1 Sleep Mode Clock
+                                            // Gating Control
+#define SYSCTL_SCGCADC_S0       0x00000001  // ADC Module 0 Sleep Mode Clock
+                                            // Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGCACMP
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGCACMP_S0      0x00000001  // Analog Comparator Module 0 Sleep
+                                            // Mode Clock Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGCPWM register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGCPWM_S0       0x00000001  // PWM Module 0 Sleep Mode Clock
+                                            // Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGCQEI register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGCQEI_S0       0x00000001  // QEI Module 0 Sleep Mode Clock
+                                            // Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGCEEPROM
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGCEEPROM_S0    0x00000001  // EEPROM Module Sleep Mode Clock
+                                            // Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGCCCM register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGCCCM_S0       0x00000001  // CRC and Cryptographic Modules
+                                            // Sleep Mode Clock Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGCLCD register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGCLCD_S0       0x00000001  // LCD Controller Module 0 Sleep
+                                            // Mode Clock Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGCOWIRE
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGCOWIRE_S0     0x00000001  // 1-Wire Module 0 Sleep Mode Clock
+                                            // Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGCEMAC
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGCEMAC_S0      0x00000001  // Ethernet MAC Module 0 Sleep Mode
+                                            // Clock Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGCWD register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGCWD_D1        0x00000002  // Watchdog Timer 1 Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCWD_D0        0x00000001  // Watchdog Timer 0 Deep-Sleep Mode
+                                            // Clock Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGCTIMER
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGCTIMER_D7     0x00000080  // 16/32-Bit General-Purpose Timer
+                                            // 7 Deep-Sleep Mode Clock Gating
+                                            // Control
+#define SYSCTL_DCGCTIMER_D6     0x00000040  // 16/32-Bit General-Purpose Timer
+                                            // 6 Deep-Sleep Mode Clock Gating
+                                            // Control
+#define SYSCTL_DCGCTIMER_D5     0x00000020  // 16/32-Bit General-Purpose Timer
+                                            // 5 Deep-Sleep Mode Clock Gating
+                                            // Control
+#define SYSCTL_DCGCTIMER_D4     0x00000010  // 16/32-Bit General-Purpose Timer
+                                            // 4 Deep-Sleep Mode Clock Gating
+                                            // Control
+#define SYSCTL_DCGCTIMER_D3     0x00000008  // 16/32-Bit General-Purpose Timer
+                                            // 3 Deep-Sleep Mode Clock Gating
+                                            // Control
+#define SYSCTL_DCGCTIMER_D2     0x00000004  // 16/32-Bit General-Purpose Timer
+                                            // 2 Deep-Sleep Mode Clock Gating
+                                            // Control
+#define SYSCTL_DCGCTIMER_D1     0x00000002  // 16/32-Bit General-Purpose Timer
+                                            // 1 Deep-Sleep Mode Clock Gating
+                                            // Control
+#define SYSCTL_DCGCTIMER_D0     0x00000001  // 16/32-Bit General-Purpose Timer
+                                            // 0 Deep-Sleep Mode Clock Gating
+                                            // Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGCGPIO
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGCGPIO_D17     0x00020000  // GPIO Port T Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCGPIO_D16     0x00010000  // GPIO Port S Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCGPIO_D15     0x00008000  // GPIO Port R Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCGPIO_D14     0x00004000  // GPIO Port Q Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCGPIO_D13     0x00002000  // GPIO Port P Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCGPIO_D12     0x00001000  // GPIO Port N Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCGPIO_D11     0x00000800  // GPIO Port M Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCGPIO_D10     0x00000400  // GPIO Port L Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCGPIO_D9      0x00000200  // GPIO Port K Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCGPIO_D8      0x00000100  // GPIO Port J Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCGPIO_D7      0x00000080  // GPIO Port H Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCGPIO_D6      0x00000040  // GPIO Port G Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCGPIO_D5      0x00000020  // GPIO Port F Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCGPIO_D4      0x00000010  // GPIO Port E Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCGPIO_D3      0x00000008  // GPIO Port D Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCGPIO_D2      0x00000004  // GPIO Port C Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCGPIO_D1      0x00000002  // GPIO Port B Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCGPIO_D0      0x00000001  // GPIO Port A Deep-Sleep Mode
+                                            // Clock Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGCDMA register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGCDMA_D0       0x00000001  // uDMA Module Deep-Sleep Mode
+                                            // Clock Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGCEPI register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGCEPI_D0       0x00000001  // EPI Module Deep-Sleep Mode Clock
+                                            // Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGCHIB register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGCHIB_D0       0x00000001  // Hibernation Module Deep-Sleep
+                                            // Mode Clock Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGCUART
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGCUART_D7      0x00000080  // UART Module 7 Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCUART_D6      0x00000040  // UART Module 6 Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCUART_D5      0x00000020  // UART Module 5 Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCUART_D4      0x00000010  // UART Module 4 Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCUART_D3      0x00000008  // UART Module 3 Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCUART_D2      0x00000004  // UART Module 2 Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCUART_D1      0x00000002  // UART Module 1 Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCUART_D0      0x00000001  // UART Module 0 Deep-Sleep Mode
+                                            // Clock Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGCSSI register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGCSSI_D3       0x00000008  // SSI Module 3 Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCSSI_D2       0x00000004  // SSI Module 2 Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCSSI_D1       0x00000002  // SSI Module 1 Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCSSI_D0       0x00000001  // SSI Module 0 Deep-Sleep Mode
+                                            // Clock Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGCI2C register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGCI2C_D9       0x00000200  // I2C Module 9 Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCI2C_D8       0x00000100  // I2C Module 8 Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCI2C_D7       0x00000080  // I2C Module 7 Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCI2C_D6       0x00000040  // I2C Module 6 Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCI2C_D5       0x00000020  // I2C Module 5 Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCI2C_D4       0x00000010  // I2C Module 4 Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCI2C_D3       0x00000008  // I2C Module 3 Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCI2C_D2       0x00000004  // I2C Module 2 Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCI2C_D1       0x00000002  // I2C Module 1 Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCI2C_D0       0x00000001  // I2C Module 0 Deep-Sleep Mode
+                                            // Clock Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGCUSB register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGCUSB_D0       0x00000001  // USB Module Deep-Sleep Mode Clock
+                                            // Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGCEPHY
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGCEPHY_D0      0x00000001  // PHY Module Deep-Sleep Mode Clock
+                                            // Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGCCAN register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGCCAN_D1       0x00000002  // CAN Module 1 Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCCAN_D0       0x00000001  // CAN Module 0 Deep-Sleep Mode
+                                            // Clock Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGCADC register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGCADC_D1       0x00000002  // ADC Module 1 Deep-Sleep Mode
+                                            // Clock Gating Control
+#define SYSCTL_DCGCADC_D0       0x00000001  // ADC Module 0 Deep-Sleep Mode
+                                            // Clock Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGCACMP
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGCACMP_D0      0x00000001  // Analog Comparator Module 0
+                                            // Deep-Sleep Mode Clock Gating
+                                            // Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGCPWM register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGCPWM_D0       0x00000001  // PWM Module 0 Deep-Sleep Mode
+                                            // Clock Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGCQEI register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGCQEI_D0       0x00000001  // QEI Module 0 Deep-Sleep Mode
+                                            // Clock Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGCEEPROM
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGCEEPROM_D0    0x00000001  // EEPROM Module Deep-Sleep Mode
+                                            // Clock Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGCCCM register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGCCCM_D0       0x00000001  // CRC and Cryptographic Modules
+                                            // Deep-Sleep Mode Clock Gating
+                                            // Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGCLCD register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGCLCD_D0       0x00000001  // LCD Controller Module 0
+                                            // Deep-Sleep Mode Clock Gating
+                                            // Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGCOWIRE
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGCOWIRE_D0     0x00000001  // 1-Wire Module 0 Deep-Sleep Mode
+                                            // Clock Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGCEMAC
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGCEMAC_D0      0x00000001  // Ethernet MAC Module 0 Deep-Sleep
+                                            // Mode Clock Gating Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PCWD register.
+//
+//*****************************************************************************
+#define SYSCTL_PCWD_P1          0x00000002  // Watchdog Timer 1 Power Control
+#define SYSCTL_PCWD_P0          0x00000001  // Watchdog Timer 0 Power Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PCTIMER register.
+//
+//*****************************************************************************
+#define SYSCTL_PCTIMER_P7       0x00000080  // General-Purpose Timer 7 Power
+                                            // Control
+#define SYSCTL_PCTIMER_P6       0x00000040  // General-Purpose Timer 6 Power
+                                            // Control
+#define SYSCTL_PCTIMER_P5       0x00000020  // General-Purpose Timer 5 Power
+                                            // Control
+#define SYSCTL_PCTIMER_P4       0x00000010  // General-Purpose Timer 4 Power
+                                            // Control
+#define SYSCTL_PCTIMER_P3       0x00000008  // General-Purpose Timer 3 Power
+                                            // Control
+#define SYSCTL_PCTIMER_P2       0x00000004  // General-Purpose Timer 2 Power
+                                            // Control
+#define SYSCTL_PCTIMER_P1       0x00000002  // General-Purpose Timer 1 Power
+                                            // Control
+#define SYSCTL_PCTIMER_P0       0x00000001  // General-Purpose Timer 0 Power
+                                            // Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PCGPIO register.
+//
+//*****************************************************************************
+#define SYSCTL_PCGPIO_P17       0x00020000  // GPIO Port T Power Control
+#define SYSCTL_PCGPIO_P16       0x00010000  // GPIO Port S Power Control
+#define SYSCTL_PCGPIO_P15       0x00008000  // GPIO Port R Power Control
+#define SYSCTL_PCGPIO_P14       0x00004000  // GPIO Port Q Power Control
+#define SYSCTL_PCGPIO_P13       0x00002000  // GPIO Port P Power Control
+#define SYSCTL_PCGPIO_P12       0x00001000  // GPIO Port N Power Control
+#define SYSCTL_PCGPIO_P11       0x00000800  // GPIO Port M Power Control
+#define SYSCTL_PCGPIO_P10       0x00000400  // GPIO Port L Power Control
+#define SYSCTL_PCGPIO_P9        0x00000200  // GPIO Port K Power Control
+#define SYSCTL_PCGPIO_P8        0x00000100  // GPIO Port J Power Control
+#define SYSCTL_PCGPIO_P7        0x00000080  // GPIO Port H Power Control
+#define SYSCTL_PCGPIO_P6        0x00000040  // GPIO Port G Power Control
+#define SYSCTL_PCGPIO_P5        0x00000020  // GPIO Port F Power Control
+#define SYSCTL_PCGPIO_P4        0x00000010  // GPIO Port E Power Control
+#define SYSCTL_PCGPIO_P3        0x00000008  // GPIO Port D Power Control
+#define SYSCTL_PCGPIO_P2        0x00000004  // GPIO Port C Power Control
+#define SYSCTL_PCGPIO_P1        0x00000002  // GPIO Port B Power Control
+#define SYSCTL_PCGPIO_P0        0x00000001  // GPIO Port A Power Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PCDMA register.
+//
+//*****************************************************************************
+#define SYSCTL_PCDMA_P0         0x00000001  // uDMA Module Power Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PCEPI register.
+//
+//*****************************************************************************
+#define SYSCTL_PCEPI_P0         0x00000001  // EPI Module Power Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PCHIB register.
+//
+//*****************************************************************************
+#define SYSCTL_PCHIB_P0         0x00000001  // Hibernation Module Power Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PCUART register.
+//
+//*****************************************************************************
+#define SYSCTL_PCUART_P7        0x00000080  // UART Module 7 Power Control
+#define SYSCTL_PCUART_P6        0x00000040  // UART Module 6 Power Control
+#define SYSCTL_PCUART_P5        0x00000020  // UART Module 5 Power Control
+#define SYSCTL_PCUART_P4        0x00000010  // UART Module 4 Power Control
+#define SYSCTL_PCUART_P3        0x00000008  // UART Module 3 Power Control
+#define SYSCTL_PCUART_P2        0x00000004  // UART Module 2 Power Control
+#define SYSCTL_PCUART_P1        0x00000002  // UART Module 1 Power Control
+#define SYSCTL_PCUART_P0        0x00000001  // UART Module 0 Power Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PCSSI register.
+//
+//*****************************************************************************
+#define SYSCTL_PCSSI_P3         0x00000008  // SSI Module 3 Power Control
+#define SYSCTL_PCSSI_P2         0x00000004  // SSI Module 2 Power Control
+#define SYSCTL_PCSSI_P1         0x00000002  // SSI Module 1 Power Control
+#define SYSCTL_PCSSI_P0         0x00000001  // SSI Module 0 Power Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PCI2C register.
+//
+//*****************************************************************************
+#define SYSCTL_PCI2C_P9         0x00000200  // I2C Module 9 Power Control
+#define SYSCTL_PCI2C_P8         0x00000100  // I2C Module 8 Power Control
+#define SYSCTL_PCI2C_P7         0x00000080  // I2C Module 7 Power Control
+#define SYSCTL_PCI2C_P6         0x00000040  // I2C Module 6 Power Control
+#define SYSCTL_PCI2C_P5         0x00000020  // I2C Module 5 Power Control
+#define SYSCTL_PCI2C_P4         0x00000010  // I2C Module 4 Power Control
+#define SYSCTL_PCI2C_P3         0x00000008  // I2C Module 3 Power Control
+#define SYSCTL_PCI2C_P2         0x00000004  // I2C Module 2 Power Control
+#define SYSCTL_PCI2C_P1         0x00000002  // I2C Module 1 Power Control
+#define SYSCTL_PCI2C_P0         0x00000001  // I2C Module 0 Power Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PCUSB register.
+//
+//*****************************************************************************
+#define SYSCTL_PCUSB_P0         0x00000001  // USB Module Power Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PCEPHY register.
+//
+//*****************************************************************************
+#define SYSCTL_PCEPHY_P0        0x00000001  // Ethernet PHY Module Power
+                                            // Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PCCAN register.
+//
+//*****************************************************************************
+#define SYSCTL_PCCAN_P1         0x00000002  // CAN Module 1 Power Control
+#define SYSCTL_PCCAN_P0         0x00000001  // CAN Module 0 Power Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PCADC register.
+//
+//*****************************************************************************
+#define SYSCTL_PCADC_P1         0x00000002  // ADC Module 1 Power Control
+#define SYSCTL_PCADC_P0         0x00000001  // ADC Module 0 Power Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PCACMP register.
+//
+//*****************************************************************************
+#define SYSCTL_PCACMP_P0        0x00000001  // Analog Comparator Module 0 Power
+                                            // Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PCPWM register.
+//
+//*****************************************************************************
+#define SYSCTL_PCPWM_P0         0x00000001  // PWM Module 0 Power Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PCQEI register.
+//
+//*****************************************************************************
+#define SYSCTL_PCQEI_P0         0x00000001  // QEI Module 0 Power Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PCEEPROM
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_PCEEPROM_P0      0x00000001  // EEPROM Module 0 Power Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PCCCM register.
+//
+//*****************************************************************************
+#define SYSCTL_PCCCM_P0         0x00000001  // CRC and Cryptographic Modules
+                                            // Power Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PCLCD register.
+//
+//*****************************************************************************
+#define SYSCTL_PCLCD_P0         0x00000001  // LCD Controller Module 0 Power
+                                            // Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PCOWIRE register.
+//
+//*****************************************************************************
+#define SYSCTL_PCOWIRE_P0       0x00000001  // 1-Wire Module 0 Power Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PCEMAC register.
+//
+//*****************************************************************************
+#define SYSCTL_PCEMAC_P0        0x00000001  // Ethernet MAC Module 0 Power
+                                            // Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PRWD register.
+//
+//*****************************************************************************
+#define SYSCTL_PRWD_R1          0x00000002  // Watchdog Timer 1 Peripheral
+                                            // Ready
+#define SYSCTL_PRWD_R0          0x00000001  // Watchdog Timer 0 Peripheral
+                                            // Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PRTIMER register.
+//
+//*****************************************************************************
+#define SYSCTL_PRTIMER_R7       0x00000080  // 16/32-Bit General-Purpose Timer
+                                            // 7 Peripheral Ready
+#define SYSCTL_PRTIMER_R6       0x00000040  // 16/32-Bit General-Purpose Timer
+                                            // 6 Peripheral Ready
+#define SYSCTL_PRTIMER_R5       0x00000020  // 16/32-Bit General-Purpose Timer
+                                            // 5 Peripheral Ready
+#define SYSCTL_PRTIMER_R4       0x00000010  // 16/32-Bit General-Purpose Timer
+                                            // 4 Peripheral Ready
+#define SYSCTL_PRTIMER_R3       0x00000008  // 16/32-Bit General-Purpose Timer
+                                            // 3 Peripheral Ready
+#define SYSCTL_PRTIMER_R2       0x00000004  // 16/32-Bit General-Purpose Timer
+                                            // 2 Peripheral Ready
+#define SYSCTL_PRTIMER_R1       0x00000002  // 16/32-Bit General-Purpose Timer
+                                            // 1 Peripheral Ready
+#define SYSCTL_PRTIMER_R0       0x00000001  // 16/32-Bit General-Purpose Timer
+                                            // 0 Peripheral Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PRGPIO register.
+//
+//*****************************************************************************
+#define SYSCTL_PRGPIO_R17       0x00020000  // GPIO Port T Peripheral Ready
+#define SYSCTL_PRGPIO_R16       0x00010000  // GPIO Port S Peripheral Ready
+#define SYSCTL_PRGPIO_R15       0x00008000  // GPIO Port R Peripheral Ready
+#define SYSCTL_PRGPIO_R14       0x00004000  // GPIO Port Q Peripheral Ready
+#define SYSCTL_PRGPIO_R13       0x00002000  // GPIO Port P Peripheral Ready
+#define SYSCTL_PRGPIO_R12       0x00001000  // GPIO Port N Peripheral Ready
+#define SYSCTL_PRGPIO_R11       0x00000800  // GPIO Port M Peripheral Ready
+#define SYSCTL_PRGPIO_R10       0x00000400  // GPIO Port L Peripheral Ready
+#define SYSCTL_PRGPIO_R9        0x00000200  // GPIO Port K Peripheral Ready
+#define SYSCTL_PRGPIO_R8        0x00000100  // GPIO Port J Peripheral Ready
+#define SYSCTL_PRGPIO_R7        0x00000080  // GPIO Port H Peripheral Ready
+#define SYSCTL_PRGPIO_R6        0x00000040  // GPIO Port G Peripheral Ready
+#define SYSCTL_PRGPIO_R5        0x00000020  // GPIO Port F Peripheral Ready
+#define SYSCTL_PRGPIO_R4        0x00000010  // GPIO Port E Peripheral Ready
+#define SYSCTL_PRGPIO_R3        0x00000008  // GPIO Port D Peripheral Ready
+#define SYSCTL_PRGPIO_R2        0x00000004  // GPIO Port C Peripheral Ready
+#define SYSCTL_PRGPIO_R1        0x00000002  // GPIO Port B Peripheral Ready
+#define SYSCTL_PRGPIO_R0        0x00000001  // GPIO Port A Peripheral Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PRDMA register.
+//
+//*****************************************************************************
+#define SYSCTL_PRDMA_R0         0x00000001  // uDMA Module Peripheral Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PREPI register.
+//
+//*****************************************************************************
+#define SYSCTL_PREPI_R0         0x00000001  // EPI Module Peripheral Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PRHIB register.
+//
+//*****************************************************************************
+#define SYSCTL_PRHIB_R0         0x00000001  // Hibernation Module Peripheral
+                                            // Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PRUART register.
+//
+//*****************************************************************************
+#define SYSCTL_PRUART_R7        0x00000080  // UART Module 7 Peripheral Ready
+#define SYSCTL_PRUART_R6        0x00000040  // UART Module 6 Peripheral Ready
+#define SYSCTL_PRUART_R5        0x00000020  // UART Module 5 Peripheral Ready
+#define SYSCTL_PRUART_R4        0x00000010  // UART Module 4 Peripheral Ready
+#define SYSCTL_PRUART_R3        0x00000008  // UART Module 3 Peripheral Ready
+#define SYSCTL_PRUART_R2        0x00000004  // UART Module 2 Peripheral Ready
+#define SYSCTL_PRUART_R1        0x00000002  // UART Module 1 Peripheral Ready
+#define SYSCTL_PRUART_R0        0x00000001  // UART Module 0 Peripheral Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PRSSI register.
+//
+//*****************************************************************************
+#define SYSCTL_PRSSI_R3         0x00000008  // SSI Module 3 Peripheral Ready
+#define SYSCTL_PRSSI_R2         0x00000004  // SSI Module 2 Peripheral Ready
+#define SYSCTL_PRSSI_R1         0x00000002  // SSI Module 1 Peripheral Ready
+#define SYSCTL_PRSSI_R0         0x00000001  // SSI Module 0 Peripheral Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PRI2C register.
+//
+//*****************************************************************************
+#define SYSCTL_PRI2C_R9         0x00000200  // I2C Module 9 Peripheral Ready
+#define SYSCTL_PRI2C_R8         0x00000100  // I2C Module 8 Peripheral Ready
+#define SYSCTL_PRI2C_R7         0x00000080  // I2C Module 7 Peripheral Ready
+#define SYSCTL_PRI2C_R6         0x00000040  // I2C Module 6 Peripheral Ready
+#define SYSCTL_PRI2C_R5         0x00000020  // I2C Module 5 Peripheral Ready
+#define SYSCTL_PRI2C_R4         0x00000010  // I2C Module 4 Peripheral Ready
+#define SYSCTL_PRI2C_R3         0x00000008  // I2C Module 3 Peripheral Ready
+#define SYSCTL_PRI2C_R2         0x00000004  // I2C Module 2 Peripheral Ready
+#define SYSCTL_PRI2C_R1         0x00000002  // I2C Module 1 Peripheral Ready
+#define SYSCTL_PRI2C_R0         0x00000001  // I2C Module 0 Peripheral Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PRUSB register.
+//
+//*****************************************************************************
+#define SYSCTL_PRUSB_R0         0x00000001  // USB Module Peripheral Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PREPHY register.
+//
+//*****************************************************************************
+#define SYSCTL_PREPHY_R0        0x00000001  // Ethernet PHY Module Peripheral
+                                            // Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PRCAN register.
+//
+//*****************************************************************************
+#define SYSCTL_PRCAN_R1         0x00000002  // CAN Module 1 Peripheral Ready
+#define SYSCTL_PRCAN_R0         0x00000001  // CAN Module 0 Peripheral Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PRADC register.
+//
+//*****************************************************************************
+#define SYSCTL_PRADC_R1         0x00000002  // ADC Module 1 Peripheral Ready
+#define SYSCTL_PRADC_R0         0x00000001  // ADC Module 0 Peripheral Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PRACMP register.
+//
+//*****************************************************************************
+#define SYSCTL_PRACMP_R0        0x00000001  // Analog Comparator Module 0
+                                            // Peripheral Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PRPWM register.
+//
+//*****************************************************************************
+#define SYSCTL_PRPWM_R0         0x00000001  // PWM Module 0 Peripheral Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PRQEI register.
+//
+//*****************************************************************************
+#define SYSCTL_PRQEI_R0         0x00000001  // QEI Module 0 Peripheral Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PREEPROM
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_PREEPROM_R0      0x00000001  // EEPROM Module Peripheral Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PRCCM register.
+//
+//*****************************************************************************
+#define SYSCTL_PRCCM_R0         0x00000001  // CRC and Cryptographic Modules
+                                            // Peripheral Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PRLCD register.
+//
+//*****************************************************************************
+#define SYSCTL_PRLCD_R0         0x00000001  // LCD Controller Module 0
+                                            // Peripheral Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PROWIRE register.
+//
+//*****************************************************************************
+#define SYSCTL_PROWIRE_R0       0x00000001  // 1-Wire Module 0 Peripheral Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PREMAC register.
+//
+//*****************************************************************************
+#define SYSCTL_PREMAC_R0        0x00000001  // Ethernet MAC Module 0 Peripheral
+                                            // Ready
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_CCMCGREQ
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_CCMCGREQ_DESCFG  0x00000004  // DES Clock Gating Request
+#define SYSCTL_CCMCGREQ_AESCFG  0x00000002  // AES Clock Gating Request
+#define SYSCTL_CCMCGREQ_SHACFG  0x00000001  // SHA/MD5 Clock Gating Request
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_STAT register.
+//
+//*****************************************************************************
+#define UDMA_STAT_DMACHANS_M    0x001F0000  // Available uDMA Channels Minus 1
+#define UDMA_STAT_STATE_M       0x000000F0  // Control State Machine Status
+#define UDMA_STAT_STATE_IDLE    0x00000000  // Idle
+#define UDMA_STAT_STATE_RD_CTRL 0x00000010  // Reading channel controller data
+#define UDMA_STAT_STATE_RD_SRCENDP                                            \
+                                0x00000020  // Reading source end pointer
+#define UDMA_STAT_STATE_RD_DSTENDP                                            \
+                                0x00000030  // Reading destination end pointer
+#define UDMA_STAT_STATE_RD_SRCDAT                                             \
+                                0x00000040  // Reading source data
+#define UDMA_STAT_STATE_WR_DSTDAT                                             \
+                                0x00000050  // Writing destination data
+#define UDMA_STAT_STATE_WAIT    0x00000060  // Waiting for uDMA request to
+                                            // clear
+#define UDMA_STAT_STATE_WR_CTRL 0x00000070  // Writing channel controller data
+#define UDMA_STAT_STATE_STALL   0x00000080  // Stalled
+#define UDMA_STAT_STATE_DONE    0x00000090  // Done
+#define UDMA_STAT_STATE_UNDEF   0x000000A0  // Undefined
+#define UDMA_STAT_MASTEN        0x00000001  // Master Enable Status
+#define UDMA_STAT_DMACHANS_S    16
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_CFG register.
+//
+//*****************************************************************************
+#define UDMA_CFG_MASTEN         0x00000001  // Controller Master Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_CTLBASE register.
+//
+//*****************************************************************************
+#define UDMA_CTLBASE_ADDR_M     0xFFFFFC00  // Channel Control Base Address
+#define UDMA_CTLBASE_ADDR_S     10
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_ALTBASE register.
+//
+//*****************************************************************************
+#define UDMA_ALTBASE_ADDR_M     0xFFFFFFFF  // Alternate Channel Address
+                                            // Pointer
+#define UDMA_ALTBASE_ADDR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_WAITSTAT register.
+//
+//*****************************************************************************
+#define UDMA_WAITSTAT_WAITREQ_M 0xFFFFFFFF  // Channel [n] Wait Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_SWREQ register.
+//
+//*****************************************************************************
+#define UDMA_SWREQ_M            0xFFFFFFFF  // Channel [n] Software Request
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_USEBURSTSET
+// register.
+//
+//*****************************************************************************
+#define UDMA_USEBURSTSET_SET_M  0xFFFFFFFF  // Channel [n] Useburst Set
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_USEBURSTCLR
+// register.
+//
+//*****************************************************************************
+#define UDMA_USEBURSTCLR_CLR_M  0xFFFFFFFF  // Channel [n] Useburst Clear
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_REQMASKSET
+// register.
+//
+//*****************************************************************************
+#define UDMA_REQMASKSET_SET_M   0xFFFFFFFF  // Channel [n] Request Mask Set
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_REQMASKCLR
+// register.
+//
+//*****************************************************************************
+#define UDMA_REQMASKCLR_CLR_M   0xFFFFFFFF  // Channel [n] Request Mask Clear
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_ENASET register.
+//
+//*****************************************************************************
+#define UDMA_ENASET_SET_M       0xFFFFFFFF  // Channel [n] Enable Set
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_ENACLR register.
+//
+//*****************************************************************************
+#define UDMA_ENACLR_CLR_M       0xFFFFFFFF  // Clear Channel [n] Enable Clear
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_ALTSET register.
+//
+//*****************************************************************************
+#define UDMA_ALTSET_SET_M       0xFFFFFFFF  // Channel [n] Alternate Set
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_ALTCLR register.
+//
+//*****************************************************************************
+#define UDMA_ALTCLR_CLR_M       0xFFFFFFFF  // Channel [n] Alternate Clear
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_PRIOSET register.
+//
+//*****************************************************************************
+#define UDMA_PRIOSET_SET_M      0xFFFFFFFF  // Channel [n] Priority Set
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_PRIOCLR register.
+//
+//*****************************************************************************
+#define UDMA_PRIOCLR_CLR_M      0xFFFFFFFF  // Channel [n] Priority Clear
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_ERRCLR register.
+//
+//*****************************************************************************
+#define UDMA_ERRCLR_ERRCLR      0x00000001  // uDMA Bus Error Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_CHASGN register.
+//
+//*****************************************************************************
+#define UDMA_CHASGN_M           0xFFFFFFFF  // Channel [n] Assignment Select
+#define UDMA_CHASGN_PRIMARY     0x00000000  // Use the primary channel
+                                            // assignment
+#define UDMA_CHASGN_SECONDARY   0x00000001  // Use the secondary channel
+                                            // assignment
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_CHMAP0 register.
+//
+//*****************************************************************************
+#define UDMA_CHMAP0_CH7SEL_M    0xF0000000  // uDMA Channel 7 Source Select
+#define UDMA_CHMAP0_CH6SEL_M    0x0F000000  // uDMA Channel 6 Source Select
+#define UDMA_CHMAP0_CH5SEL_M    0x00F00000  // uDMA Channel 5 Source Select
+#define UDMA_CHMAP0_CH4SEL_M    0x000F0000  // uDMA Channel 4 Source Select
+#define UDMA_CHMAP0_CH3SEL_M    0x0000F000  // uDMA Channel 3 Source Select
+#define UDMA_CHMAP0_CH2SEL_M    0x00000F00  // uDMA Channel 2 Source Select
+#define UDMA_CHMAP0_CH1SEL_M    0x000000F0  // uDMA Channel 1 Source Select
+#define UDMA_CHMAP0_CH0SEL_M    0x0000000F  // uDMA Channel 0 Source Select
+#define UDMA_CHMAP0_CH7SEL_S    28
+#define UDMA_CHMAP0_CH6SEL_S    24
+#define UDMA_CHMAP0_CH5SEL_S    20
+#define UDMA_CHMAP0_CH4SEL_S    16
+#define UDMA_CHMAP0_CH3SEL_S    12
+#define UDMA_CHMAP0_CH2SEL_S    8
+#define UDMA_CHMAP0_CH1SEL_S    4
+#define UDMA_CHMAP0_CH0SEL_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_CHMAP1 register.
+//
+//*****************************************************************************
+#define UDMA_CHMAP1_CH15SEL_M   0xF0000000  // uDMA Channel 15 Source Select
+#define UDMA_CHMAP1_CH14SEL_M   0x0F000000  // uDMA Channel 14 Source Select
+#define UDMA_CHMAP1_CH13SEL_M   0x00F00000  // uDMA Channel 13 Source Select
+#define UDMA_CHMAP1_CH12SEL_M   0x000F0000  // uDMA Channel 12 Source Select
+#define UDMA_CHMAP1_CH11SEL_M   0x0000F000  // uDMA Channel 11 Source Select
+#define UDMA_CHMAP1_CH10SEL_M   0x00000F00  // uDMA Channel 10 Source Select
+#define UDMA_CHMAP1_CH9SEL_M    0x000000F0  // uDMA Channel 9 Source Select
+#define UDMA_CHMAP1_CH8SEL_M    0x0000000F  // uDMA Channel 8 Source Select
+#define UDMA_CHMAP1_CH15SEL_S   28
+#define UDMA_CHMAP1_CH14SEL_S   24
+#define UDMA_CHMAP1_CH13SEL_S   20
+#define UDMA_CHMAP1_CH12SEL_S   16
+#define UDMA_CHMAP1_CH11SEL_S   12
+#define UDMA_CHMAP1_CH10SEL_S   8
+#define UDMA_CHMAP1_CH9SEL_S    4
+#define UDMA_CHMAP1_CH8SEL_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_CHMAP2 register.
+//
+//*****************************************************************************
+#define UDMA_CHMAP2_CH23SEL_M   0xF0000000  // uDMA Channel 23 Source Select
+#define UDMA_CHMAP2_CH22SEL_M   0x0F000000  // uDMA Channel 22 Source Select
+#define UDMA_CHMAP2_CH21SEL_M   0x00F00000  // uDMA Channel 21 Source Select
+#define UDMA_CHMAP2_CH20SEL_M   0x000F0000  // uDMA Channel 20 Source Select
+#define UDMA_CHMAP2_CH19SEL_M   0x0000F000  // uDMA Channel 19 Source Select
+#define UDMA_CHMAP2_CH18SEL_M   0x00000F00  // uDMA Channel 18 Source Select
+#define UDMA_CHMAP2_CH17SEL_M   0x000000F0  // uDMA Channel 17 Source Select
+#define UDMA_CHMAP2_CH16SEL_M   0x0000000F  // uDMA Channel 16 Source Select
+#define UDMA_CHMAP2_CH23SEL_S   28
+#define UDMA_CHMAP2_CH22SEL_S   24
+#define UDMA_CHMAP2_CH21SEL_S   20
+#define UDMA_CHMAP2_CH20SEL_S   16
+#define UDMA_CHMAP2_CH19SEL_S   12
+#define UDMA_CHMAP2_CH18SEL_S   8
+#define UDMA_CHMAP2_CH17SEL_S   4
+#define UDMA_CHMAP2_CH16SEL_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_CHMAP3 register.
+//
+//*****************************************************************************
+#define UDMA_CHMAP3_CH31SEL_M   0xF0000000  // uDMA Channel 31 Source Select
+#define UDMA_CHMAP3_CH30SEL_M   0x0F000000  // uDMA Channel 30 Source Select
+#define UDMA_CHMAP3_CH29SEL_M   0x00F00000  // uDMA Channel 29 Source Select
+#define UDMA_CHMAP3_CH28SEL_M   0x000F0000  // uDMA Channel 28 Source Select
+#define UDMA_CHMAP3_CH27SEL_M   0x0000F000  // uDMA Channel 27 Source Select
+#define UDMA_CHMAP3_CH26SEL_M   0x00000F00  // uDMA Channel 26 Source Select
+#define UDMA_CHMAP3_CH25SEL_M   0x000000F0  // uDMA Channel 25 Source Select
+#define UDMA_CHMAP3_CH24SEL_M   0x0000000F  // uDMA Channel 24 Source Select
+#define UDMA_CHMAP3_CH31SEL_S   28
+#define UDMA_CHMAP3_CH30SEL_S   24
+#define UDMA_CHMAP3_CH29SEL_S   20
+#define UDMA_CHMAP3_CH28SEL_S   16
+#define UDMA_CHMAP3_CH27SEL_S   12
+#define UDMA_CHMAP3_CH26SEL_S   8
+#define UDMA_CHMAP3_CH25SEL_S   4
+#define UDMA_CHMAP3_CH24SEL_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_O_SRCENDP register.
+//
+//*****************************************************************************
+#define UDMA_SRCENDP_ADDR_M     0xFFFFFFFF  // Source Address End Pointer
+#define UDMA_SRCENDP_ADDR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_O_DSTENDP register.
+//
+//*****************************************************************************
+#define UDMA_DSTENDP_ADDR_M     0xFFFFFFFF  // Destination Address End Pointer
+#define UDMA_DSTENDP_ADDR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_O_CHCTL register.
+//
+//*****************************************************************************
+#define UDMA_CHCTL_DSTINC_M     0xC0000000  // Destination Address Increment
+#define UDMA_CHCTL_DSTINC_8     0x00000000  // Byte
+#define UDMA_CHCTL_DSTINC_16    0x40000000  // Half-word
+#define UDMA_CHCTL_DSTINC_32    0x80000000  // Word
+#define UDMA_CHCTL_DSTINC_NONE  0xC0000000  // No increment
+#define UDMA_CHCTL_DSTSIZE_M    0x30000000  // Destination Data Size
+#define UDMA_CHCTL_DSTSIZE_8    0x00000000  // Byte
+#define UDMA_CHCTL_DSTSIZE_16   0x10000000  // Half-word
+#define UDMA_CHCTL_DSTSIZE_32   0x20000000  // Word
+#define UDMA_CHCTL_SRCINC_M     0x0C000000  // Source Address Increment
+#define UDMA_CHCTL_SRCINC_8     0x00000000  // Byte
+#define UDMA_CHCTL_SRCINC_16    0x04000000  // Half-word
+#define UDMA_CHCTL_SRCINC_32    0x08000000  // Word
+#define UDMA_CHCTL_SRCINC_NONE  0x0C000000  // No increment
+#define UDMA_CHCTL_SRCSIZE_M    0x03000000  // Source Data Size
+#define UDMA_CHCTL_SRCSIZE_8    0x00000000  // Byte
+#define UDMA_CHCTL_SRCSIZE_16   0x01000000  // Half-word
+#define UDMA_CHCTL_SRCSIZE_32   0x02000000  // Word
+#define UDMA_CHCTL_DSTPROT0     0x00200000  // Destination Privilege Access
+#define UDMA_CHCTL_SRCPROT0     0x00040000  // Source Privilege Access
+#define UDMA_CHCTL_ARBSIZE_M    0x0003C000  // Arbitration Size
+#define UDMA_CHCTL_ARBSIZE_1    0x00000000  // 1 Transfer
+#define UDMA_CHCTL_ARBSIZE_2    0x00004000  // 2 Transfers
+#define UDMA_CHCTL_ARBSIZE_4    0x00008000  // 4 Transfers
+#define UDMA_CHCTL_ARBSIZE_8    0x0000C000  // 8 Transfers
+#define UDMA_CHCTL_ARBSIZE_16   0x00010000  // 16 Transfers
+#define UDMA_CHCTL_ARBSIZE_32   0x00014000  // 32 Transfers
+#define UDMA_CHCTL_ARBSIZE_64   0x00018000  // 64 Transfers
+#define UDMA_CHCTL_ARBSIZE_128  0x0001C000  // 128 Transfers
+#define UDMA_CHCTL_ARBSIZE_256  0x00020000  // 256 Transfers
+#define UDMA_CHCTL_ARBSIZE_512  0x00024000  // 512 Transfers
+#define UDMA_CHCTL_ARBSIZE_1024 0x00028000  // 1024 Transfers
+#define UDMA_CHCTL_XFERSIZE_M   0x00003FF0  // Transfer Size (minus 1)
+#define UDMA_CHCTL_NXTUSEBURST  0x00000008  // Next Useburst
+#define UDMA_CHCTL_XFERMODE_M   0x00000007  // uDMA Transfer Mode
+#define UDMA_CHCTL_XFERMODE_STOP                                              \
+                                0x00000000  // Stop
+#define UDMA_CHCTL_XFERMODE_BASIC                                             \
+                                0x00000001  // Basic
+#define UDMA_CHCTL_XFERMODE_AUTO                                              \
+                                0x00000002  // Auto-Request
+#define UDMA_CHCTL_XFERMODE_PINGPONG                                          \
+                                0x00000003  // Ping-Pong
+#define UDMA_CHCTL_XFERMODE_MEM_SG                                            \
+                                0x00000004  // Memory Scatter-Gather
+#define UDMA_CHCTL_XFERMODE_MEM_SGA                                           \
+                                0x00000005  // Alternate Memory Scatter-Gather
+#define UDMA_CHCTL_XFERMODE_PER_SG                                            \
+                                0x00000006  // Peripheral Scatter-Gather
+#define UDMA_CHCTL_XFERMODE_PER_SGA                                           \
+                                0x00000007  // Alternate Peripheral
+                                            // Scatter-Gather
+#define UDMA_CHCTL_XFERSIZE_S   4
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CCM_O_CRCCTRL register.
+//
+//*****************************************************************************
+#define CCM_CRCCTRL_INIT_M      0x00006000  // CRC Initialization
+#define CCM_CRCCTRL_INIT_SEED   0x00000000  // Use the CRCSEED register context
+                                            // as the starting value
+#define CCM_CRCCTRL_INIT_0      0x00004000  // Initialize to all '0s'
+#define CCM_CRCCTRL_INIT_1      0x00006000  // Initialize to all '1s'
+#define CCM_CRCCTRL_SIZE        0x00001000  // Input Data Size
+#define CCM_CRCCTRL_RESINV      0x00000200  // Result Inverse Enable
+#define CCM_CRCCTRL_OBR         0x00000100  // Output Reverse Enable
+#define CCM_CRCCTRL_BR          0x00000080  // Bit reverse enable
+#define CCM_CRCCTRL_ENDIAN_M    0x00000030  // Endian Control
+#define CCM_CRCCTRL_ENDIAN_SBHW 0x00000000  // Configuration unchanged. (B3,
+                                            // B2, B1, B0)
+#define CCM_CRCCTRL_ENDIAN_SHW  0x00000010  // Bytes are swapped in half-words
+                                            // but half-words are not swapped
+                                            // (B2, B3, B0, B1)
+#define CCM_CRCCTRL_ENDIAN_SHWNB                                              \
+                                0x00000020  // Half-words are swapped but bytes
+                                            // are not swapped in half-word.
+                                            // (B1, B0, B3, B2)
+#define CCM_CRCCTRL_ENDIAN_SBSW 0x00000030  // Bytes are swapped in half-words
+                                            // and half-words are swapped. (B0,
+                                            // B1, B2, B3)
+#define CCM_CRCCTRL_TYPE_M      0x0000000F  // Operation Type
+#define CCM_CRCCTRL_TYPE_P8055  0x00000000  // Polynomial 0x8005
+#define CCM_CRCCTRL_TYPE_P1021  0x00000001  // Polynomial 0x1021
+#define CCM_CRCCTRL_TYPE_P4C11DB7                                             \
+                                0x00000002  // Polynomial 0x4C11DB7
+#define CCM_CRCCTRL_TYPE_P1EDC6F41                                            \
+                                0x00000003  // Polynomial 0x1EDC6F41
+#define CCM_CRCCTRL_TYPE_TCPCHKSUM                                            \
+                                0x00000008  // TCP checksum
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CCM_O_CRCSEED register.
+//
+//*****************************************************************************
+#define CCM_CRCSEED_SEED_M      0xFFFFFFFF  // SEED/Context Value
+#define CCM_CRCSEED_SEED_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CCM_O_CRCDIN register.
+//
+//*****************************************************************************
+#define CCM_CRCDIN_DATAIN_M     0xFFFFFFFF  // Data Input
+#define CCM_CRCDIN_DATAIN_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CCM_O_CRCRSLTPP
+// register.
+//
+//*****************************************************************************
+#define CCM_CRCRSLTPP_RSLTPP_M  0xFFFFFFFF  // Post Processing Result
+#define CCM_CRCRSLTPP_RSLTPP_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_ODIGEST_A
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_ODIGEST_A_DATA_M 0xFFFFFFFF  // Digest/Key Data
+#define SHAMD5_ODIGEST_A_DATA_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_ODIGEST_B
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_ODIGEST_B_DATA_M 0xFFFFFFFF  // Digest/Key Data
+#define SHAMD5_ODIGEST_B_DATA_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_ODIGEST_C
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_ODIGEST_C_DATA_M 0xFFFFFFFF  // Digest/Key Data
+#define SHAMD5_ODIGEST_C_DATA_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_ODIGEST_D
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_ODIGEST_D_DATA_M 0xFFFFFFFF  // Digest/Key Data
+#define SHAMD5_ODIGEST_D_DATA_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_ODIGEST_E
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_ODIGEST_E_DATA_M 0xFFFFFFFF  // Digest/Key Data
+#define SHAMD5_ODIGEST_E_DATA_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_ODIGEST_F
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_ODIGEST_F_DATA_M 0xFFFFFFFF  // Digest/Key Data
+#define SHAMD5_ODIGEST_F_DATA_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_ODIGEST_G
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_ODIGEST_G_DATA_M 0xFFFFFFFF  // Digest/Key Data
+#define SHAMD5_ODIGEST_G_DATA_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_ODIGEST_H
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_ODIGEST_H_DATA_M 0xFFFFFFFF  // Digest/Key Data
+#define SHAMD5_ODIGEST_H_DATA_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_IDIGEST_A
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_IDIGEST_A_DATA_M 0xFFFFFFFF  // Digest/Key Data
+#define SHAMD5_IDIGEST_A_DATA_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_IDIGEST_B
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_IDIGEST_B_DATA_M 0xFFFFFFFF  // Digest/Key Data
+#define SHAMD5_IDIGEST_B_DATA_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_IDIGEST_C
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_IDIGEST_C_DATA_M 0xFFFFFFFF  // Digest/Key Data
+#define SHAMD5_IDIGEST_C_DATA_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_IDIGEST_D
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_IDIGEST_D_DATA_M 0xFFFFFFFF  // Digest/Key Data
+#define SHAMD5_IDIGEST_D_DATA_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_IDIGEST_E
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_IDIGEST_E_DATA_M 0xFFFFFFFF  // Digest/Key Data
+#define SHAMD5_IDIGEST_E_DATA_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_IDIGEST_F
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_IDIGEST_F_DATA_M 0xFFFFFFFF  // Digest/Key Data
+#define SHAMD5_IDIGEST_F_DATA_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_IDIGEST_G
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_IDIGEST_G_DATA_M 0xFFFFFFFF  // Digest/Key Data
+#define SHAMD5_IDIGEST_G_DATA_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_IDIGEST_H
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_IDIGEST_H_DATA_M 0xFFFFFFFF  // Digest/Key Data
+#define SHAMD5_IDIGEST_H_DATA_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_DIGEST_COUNT
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_DIGEST_COUNT_M   0xFFFFFFFF  // Digest Count
+#define SHAMD5_DIGEST_COUNT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_MODE register.
+//
+//*****************************************************************************
+#define SHAMD5_MODE_HMAC_OUTER_HASH                                           \
+                                0x00000080  // HMAC Outer Hash Processing
+                                            // Enable
+#define SHAMD5_MODE_HMAC_KEY_PROC                                             \
+                                0x00000020  // HMAC Key Processing Enable
+#define SHAMD5_MODE_CLOSE_HASH  0x00000010  // Performs the padding, the
+                                            // Hash/HMAC will be 'closed' at
+                                            // the end of the block, as per
+                                            // MD5/SHA-1/SHA-2 specification
+#define SHAMD5_MODE_ALGO_CONSTANT                                             \
+                                0x00000008  // The initial digest register will
+                                            // be overwritten with the
+                                            // algorithm constants for the
+                                            // selected algorithm when hashing
+                                            // and the initial digest count
+                                            // register will be reset to 0
+#define SHAMD5_MODE_ALGO_M      0x00000007  // Hash Algorithm
+#define SHAMD5_MODE_ALGO_MD5    0x00000000  // MD5
+#define SHAMD5_MODE_ALGO_SHA1   0x00000002  // SHA-1
+#define SHAMD5_MODE_ALGO_SHA224 0x00000004  // SHA-224
+#define SHAMD5_MODE_ALGO_SHA256 0x00000006  // SHA-256
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_LENGTH
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_LENGTH_M         0xFFFFFFFF  // Block Length/Remaining Byte
+                                            // Count
+#define SHAMD5_LENGTH_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_DATA_0_IN
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_DATA_0_IN_DATA_M 0xFFFFFFFF  // Digest/Key Data
+#define SHAMD5_DATA_0_IN_DATA_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_DATA_1_IN
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_DATA_1_IN_DATA_M 0xFFFFFFFF  // Digest/Key Data
+#define SHAMD5_DATA_1_IN_DATA_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_DATA_2_IN
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_DATA_2_IN_DATA_M 0xFFFFFFFF  // Digest/Key Data
+#define SHAMD5_DATA_2_IN_DATA_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_DATA_3_IN
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_DATA_3_IN_DATA_M 0xFFFFFFFF  // Digest/Key Data
+#define SHAMD5_DATA_3_IN_DATA_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_DATA_4_IN
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_DATA_4_IN_DATA_M 0xFFFFFFFF  // Digest/Key Data
+#define SHAMD5_DATA_4_IN_DATA_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_DATA_5_IN
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_DATA_5_IN_DATA_M 0xFFFFFFFF  // Digest/Key Data
+#define SHAMD5_DATA_5_IN_DATA_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_DATA_6_IN
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_DATA_6_IN_DATA_M 0xFFFFFFFF  // Digest/Key Data
+#define SHAMD5_DATA_6_IN_DATA_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_DATA_7_IN
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_DATA_7_IN_DATA_M 0xFFFFFFFF  // Digest/Key Data
+#define SHAMD5_DATA_7_IN_DATA_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_DATA_8_IN
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_DATA_8_IN_DATA_M 0xFFFFFFFF  // Digest/Key Data
+#define SHAMD5_DATA_8_IN_DATA_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_DATA_9_IN
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_DATA_9_IN_DATA_M 0xFFFFFFFF  // Digest/Key Data
+#define SHAMD5_DATA_9_IN_DATA_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_DATA_10_IN
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_DATA_10_IN_DATA_M                                              \
+                                0xFFFFFFFF  // Digest/Key Data
+#define SHAMD5_DATA_10_IN_DATA_S                                              \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_DATA_11_IN
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_DATA_11_IN_DATA_M                                              \
+                                0xFFFFFFFF  // Digest/Key Data
+#define SHAMD5_DATA_11_IN_DATA_S                                              \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_DATA_12_IN
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_DATA_12_IN_DATA_M                                              \
+                                0xFFFFFFFF  // Digest/Key Data
+#define SHAMD5_DATA_12_IN_DATA_S                                              \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_DATA_13_IN
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_DATA_13_IN_DATA_M                                              \
+                                0xFFFFFFFF  // Digest/Key Data
+#define SHAMD5_DATA_13_IN_DATA_S                                              \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_DATA_14_IN
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_DATA_14_IN_DATA_M                                              \
+                                0xFFFFFFFF  // Digest/Key Data
+#define SHAMD5_DATA_14_IN_DATA_S                                              \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_DATA_15_IN
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_DATA_15_IN_DATA_M                                              \
+                                0xFFFFFFFF  // Digest/Key Data
+#define SHAMD5_DATA_15_IN_DATA_S                                              \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_REVISION
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_REVISION_M       0xFFFFFFFF  // Revision Number
+#define SHAMD5_REVISION_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_SYSCONFIG
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_SYSCONFIG_SADVANCED                                            \
+                                0x00000080  // Advanced Mode Enable
+#define SHAMD5_SYSCONFIG_SIDLE_M                                              \
+                                0x00000030  // Sidle mode
+#define SHAMD5_SYSCONFIG_SIDLE_FORCE                                          \
+                                0x00000000  // Force-idle mode
+#define SHAMD5_SYSCONFIG_DMA_EN 0x00000008  // uDMA Request Enable
+#define SHAMD5_SYSCONFIG_IT_EN  0x00000004  // Interrupt Enable
+#define SHAMD5_SYSCONFIG_SOFTRESET                                            \
+                                0x00000002  // Soft reset
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_SYSSTATUS
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_SYSSTATUS_RESETDONE                                            \
+                                0x00000001  // Reset done status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_IRQSTATUS
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_IRQSTATUS_CONTEXT_READY                                        \
+                                0x00000008  // Context Ready Status
+#define SHAMD5_IRQSTATUS_INPUT_READY                                          \
+                                0x00000002  // Input Ready Status
+#define SHAMD5_IRQSTATUS_OUTPUT_READY                                         \
+                                0x00000001  // Output Ready Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_IRQENABLE
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_IRQENABLE_CONTEXT_READY                                        \
+                                0x00000008  // Mask for context ready interrupt
+#define SHAMD5_IRQENABLE_INPUT_READY                                          \
+                                0x00000002  // Mask for input ready interrupt
+#define SHAMD5_IRQENABLE_OUTPUT_READY                                         \
+                                0x00000001  // Mask for output ready interrupt
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_DMAIM register.
+//
+//*****************************************************************************
+#define SHAMD5_DMAIM_COUT       0x00000004  // Context Out DMA Done Interrupt
+                                            // Mask
+#define SHAMD5_DMAIM_DIN        0x00000002  // Data In DMA Done Interrupt Mask
+#define SHAMD5_DMAIM_CIN        0x00000001  // Context In DMA Done Interrupt
+                                            // Mask
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_DMARIS
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_DMARIS_COUT      0x00000004  // Context Out DMA Done Raw
+                                            // Interrupt Status
+#define SHAMD5_DMARIS_DIN       0x00000002  // Data In DMA Done Raw Interrupt
+                                            // Status
+#define SHAMD5_DMARIS_CIN       0x00000001  // Context In DMA Done Raw
+                                            // Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_DMAMIS
+// register.
+//
+//*****************************************************************************
+#define SHAMD5_DMAMIS_COUT      0x00000004  // Context Out DMA Done Masked
+                                            // Interrupt Status
+#define SHAMD5_DMAMIS_DIN       0x00000002  // Data In DMA Done Masked
+                                            // Interrupt Status
+#define SHAMD5_DMAMIS_CIN       0x00000001  // Context In DMA Done Raw
+                                            // Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SHAMD5_O_DMAIC register.
+//
+//*****************************************************************************
+#define SHAMD5_DMAIC_COUT       0x00000004  // Context Out DMA Done Masked
+                                            // Interrupt Status
+#define SHAMD5_DMAIC_DIN        0x00000002  // Data In DMA Done Interrupt Clear
+#define SHAMD5_DMAIC_CIN        0x00000001  // Context In DMA Done Raw
+                                            // Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_KEY2_6 register.
+//
+//*****************************************************************************
+#define AES_KEY2_6_KEY_M        0xFFFFFFFF  // Key Data
+#define AES_KEY2_6_KEY_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_KEY2_7 register.
+//
+//*****************************************************************************
+#define AES_KEY2_7_KEY_M        0xFFFFFFFF  // Key Data
+#define AES_KEY2_7_KEY_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_KEY2_4 register.
+//
+//*****************************************************************************
+#define AES_KEY2_4_KEY_M        0xFFFFFFFF  // Key Data
+#define AES_KEY2_4_KEY_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_KEY2_5 register.
+//
+//*****************************************************************************
+#define AES_KEY2_5_KEY_M        0xFFFFFFFF  // Key Data
+#define AES_KEY2_5_KEY_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_KEY2_2 register.
+//
+//*****************************************************************************
+#define AES_KEY2_2_KEY_M        0xFFFFFFFF  // Key Data
+#define AES_KEY2_2_KEY_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_KEY2_3 register.
+//
+//*****************************************************************************
+#define AES_KEY2_3_KEY_M        0xFFFFFFFF  // Key Data
+#define AES_KEY2_3_KEY_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_KEY2_0 register.
+//
+//*****************************************************************************
+#define AES_KEY2_0_KEY_M        0xFFFFFFFF  // Key Data
+#define AES_KEY2_0_KEY_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_KEY2_1 register.
+//
+//*****************************************************************************
+#define AES_KEY2_1_KEY_M        0xFFFFFFFF  // Key Data
+#define AES_KEY2_1_KEY_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_KEY1_6 register.
+//
+//*****************************************************************************
+#define AES_KEY1_6_KEY_M        0xFFFFFFFF  // Key Data
+#define AES_KEY1_6_KEY_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_KEY1_7 register.
+//
+//*****************************************************************************
+#define AES_KEY1_7_KEY_M        0xFFFFFFFF  // Key Data
+#define AES_KEY1_7_KEY_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_KEY1_4 register.
+//
+//*****************************************************************************
+#define AES_KEY1_4_KEY_M        0xFFFFFFFF  // Key Data
+#define AES_KEY1_4_KEY_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_KEY1_5 register.
+//
+//*****************************************************************************
+#define AES_KEY1_5_KEY_M        0xFFFFFFFF  // Key Data
+#define AES_KEY1_5_KEY_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_KEY1_2 register.
+//
+//*****************************************************************************
+#define AES_KEY1_2_KEY_M        0xFFFFFFFF  // Key Data
+#define AES_KEY1_2_KEY_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_KEY1_3 register.
+//
+//*****************************************************************************
+#define AES_KEY1_3_KEY_M        0xFFFFFFFF  // Key Data
+#define AES_KEY1_3_KEY_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_KEY1_0 register.
+//
+//*****************************************************************************
+#define AES_KEY1_0_KEY_M        0xFFFFFFFF  // Key Data
+#define AES_KEY1_0_KEY_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_KEY1_1 register.
+//
+//*****************************************************************************
+#define AES_KEY1_1_KEY_M        0xFFFFFFFF  // Key Data
+#define AES_KEY1_1_KEY_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_IV_IN_0 register.
+//
+//*****************************************************************************
+#define AES_IV_IN_0_DATA_M      0xFFFFFFFF  // Initialization Vector Input
+#define AES_IV_IN_0_DATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_IV_IN_1 register.
+//
+//*****************************************************************************
+#define AES_IV_IN_1_DATA_M      0xFFFFFFFF  // Initialization Vector Input
+#define AES_IV_IN_1_DATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_IV_IN_2 register.
+//
+//*****************************************************************************
+#define AES_IV_IN_2_DATA_M      0xFFFFFFFF  // Initialization Vector Input
+#define AES_IV_IN_2_DATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_IV_IN_3 register.
+//
+//*****************************************************************************
+#define AES_IV_IN_3_DATA_M      0xFFFFFFFF  // Initialization Vector Input
+#define AES_IV_IN_3_DATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_CTRL register.
+//
+//*****************************************************************************
+#define AES_CTRL_CTXTRDY        0x80000000  // Context Data Registers Ready
+#define AES_CTRL_SVCTXTRDY      0x40000000  // AES TAG/IV Block(s) Ready
+#define AES_CTRL_SAVE_CONTEXT   0x20000000  // TAG or Result IV Save
+#define AES_CTRL_CCM_M_M        0x01C00000  // Counter with CBC-MAC (CCM)
+#define AES_CTRL_CCM_L_M        0x00380000  // L Value
+#define AES_CTRL_CCM_L_2        0x00080000  // width = 2
+#define AES_CTRL_CCM_L_4        0x00180000  // width = 4
+#define AES_CTRL_CCM_L_8        0x00380000  // width = 8
+#define AES_CTRL_CCM            0x00040000  // AES-CCM Mode Enable
+#define AES_CTRL_GCM_M          0x00030000  // AES-GCM Mode Enable
+#define AES_CTRL_GCM_NOP        0x00000000  // No operation
+#define AES_CTRL_GCM_HLY0ZERO   0x00010000  // GHASH with H loaded and
+                                            // Y0-encrypted forced to zero
+#define AES_CTRL_GCM_HLY0CALC   0x00020000  // GHASH with H loaded and
+                                            // Y0-encrypted calculated
+                                            // internally
+#define AES_CTRL_GCM_HY0CALC    0x00030000  // Autonomous GHASH (both H and
+                                            // Y0-encrypted calculated
+                                            // internally)
+#define AES_CTRL_CBCMAC         0x00008000  // AES-CBC MAC Enable
+#define AES_CTRL_F9             0x00004000  // AES f9 Mode Enable
+#define AES_CTRL_F8             0x00002000  // AES f8 Mode Enable
+#define AES_CTRL_XTS_M          0x00001800  // AES-XTS Operation Enabled
+#define AES_CTRL_XTS_NOP        0x00000000  // No operation
+#define AES_CTRL_XTS_TWEAKJL    0x00000800  // Previous/intermediate tweak
+                                            // value and j loaded (value is
+                                            // loaded via IV, j is loaded via
+                                            // the AAD length register)
+#define AES_CTRL_XTS_K2IJL      0x00001000  // Key2, n and j are loaded (n is
+                                            // loaded via IV, j is loaded via
+                                            // the AAD length register)
+#define AES_CTRL_XTS_K2ILJ0     0x00001800  // Key2 and n are loaded; j=0 (n is
+                                            // loaded via IV)
+#define AES_CTRL_CFB            0x00000400  // Full block AES cipher feedback
+                                            // mode (CFB128) Enable
+#define AES_CTRL_ICM            0x00000200  // AES Integer Counter Mode (ICM)
+                                            // Enable
+#define AES_CTRL_CTR_WIDTH_M    0x00000180  // AES-CTR Mode Counter Width
+#define AES_CTRL_CTR_WIDTH_32   0x00000000  // Counter is 32 bits
+#define AES_CTRL_CTR_WIDTH_64   0x00000080  // Counter is 64 bits
+#define AES_CTRL_CTR_WIDTH_96   0x00000100  // Counter is 96 bits
+#define AES_CTRL_CTR_WIDTH_128  0x00000180  // Counter is 128 bits
+#define AES_CTRL_CTR            0x00000040  // Counter Mode
+#define AES_CTRL_MODE           0x00000020  // ECB/CBC Mode
+#define AES_CTRL_KEY_SIZE_M     0x00000018  // Key Size
+#define AES_CTRL_KEY_SIZE_128   0x00000008  // Key is 128 bits
+#define AES_CTRL_KEY_SIZE_192   0x00000010  // Key is 192 bits
+#define AES_CTRL_KEY_SIZE_256   0x00000018  // Key is 256 bits
+#define AES_CTRL_DIRECTION      0x00000004  // Encryption/Decryption Selection
+#define AES_CTRL_INPUT_READY    0x00000002  // Input Ready Status
+#define AES_CTRL_OUTPUT_READY   0x00000001  // Output Ready Status
+#define AES_CTRL_CCM_M_S        22
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_C_LENGTH_0
+// register.
+//
+//*****************************************************************************
+#define AES_C_LENGTH_0_LENGTH_M 0xFFFFFFFF  // Data Length
+#define AES_C_LENGTH_0_LENGTH_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_C_LENGTH_1
+// register.
+//
+//*****************************************************************************
+#define AES_C_LENGTH_1_LENGTH_M 0xFFFFFFFF  // Data Length
+#define AES_C_LENGTH_1_LENGTH_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_AUTH_LENGTH
+// register.
+//
+//*****************************************************************************
+#define AES_AUTH_LENGTH_AUTH_M  0xFFFFFFFF  // Authentication Data Length
+#define AES_AUTH_LENGTH_AUTH_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_DATA_IN_0
+// register.
+//
+//*****************************************************************************
+#define AES_DATA_IN_0_DATA_M    0xFFFFFFFF  // Secure Data RW
+                                            // Plaintext/Ciphertext
+#define AES_DATA_IN_0_DATA_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_DATA_IN_1
+// register.
+//
+//*****************************************************************************
+#define AES_DATA_IN_1_DATA_M    0xFFFFFFFF  // Secure Data RW
+                                            // Plaintext/Ciphertext
+#define AES_DATA_IN_1_DATA_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_DATA_IN_2
+// register.
+//
+//*****************************************************************************
+#define AES_DATA_IN_2_DATA_M    0xFFFFFFFF  // Secure Data RW
+                                            // Plaintext/Ciphertext
+#define AES_DATA_IN_2_DATA_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_DATA_IN_3
+// register.
+//
+//*****************************************************************************
+#define AES_DATA_IN_3_DATA_M    0xFFFFFFFF  // Secure Data RW
+                                            // Plaintext/Ciphertext
+#define AES_DATA_IN_3_DATA_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_TAG_OUT_0
+// register.
+//
+//*****************************************************************************
+#define AES_TAG_OUT_0_HASH_M    0xFFFFFFFF  // Hash Result
+#define AES_TAG_OUT_0_HASH_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_TAG_OUT_1
+// register.
+//
+//*****************************************************************************
+#define AES_TAG_OUT_1_HASH_M    0xFFFFFFFF  // Hash Result
+#define AES_TAG_OUT_1_HASH_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_TAG_OUT_2
+// register.
+//
+//*****************************************************************************
+#define AES_TAG_OUT_2_HASH_M    0xFFFFFFFF  // Hash Result
+#define AES_TAG_OUT_2_HASH_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_TAG_OUT_3
+// register.
+//
+//*****************************************************************************
+#define AES_TAG_OUT_3_HASH_M    0xFFFFFFFF  // Hash Result
+#define AES_TAG_OUT_3_HASH_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_REVISION register.
+//
+//*****************************************************************************
+#define AES_REVISION_M          0xFFFFFFFF  // Revision number
+#define AES_REVISION_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_SYSCONFIG
+// register.
+//
+//*****************************************************************************
+#define AES_SYSCONFIG_K3        0x00001000  // K3 Select
+#define AES_SYSCONFIG_KEYENC    0x00000800  // Key Encoding
+#define AES_SYSCONFIG_MAP_CONTEXT_OUT_ON_DATA_OUT                             \
+                                0x00000200  // Map Context Out on Data Out
+                                            // Enable
+#define AES_SYSCONFIG_DMA_REQ_CONTEXT_OUT_EN                                  \
+                                0x00000100  // DMA Request Context Out Enable
+#define AES_SYSCONFIG_DMA_REQ_CONTEXT_IN_EN                                   \
+                                0x00000080  // DMA Request Context In Enable
+#define AES_SYSCONFIG_DMA_REQ_DATA_OUT_EN                                     \
+                                0x00000040  // DMA Request Data Out Enable
+#define AES_SYSCONFIG_DMA_REQ_DATA_IN_EN                                      \
+                                0x00000020  // DMA Request Data In Enable
+#define AES_SYSCONFIG_SOFTRESET 0x00000002  // Soft reset
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_SYSSTATUS
+// register.
+//
+//*****************************************************************************
+#define AES_SYSSTATUS_RESETDONE 0x00000001  // Reset Done
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_IRQSTATUS
+// register.
+//
+//*****************************************************************************
+#define AES_IRQSTATUS_CONTEXT_OUT                                             \
+                                0x00000008  // Context Output Interrupt Status
+#define AES_IRQSTATUS_DATA_OUT  0x00000004  // Data Out Interrupt Status
+#define AES_IRQSTATUS_DATA_IN   0x00000002  // Data In Interrupt Status
+#define AES_IRQSTATUS_CONTEXT_IN                                              \
+                                0x00000001  // Context In Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_IRQENABLE
+// register.
+//
+//*****************************************************************************
+#define AES_IRQENABLE_CONTEXT_OUT                                             \
+                                0x00000008  // Context Out Interrupt Enable
+#define AES_IRQENABLE_DATA_OUT  0x00000004  // Data Out Interrupt Enable
+#define AES_IRQENABLE_DATA_IN   0x00000002  // Data In Interrupt Enable
+#define AES_IRQENABLE_CONTEXT_IN                                              \
+                                0x00000001  // Context In Interrupt Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_DIRTYBITS
+// register.
+//
+//*****************************************************************************
+#define AES_DIRTYBITS_S_DIRTY   0x00000002  // AES Dirty Bit
+#define AES_DIRTYBITS_S_ACCESS  0x00000001  // AES Access Bit
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_DMAIM register.
+//
+//*****************************************************************************
+#define AES_DMAIM_DOUT          0x00000008  // Data Out DMA Done Interrupt Mask
+#define AES_DMAIM_DIN           0x00000004  // Data In DMA Done Interrupt Mask
+#define AES_DMAIM_COUT          0x00000002  // Context Out DMA Done Interrupt
+                                            // Mask
+#define AES_DMAIM_CIN           0x00000001  // Context In DMA Done Interrupt
+                                            // Mask
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_DMARIS register.
+//
+//*****************************************************************************
+#define AES_DMARIS_DOUT         0x00000008  // Data Out DMA Done Raw Interrupt
+                                            // Status
+#define AES_DMARIS_DIN          0x00000004  // Data In DMA Done Raw Interrupt
+                                            // Status
+#define AES_DMARIS_COUT         0x00000002  // Context Out DMA Done Raw
+                                            // Interrupt Status
+#define AES_DMARIS_CIN          0x00000001  // Context In DMA Done Raw
+                                            // Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_DMAMIS register.
+//
+//*****************************************************************************
+#define AES_DMAMIS_DOUT         0x00000008  // Data Out DMA Done Masked
+                                            // Interrupt Status
+#define AES_DMAMIS_DIN          0x00000004  // Data In DMA Done Masked
+                                            // Interrupt Status
+#define AES_DMAMIS_COUT         0x00000002  // Context Out DMA Done Masked
+                                            // Interrupt Status
+#define AES_DMAMIS_CIN          0x00000001  // Context In DMA Done Raw
+                                            // Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the AES_O_DMAIC register.
+//
+//*****************************************************************************
+#define AES_DMAIC_DOUT          0x00000008  // Data Out DMA Done Interrupt
+                                            // Clear
+#define AES_DMAIC_DIN           0x00000004  // Data In DMA Done Interrupt Clear
+#define AES_DMAIC_COUT          0x00000002  // Context Out DMA Done Masked
+                                            // Interrupt Status
+#define AES_DMAIC_CIN           0x00000001  // Context In DMA Done Raw
+                                            // Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the DES_O_KEY3_L register.
+//
+//*****************************************************************************
+#define DES_KEY3_L_KEY_M        0xFFFFFFFF  // Key Data
+#define DES_KEY3_L_KEY_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the DES_O_KEY3_H register.
+//
+//*****************************************************************************
+#define DES_KEY3_H_KEY_M        0xFFFFFFFF  // Key Data
+#define DES_KEY3_H_KEY_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the DES_O_KEY2_L register.
+//
+//*****************************************************************************
+#define DES_KEY2_L_KEY_M        0xFFFFFFFF  // Key Data
+#define DES_KEY2_L_KEY_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the DES_O_KEY2_H register.
+//
+//*****************************************************************************
+#define DES_KEY2_H_KEY_M        0xFFFFFFFF  // Key Data
+#define DES_KEY2_H_KEY_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the DES_O_KEY1_L register.
+//
+//*****************************************************************************
+#define DES_KEY1_L_KEY_M        0xFFFFFFFF  // Key Data
+#define DES_KEY1_L_KEY_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the DES_O_KEY1_H register.
+//
+//*****************************************************************************
+#define DES_KEY1_H_KEY_M        0xFFFFFFFF  // Key Data
+#define DES_KEY1_H_KEY_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the DES_O_IV_L register.
+//
+//*****************************************************************************
+#define DES_IV_L_M              0xFFFFFFFF  // Initialization vector for CBC,
+                                            // CFB modes (LSW)
+#define DES_IV_L_S              0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the DES_O_IV_H register.
+//
+//*****************************************************************************
+#define DES_IV_H_M              0xFFFFFFFF  // Initialization vector for CBC,
+                                            // CFB modes (MSW)
+#define DES_IV_H_S              0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the DES_O_CTRL register.
+//
+//*****************************************************************************
+#define DES_CTRL_CONTEXT        0x80000000  // If 1, this read-only status bit
+                                            // indicates that the context data
+                                            // registers can be overwritten and
+                                            // the host is permitted to write
+                                            // the next context
+#define DES_CTRL_MODE_M         0x00000030  // Select CBC, ECB or CFB mode0x0:
+                                            // ECB mode0x1: CBC mode0x2: CFB
+                                            // mode0x3: reserved
+#define DES_CTRL_TDES           0x00000008  // Select DES or triple DES
+                                            // encryption/decryption
+#define DES_CTRL_DIRECTION      0x00000004  // Select encryption/decryption
+                                            // 0x0: decryption is selected0x1:
+                                            // Encryption is selected
+#define DES_CTRL_INPUT_READY    0x00000002  // When 1, ready to encrypt/decrypt
+                                            // data
+#define DES_CTRL_OUTPUT_READY   0x00000001  // When 1, Data decrypted/encrypted
+                                            // ready
+#define DES_CTRL_MODE_S         4
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the DES_O_LENGTH register.
+//
+//*****************************************************************************
+#define DES_LENGTH_M            0xFFFFFFFF  // Cryptographic data length in
+                                            // bytes for all modes
+#define DES_LENGTH_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the DES_O_DATA_L register.
+//
+//*****************************************************************************
+#define DES_DATA_L_M            0xFFFFFFFF  // Data for encryption/decryption,
+                                            // LSW
+#define DES_DATA_L_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the DES_O_DATA_H register.
+//
+//*****************************************************************************
+#define DES_DATA_H_M            0xFFFFFFFF  // Data for encryption/decryption,
+                                            // MSW
+#define DES_DATA_H_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the DES_O_REVISION register.
+//
+//*****************************************************************************
+#define DES_REVISION_M          0xFFFFFFFF  // Revision number
+#define DES_REVISION_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the DES_O_SYSCONFIG
+// register.
+//
+//*****************************************************************************
+#define DES_SYSCONFIG_DMA_REQ_CONTEXT_IN_EN                                   \
+                                0x00000080  // DMA Request Context In Enable
+#define DES_SYSCONFIG_DMA_REQ_DATA_OUT_EN                                     \
+                                0x00000040  // DMA Request Data Out Enable
+#define DES_SYSCONFIG_DMA_REQ_DATA_IN_EN                                      \
+                                0x00000020  // DMA Request Data In Enable
+#define DES_SYSCONFIG_SIDLE_M   0x0000000C  // Sidle mode
+#define DES_SYSCONFIG_SIDLE_FORCE                                             \
+                                0x00000000  // Force-idle mode
+#define DES_SYSCONFIG_SOFTRESET 0x00000002  // Soft reset
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the DES_O_SYSSTATUS
+// register.
+//
+//*****************************************************************************
+#define DES_SYSSTATUS_RESETDONE 0x00000001  // Reset Done
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the DES_O_IRQSTATUS
+// register.
+//
+//*****************************************************************************
+#define DES_IRQSTATUS_DATA_OUT  0x00000004  // This bit indicates data output
+                                            // interrupt is active and triggers
+                                            // the interrupt output
+#define DES_IRQSTATUS_DATA_IN   0x00000002  // This bit indicates data input
+                                            // interrupt is active and triggers
+                                            // the interrupt output
+#define DES_IRQSTATUS_CONTEX_IN 0x00000001  // This bit indicates context
+                                            // interrupt is active and triggers
+                                            // the interrupt output
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the DES_O_IRQENABLE
+// register.
+//
+//*****************************************************************************
+#define DES_IRQENABLE_M_DATA_OUT                                              \
+                                0x00000004  // If this bit is set to 1 the data
+                                            // output interrupt is enabled
+#define DES_IRQENABLE_M_DATA_IN 0x00000002  // If this bit is set to 1 the data
+                                            // input interrupt is enabled
+#define DES_IRQENABLE_M_CONTEX_IN                                             \
+                                0x00000001  // If this bit is set to 1 the
+                                            // context interrupt is enabled
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the DES_O_DIRTYBITS
+// register.
+//
+//*****************************************************************************
+#define DES_DIRTYBITS_S_DIRTY   0x00000002  // This bit is set to 1 by the
+                                            // module if any of the DES_*
+                                            // registers is written
+#define DES_DIRTYBITS_S_ACCESS  0x00000001  // This bit is set to 1 by the
+                                            // module if any of the DES_*
+                                            // registers is read
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the DES_O_DMAIM register.
+//
+//*****************************************************************************
+#define DES_DMAIM_DOUT          0x00000004  // Data Out DMA Done Interrupt Mask
+#define DES_DMAIM_DIN           0x00000002  // Data In DMA Done Interrupt Mask
+#define DES_DMAIM_CIN           0x00000001  // Context In DMA Done Interrupt
+                                            // Mask
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the DES_O_DMARIS register.
+//
+//*****************************************************************************
+#define DES_DMARIS_DOUT         0x00000004  // Data Out DMA Done Raw Interrupt
+                                            // Status
+#define DES_DMARIS_DIN          0x00000002  // Data In DMA Done Raw Interrupt
+                                            // Status
+#define DES_DMARIS_CIN          0x00000001  // Context In DMA Done Raw
+                                            // Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the DES_O_DMAMIS register.
+//
+//*****************************************************************************
+#define DES_DMAMIS_DOUT         0x00000004  // Data Out DMA Done Masked
+                                            // Interrupt Status
+#define DES_DMAMIS_DIN          0x00000002  // Data In DMA Done Masked
+                                            // Interrupt Status
+#define DES_DMAMIS_CIN          0x00000001  // Context In DMA Done Raw
+                                            // Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the DES_O_DMAIC register.
+//
+//*****************************************************************************
+#define DES_DMAIC_DOUT          0x00000004  // Data Out DMA Done Interrupt
+                                            // Clear
+#define DES_DMAIC_DIN           0x00000002  // Data In DMA Done Interrupt Clear
+#define DES_DMAIC_CIN           0x00000001  // Context In DMA Done Raw
+                                            // Interrupt Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ACTLR register.
+//
+//*****************************************************************************
+#define NVIC_ACTLR_DISOOFP      0x00000200  // Disable Out-Of-Order Floating
+                                            // Point
+#define NVIC_ACTLR_DISFPCA      0x00000100  // Disable CONTROL
+#define NVIC_ACTLR_DISFOLD      0x00000004  // Disable IT Folding
+#define NVIC_ACTLR_DISWBUF      0x00000002  // Disable Write Buffer
+#define NVIC_ACTLR_DISMCYC      0x00000001  // Disable Interrupts of Multiple
+                                            // Cycle Instructions
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ST_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_ST_CTRL_COUNT      0x00010000  // Count Flag
+#define NVIC_ST_CTRL_CLK_SRC    0x00000004  // Clock Source
+#define NVIC_ST_CTRL_INTEN      0x00000002  // Interrupt Enable
+#define NVIC_ST_CTRL_ENABLE     0x00000001  // Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ST_RELOAD register.
+//
+//*****************************************************************************
+#define NVIC_ST_RELOAD_M        0x00FFFFFF  // Reload Value
+#define NVIC_ST_RELOAD_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ST_CURRENT
+// register.
+//
+//*****************************************************************************
+#define NVIC_ST_CURRENT_M       0x00FFFFFF  // Current Value
+#define NVIC_ST_CURRENT_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_EN0 register.
+//
+//*****************************************************************************
+#define NVIC_EN0_INT_M          0xFFFFFFFF  // Interrupt Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_EN1 register.
+//
+//*****************************************************************************
+#define NVIC_EN1_INT_M          0xFFFFFFFF  // Interrupt Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_EN2 register.
+//
+//*****************************************************************************
+#define NVIC_EN2_INT_M          0xFFFFFFFF  // Interrupt Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_EN3 register.
+//
+//*****************************************************************************
+#define NVIC_EN3_INT_M          0xFFFFFFFF  // Interrupt Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DIS0 register.
+//
+//*****************************************************************************
+#define NVIC_DIS0_INT_M         0xFFFFFFFF  // Interrupt Disable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DIS1 register.
+//
+//*****************************************************************************
+#define NVIC_DIS1_INT_M         0xFFFFFFFF  // Interrupt Disable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DIS2 register.
+//
+//*****************************************************************************
+#define NVIC_DIS2_INT_M         0xFFFFFFFF  // Interrupt Disable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DIS3 register.
+//
+//*****************************************************************************
+#define NVIC_DIS3_INT_M         0xFFFFFFFF  // Interrupt Disable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PEND0 register.
+//
+//*****************************************************************************
+#define NVIC_PEND0_INT_M        0xFFFFFFFF  // Interrupt Set Pending
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PEND1 register.
+//
+//*****************************************************************************
+#define NVIC_PEND1_INT_M        0xFFFFFFFF  // Interrupt Set Pending
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PEND2 register.
+//
+//*****************************************************************************
+#define NVIC_PEND2_INT_M        0xFFFFFFFF  // Interrupt Set Pending
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PEND3 register.
+//
+//*****************************************************************************
+#define NVIC_PEND3_INT_M        0xFFFFFFFF  // Interrupt Set Pending
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_UNPEND0 register.
+//
+//*****************************************************************************
+#define NVIC_UNPEND0_INT_M      0xFFFFFFFF  // Interrupt Clear Pending
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_UNPEND1 register.
+//
+//*****************************************************************************
+#define NVIC_UNPEND1_INT_M      0xFFFFFFFF  // Interrupt Clear Pending
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_UNPEND2 register.
+//
+//*****************************************************************************
+#define NVIC_UNPEND2_INT_M      0xFFFFFFFF  // Interrupt Clear Pending
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_UNPEND3 register.
+//
+//*****************************************************************************
+#define NVIC_UNPEND3_INT_M      0xFFFFFFFF  // Interrupt Clear Pending
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ACTIVE0 register.
+//
+//*****************************************************************************
+#define NVIC_ACTIVE0_INT_M      0xFFFFFFFF  // Interrupt Active
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ACTIVE1 register.
+//
+//*****************************************************************************
+#define NVIC_ACTIVE1_INT_M      0xFFFFFFFF  // Interrupt Active
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ACTIVE2 register.
+//
+//*****************************************************************************
+#define NVIC_ACTIVE2_INT_M      0xFFFFFFFF  // Interrupt Active
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ACTIVE3 register.
+//
+//*****************************************************************************
+#define NVIC_ACTIVE3_INT_M      0xFFFFFFFF  // Interrupt Active
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI0 register.
+//
+//*****************************************************************************
+#define NVIC_PRI0_INT3_M        0xE0000000  // Interrupt 3 Priority Mask
+#define NVIC_PRI0_INT2_M        0x00E00000  // Interrupt 2 Priority Mask
+#define NVIC_PRI0_INT1_M        0x0000E000  // Interrupt 1 Priority Mask
+#define NVIC_PRI0_INT0_M        0x000000E0  // Interrupt 0 Priority Mask
+#define NVIC_PRI0_INT3_S        29
+#define NVIC_PRI0_INT2_S        21
+#define NVIC_PRI0_INT1_S        13
+#define NVIC_PRI0_INT0_S        5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI1 register.
+//
+//*****************************************************************************
+#define NVIC_PRI1_INT7_M        0xE0000000  // Interrupt 7 Priority Mask
+#define NVIC_PRI1_INT6_M        0x00E00000  // Interrupt 6 Priority Mask
+#define NVIC_PRI1_INT5_M        0x0000E000  // Interrupt 5 Priority Mask
+#define NVIC_PRI1_INT4_M        0x000000E0  // Interrupt 4 Priority Mask
+#define NVIC_PRI1_INT7_S        29
+#define NVIC_PRI1_INT6_S        21
+#define NVIC_PRI1_INT5_S        13
+#define NVIC_PRI1_INT4_S        5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI2 register.
+//
+//*****************************************************************************
+#define NVIC_PRI2_INT11_M       0xE0000000  // Interrupt 11 Priority Mask
+#define NVIC_PRI2_INT10_M       0x00E00000  // Interrupt 10 Priority Mask
+#define NVIC_PRI2_INT9_M        0x0000E000  // Interrupt 9 Priority Mask
+#define NVIC_PRI2_INT8_M        0x000000E0  // Interrupt 8 Priority Mask
+#define NVIC_PRI2_INT11_S       29
+#define NVIC_PRI2_INT10_S       21
+#define NVIC_PRI2_INT9_S        13
+#define NVIC_PRI2_INT8_S        5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI3 register.
+//
+//*****************************************************************************
+#define NVIC_PRI3_INT15_M       0xE0000000  // Interrupt 15 Priority Mask
+#define NVIC_PRI3_INT14_M       0x00E00000  // Interrupt 14 Priority Mask
+#define NVIC_PRI3_INT13_M       0x0000E000  // Interrupt 13 Priority Mask
+#define NVIC_PRI3_INT12_M       0x000000E0  // Interrupt 12 Priority Mask
+#define NVIC_PRI3_INT15_S       29
+#define NVIC_PRI3_INT14_S       21
+#define NVIC_PRI3_INT13_S       13
+#define NVIC_PRI3_INT12_S       5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI4 register.
+//
+//*****************************************************************************
+#define NVIC_PRI4_INT19_M       0xE0000000  // Interrupt 19 Priority Mask
+#define NVIC_PRI4_INT18_M       0x00E00000  // Interrupt 18 Priority Mask
+#define NVIC_PRI4_INT17_M       0x0000E000  // Interrupt 17 Priority Mask
+#define NVIC_PRI4_INT16_M       0x000000E0  // Interrupt 16 Priority Mask
+#define NVIC_PRI4_INT19_S       29
+#define NVIC_PRI4_INT18_S       21
+#define NVIC_PRI4_INT17_S       13
+#define NVIC_PRI4_INT16_S       5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI5 register.
+//
+//*****************************************************************************
+#define NVIC_PRI5_INT23_M       0xE0000000  // Interrupt 23 Priority Mask
+#define NVIC_PRI5_INT22_M       0x00E00000  // Interrupt 22 Priority Mask
+#define NVIC_PRI5_INT21_M       0x0000E000  // Interrupt 21 Priority Mask
+#define NVIC_PRI5_INT20_M       0x000000E0  // Interrupt 20 Priority Mask
+#define NVIC_PRI5_INT23_S       29
+#define NVIC_PRI5_INT22_S       21
+#define NVIC_PRI5_INT21_S       13
+#define NVIC_PRI5_INT20_S       5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI6 register.
+//
+//*****************************************************************************
+#define NVIC_PRI6_INT27_M       0xE0000000  // Interrupt 27 Priority Mask
+#define NVIC_PRI6_INT26_M       0x00E00000  // Interrupt 26 Priority Mask
+#define NVIC_PRI6_INT25_M       0x0000E000  // Interrupt 25 Priority Mask
+#define NVIC_PRI6_INT24_M       0x000000E0  // Interrupt 24 Priority Mask
+#define NVIC_PRI6_INT27_S       29
+#define NVIC_PRI6_INT26_S       21
+#define NVIC_PRI6_INT25_S       13
+#define NVIC_PRI6_INT24_S       5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI7 register.
+//
+//*****************************************************************************
+#define NVIC_PRI7_INT31_M       0xE0000000  // Interrupt 31 Priority Mask
+#define NVIC_PRI7_INT30_M       0x00E00000  // Interrupt 30 Priority Mask
+#define NVIC_PRI7_INT29_M       0x0000E000  // Interrupt 29 Priority Mask
+#define NVIC_PRI7_INT28_M       0x000000E0  // Interrupt 28 Priority Mask
+#define NVIC_PRI7_INT31_S       29
+#define NVIC_PRI7_INT30_S       21
+#define NVIC_PRI7_INT29_S       13
+#define NVIC_PRI7_INT28_S       5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI8 register.
+//
+//*****************************************************************************
+#define NVIC_PRI8_INT35_M       0xE0000000  // Interrupt 35 Priority Mask
+#define NVIC_PRI8_INT34_M       0x00E00000  // Interrupt 34 Priority Mask
+#define NVIC_PRI8_INT33_M       0x0000E000  // Interrupt 33 Priority Mask
+#define NVIC_PRI8_INT32_M       0x000000E0  // Interrupt 32 Priority Mask
+#define NVIC_PRI8_INT35_S       29
+#define NVIC_PRI8_INT34_S       21
+#define NVIC_PRI8_INT33_S       13
+#define NVIC_PRI8_INT32_S       5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI9 register.
+//
+//*****************************************************************************
+#define NVIC_PRI9_INT39_M       0xE0000000  // Interrupt 39 Priority Mask
+#define NVIC_PRI9_INT38_M       0x00E00000  // Interrupt 38 Priority Mask
+#define NVIC_PRI9_INT37_M       0x0000E000  // Interrupt 37 Priority Mask
+#define NVIC_PRI9_INT36_M       0x000000E0  // Interrupt 36 Priority Mask
+#define NVIC_PRI9_INT39_S       29
+#define NVIC_PRI9_INT38_S       21
+#define NVIC_PRI9_INT37_S       13
+#define NVIC_PRI9_INT36_S       5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI10 register.
+//
+//*****************************************************************************
+#define NVIC_PRI10_INT43_M      0xE0000000  // Interrupt 43 Priority Mask
+#define NVIC_PRI10_INT42_M      0x00E00000  // Interrupt 42 Priority Mask
+#define NVIC_PRI10_INT41_M      0x0000E000  // Interrupt 41 Priority Mask
+#define NVIC_PRI10_INT40_M      0x000000E0  // Interrupt 40 Priority Mask
+#define NVIC_PRI10_INT43_S      29
+#define NVIC_PRI10_INT42_S      21
+#define NVIC_PRI10_INT41_S      13
+#define NVIC_PRI10_INT40_S      5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI11 register.
+//
+//*****************************************************************************
+#define NVIC_PRI11_INT47_M      0xE0000000  // Interrupt 47 Priority Mask
+#define NVIC_PRI11_INT46_M      0x00E00000  // Interrupt 46 Priority Mask
+#define NVIC_PRI11_INT45_M      0x0000E000  // Interrupt 45 Priority Mask
+#define NVIC_PRI11_INT44_M      0x000000E0  // Interrupt 44 Priority Mask
+#define NVIC_PRI11_INT47_S      29
+#define NVIC_PRI11_INT46_S      21
+#define NVIC_PRI11_INT45_S      13
+#define NVIC_PRI11_INT44_S      5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI12 register.
+//
+//*****************************************************************************
+#define NVIC_PRI12_INT51_M      0xE0000000  // Interrupt 51 Priority Mask
+#define NVIC_PRI12_INT50_M      0x00E00000  // Interrupt 50 Priority Mask
+#define NVIC_PRI12_INT49_M      0x0000E000  // Interrupt 49 Priority Mask
+#define NVIC_PRI12_INT48_M      0x000000E0  // Interrupt 48 Priority Mask
+#define NVIC_PRI12_INT51_S      29
+#define NVIC_PRI12_INT50_S      21
+#define NVIC_PRI12_INT49_S      13
+#define NVIC_PRI12_INT48_S      5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI13 register.
+//
+//*****************************************************************************
+#define NVIC_PRI13_INT55_M      0xE0000000  // Interrupt 55 Priority Mask
+#define NVIC_PRI13_INT54_M      0x00E00000  // Interrupt 54 Priority Mask
+#define NVIC_PRI13_INT53_M      0x0000E000  // Interrupt 53 Priority Mask
+#define NVIC_PRI13_INT52_M      0x000000E0  // Interrupt 52 Priority Mask
+#define NVIC_PRI13_INT55_S      29
+#define NVIC_PRI13_INT54_S      21
+#define NVIC_PRI13_INT53_S      13
+#define NVIC_PRI13_INT52_S      5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI14 register.
+//
+//*****************************************************************************
+#define NVIC_PRI14_INTD_M       0xE0000000  // Interrupt 59 Priority Mask
+#define NVIC_PRI14_INTC_M       0x00E00000  // Interrupt 58 Priority Mask
+#define NVIC_PRI14_INTB_M       0x0000E000  // Interrupt 57 Priority Mask
+#define NVIC_PRI14_INTA_M       0x000000E0  // Interrupt 56 Priority Mask
+#define NVIC_PRI14_INTD_S       29
+#define NVIC_PRI14_INTC_S       21
+#define NVIC_PRI14_INTB_S       13
+#define NVIC_PRI14_INTA_S       5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI15 register.
+//
+//*****************************************************************************
+#define NVIC_PRI15_INTD_M       0xE0000000  // Interrupt 63 Priority Mask
+#define NVIC_PRI15_INTC_M       0x00E00000  // Interrupt 62 Priority Mask
+#define NVIC_PRI15_INTB_M       0x0000E000  // Interrupt 61 Priority Mask
+#define NVIC_PRI15_INTA_M       0x000000E0  // Interrupt 60 Priority Mask
+#define NVIC_PRI15_INTD_S       29
+#define NVIC_PRI15_INTC_S       21
+#define NVIC_PRI15_INTB_S       13
+#define NVIC_PRI15_INTA_S       5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI16 register.
+//
+//*****************************************************************************
+#define NVIC_PRI16_INTD_M       0xE0000000  // Interrupt 67 Priority Mask
+#define NVIC_PRI16_INTC_M       0x00E00000  // Interrupt 66 Priority Mask
+#define NVIC_PRI16_INTB_M       0x0000E000  // Interrupt 65 Priority Mask
+#define NVIC_PRI16_INTA_M       0x000000E0  // Interrupt 64 Priority Mask
+#define NVIC_PRI16_INTD_S       29
+#define NVIC_PRI16_INTC_S       21
+#define NVIC_PRI16_INTB_S       13
+#define NVIC_PRI16_INTA_S       5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI17 register.
+//
+//*****************************************************************************
+#define NVIC_PRI17_INTD_M       0xE0000000  // Interrupt 71 Priority Mask
+#define NVIC_PRI17_INTC_M       0x00E00000  // Interrupt 70 Priority Mask
+#define NVIC_PRI17_INTB_M       0x0000E000  // Interrupt 69 Priority Mask
+#define NVIC_PRI17_INTA_M       0x000000E0  // Interrupt 68 Priority Mask
+#define NVIC_PRI17_INTD_S       29
+#define NVIC_PRI17_INTC_S       21
+#define NVIC_PRI17_INTB_S       13
+#define NVIC_PRI17_INTA_S       5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI18 register.
+//
+//*****************************************************************************
+#define NVIC_PRI18_INTD_M       0xE0000000  // Interrupt 75 Priority Mask
+#define NVIC_PRI18_INTC_M       0x00E00000  // Interrupt 74 Priority Mask
+#define NVIC_PRI18_INTB_M       0x0000E000  // Interrupt 73 Priority Mask
+#define NVIC_PRI18_INTA_M       0x000000E0  // Interrupt 72 Priority Mask
+#define NVIC_PRI18_INTD_S       29
+#define NVIC_PRI18_INTC_S       21
+#define NVIC_PRI18_INTB_S       13
+#define NVIC_PRI18_INTA_S       5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI19 register.
+//
+//*****************************************************************************
+#define NVIC_PRI19_INTD_M       0xE0000000  // Interrupt 79 Priority Mask
+#define NVIC_PRI19_INTC_M       0x00E00000  // Interrupt 78 Priority Mask
+#define NVIC_PRI19_INTB_M       0x0000E000  // Interrupt 77 Priority Mask
+#define NVIC_PRI19_INTA_M       0x000000E0  // Interrupt 76 Priority Mask
+#define NVIC_PRI19_INTD_S       29
+#define NVIC_PRI19_INTC_S       21
+#define NVIC_PRI19_INTB_S       13
+#define NVIC_PRI19_INTA_S       5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI20 register.
+//
+//*****************************************************************************
+#define NVIC_PRI20_INTD_M       0xE0000000  // Interrupt 83 Priority Mask
+#define NVIC_PRI20_INTC_M       0x00E00000  // Interrupt 82 Priority Mask
+#define NVIC_PRI20_INTB_M       0x0000E000  // Interrupt 81 Priority Mask
+#define NVIC_PRI20_INTA_M       0x000000E0  // Interrupt 80 Priority Mask
+#define NVIC_PRI20_INTD_S       29
+#define NVIC_PRI20_INTC_S       21
+#define NVIC_PRI20_INTB_S       13
+#define NVIC_PRI20_INTA_S       5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI21 register.
+//
+//*****************************************************************************
+#define NVIC_PRI21_INTD_M       0xE0000000  // Interrupt 87 Priority Mask
+#define NVIC_PRI21_INTC_M       0x00E00000  // Interrupt 86 Priority Mask
+#define NVIC_PRI21_INTB_M       0x0000E000  // Interrupt 85 Priority Mask
+#define NVIC_PRI21_INTA_M       0x000000E0  // Interrupt 84 Priority Mask
+#define NVIC_PRI21_INTD_S       29
+#define NVIC_PRI21_INTC_S       21
+#define NVIC_PRI21_INTB_S       13
+#define NVIC_PRI21_INTA_S       5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI22 register.
+//
+//*****************************************************************************
+#define NVIC_PRI22_INTD_M       0xE0000000  // Interrupt 91 Priority Mask
+#define NVIC_PRI22_INTC_M       0x00E00000  // Interrupt 90 Priority Mask
+#define NVIC_PRI22_INTB_M       0x0000E000  // Interrupt 89 Priority Mask
+#define NVIC_PRI22_INTA_M       0x000000E0  // Interrupt 88 Priority Mask
+#define NVIC_PRI22_INTD_S       29
+#define NVIC_PRI22_INTC_S       21
+#define NVIC_PRI22_INTB_S       13
+#define NVIC_PRI22_INTA_S       5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI23 register.
+//
+//*****************************************************************************
+#define NVIC_PRI23_INTD_M       0xE0000000  // Interrupt 95 Priority Mask
+#define NVIC_PRI23_INTC_M       0x00E00000  // Interrupt 94 Priority Mask
+#define NVIC_PRI23_INTB_M       0x0000E000  // Interrupt 93 Priority Mask
+#define NVIC_PRI23_INTA_M       0x000000E0  // Interrupt 92 Priority Mask
+#define NVIC_PRI23_INTD_S       29
+#define NVIC_PRI23_INTC_S       21
+#define NVIC_PRI23_INTB_S       13
+#define NVIC_PRI23_INTA_S       5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI24 register.
+//
+//*****************************************************************************
+#define NVIC_PRI24_INTD_M       0xE0000000  // Interrupt 99 Priority Mask
+#define NVIC_PRI24_INTC_M       0x00E00000  // Interrupt 98 Priority Mask
+#define NVIC_PRI24_INTB_M       0x0000E000  // Interrupt 97 Priority Mask
+#define NVIC_PRI24_INTA_M       0x000000E0  // Interrupt 96 Priority Mask
+#define NVIC_PRI24_INTD_S       29
+#define NVIC_PRI24_INTC_S       21
+#define NVIC_PRI24_INTB_S       13
+#define NVIC_PRI24_INTA_S       5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI25 register.
+//
+//*****************************************************************************
+#define NVIC_PRI25_INTD_M       0xE0000000  // Interrupt 103 Priority Mask
+#define NVIC_PRI25_INTC_M       0x00E00000  // Interrupt 102 Priority Mask
+#define NVIC_PRI25_INTB_M       0x0000E000  // Interrupt 101 Priority Mask
+#define NVIC_PRI25_INTA_M       0x000000E0  // Interrupt 100 Priority Mask
+#define NVIC_PRI25_INTD_S       29
+#define NVIC_PRI25_INTC_S       21
+#define NVIC_PRI25_INTB_S       13
+#define NVIC_PRI25_INTA_S       5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI26 register.
+//
+//*****************************************************************************
+#define NVIC_PRI26_INTD_M       0xE0000000  // Interrupt 107 Priority Mask
+#define NVIC_PRI26_INTC_M       0x00E00000  // Interrupt 106 Priority Mask
+#define NVIC_PRI26_INTB_M       0x0000E000  // Interrupt 105 Priority Mask
+#define NVIC_PRI26_INTA_M       0x000000E0  // Interrupt 104 Priority Mask
+#define NVIC_PRI26_INTD_S       29
+#define NVIC_PRI26_INTC_S       21
+#define NVIC_PRI26_INTB_S       13
+#define NVIC_PRI26_INTA_S       5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI27 register.
+//
+//*****************************************************************************
+#define NVIC_PRI27_INTD_M       0xE0000000  // Interrupt 111 Priority Mask
+#define NVIC_PRI27_INTC_M       0x00E00000  // Interrupt 110 Priority Mask
+#define NVIC_PRI27_INTB_M       0x0000E000  // Interrupt 109 Priority Mask
+#define NVIC_PRI27_INTA_M       0x000000E0  // Interrupt 108 Priority Mask
+#define NVIC_PRI27_INTD_S       29
+#define NVIC_PRI27_INTC_S       21
+#define NVIC_PRI27_INTB_S       13
+#define NVIC_PRI27_INTA_S       5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI28 register.
+//
+//*****************************************************************************
+#define NVIC_PRI28_INTD_M       0xE0000000  // Interrupt 115 Priority Mask
+#define NVIC_PRI28_INTC_M       0x00E00000  // Interrupt 114 Priority Mask
+#define NVIC_PRI28_INTB_M       0x0000E000  // Interrupt 113 Priority Mask
+#define NVIC_PRI28_INTA_M       0x000000E0  // Interrupt 112 Priority Mask
+#define NVIC_PRI28_INTD_S       29
+#define NVIC_PRI28_INTC_S       21
+#define NVIC_PRI28_INTB_S       13
+#define NVIC_PRI28_INTA_S       5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_CPUID register.
+//
+//*****************************************************************************
+#define NVIC_CPUID_IMP_M        0xFF000000  // Implementer Code
+#define NVIC_CPUID_IMP_ARM      0x41000000  // ARM
+#define NVIC_CPUID_VAR_M        0x00F00000  // Variant Number
+#define NVIC_CPUID_CON_M        0x000F0000  // Constant
+#define NVIC_CPUID_PARTNO_M     0x0000FFF0  // Part Number
+#define NVIC_CPUID_PARTNO_CM4   0x0000C240  // Cortex-M4 processor
+#define NVIC_CPUID_REV_M        0x0000000F  // Revision Number
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_INT_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_INT_CTRL_NMI_SET   0x80000000  // NMI Set Pending
+#define NVIC_INT_CTRL_PEND_SV   0x10000000  // PendSV Set Pending
+#define NVIC_INT_CTRL_UNPEND_SV 0x08000000  // PendSV Clear Pending
+#define NVIC_INT_CTRL_PENDSTSET 0x04000000  // SysTick Set Pending
+#define NVIC_INT_CTRL_PENDSTCLR 0x02000000  // SysTick Clear Pending
+#define NVIC_INT_CTRL_ISR_PRE   0x00800000  // Debug Interrupt Handling
+#define NVIC_INT_CTRL_ISR_PEND  0x00400000  // Interrupt Pending
+#define NVIC_INT_CTRL_VEC_PEN_M 0x000FF000  // Interrupt Pending Vector Number
+#define NVIC_INT_CTRL_VEC_PEN_NMI                                             \
+                                0x00002000  // NMI
+#define NVIC_INT_CTRL_VEC_PEN_HARD                                            \
+                                0x00003000  // Hard fault
+#define NVIC_INT_CTRL_VEC_PEN_MEM                                             \
+                                0x00004000  // Memory management fault
+#define NVIC_INT_CTRL_VEC_PEN_BUS                                             \
+                                0x00005000  // Bus fault
+#define NVIC_INT_CTRL_VEC_PEN_USG                                             \
+                                0x00006000  // Usage fault
+#define NVIC_INT_CTRL_VEC_PEN_SVC                                             \
+                                0x0000B000  // SVCall
+#define NVIC_INT_CTRL_VEC_PEN_PNDSV                                           \
+                                0x0000E000  // PendSV
+#define NVIC_INT_CTRL_VEC_PEN_TICK                                            \
+                                0x0000F000  // SysTick
+#define NVIC_INT_CTRL_RET_BASE  0x00000800  // Return to Base
+#define NVIC_INT_CTRL_VEC_ACT_M 0x000000FF  // Interrupt Pending Vector Number
+#define NVIC_INT_CTRL_VEC_ACT_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_VTABLE register.
+//
+//*****************************************************************************
+#define NVIC_VTABLE_OFFSET_M    0xFFFFFC00  // Vector Table Offset
+#define NVIC_VTABLE_OFFSET_S    10
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_APINT register.
+//
+//*****************************************************************************
+#define NVIC_APINT_VECTKEY_M    0xFFFF0000  // Register Key
+#define NVIC_APINT_VECTKEY      0x05FA0000  // Vector key
+#define NVIC_APINT_ENDIANESS    0x00008000  // Data Endianess
+#define NVIC_APINT_PRIGROUP_M   0x00000700  // Interrupt Priority Grouping
+#define NVIC_APINT_PRIGROUP_7_1 0x00000000  // Priority group 7.1 split
+#define NVIC_APINT_PRIGROUP_6_2 0x00000100  // Priority group 6.2 split
+#define NVIC_APINT_PRIGROUP_5_3 0x00000200  // Priority group 5.3 split
+#define NVIC_APINT_PRIGROUP_4_4 0x00000300  // Priority group 4.4 split
+#define NVIC_APINT_PRIGROUP_3_5 0x00000400  // Priority group 3.5 split
+#define NVIC_APINT_PRIGROUP_2_6 0x00000500  // Priority group 2.6 split
+#define NVIC_APINT_PRIGROUP_1_7 0x00000600  // Priority group 1.7 split
+#define NVIC_APINT_PRIGROUP_0_8 0x00000700  // Priority group 0.8 split
+#define NVIC_APINT_SYSRESETREQ  0x00000004  // System Reset Request
+#define NVIC_APINT_VECT_CLR_ACT 0x00000002  // Clear Active NMI / Fault
+#define NVIC_APINT_VECT_RESET   0x00000001  // System Reset
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SYS_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_SYS_CTRL_SEVONPEND 0x00000010  // Wake Up on Pending
+#define NVIC_SYS_CTRL_SLEEPDEEP 0x00000004  // Deep Sleep Enable
+#define NVIC_SYS_CTRL_SLEEPEXIT 0x00000002  // Sleep on ISR Exit
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_CFG_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_CFG_CTRL_STKALIGN  0x00000200  // Stack Alignment on Exception
+                                            // Entry
+#define NVIC_CFG_CTRL_BFHFNMIGN 0x00000100  // Ignore Bus Fault in NMI and
+                                            // Fault
+#define NVIC_CFG_CTRL_DIV0      0x00000010  // Trap on Divide by 0
+#define NVIC_CFG_CTRL_UNALIGNED 0x00000008  // Trap on Unaligned Access
+#define NVIC_CFG_CTRL_MAIN_PEND 0x00000002  // Allow Main Interrupt Trigger
+#define NVIC_CFG_CTRL_BASE_THR  0x00000001  // Thread State Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SYS_PRI1 register.
+//
+//*****************************************************************************
+#define NVIC_SYS_PRI1_USAGE_M   0x00E00000  // Usage Fault Priority
+#define NVIC_SYS_PRI1_BUS_M     0x0000E000  // Bus Fault Priority
+#define NVIC_SYS_PRI1_MEM_M     0x000000E0  // Memory Management Fault Priority
+#define NVIC_SYS_PRI1_USAGE_S   21
+#define NVIC_SYS_PRI1_BUS_S     13
+#define NVIC_SYS_PRI1_MEM_S     5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SYS_PRI2 register.
+//
+//*****************************************************************************
+#define NVIC_SYS_PRI2_SVC_M     0xE0000000  // SVCall Priority
+#define NVIC_SYS_PRI2_SVC_S     29
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SYS_PRI3 register.
+//
+//*****************************************************************************
+#define NVIC_SYS_PRI3_TICK_M    0xE0000000  // SysTick Exception Priority
+#define NVIC_SYS_PRI3_PENDSV_M  0x00E00000  // PendSV Priority
+#define NVIC_SYS_PRI3_DEBUG_M   0x000000E0  // Debug Priority
+#define NVIC_SYS_PRI3_TICK_S    29
+#define NVIC_SYS_PRI3_PENDSV_S  21
+#define NVIC_SYS_PRI3_DEBUG_S   5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SYS_HND_CTRL
+// register.
+//
+//*****************************************************************************
+#define NVIC_SYS_HND_CTRL_USAGE 0x00040000  // Usage Fault Enable
+#define NVIC_SYS_HND_CTRL_BUS   0x00020000  // Bus Fault Enable
+#define NVIC_SYS_HND_CTRL_MEM   0x00010000  // Memory Management Fault Enable
+#define NVIC_SYS_HND_CTRL_SVC   0x00008000  // SVC Call Pending
+#define NVIC_SYS_HND_CTRL_BUSP  0x00004000  // Bus Fault Pending
+#define NVIC_SYS_HND_CTRL_MEMP  0x00002000  // Memory Management Fault Pending
+#define NVIC_SYS_HND_CTRL_USAGEP                                              \
+                                0x00001000  // Usage Fault Pending
+#define NVIC_SYS_HND_CTRL_TICK  0x00000800  // SysTick Exception Active
+#define NVIC_SYS_HND_CTRL_PNDSV 0x00000400  // PendSV Exception Active
+#define NVIC_SYS_HND_CTRL_MON   0x00000100  // Debug Monitor Active
+#define NVIC_SYS_HND_CTRL_SVCA  0x00000080  // SVC Call Active
+#define NVIC_SYS_HND_CTRL_USGA  0x00000008  // Usage Fault Active
+#define NVIC_SYS_HND_CTRL_BUSA  0x00000002  // Bus Fault Active
+#define NVIC_SYS_HND_CTRL_MEMA  0x00000001  // Memory Management Fault Active
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_FAULT_STAT
+// register.
+//
+//*****************************************************************************
+#define NVIC_FAULT_STAT_DIV0    0x02000000  // Divide-by-Zero Usage Fault
+#define NVIC_FAULT_STAT_UNALIGN 0x01000000  // Unaligned Access Usage Fault
+#define NVIC_FAULT_STAT_NOCP    0x00080000  // No Coprocessor Usage Fault
+#define NVIC_FAULT_STAT_INVPC   0x00040000  // Invalid PC Load Usage Fault
+#define NVIC_FAULT_STAT_INVSTAT 0x00020000  // Invalid State Usage Fault
+#define NVIC_FAULT_STAT_UNDEF   0x00010000  // Undefined Instruction Usage
+                                            // Fault
+#define NVIC_FAULT_STAT_BFARV   0x00008000  // Bus Fault Address Register Valid
+#define NVIC_FAULT_STAT_BLSPERR 0x00002000  // Bus Fault on Floating-Point Lazy
+                                            // State Preservation
+#define NVIC_FAULT_STAT_BSTKE   0x00001000  // Stack Bus Fault
+#define NVIC_FAULT_STAT_BUSTKE  0x00000800  // Unstack Bus Fault
+#define NVIC_FAULT_STAT_IMPRE   0x00000400  // Imprecise Data Bus Error
+#define NVIC_FAULT_STAT_PRECISE 0x00000200  // Precise Data Bus Error
+#define NVIC_FAULT_STAT_IBUS    0x00000100  // Instruction Bus Error
+#define NVIC_FAULT_STAT_MMARV   0x00000080  // Memory Management Fault Address
+                                            // Register Valid
+#define NVIC_FAULT_STAT_MLSPERR 0x00000020  // Memory Management Fault on
+                                            // Floating-Point Lazy State
+                                            // Preservation
+#define NVIC_FAULT_STAT_MSTKE   0x00000010  // Stack Access Violation
+#define NVIC_FAULT_STAT_MUSTKE  0x00000008  // Unstack Access Violation
+#define NVIC_FAULT_STAT_DERR    0x00000002  // Data Access Violation
+#define NVIC_FAULT_STAT_IERR    0x00000001  // Instruction Access Violation
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_HFAULT_STAT
+// register.
+//
+//*****************************************************************************
+#define NVIC_HFAULT_STAT_DBG    0x80000000  // Debug Event
+#define NVIC_HFAULT_STAT_FORCED 0x40000000  // Forced Hard Fault
+#define NVIC_HFAULT_STAT_VECT   0x00000002  // Vector Table Read Fault
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DEBUG_STAT
+// register.
+//
+//*****************************************************************************
+#define NVIC_DEBUG_STAT_EXTRNL  0x00000010  // EDBGRQ asserted
+#define NVIC_DEBUG_STAT_VCATCH  0x00000008  // Vector catch
+#define NVIC_DEBUG_STAT_DWTTRAP 0x00000004  // DWT match
+#define NVIC_DEBUG_STAT_BKPT    0x00000002  // Breakpoint instruction
+#define NVIC_DEBUG_STAT_HALTED  0x00000001  // Halt request
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MM_ADDR register.
+//
+//*****************************************************************************
+#define NVIC_MM_ADDR_M          0xFFFFFFFF  // Fault Address
+#define NVIC_MM_ADDR_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_FAULT_ADDR
+// register.
+//
+//*****************************************************************************
+#define NVIC_FAULT_ADDR_M       0xFFFFFFFF  // Fault Address
+#define NVIC_FAULT_ADDR_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_CPAC register.
+//
+//*****************************************************************************
+#define NVIC_CPAC_CP11_M        0x00C00000  // CP11 Coprocessor Access
+                                            // Privilege
+#define NVIC_CPAC_CP11_DIS      0x00000000  // Access Denied
+#define NVIC_CPAC_CP11_PRIV     0x00400000  // Privileged Access Only
+#define NVIC_CPAC_CP11_FULL     0x00C00000  // Full Access
+#define NVIC_CPAC_CP10_M        0x00300000  // CP10 Coprocessor Access
+                                            // Privilege
+#define NVIC_CPAC_CP10_DIS      0x00000000  // Access Denied
+#define NVIC_CPAC_CP10_PRIV     0x00100000  // Privileged Access Only
+#define NVIC_CPAC_CP10_FULL     0x00300000  // Full Access
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_TYPE register.
+//
+//*****************************************************************************
+#define NVIC_MPU_TYPE_IREGION_M 0x00FF0000  // Number of I Regions
+#define NVIC_MPU_TYPE_DREGION_M 0x0000FF00  // Number of D Regions
+#define NVIC_MPU_TYPE_SEPARATE  0x00000001  // Separate or Unified MPU
+#define NVIC_MPU_TYPE_IREGION_S 16
+#define NVIC_MPU_TYPE_DREGION_S 8
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_MPU_CTRL_PRIVDEFEN 0x00000004  // MPU Default Region
+#define NVIC_MPU_CTRL_HFNMIENA  0x00000002  // MPU Enabled During Faults
+#define NVIC_MPU_CTRL_ENABLE    0x00000001  // MPU Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_NUMBER
+// register.
+//
+//*****************************************************************************
+#define NVIC_MPU_NUMBER_M       0x00000007  // MPU Region to Access
+#define NVIC_MPU_NUMBER_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_BASE register.
+//
+//*****************************************************************************
+#define NVIC_MPU_BASE_ADDR_M    0xFFFFFFE0  // Base Address Mask
+#define NVIC_MPU_BASE_VALID     0x00000010  // Region Number Valid
+#define NVIC_MPU_BASE_REGION_M  0x00000007  // Region Number
+#define NVIC_MPU_BASE_ADDR_S    5
+#define NVIC_MPU_BASE_REGION_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_ATTR register.
+//
+//*****************************************************************************
+#define NVIC_MPU_ATTR_XN        0x10000000  // Instruction Access Disable
+#define NVIC_MPU_ATTR_AP_M      0x07000000  // Access Privilege
+#define NVIC_MPU_ATTR_TEX_M     0x00380000  // Type Extension Mask
+#define NVIC_MPU_ATTR_SHAREABLE 0x00040000  // Shareable
+#define NVIC_MPU_ATTR_CACHEABLE 0x00020000  // Cacheable
+#define NVIC_MPU_ATTR_BUFFRABLE 0x00010000  // Bufferable
+#define NVIC_MPU_ATTR_SRD_M     0x0000FF00  // Subregion Disable Bits
+#define NVIC_MPU_ATTR_SIZE_M    0x0000003E  // Region Size Mask
+#define NVIC_MPU_ATTR_ENABLE    0x00000001  // Region Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_BASE1 register.
+//
+//*****************************************************************************
+#define NVIC_MPU_BASE1_ADDR_M   0xFFFFFFE0  // Base Address Mask
+#define NVIC_MPU_BASE1_VALID    0x00000010  // Region Number Valid
+#define NVIC_MPU_BASE1_REGION_M 0x00000007  // Region Number
+#define NVIC_MPU_BASE1_ADDR_S   5
+#define NVIC_MPU_BASE1_REGION_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_ATTR1 register.
+//
+//*****************************************************************************
+#define NVIC_MPU_ATTR1_XN       0x10000000  // Instruction Access Disable
+#define NVIC_MPU_ATTR1_AP_M     0x07000000  // Access Privilege
+#define NVIC_MPU_ATTR1_TEX_M    0x00380000  // Type Extension Mask
+#define NVIC_MPU_ATTR1_SHAREABLE                                              \
+                                0x00040000  // Shareable
+#define NVIC_MPU_ATTR1_CACHEABLE                                              \
+                                0x00020000  // Cacheable
+#define NVIC_MPU_ATTR1_BUFFRABLE                                              \
+                                0x00010000  // Bufferable
+#define NVIC_MPU_ATTR1_SRD_M    0x0000FF00  // Subregion Disable Bits
+#define NVIC_MPU_ATTR1_SIZE_M   0x0000003E  // Region Size Mask
+#define NVIC_MPU_ATTR1_ENABLE   0x00000001  // Region Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_BASE2 register.
+//
+//*****************************************************************************
+#define NVIC_MPU_BASE2_ADDR_M   0xFFFFFFE0  // Base Address Mask
+#define NVIC_MPU_BASE2_VALID    0x00000010  // Region Number Valid
+#define NVIC_MPU_BASE2_REGION_M 0x00000007  // Region Number
+#define NVIC_MPU_BASE2_ADDR_S   5
+#define NVIC_MPU_BASE2_REGION_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_ATTR2 register.
+//
+//*****************************************************************************
+#define NVIC_MPU_ATTR2_XN       0x10000000  // Instruction Access Disable
+#define NVIC_MPU_ATTR2_AP_M     0x07000000  // Access Privilege
+#define NVIC_MPU_ATTR2_TEX_M    0x00380000  // Type Extension Mask
+#define NVIC_MPU_ATTR2_SHAREABLE                                              \
+                                0x00040000  // Shareable
+#define NVIC_MPU_ATTR2_CACHEABLE                                              \
+                                0x00020000  // Cacheable
+#define NVIC_MPU_ATTR2_BUFFRABLE                                              \
+                                0x00010000  // Bufferable
+#define NVIC_MPU_ATTR2_SRD_M    0x0000FF00  // Subregion Disable Bits
+#define NVIC_MPU_ATTR2_SIZE_M   0x0000003E  // Region Size Mask
+#define NVIC_MPU_ATTR2_ENABLE   0x00000001  // Region Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_BASE3 register.
+//
+//*****************************************************************************
+#define NVIC_MPU_BASE3_ADDR_M   0xFFFFFFE0  // Base Address Mask
+#define NVIC_MPU_BASE3_VALID    0x00000010  // Region Number Valid
+#define NVIC_MPU_BASE3_REGION_M 0x00000007  // Region Number
+#define NVIC_MPU_BASE3_ADDR_S   5
+#define NVIC_MPU_BASE3_REGION_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_ATTR3 register.
+//
+//*****************************************************************************
+#define NVIC_MPU_ATTR3_XN       0x10000000  // Instruction Access Disable
+#define NVIC_MPU_ATTR3_AP_M     0x07000000  // Access Privilege
+#define NVIC_MPU_ATTR3_TEX_M    0x00380000  // Type Extension Mask
+#define NVIC_MPU_ATTR3_SHAREABLE                                              \
+                                0x00040000  // Shareable
+#define NVIC_MPU_ATTR3_CACHEABLE                                              \
+                                0x00020000  // Cacheable
+#define NVIC_MPU_ATTR3_BUFFRABLE                                              \
+                                0x00010000  // Bufferable
+#define NVIC_MPU_ATTR3_SRD_M    0x0000FF00  // Subregion Disable Bits
+#define NVIC_MPU_ATTR3_SIZE_M   0x0000003E  // Region Size Mask
+#define NVIC_MPU_ATTR3_ENABLE   0x00000001  // Region Enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DBG_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_DBG_CTRL_DBGKEY_M  0xFFFF0000  // Debug key mask
+#define NVIC_DBG_CTRL_DBGKEY    0xA05F0000  // Debug key
+#define NVIC_DBG_CTRL_S_RESET_ST                                              \
+                                0x02000000  // Core has reset since last read
+#define NVIC_DBG_CTRL_S_RETIRE_ST                                             \
+                                0x01000000  // Core has executed insruction
+                                            // since last read
+#define NVIC_DBG_CTRL_S_LOCKUP  0x00080000  // Core is locked up
+#define NVIC_DBG_CTRL_S_SLEEP   0x00040000  // Core is sleeping
+#define NVIC_DBG_CTRL_S_HALT    0x00020000  // Core status on halt
+#define NVIC_DBG_CTRL_S_REGRDY  0x00010000  // Register read/write available
+#define NVIC_DBG_CTRL_C_SNAPSTALL                                             \
+                                0x00000020  // Breaks a stalled load/store
+#define NVIC_DBG_CTRL_C_MASKINT 0x00000008  // Mask interrupts when stepping
+#define NVIC_DBG_CTRL_C_STEP    0x00000004  // Step the core
+#define NVIC_DBG_CTRL_C_HALT    0x00000002  // Halt the core
+#define NVIC_DBG_CTRL_C_DEBUGEN 0x00000001  // Enable debug
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DBG_XFER register.
+//
+//*****************************************************************************
+#define NVIC_DBG_XFER_REG_WNR   0x00010000  // Write or not read
+#define NVIC_DBG_XFER_REG_SEL_M 0x0000001F  // Register
+#define NVIC_DBG_XFER_REG_R0    0x00000000  // Register R0
+#define NVIC_DBG_XFER_REG_R1    0x00000001  // Register R1
+#define NVIC_DBG_XFER_REG_R2    0x00000002  // Register R2
+#define NVIC_DBG_XFER_REG_R3    0x00000003  // Register R3
+#define NVIC_DBG_XFER_REG_R4    0x00000004  // Register R4
+#define NVIC_DBG_XFER_REG_R5    0x00000005  // Register R5
+#define NVIC_DBG_XFER_REG_R6    0x00000006  // Register R6
+#define NVIC_DBG_XFER_REG_R7    0x00000007  // Register R7
+#define NVIC_DBG_XFER_REG_R8    0x00000008  // Register R8
+#define NVIC_DBG_XFER_REG_R9    0x00000009  // Register R9
+#define NVIC_DBG_XFER_REG_R10   0x0000000A  // Register R10
+#define NVIC_DBG_XFER_REG_R11   0x0000000B  // Register R11
+#define NVIC_DBG_XFER_REG_R12   0x0000000C  // Register R12
+#define NVIC_DBG_XFER_REG_R13   0x0000000D  // Register R13
+#define NVIC_DBG_XFER_REG_R14   0x0000000E  // Register R14
+#define NVIC_DBG_XFER_REG_R15   0x0000000F  // Register R15
+#define NVIC_DBG_XFER_REG_FLAGS 0x00000010  // xPSR/Flags register
+#define NVIC_DBG_XFER_REG_MSP   0x00000011  // Main SP
+#define NVIC_DBG_XFER_REG_PSP   0x00000012  // Process SP
+#define NVIC_DBG_XFER_REG_DSP   0x00000013  // Deep SP
+#define NVIC_DBG_XFER_REG_CFBP  0x00000014  // Control/Fault/BasePri/PriMask
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DBG_DATA register.
+//
+//*****************************************************************************
+#define NVIC_DBG_DATA_M         0xFFFFFFFF  // Data temporary cache
+#define NVIC_DBG_DATA_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DBG_INT register.
+//
+//*****************************************************************************
+#define NVIC_DBG_INT_HARDERR    0x00000400  // Debug trap on hard fault
+#define NVIC_DBG_INT_INTERR     0x00000200  // Debug trap on interrupt errors
+#define NVIC_DBG_INT_BUSERR     0x00000100  // Debug trap on bus error
+#define NVIC_DBG_INT_STATERR    0x00000080  // Debug trap on usage fault state
+#define NVIC_DBG_INT_CHKERR     0x00000040  // Debug trap on usage fault check
+#define NVIC_DBG_INT_NOCPERR    0x00000020  // Debug trap on coprocessor error
+#define NVIC_DBG_INT_MMERR      0x00000010  // Debug trap on mem manage fault
+#define NVIC_DBG_INT_RESET      0x00000008  // Core reset status
+#define NVIC_DBG_INT_RSTPENDCLR 0x00000004  // Clear pending core reset
+#define NVIC_DBG_INT_RSTPENDING 0x00000002  // Core reset is pending
+#define NVIC_DBG_INT_RSTVCATCH  0x00000001  // Reset vector catch
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SW_TRIG register.
+//
+//*****************************************************************************
+#define NVIC_SW_TRIG_INTID_M    0x000000FF  // Interrupt ID
+#define NVIC_SW_TRIG_INTID_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_FPCC register.
+//
+//*****************************************************************************
+#define NVIC_FPCC_ASPEN         0x80000000  // Automatic State Preservation
+                                            // Enable
+#define NVIC_FPCC_LSPEN         0x40000000  // Lazy State Preservation Enable
+#define NVIC_FPCC_MONRDY        0x00000100  // Monitor Ready
+#define NVIC_FPCC_BFRDY         0x00000040  // Bus Fault Ready
+#define NVIC_FPCC_MMRDY         0x00000020  // Memory Management Fault Ready
+#define NVIC_FPCC_HFRDY         0x00000010  // Hard Fault Ready
+#define NVIC_FPCC_THREAD        0x00000008  // Thread Mode
+#define NVIC_FPCC_USER          0x00000002  // User Privilege Level
+#define NVIC_FPCC_LSPACT        0x00000001  // Lazy State Preservation Active
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_FPCA register.
+//
+//*****************************************************************************
+#define NVIC_FPCA_ADDRESS_M     0xFFFFFFF8  // Address
+#define NVIC_FPCA_ADDRESS_S     3
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_FPDSC register.
+//
+//*****************************************************************************
+#define NVIC_FPDSC_AHP          0x04000000  // AHP Bit Default
+#define NVIC_FPDSC_DN           0x02000000  // DN Bit Default
+#define NVIC_FPDSC_FZ           0x01000000  // FZ Bit Default
+#define NVIC_FPDSC_RMODE_M      0x00C00000  // RMODE Bit Default
+#define NVIC_FPDSC_RMODE_RN     0x00000000  // Round to Nearest (RN) mode
+#define NVIC_FPDSC_RMODE_RP     0x00400000  // Round towards Plus Infinity (RP)
+                                            // mode
+#define NVIC_FPDSC_RMODE_RM     0x00800000  // Round towards Minus Infinity
+                                            // (RM) mode
+#define NVIC_FPDSC_RMODE_RZ     0x00C00000  // Round towards Zero (RZ) mode
+
+//*****************************************************************************
+//
+// The following definitions are deprecated.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+#define SYSCTL_DID0_CLASS_SNOWFLAKE                                           \
+                                0x000A0000  // Tiva(TM) C Series TM4C129-class
+                                            // microcontrollers
+
+//*****************************************************************************
+//
+// Deprecated defines for the bit fields in the SYSCTL_PWRTC register.
+//
+//*****************************************************************************
+#define SYSCTL_PWRTC_VDDA_UBOR0 0x00000010  // VDDA Under BOR0 Status
+#define SYSCTL_PWRTC_VDD_UBOR0  0x00000001  // VDD Under BOR0 Status
+
+#endif
+
+#endif // __TM4C129XNCZAD_H__
diff --git a/bsp/tm4c129x/libraries/startup/startup_gcc.c b/bsp/tm4c129x/libraries/startup/startup_gcc.c
index ae10bf8..ae3ce88 100644
--- a/bsp/tm4c129x/libraries/startup/startup_gcc.c
+++ b/bsp/tm4c129x/libraries/startup/startup_gcc.c
@@ -42,17 +42,22 @@ static void IntDefaultHandler(void);
 //
 //*****************************************************************************
 extern int main(void);
-
+extern void IntGpioD();
 extern void SysTick_Handler(void);
 extern void PendSV_Handler(void);
 extern void UART0_IRQHandler(void);
+extern void UART6_IRQHandler(void);
+extern void UART2_IRQHandler(void);
+extern void UART3_IRQHandler(void);
+extern void UART4_IRQHandler(void);
+extern void USB0DeviceIntHandler(void);
 extern void HardFault_Handler(void);
 //*****************************************************************************
 //
 // Reserve space for the system stack.
 //
 //*****************************************************************************
-static uint32_t pui32Stack[64];
+static uint32_t pui32Stack[512];
 
 //*****************************************************************************
 //
@@ -81,9 +86,9 @@ void (* const g_pfnVectors[])(void) =
     PendSV_Handler,                         // The PendSV handler
     SysTick_Handler,                        // The SysTick handler
     IntDefaultHandler,                      // GPIO Port A
-    IntDefaultHandler,                      // GPIO Port B
+    IntDefaultHandler,                      		// GPIO Port B
     IntDefaultHandler,                      // GPIO Port C
-    IntDefaultHandler,                      // GPIO Port D
+    IntGpioD,                      		  // GPIO Port D
     IntDefaultHandler,                      // GPIO Port E
     UART0_IRQHandler,                      // UART0 Rx and Tx
     IntDefaultHandler,                      // UART1 Rx and Tx
@@ -113,7 +118,7 @@ void (* const g_pfnVectors[])(void) =
     IntDefaultHandler,                      // GPIO Port F
     IntDefaultHandler,                      // GPIO Port G
     IntDefaultHandler,                      // GPIO Port H
-    IntDefaultHandler,                      // UART2 Rx and Tx
+    UART2_IRQHandler,                      // UART2 Rx and Tx
     IntDefaultHandler,                      // SSI1 Rx and Tx
     IntDefaultHandler,                      // Timer 3 subtimer A
     IntDefaultHandler,                      // Timer 3 subtimer B
@@ -122,7 +127,7 @@ void (* const g_pfnVectors[])(void) =
     IntDefaultHandler,                      // CAN1
     IntDefaultHandler,                      // Ethernet
     IntDefaultHandler,                      // Hibernate
-    IntDefaultHandler,                      // USB0
+    USB0DeviceIntHandler,                      // USB0
     IntDefaultHandler,                      // PWM Generator 3
     IntDefaultHandler,                      // uDMA Software Transfer
     IntDefaultHandler,                      // uDMA Error
@@ -136,10 +141,10 @@ void (* const g_pfnVectors[])(void) =
     IntDefaultHandler,                      // GPIO Port L
     IntDefaultHandler,                      // SSI2 Rx and Tx
     IntDefaultHandler,                      // SSI3 Rx and Tx
-    IntDefaultHandler,                      // UART3 Rx and Tx
-    IntDefaultHandler,                      // UART4 Rx and Tx
+    UART3_IRQHandler,                      // UART3 Rx and Tx
+    UART4_IRQHandler,                      // UART4 Rx and Tx
     IntDefaultHandler,                      // UART5 Rx and Tx
-    IntDefaultHandler,                      // UART6 Rx and Tx
+    UART6_IRQHandler,                      // UART6 Rx and Tx
     IntDefaultHandler,                      // UART7 Rx and Tx
     IntDefaultHandler,                      // I2C2 Master and Slave
     IntDefaultHandler,                      // I2C3 Master and Slave
diff --git a/bsp/tm4c129x/libraries/usblib/Makefile b/bsp/tm4c129x/libraries/usblib/Makefile
new file mode 100755
index 0000000..b554dda
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/Makefile
@@ -0,0 +1,103 @@
+#******************************************************************************
+#
+# Makefile - Rules for building the USB library.
+#
+# Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+# Software License Agreement
+# 
+# Texas Instruments (TI) is supplying this software for use solely and
+# exclusively on TI's microcontroller products. The software is owned by
+# TI and/or its suppliers, and is protected under applicable copyright
+# laws. You may not combine this software with "viral" open-source
+# software in order to form a larger program.
+# 
+# THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+# NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+# NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+# CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+# DAMAGES, FOR ANY REASON WHATSOEVER.
+# 
+# This is part of revision 2.1.0.12573 of the Tiva USB Library.
+#
+#******************************************************************************
+
+#
+# The base directory for TivaWare.
+#
+ROOT=..
+
+#
+# Include the common make definitions.
+#
+include ${ROOT}/makedefs
+
+#
+# Where to find source files that do not live in this directory.
+#
+VPATH=./device
+VPATH+=./host
+
+#
+# Where to find header files that do not live in the source directory.
+#
+IPATH=..
+
+#
+# The default rule, which causes the USB library to be built.
+#
+all: ${COMPILER}
+all: ${COMPILER}/libusb.a
+
+#
+# The rule to clean out all the build products.
+#
+clean:
+	@rm -rf ${COMPILER} ${wildcard *~}
+
+#
+# The rule to create the target directory.
+#
+${COMPILER}:
+	@mkdir -p ${COMPILER}
+
+#
+# Rules for building the USB library.
+#
+${COMPILER}/libusb.a: ${COMPILER}/usbbuffer.o
+${COMPILER}/libusb.a: ${COMPILER}/usbdaudio.o
+${COMPILER}/libusb.a: ${COMPILER}/usbdbulk.o
+${COMPILER}/libusb.a: ${COMPILER}/usbdcdc.o
+${COMPILER}/libusb.a: ${COMPILER}/usbdcdesc.o
+${COMPILER}/libusb.a: ${COMPILER}/usbdcomp.o
+${COMPILER}/libusb.a: ${COMPILER}/usbdconfig.o
+${COMPILER}/libusb.a: ${COMPILER}/usbddfu-rt.o
+${COMPILER}/libusb.a: ${COMPILER}/usbdenum.o
+${COMPILER}/libusb.a: ${COMPILER}/usbdesc.o
+${COMPILER}/libusb.a: ${COMPILER}/usbdhandler.o
+${COMPILER}/libusb.a: ${COMPILER}/usbdhid.o
+${COMPILER}/libusb.a: ${COMPILER}/usbdhidgamepad.o
+${COMPILER}/libusb.a: ${COMPILER}/usbdhidkeyb.o
+${COMPILER}/libusb.a: ${COMPILER}/usbdhidmouse.o
+${COMPILER}/libusb.a: ${COMPILER}/usbdma.o
+${COMPILER}/libusb.a: ${COMPILER}/usbdmsc.o
+${COMPILER}/libusb.a: ${COMPILER}/usbhaudio.o
+${COMPILER}/libusb.a: ${COMPILER}/usbhhid.o
+${COMPILER}/libusb.a: ${COMPILER}/usbhhidkeyboard.o
+${COMPILER}/libusb.a: ${COMPILER}/usbhhidmouse.o
+${COMPILER}/libusb.a: ${COMPILER}/usbhhub.o
+${COMPILER}/libusb.a: ${COMPILER}/usbhmsc.o
+${COMPILER}/libusb.a: ${COMPILER}/usbhostenum.o
+${COMPILER}/libusb.a: ${COMPILER}/usbhscsi.o
+${COMPILER}/libusb.a: ${COMPILER}/usbkeyboardmap.o
+${COMPILER}/libusb.a: ${COMPILER}/usbmode.o
+${COMPILER}/libusb.a: ${COMPILER}/usbringbuf.o
+${COMPILER}/libusb.a: ${COMPILER}/usbtick.o
+${COMPILER}/libusb.a: ${COMPILER}/usbulpi.o
+
+#
+# Include the automatically generated dependency files.
+#
+ifneq (${MAKECMDGOALS},clean)
+-include ${wildcard ${COMPILER}/*.d} __dummy__
+endif
diff --git a/bsp/tm4c129x/libraries/usblib/ccs/.ccsproject b/bsp/tm4c129x/libraries/usblib/ccs/.ccsproject
new file mode 100755
index 0000000..7796c65
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/ccs/.ccsproject
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+<?ccsproject version="1.0"?>
+<projectOptions>
+	<deviceVariant value="Cortex M.TM4C1230C3PM"/>
+	<deviceFamily value="TMS470"/>
+	<deviceEndianness value="little"/>
+	<codegenToolVersion value="5.0.4"/>
+	<isElfFormat value="true"/>
+</projectOptions>
diff --git a/bsp/tm4c129x/libraries/usblib/ccs/.cproject b/bsp/tm4c129x/libraries/usblib/ccs/.cproject
new file mode 100755
index 0000000..7db6d88
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/ccs/.cproject
@@ -0,0 +1,164 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<?fileVersion 4.0.0?>
+
+<cproject storage_type_id="org.eclipse.cdt.core.XmlProjectDescriptionStorage">
+	<storageModule moduleId="org.eclipse.cdt.core.settings">
+		<cconfiguration id="com.ti.ccstudio.buildDefinitions.TMS470.Debug.688171224">
+			<storageModule buildSystemId="org.eclipse.cdt.managedbuilder.core.configurationDataProvider" id="com.ti.ccstudio.buildDefinitions.TMS470.Debug.688171224" moduleId="org.eclipse.cdt.core.settings" name="Debug">
+				<macros>
+					<stringMacro name="SW_ROOT" type="VALUE_PATH_DIR" value="${PROJECT_ROOT}/../.."/>
+				</macros>
+				<externalSettings/>
+				<extensions>
+					<extension id="com.ti.ccstudio.binaryparser.CoffParser" point="org.eclipse.cdt.core.BinaryParser"/>
+					<extension id="com.ti.ccstudio.errorparser.CoffErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="com.ti.ccstudio.errorparser.LinkErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="com.ti.ccstudio.errorparser.AsmErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+				</extensions>
+			</storageModule>
+			<storageModule moduleId="cdtBuildSystem" version="4.0.0">
+				<configuration artifactExtension="lib" artifactName="${ProjName}" buildProperties="" cleanCommand="${CG_CLEAN_CMD}" description="" id="com.ti.ccstudio.buildDefinitions.TMS470.Debug.688171224" name="Debug" parent="com.ti.ccstudio.buildDefinitions.TMS470.Debug">
+					<folderInfo id="com.ti.ccstudio.buildDefinitions.TMS470.Debug.688171224." name="/" resourcePath="">
+						<toolChain id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.libraryDebugToolchain.1199429182" name="TI Build Tools" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.libraryDebugToolchain" targetTool="com.ti.ccstudio.buildDefinitions.TMS470_5.0.library.librarianDebug.517344320">
+							<option id="com.ti.ccstudio.buildDefinitions.core.OPT_TAGS.1656348484" superClass="com.ti.ccstudio.buildDefinitions.core.OPT_TAGS" valueType="stringList">
+								<listOptionValue builtIn="false" value="DEVICE_CONFIGURATION_ID=Cortex M.TM4C1230C3PM"/>
+								<listOptionValue builtIn="false" value="DEVICE_ENDIANNESS=little"/>
+								<listOptionValue builtIn="false" value="OUTPUT_FORMAT=ELF"/>
+								<listOptionValue builtIn="false" value="CCS_MBS_VERSION=5.1.0.01"/>
+								<listOptionValue builtIn="false" value="OUTPUT_TYPE=staticLibrary"/>
+							</option>
+							<option id="com.ti.ccstudio.buildDefinitions.core.OPT_CODEGEN_VERSION.1071374229" superClass="com.ti.ccstudio.buildDefinitions.core.OPT_CODEGEN_VERSION" value="5.0.4" valueType="string"/>
+							<targetPlatform id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.library.targetPlatformDebug.1526412577" name="Platform" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.library.targetPlatformDebug"/>
+							<builder buildPath="${BuildDirectory}" id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.library.builderDebug.1762046893" name="GNU Make.Debug" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.library.builderDebug"/>
+							<tool id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.library.compilerDebug.1251797066" name="ARM Compiler" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.library.compilerDebug">
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.SILICON_VERSION.812149092" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.SILICON_VERSION" value="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.SILICON_VERSION.7M4" valueType="enumerated"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.CODE_STATE.2015628749" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.CODE_STATE" value="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.CODE_STATE.16" valueType="enumerated"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.ABI.1495507101" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.ABI" value="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.ABI.eabi" valueType="enumerated"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.FLOAT_SUPPORT.1886829153" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.FLOAT_SUPPORT" value="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.FLOAT_SUPPORT.FPv4SPD16" valueType="enumerated"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DEBUGGING_MODEL.296773954" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DEBUGGING_MODEL" value="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DEBUGGING_MODEL.SYMDEBUG__DWARF" valueType="enumerated"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DIAG_WARNING.1719263867" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DIAG_WARNING" valueType="stringList">
+									<listOptionValue builtIn="false" value="225"/>
+								</option>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DISPLAY_ERROR_NUMBER.1222339691" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DISPLAY_ERROR_NUMBER" value="true" valueType="boolean"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DIAG_WRAP.2113959950" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DIAG_WRAP" value="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DIAG_WRAP.off" valueType="enumerated"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.INCLUDE_PATH.1821809944" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.INCLUDE_PATH" valueType="includePath">
+									<listOptionValue builtIn="false" value="&quot;${CG_TOOL_ROOT}/include&quot;"/>
+									<listOptionValue builtIn="false" value="&quot;${SW_ROOT}&quot;"/>
+								</option>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.LITTLE_ENDIAN.1638962570" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.LITTLE_ENDIAN" value="true" valueType="boolean"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.GEN_FUNC_SUBSECTIONS.291209018" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.GEN_FUNC_SUBSECTIONS" value="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.GEN_FUNC_SUBSECTIONS.on" valueType="enumerated"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.OPT_LEVEL.187298390" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.OPT_LEVEL" value="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.OPT_LEVEL.2" valueType="enumerated"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.GCC.604934158" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.GCC" value="true" valueType="boolean"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.UAL.1446620616" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.UAL" value="true" valueType="boolean"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DEFINE.462031813" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DEFINE" valueType="definedSymbols">
+									<listOptionValue builtIn="false" value="ccs=&quot;ccs&quot;"/>
+								</option>
+								<inputType id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__C_SRCS.813107964" name="C Sources" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__C_SRCS"/>
+								<inputType id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__CPP_SRCS.124449644" name="C++ Sources" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__CPP_SRCS"/>
+								<inputType id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__ASM_SRCS.999923136" name="Assembly Sources" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__ASM_SRCS"/>
+								<inputType id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__ASM2_SRCS.212027145" name="Assembly Sources" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__ASM2_SRCS"/>
+							</tool>
+							<tool id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.library.librarianDebug.517344320" name="ARM Archiver" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.library.librarianDebug">
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.archiverID.OUTPUT_FILE.1315708159" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.archiverID.OUTPUT_FILE" value="&quot;${ProjName}.lib&quot;" valueType="string"/>
+							</tool>
+						</toolChain>
+					</folderInfo>
+				</configuration>
+			</storageModule>
+			<storageModule moduleId="org.eclipse.cdt.core.externalSettings"/>
+		</cconfiguration>
+		<cconfiguration id="com.ti.ccstudio.buildDefinitions.TMS470.Release.1976680244">
+			<storageModule buildSystemId="org.eclipse.cdt.managedbuilder.core.configurationDataProvider" id="com.ti.ccstudio.buildDefinitions.TMS470.Release.1976680244" moduleId="org.eclipse.cdt.core.settings" name="Release">
+				<macros>
+					<stringMacro name="SW_ROOT" type="VALUE_PATH_DIR" value="${PROJECT_ROOT}/../.."/>
+				</macros>
+				<externalSettings/>
+				<extensions>
+					<extension id="com.ti.ccstudio.binaryparser.CoffParser" point="org.eclipse.cdt.core.BinaryParser"/>
+					<extension id="com.ti.ccstudio.errorparser.CoffErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="com.ti.ccstudio.errorparser.LinkErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="com.ti.ccstudio.errorparser.AsmErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+				</extensions>
+			</storageModule>
+			<storageModule moduleId="cdtBuildSystem" version="4.0.0">
+				<configuration artifactExtension="lib" artifactName="${ProjName}" buildProperties="" cleanCommand="${CG_CLEAN_CMD}" description="" id="com.ti.ccstudio.buildDefinitions.TMS470.Release.1976680244" name="Release" parent="com.ti.ccstudio.buildDefinitions.TMS470.Release">
+					<folderInfo id="com.ti.ccstudio.buildDefinitions.TMS470.Release.1976680244." name="/" resourcePath="">
+						<toolChain id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.library.ReleaseToolchain.1043090827" name="TI Build Tools" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.library.ReleaseToolchain" targetTool="com.ti.ccstudio.buildDefinitions.TMS470_5.0.library.librarianRelease.472098384">
+							<option id="com.ti.ccstudio.buildDefinitions.core.OPT_TAGS.1111383295" superClass="com.ti.ccstudio.buildDefinitions.core.OPT_TAGS" valueType="stringList">
+								<listOptionValue builtIn="false" value="DEVICE_CONFIGURATION_ID=Cortex M.TM4C1230C3PM"/>
+								<listOptionValue builtIn="false" value="DEVICE_ENDIANNESS=little"/>
+								<listOptionValue builtIn="false" value="OUTPUT_FORMAT=ELF"/>
+								<listOptionValue builtIn="false" value="CCS_MBS_VERSION=5.1.0.01"/>
+								<listOptionValue builtIn="false" value="OUTPUT_TYPE=staticLibrary"/>
+							</option>
+							<option id="com.ti.ccstudio.buildDefinitions.core.OPT_CODEGEN_VERSION.88898150" superClass="com.ti.ccstudio.buildDefinitions.core.OPT_CODEGEN_VERSION" value="5.0.4" valueType="string"/>
+							<targetPlatform id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.library.targetPlatformRelease.644864433" name="Platform" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.library.targetPlatformRelease"/>
+							<builder buildPath="${BuildDirectory}" id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.library.builderRelease.1887536299" name="GNU Make.Release" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.library.builderRelease"/>
+							<tool id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.library.compilerRelease.764598937" name="ARM Compiler" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.library.compilerRelease">
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.SILICON_VERSION.718553667" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.SILICON_VERSION" value="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.SILICON_VERSION.7M4" valueType="enumerated"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.CODE_STATE.851432476" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.CODE_STATE" value="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.CODE_STATE.16" valueType="enumerated"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.ABI.1727423064" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.ABI" value="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.ABI.eabi" valueType="enumerated"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.FLOAT_SUPPORT.1008942853" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.FLOAT_SUPPORT" value="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.FLOAT_SUPPORT.FPv4SPD16" valueType="enumerated"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DIAG_WARNING.1359721383" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DIAG_WARNING" valueType="stringList">
+									<listOptionValue builtIn="false" value="225"/>
+								</option>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DISPLAY_ERROR_NUMBER.2078518258" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DISPLAY_ERROR_NUMBER" value="true" valueType="boolean"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DIAG_WRAP.1006078791" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DIAG_WRAP" value="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DIAG_WRAP.off" valueType="enumerated"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.INCLUDE_PATH.1832633464" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.INCLUDE_PATH" valueType="includePath">
+									<listOptionValue builtIn="false" value="&quot;${CG_TOOL_ROOT}/include&quot;"/>
+									<listOptionValue builtIn="false" value="&quot;${SW_ROOT}&quot;"/>
+								</option>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.LITTLE_ENDIAN.1338574271" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.LITTLE_ENDIAN" value="true" valueType="boolean"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.GEN_FUNC_SUBSECTIONS.1604415284" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.GEN_FUNC_SUBSECTIONS" value="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.GEN_FUNC_SUBSECTIONS.on" valueType="enumerated"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.GCC.305169826" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.GCC" value="true" valueType="boolean"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.UAL.1395139601" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.UAL" value="true" valueType="boolean"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DEFINE.586555075" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DEFINE" valueType="definedSymbols">
+									<listOptionValue builtIn="false" value="ccs=&quot;ccs&quot;"/>
+								</option>
+								<inputType id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__C_SRCS.1682483173" name="C Sources" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__C_SRCS"/>
+								<inputType id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__CPP_SRCS.1780668618" name="C++ Sources" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__CPP_SRCS"/>
+								<inputType id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__ASM_SRCS.847380163" name="Assembly Sources" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__ASM_SRCS"/>
+								<inputType id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__ASM2_SRCS.1792912495" name="Assembly Sources" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__ASM2_SRCS"/>
+							</tool>
+							<tool id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.library.librarianRelease.472098384" name="ARM Archiver" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.library.librarianRelease">
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.archiverID.OUTPUT_FILE.2135546246" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.archiverID.OUTPUT_FILE" value="&quot;${ProjName}.lib&quot;" valueType="string"/>
+							</tool>
+						</toolChain>
+					</folderInfo>
+				</configuration>
+			</storageModule>
+			<storageModule moduleId="org.eclipse.cdt.core.externalSettings"/>
+		</cconfiguration>
+	</storageModule>
+	<storageModule moduleId="org.eclipse.cdt.core.LanguageSettingsProviders"/>
+	<storageModule moduleId="cdtBuildSystem" version="4.0.0">
+		<project id="usblib.com.ti.ccstudio.buildDefinitions.TMS470.ProjectType.1894937210" name="ARM" projectType="com.ti.ccstudio.buildDefinitions.TMS470.ProjectType"/>
+	</storageModule>
+	<storageModule moduleId="scannerConfiguration">
+		<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId=""/>
+		<scannerConfigBuildInfo instanceId="com.ti.ccstudio.buildDefinitions.TMS470.Release.1976680244;com.ti.ccstudio.buildDefinitions.TMS470.Release.1976680244.;com.ti.ccstudio.buildDefinitions.TMS470_5.0.library.compilerRelease.764598937;com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__C_SRCS.1682483173">
+			<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId="com.ti.ccstudio.project.core.CCSScannerDiscoveryProfile"/>
+		</scannerConfigBuildInfo>
+		<scannerConfigBuildInfo instanceId="com.ti.ccstudio.buildDefinitions.TMS470.Release.1976680244;com.ti.ccstudio.buildDefinitions.TMS470.Release.1976680244.;com.ti.ccstudio.buildDefinitions.TMS470_5.0.library.compilerRelease.764598937;com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__ASM2_SRCS.1792912495">
+			<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId="com.ti.ccstudio.project.core.CCSScannerDiscoveryProfile"/>
+		</scannerConfigBuildInfo>
+		<scannerConfigBuildInfo instanceId="com.ti.ccstudio.buildDefinitions.TMS470.Debug.688171224;com.ti.ccstudio.buildDefinitions.TMS470.Debug.688171224.;com.ti.ccstudio.buildDefinitions.TMS470_5.0.library.compilerDebug.1251797066;com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__C_SRCS.813107964">
+			<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId="com.ti.ccstudio.project.core.CCSScannerDiscoveryProfile"/>
+		</scannerConfigBuildInfo>
+		<scannerConfigBuildInfo instanceId="com.ti.ccstudio.buildDefinitions.TMS470.Debug.688171224;com.ti.ccstudio.buildDefinitions.TMS470.Debug.688171224.;com.ti.ccstudio.buildDefinitions.TMS470_5.0.library.compilerDebug.1251797066;com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__ASM2_SRCS.212027145">
+			<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId="com.ti.ccstudio.project.core.CCSScannerDiscoveryProfile"/>
+		</scannerConfigBuildInfo>
+		<scannerConfigBuildInfo instanceId="com.ti.ccstudio.buildDefinitions.TMS470.Debug.688171224;com.ti.ccstudio.buildDefinitions.TMS470.Debug.688171224.;com.ti.ccstudio.buildDefinitions.TMS470_5.0.library.compilerDebug.1251797066;com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__CPP_SRCS.124449644">
+			<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId="com.ti.ccstudio.project.core.CCSScannerDiscoveryProfile"/>
+		</scannerConfigBuildInfo>
+		<scannerConfigBuildInfo instanceId="com.ti.ccstudio.buildDefinitions.TMS470.Release.1976680244;com.ti.ccstudio.buildDefinitions.TMS470.Release.1976680244.;com.ti.ccstudio.buildDefinitions.TMS470_5.0.library.compilerRelease.764598937;com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__CPP_SRCS.1780668618">
+			<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId="com.ti.ccstudio.project.core.CCSScannerDiscoveryProfile"/>
+		</scannerConfigBuildInfo>
+		<scannerConfigBuildInfo instanceId="com.ti.ccstudio.buildDefinitions.TMS470.Release.1976680244;com.ti.ccstudio.buildDefinitions.TMS470.Release.1976680244.;com.ti.ccstudio.buildDefinitions.TMS470_5.0.library.compilerRelease.764598937;com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__ASM_SRCS.847380163">
+			<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId="com.ti.ccstudio.project.core.CCSScannerDiscoveryProfile"/>
+		</scannerConfigBuildInfo>
+		<scannerConfigBuildInfo instanceId="com.ti.ccstudio.buildDefinitions.TMS470.Debug.688171224;com.ti.ccstudio.buildDefinitions.TMS470.Debug.688171224.;com.ti.ccstudio.buildDefinitions.TMS470_5.0.library.compilerDebug.1251797066;com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__ASM_SRCS.999923136">
+			<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId="com.ti.ccstudio.project.core.CCSScannerDiscoveryProfile"/>
+		</scannerConfigBuildInfo>
+	</storageModule>
+</cproject>
diff --git a/bsp/tm4c129x/libraries/usblib/ccs/.project b/bsp/tm4c129x/libraries/usblib/ccs/.project
new file mode 100755
index 0000000..5fe45f0
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/ccs/.project
@@ -0,0 +1,185 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>usblib</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.genmakebuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.ScannerConfigBuilder</name>
+			<triggers>full,incremental,</triggers>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.ti.ccstudio.core.ccsNature</nature>
+		<nature>org.eclipse.cdt.core.cnature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.managedBuildNature</nature>
+		<nature>org.eclipse.cdt.core.ccnature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.ScannerConfigNature</nature>
+	</natures>
+	<linkedResources>
+		<link>
+			<name>usbbuffer.c</name>
+			<type>1</type>
+			<locationURI>SW_ROOT/usblib/usbbuffer.c</locationURI>
+		</link>
+		<link>
+			<name>usbdesc.c</name>
+			<type>1</type>
+			<locationURI>SW_ROOT/usblib/usbdesc.c</locationURI>
+		</link>
+		<link>
+			<name>usbdma.c</name>
+			<type>1</type>
+			<locationURI>SW_ROOT/usblib/usbdma.c</locationURI>
+		</link>
+		<link>
+			<name>usbkeyboardmap.c</name>
+			<type>1</type>
+			<locationURI>SW_ROOT/usblib/usbkeyboardmap.c</locationURI>
+		</link>
+		<link>
+			<name>usbmode.c</name>
+			<type>1</type>
+			<locationURI>SW_ROOT/usblib/usbmode.c</locationURI>
+		</link>
+		<link>
+			<name>usbringbuf.c</name>
+			<type>1</type>
+			<locationURI>SW_ROOT/usblib/usbringbuf.c</locationURI>
+		</link>
+		<link>
+			<name>usbtick.c</name>
+			<type>1</type>
+			<locationURI>SW_ROOT/usblib/usbtick.c</locationURI>
+		</link>
+		<link>
+			<name>usbulpi.c</name>
+			<type>1</type>
+			<locationURI>SW_ROOT/usblib/usbulpi.c</locationURI>
+		</link>
+		<link>
+			<name>device/usbdaudio.c</name>
+			<type>1</type>
+			<locationURI>SW_ROOT/usblib/device/usbdaudio.c</locationURI>
+		</link>
+		<link>
+			<name>device/usbdbulk.c</name>
+			<type>1</type>
+			<locationURI>SW_ROOT/usblib/device/usbdbulk.c</locationURI>
+		</link>
+		<link>
+			<name>device/usbdcdc.c</name>
+			<type>1</type>
+			<locationURI>SW_ROOT/usblib/device/usbdcdc.c</locationURI>
+		</link>
+		<link>
+			<name>device/usbdcdesc.c</name>
+			<type>1</type>
+			<locationURI>SW_ROOT/usblib/device/usbdcdesc.c</locationURI>
+		</link>
+		<link>
+			<name>device/usbdcomp.c</name>
+			<type>1</type>
+			<locationURI>SW_ROOT/usblib/device/usbdcomp.c</locationURI>
+		</link>
+		<link>
+			<name>device/usbdconfig.c</name>
+			<type>1</type>
+			<locationURI>SW_ROOT/usblib/device/usbdconfig.c</locationURI>
+		</link>
+		<link>
+			<name>device/usbddfu-rt.c</name>
+			<type>1</type>
+			<locationURI>SW_ROOT/usblib/device/usbddfu-rt.c</locationURI>
+		</link>
+		<link>
+			<name>device/usbdenum.c</name>
+			<type>1</type>
+			<locationURI>SW_ROOT/usblib/device/usbdenum.c</locationURI>
+		</link>
+		<link>
+			<name>device/usbdhandler.c</name>
+			<type>1</type>
+			<locationURI>SW_ROOT/usblib/device/usbdhandler.c</locationURI>
+		</link>
+		<link>
+			<name>device/usbdhid.c</name>
+			<type>1</type>
+			<locationURI>SW_ROOT/usblib/device/usbdhid.c</locationURI>
+		</link>
+		<link>
+			<name>device/usbdhidgamepad.c</name>
+			<type>1</type>
+			<locationURI>SW_ROOT/usblib/device/usbdhidgamepad.c</locationURI>
+		</link>
+		<link>
+			<name>device/usbdhidkeyb.c</name>
+			<type>1</type>
+			<locationURI>SW_ROOT/usblib/device/usbdhidkeyb.c</locationURI>
+		</link>
+		<link>
+			<name>device/usbdhidmouse.c</name>
+			<type>1</type>
+			<locationURI>SW_ROOT/usblib/device/usbdhidmouse.c</locationURI>
+		</link>
+		<link>
+			<name>device/usbdmsc.c</name>
+			<type>1</type>
+			<locationURI>SW_ROOT/usblib/device/usbdmsc.c</locationURI>
+		</link>
+		<link>
+			<name>host/usbhaudio.c</name>
+			<type>1</type>
+			<locationURI>SW_ROOT/usblib/host/usbhaudio.c</locationURI>
+		</link>
+		<link>
+			<name>host/usbhhid.c</name>
+			<type>1</type>
+			<locationURI>SW_ROOT/usblib/host/usbhhid.c</locationURI>
+		</link>
+		<link>
+			<name>host/usbhhidkeyboard.c</name>
+			<type>1</type>
+			<locationURI>SW_ROOT/usblib/host/usbhhidkeyboard.c</locationURI>
+		</link>
+		<link>
+			<name>host/usbhhidmouse.c</name>
+			<type>1</type>
+			<locationURI>SW_ROOT/usblib/host/usbhhidmouse.c</locationURI>
+		</link>
+		<link>
+			<name>host/usbhhub.c</name>
+			<type>1</type>
+			<locationURI>SW_ROOT/usblib/host/usbhhub.c</locationURI>
+		</link>
+		<link>
+			<name>host/usbhmsc.c</name>
+			<type>1</type>
+			<locationURI>SW_ROOT/usblib/host/usbhmsc.c</locationURI>
+		</link>
+		<link>
+			<name>host/usbhostenum.c</name>
+			<type>1</type>
+			<locationURI>SW_ROOT/usblib/host/usbhostenum.c</locationURI>
+		</link>
+		<link>
+			<name>host/usbhscsi.c</name>
+			<type>1</type>
+			<locationURI>SW_ROOT/usblib/host/usbhscsi.c</locationURI>
+		</link>
+	</linkedResources>
+	<variableList>
+		<variable>
+			<name>SW_ROOT</name>
+			<value>$%7BPARENT-2-PROJECT_LOC%7D</value>
+		</variable>
+	</variableList>
+</projectDescription>
diff --git a/bsp/tm4c129x/libraries/usblib/ccs/.settings/org.eclipse.cdt.codan.core.prefs b/bsp/tm4c129x/libraries/usblib/ccs/.settings/org.eclipse.cdt.codan.core.prefs
new file mode 100755
index 0000000..f653028
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/ccs/.settings/org.eclipse.cdt.codan.core.prefs
@@ -0,0 +1,3 @@
+eclipse.preferences.version=1
+inEditor=false
+onBuild=false
diff --git a/bsp/tm4c129x/libraries/usblib/ccs/macros.ini_initial b/bsp/tm4c129x/libraries/usblib/ccs/macros.ini_initial
new file mode 100755
index 0000000..89a26bd
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/ccs/macros.ini_initial
@@ -0,0 +1 @@
+SW_ROOT = ../..
diff --git a/bsp/tm4c129x/libraries/usblib/device/usbdaudio.c b/bsp/tm4c129x/libraries/usblib/device/usbdaudio.c
new file mode 100755
index 0000000..36ec664
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/device/usbdaudio.c
@@ -0,0 +1,1510 @@
+//*****************************************************************************
+//
+// usbdaudio.c - USB audio device class driver.
+//
+// Copyright (c) 2009-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "inc/hw_memmap.h"
+#include "inc/hw_types.h"
+#include "driverlib/debug.h"
+#include "driverlib/rom.h"
+#include "driverlib/rom_map.h"
+#include "driverlib/usb.h"
+#include "usblib/usblib.h"
+#include "usblib/usblibpriv.h"
+#include "usblib/usbaudio.h"
+#include "usblib/device/usbdevice.h"
+#include "usblib/device/usbdaudio.h"
+
+//*****************************************************************************
+//
+//! \addtogroup audio_device_class_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// The following are the USB audio descriptor identifiers.
+//
+//*****************************************************************************
+#define AUDIO_IN_TERMINAL_ID    1
+#define AUDIO_OUT_TERMINAL_ID   2
+#define AUDIO_CONTROL_ID        3
+
+//*****************************************************************************
+//
+// The following are the USB interface numbers for this audio device.
+//
+//*****************************************************************************
+#define AUDIO_INTERFACE_CONTROL 0
+#define AUDIO_INTERFACE_OUTPUT  1
+
+//*****************************************************************************
+//
+// Endpoints to use for each of the required endpoints in the driver.
+//
+//*****************************************************************************
+#define ISOC_OUT_ENDPOINT       USB_EP_1
+
+//*****************************************************************************
+//
+// Max size is (48000 samples/sec * 4 bytes/sample) * 0.001 seconds/frame.
+//
+//*****************************************************************************
+#define ISOC_OUT_EP_MAX_SIZE    ((48000*4)/1000)
+
+//*****************************************************************************
+//
+// Device Descriptor.  This is stored in RAM to allow several fields to be
+// changed at runtime based on the client's requirements.
+//
+//*****************************************************************************
+static uint8_t g_pui8AudioDeviceDescriptor[] =
+{
+    18,                     // Size of this structure.
+    USB_DTYPE_DEVICE,       // Type of this structure.
+    USBShort(0x110),        // USB version 1.1 (if we say 2.0, hosts assume
+                            // high-speed - see USB 2.0 spec 9.2.6.6)
+    0,                      // USB Device Class (spec 5.1.1)
+    0,                      // USB Device Sub-class (spec 5.1.1)
+    0,                      // USB Device protocol (spec 5.1.1)
+    64,                     // Maximum packet size for default pipe.
+    USBShort(0),            // Vendor ID (filled in during USBDAudioInit).
+    USBShort(0),            // Product ID (filled in during USBDAudioInit).
+    USBShort(0x100),        // Device Version BCD.
+    1,                      // Manufacturer string identifier.
+    2,                      // Product string identifier.
+    3,                      // Product serial number.
+    1                       // Number of configurations.
+};
+
+//*****************************************************************************
+//
+// Audio class device configuration descriptor.
+//
+// It is vital that the configuration descriptor bConfigurationValue field
+// (byte 6) is 1 for the first configuration and increments by 1 for each
+// additional configuration defined here.  This relationship is assumed in the
+// device stack for simplicity even though the USB 2.0 specification imposes
+// no such restriction on the bConfigurationValue values.
+//
+// Note that this structure is deliberately located in RAM since we need to
+// be able to patch some values in it based on client requirements.
+//
+//*****************************************************************************
+static uint8_t g_pui8AudioDescriptor[] =
+{
+    //
+    // Configuration descriptor header.
+    //
+    9,                          // Size of the configuration descriptor.
+    USB_DTYPE_CONFIGURATION,    // Type of this descriptor.
+    USBShort(32),               // The total size of this full structure.
+    2,                          // The number of interfaces in this
+                                // configuration.
+    1,                          // The unique value for this configuration.
+    0,                          // The string identifier that describes this
+                                // configuration.
+    USB_CONF_ATTR_BUS_PWR,      // Bus Powered, Self Powered, remote wake up.
+    250,                        // The maximum power in 2mA increments.
+};
+
+//*****************************************************************************
+//
+// This is the Interface Association Descriptor for the serial device used in
+// composite devices.
+//
+//*****************************************************************************
+uint8_t g_pui8IADAudioDescriptor[AUDIODESCRIPTOR_SIZE] =
+{
+
+    8,                          // Size of the interface descriptor.
+    USB_DTYPE_INTERFACE_ASC,    // Interface Association Type.
+    0x0,                        // Default starting interface is 0.
+    0x2,                        // Number of interfaces in this association.
+    USB_CLASS_AUDIO,            // The device class for this association.
+    USB_SUBCLASS_UNDEFINED,     // The device subclass for this association.
+    USB_PROTOCOL_UNDEFINED,     // The protocol for this association.
+    0                           // The string index for this association.
+};
+
+const tConfigSection g_sIADAudioConfigSection =
+{
+    sizeof(g_pui8IADAudioDescriptor),
+    g_pui8IADAudioDescriptor
+};
+
+//*****************************************************************************
+//
+// The remainder of the configuration descriptor is stored in flash since we
+// don't need to modify anything in it at runtime.
+//
+//*****************************************************************************
+const uint8_t g_pui8AudioControlInterface[CONTROLINTERFACE_SIZE] =
+{
+    //
+    // Vendor-specific Interface Descriptor.
+    //
+    9,                          // Size of the interface descriptor.
+    USB_DTYPE_INTERFACE,        // Type of this descriptor.
+    AUDIO_INTERFACE_CONTROL,    // The index for this interface.
+    0,                          // The alternate setting for this interface.
+    0,                          // The number of endpoints used by this
+                                // interface.
+    USB_CLASS_AUDIO,            // The interface class
+    USB_ASC_AUDIO_CONTROL,      // The interface sub-class.
+    0,                          // The interface protocol for the sub-class
+                                // specified above.
+    0,                          // The string index for this interface.
+
+    //
+    // Audio Header Descriptor.
+    //
+    9,                          // The size of this descriptor.
+    USB_DTYPE_CS_INTERFACE,     // Interface descriptor is class specific.
+    USB_ACDSTYPE_HEADER,        // Descriptor sub-type is HEADER.
+    USBShort(0x0100),           // Audio Device Class Specification Release
+                                // Number in Binary-Coded Decimal.
+                                // Total number of bytes in
+                                // g_pui8AudioControlInterface
+    USBShort((9 + 9 + 12 + 13 + 9)),
+    1,                          // Number of streaming interfaces.
+    1,                          // Index of the first and only streaming
+                                // interface.
+
+    //
+    // Audio Input Terminal Descriptor.
+    //
+    12,                         // The size of this descriptor.
+    USB_DTYPE_CS_INTERFACE,     // Interface descriptor is class specific.
+    USB_ACDSTYPE_IN_TERMINAL,   // Descriptor sub-type is INPUT_TERMINAL.
+    AUDIO_IN_TERMINAL_ID,       // Terminal ID for this interface.
+                                // USB streaming interface.
+    USBShort(USB_TTYPE_STREAMING),
+    0,                          // ID of the Output Terminal to which this
+                                // Input Terminal is associated.
+    2,                          // Number of logical output channels in the
+                                // Terminal's output audio channel cluster.
+    USBShort((USB_CHANNEL_L |   // Describes the spatial location of the
+             USB_CHANNEL_R)),   // logical channels.
+    0,                          // Channel Name string index.
+    0,                          // Terminal Name string index.
+
+    //
+    // Audio Feature Unit Descriptor
+    //
+    13,                         // The size of this descriptor.
+    USB_DTYPE_CS_INTERFACE,     // Interface descriptor is class specific.
+    USB_ACDSTYPE_FEATURE_UNIT,  // Descriptor sub-type is FEATURE_UNIT.
+    AUDIO_CONTROL_ID,           // Unit ID for this interface.
+    AUDIO_IN_TERMINAL_ID,       // ID of the Unit or Terminal to which this
+                                // Feature Unit is connected.
+    2,                          // Size in bytes of an element of the
+                                // bmaControls() array that follows.
+                                // Master Mute control.
+    USBShort(USB_ACONTROL_MUTE),
+                                // Left channel volume control.
+    USBShort(USB_ACONTROL_VOLUME),
+                                // Right channel volume control.
+    USBShort(USB_ACONTROL_VOLUME),
+    0,                          // Feature unit string index.
+
+    //
+    // Audio Output Terminal Descriptor.
+    //
+    9,                          // The size of this descriptor.
+    USB_DTYPE_CS_INTERFACE,     // Interface descriptor is class specific.
+    USB_ACDSTYPE_OUT_TERMINAL,  // Descriptor sub-type is INPUT_TERMINAL.
+    AUDIO_OUT_TERMINAL_ID,      // Terminal ID for this interface.
+                                // Output type is a generic speaker.
+    USBShort(USB_ATTYPE_SPEAKER),
+    AUDIO_IN_TERMINAL_ID,       // ID of the input terminal to which this
+                                // output terminal is connected.
+    AUDIO_CONTROL_ID,           // ID of the feature unit that this output
+                                // terminal is connected to.
+    0,                          // Output terminal string index.
+
+};
+
+//*****************************************************************************
+//
+// The audio streaming interface descriptor.  This describes the two valid
+// interfaces for this class.  The first interface has no endpoints and is used
+// by host operating systems to put the device in idle mode, while the second
+// is used when the audio device is active.
+//
+//*****************************************************************************
+const uint8_t g_pui8AudioStreamInterface[STREAMINTERFACE_SIZE] =
+{
+    //
+    // Vendor-specific Interface Descriptor.
+    //
+    9,                          // Size of the interface descriptor.
+    USB_DTYPE_INTERFACE,        // Type of this descriptor.
+    AUDIO_INTERFACE_OUTPUT,     // The index for this interface.
+    0,                          // The alternate setting for this interface.
+    0,                          // The number of endpoints used by this
+                                // interface.
+    USB_CLASS_AUDIO,            // The interface class
+    USB_ASC_AUDIO_STREAMING,    // The interface sub-class.
+    0,                          // Unused must be 0.
+    0,                          // The string index for this interface.
+
+    //
+    // Vendor-specific Interface Descriptor.
+    //
+    9,                          // Size of the interface descriptor.
+    USB_DTYPE_INTERFACE,        // Type of this descriptor.
+    1,                          // The index for this interface.
+    1,                          // The alternate setting for this interface.
+    1,                          // The number of endpoints used by this
+                                // interface.
+    USB_CLASS_AUDIO,            // The interface class
+    USB_ASC_AUDIO_STREAMING,    // The interface sub-class.
+    0,                          // Unused must be 0.
+    0,                          // The string index for this interface.
+
+    //
+    // Class specific Audio Streaming Interface descriptor.
+    //
+    7,                          // Size of the interface descriptor.
+    USB_DTYPE_CS_INTERFACE,     // Interface descriptor is class specific.
+    USB_ASDSTYPE_GENERAL,       // General information.
+    AUDIO_IN_TERMINAL_ID,       // ID of the terminal to which this streaming
+                                // interface is connected.
+    1,                          // One frame delay.
+    USBShort(USB_ADF_PCM),      //
+
+    //
+    // Format type Audio Streaming descriptor.
+    //
+    11,                         // Size of the interface descriptor.
+    USB_DTYPE_CS_INTERFACE,     // Interface descriptor is class specific.
+    USB_ASDSTYPE_FORMAT_TYPE,   // Audio Streaming format type.
+    USB_AF_TYPE_TYPE_I,         // Type I audio format type.
+    2,                          // Two audio channels.
+    2,                          // Two bytes per audio sub-frame.
+    16,                         // 16 bits per sample.
+    1,                          // One sample rate provided.
+    USB3Byte(48000),            // Only 48000 sample rate supported.
+
+    //
+    // Endpoint Descriptor
+    //
+    9,                              // The size of the endpoint descriptor.
+    USB_DTYPE_ENDPOINT,             // Descriptor type is an endpoint.
+                                    // OUT endpoint with address
+                                    // ISOC_OUT_ENDPOINT.
+    USB_EP_DESC_OUT | USBEPToIndex(ISOC_OUT_ENDPOINT),
+    USB_EP_ATTR_ISOC |              // Endpoint is an adaptive isochronous data
+    USB_EP_ATTR_ISOC_ADAPT |        //  endpoint.
+    USB_EP_ATTR_USAGE_DATA,
+    USBShort(ISOC_OUT_EP_MAX_SIZE), // The maximum packet size.
+    1,                              // The polling interval for this endpoint.
+    0,                              // Refresh is unused.
+    0,                              // Synch endpoint address.
+
+    //
+    // Audio Streaming Isochronous Audio Data Endpoint Descriptor
+    //
+    7,                              // The size of the descriptor.
+    USB_ACSDT_ENDPOINT,             // Audio Class Specific Endpoint
+                                    // Descriptor.
+    USB_ASDSTYPE_GENERAL,           // This is a general descriptor.
+    USB_EP_ATTR_ACG_SAMPLING,       // Sampling frequency is supported.
+    USB_EP_LOCKDELAY_UNDEF,         // Undefined lock delay units.
+    USBShort(0),                    // No lock delay.
+};
+
+//*****************************************************************************
+//
+// The audio device configuration descriptor is defined as three sections,
+// one containing just the 9 byte USB configuration descriptor.  The second
+// holds the audio streaming interface and the third holds the audio control
+// interface.
+//
+//*****************************************************************************
+const tConfigSection g_sAudioConfigSection =
+{
+    sizeof(g_pui8AudioDescriptor),
+    g_pui8AudioDescriptor
+};
+
+const tConfigSection g_sAudioStreamInterfaceSection =
+{
+    sizeof(g_pui8AudioStreamInterface),
+    g_pui8AudioStreamInterface
+};
+
+const tConfigSection g_sAudioControlInterfaceSection =
+{
+    sizeof(g_pui8AudioControlInterface),
+    g_pui8AudioControlInterface
+};
+
+//*****************************************************************************
+//
+// This array lists all the sections that must be concatenated to make a
+// single, complete audio device configuration descriptor.
+//
+//*****************************************************************************
+const tConfigSection *g_psAudioSections[] =
+{
+    &g_sAudioConfigSection,
+    &g_sIADAudioConfigSection,
+    &g_sAudioControlInterfaceSection,
+    &g_sAudioStreamInterfaceSection
+};
+
+#define NUM_AUDIO_SECTIONS      (sizeof(g_psAudioSections) /                  \
+                                 sizeof(g_psAudioSections[0]))
+
+//*****************************************************************************
+//
+// The header for the single configuration we support.  This is the root of
+// the data structure that defines all the bits and pieces that are pulled
+// together to generate the configuration descriptor.
+//
+//*****************************************************************************
+const tConfigHeader g_sAudioConfigHeader =
+{
+    NUM_AUDIO_SECTIONS,
+    g_psAudioSections
+};
+
+//*****************************************************************************
+//
+// Configuration Descriptor.
+//
+//*****************************************************************************
+const tConfigHeader * const g_ppAudioConfigDescriptors[] =
+{
+    &g_sAudioConfigHeader
+};
+
+//*****************************************************************************
+//
+// Various internal handlers needed by this class.
+//
+//*****************************************************************************
+static void HandleDisconnect(void *pvAudioDevice);
+static void InterfaceChange(void *pvAudioDevice, uint8_t ui8Interface,
+                            uint8_t ui8AlternateSetting);
+static void ConfigChangeHandler(void *pvAudioDevice, uint32_t ui32Value);
+static void DataReceived(void *pvAudioDevice, uint32_t ui32Info);
+static void HandleEndpoints(void *pvAudioDevice, uint32_t ui32Status);
+static void HandleRequests(void *pvAudioDevice, tUSBRequest *psUSBRequest);
+static void HandleDevice(void *pvAudioDevice, uint32_t ui32Request,
+                         void *pvRequestData);
+
+//*****************************************************************************
+//
+// The device information structure for the USB Audio device.
+//
+//*****************************************************************************
+static const tCustomHandlers g_sAudioHandlers =
+{
+    //
+    // GetDescriptor
+    //
+    0,
+
+    //
+    // RequestHandler
+    //
+    HandleRequests,
+
+    //
+    // InterfaceChange
+    //
+    InterfaceChange,
+
+    //
+    // ConfigChange
+    //
+    ConfigChangeHandler,
+
+    //
+    // DataReceived
+    //
+    DataReceived,
+
+    //
+    // DataSentCallback
+    //
+    0,
+
+    //
+    // ResetHandler
+    //
+    0,
+
+    //
+    // SuspendHandler
+    //
+    0,
+
+    //
+    // ResumeHandler
+    //
+    0,
+
+    //
+    // DisconnectHandler
+    //
+    HandleDisconnect,
+
+    //
+    // EndpointHandler
+    //
+    HandleEndpoints,
+
+    //
+    // Device handler
+    //
+    HandleDevice
+};
+
+//*****************************************************************************
+//
+// This function is called to handle data being received back from the host so
+// that the application callback can be called when the new data is ready.
+//
+//*****************************************************************************
+static void
+DataReceived(void *pvAudioDevice, uint32_t ui32Info)
+{
+    tAudioInstance *psInst;
+    tUSBDAudioDevice *psAudioDevice;
+
+    ASSERT(pvAudioDevice != 0);
+
+    //
+    // Create the instance pointer.
+    //
+    psAudioDevice = (tUSBDAudioDevice *)pvAudioDevice;
+
+    //
+    // Make a copy of this pointer for ease of use in this function.
+    //
+    psInst = &psAudioDevice->sPrivateData;
+
+    //
+    // If there is an update pending and the request was to set a current
+    // value then check which value was set.
+    //
+    if(psInst->ui16Update && (psInst->ui8Request == USB_AC_SET_CUR))
+    {
+        //
+        // Only handling interface requests.
+        //
+        if((psInst->ui16RequestType & USB_RTYPE_RECIPIENT_M) ==
+           USB_RTYPE_INTERFACE)
+        {
+            if(psInst->ui16Update == VOLUME_CONTROL)
+            {
+                //
+                // Inform the callback of the new volume.
+                //
+                psAudioDevice->pfnCallback(0, USBD_AUDIO_EVENT_VOLUME,
+                                      psInst->i16Volume, 0);
+            }
+            else if(psAudioDevice->sPrivateData.ui16Update == MUTE_CONTROL)
+            {
+                //
+                // Inform the callback of the new data.
+                //
+                psAudioDevice->pfnCallback(0, USBD_AUDIO_EVENT_MUTE,
+                                      psInst->ui8Mute, 0);
+            }
+        }
+        psInst->ui16Update = 0;
+    }
+}
+
+//*****************************************************************************
+//
+// This function is called to handle the interrupts on the isochronous endpoint
+// for the audio device class.
+//
+//*****************************************************************************
+static void
+HandleEndpoints(void *pvAudioDevice, uint32_t ui32Status)
+{
+    uint32_t ui32EPStatus;
+    tAudioInstance *psInst;
+    tUSBDAudioDevice *psAudioDevice;
+    uint32_t ui32Size;
+
+    ASSERT(pvAudioDevice != 0);
+
+    //
+    // The audio device structure pointer.
+    //
+    psAudioDevice = (tUSBDAudioDevice *)pvAudioDevice;
+
+    //
+    // Create a pointer to the audio instance data.
+    //
+    psInst = &psAudioDevice->sPrivateData;
+
+    //
+    // Read out the current endpoint status.
+    //
+    ui32EPStatus = MAP_USBEndpointStatus(USB0_BASE, psInst->ui8OUTEndpoint);
+
+    //
+    // See if there is a receive interrupt pending.
+    //
+    if(ui32Status & (0x10000 << USBEPToIndex(psInst->ui8OUTEndpoint)))
+    {
+        //
+        // Get the amount of data available in the FIFO.
+        //
+        ui32Size = USBEndpointDataAvail(psInst->ui32USBBase,
+                                        psInst->ui8OUTEndpoint);
+
+        //
+        // Clear the status bits.
+        //
+        MAP_USBDevEndpointStatusClear(USB0_BASE, psInst->ui8OUTEndpoint,
+                                      ui32EPStatus);
+
+        //
+        // Configure the next DMA transfer.
+        //
+        USBLibDMATransfer(psInst->psDMAInstance, psInst->ui8OUTDMA,
+                          psInst->sBuffer.pvData, ui32Size);
+    }
+    else if((USBLibDMAChannelStatus(psInst->psDMAInstance,
+                                    psInst->ui8OUTDMA) ==
+            USBLIBSTATUS_DMA_COMPLETE))
+    {
+        USBEndpointDMADisable(USB0_BASE,
+                              psInst->ui8OUTEndpoint, USB_EP_DEV_OUT);
+
+        //
+        // Acknowledge that the data was read, this will not cause a bus
+        // acknowledgment.
+        //
+        MAP_USBDevEndpointDataAck(USB0_BASE, psInst->ui8OUTEndpoint, 0);
+
+        //
+        // Inform the callback of the new data.
+        //
+        psInst->sBuffer.pfnCallback(psInst->sBuffer.pvData,
+                                    psInst->sBuffer.ui32Size,
+                                    USBD_AUDIO_EVENT_DATAOUT);
+    }
+}
+
+//*****************************************************************************
+//
+// Device instance specific handler.
+//
+//*****************************************************************************
+static void
+HandleDevice(void *pvAudioDevice, uint32_t ui32Request, void *pvRequestData)
+{
+    tAudioInstance *psInst;
+    uint8_t *pui8Data;
+    tUSBDAudioDevice *psAudioDevice;
+
+    //
+    // The audio device structure pointer.
+    //
+    psAudioDevice = (tUSBDAudioDevice *)pvAudioDevice;
+
+    //
+    // Create a pointer to the audio instance data.
+    //
+    psInst = &psAudioDevice->sPrivateData;
+
+    //
+    // Create the 8-bit array used by the events supported by the USB CDC
+    // serial class.
+    //
+    pui8Data = (uint8_t *)pvRequestData;
+
+    switch(ui32Request)
+    {
+        //
+        // This was an interface change event.
+        //
+        case USB_EVENT_COMP_IFACE_CHANGE:
+        {
+            //
+            // Save the change to the appropriate interface number.
+            //
+            if(pui8Data[0] == AUDIO_INTERFACE_CONTROL)
+            {
+                psInst->ui8InterfaceControl = pui8Data[1];
+            }
+            else if(pui8Data[0] == AUDIO_INTERFACE_OUTPUT)
+            {
+                psInst->ui8InterfaceAudio = pui8Data[1];
+            }
+            break;
+        }
+
+        //
+        // This was an endpoint change event.
+        //
+        case USB_EVENT_COMP_EP_CHANGE:
+        {
+            //
+            // Determine if this is an IN or OUT endpoint that has changed.
+            //
+            if((pui8Data[0] & USB_EP_DESC_IN) == 0)
+            {
+                //
+                // Extract the new endpoint number without the DIR bit.
+                //
+                psInst->ui8OUTEndpoint = IndexToUSBEP(pui8Data[1] & 0x7f);
+
+                //
+                // If the DMA channel has already been allocated then clear
+                // that channel and prepare to possibly use a new one.
+                //
+                if(psInst->ui8OUTDMA != 0)
+                {
+                    USBLibDMAChannelRelease(psInst->psDMAInstance,
+                                            psInst->ui8OUTDMA);
+                }
+
+                //
+                // Allocate a DMA channel to the endpoint.
+                //
+                psInst->ui8OUTDMA =
+                    USBLibDMAChannelAllocate(psInst->psDMAInstance,
+                                             psInst->ui8OUTEndpoint,
+                                             ISOC_OUT_EP_MAX_SIZE,
+                                             (USB_DMA_EP_RX |
+                                              USB_DMA_EP_TYPE_ISOC |
+                                              USB_DMA_EP_DEVICE));
+
+                //
+                // Set the DMA individual transfer size.
+                //
+                USBLibDMAUnitSizeSet(psInst->psDMAInstance, psInst->ui8OUTDMA,
+                                     32);
+
+                //
+                // Set the DMA arbitration size.
+                //
+                USBLibDMAArbSizeSet(psInst->psDMAInstance, psInst->ui8OUTDMA,
+                                    16);
+            }
+            break;
+        }
+
+        //
+        // Handle class specific reconfiguring of the configuration descriptor
+        // once the composite class has built the full descriptor.
+        //
+        case USB_EVENT_COMP_CONFIG:
+        {
+            //
+            // This sets the bFirstInterface of the Interface Association
+            // descriptor to the first interface which is the control
+            // interface used by this instance.
+            //
+            pui8Data[2] = psInst->ui8InterfaceControl;
+
+            break;
+        }
+        case USB_EVENT_LPM_RESUME:
+        {
+            if(psAudioDevice->pfnCallback)
+            {
+                //
+                // Pass the LPM resume event to the client.
+                //
+                psAudioDevice->pfnCallback(0, USB_EVENT_LPM_RESUME, 0,
+                                           (void *)0);
+            }
+            break;
+        }
+        case USB_EVENT_LPM_SLEEP:
+        {
+            if(psAudioDevice->pfnCallback)
+            {
+                //
+                // Pass the LPM sleep event to the client.
+                //
+                psAudioDevice->pfnCallback(0, USB_EVENT_LPM_SLEEP, 0,
+                                           (void *)0);
+            }
+            break;
+        }
+        case USB_EVENT_LPM_ERROR:
+        {
+            if(psAudioDevice->pfnCallback)
+            {
+                //
+                // Pass the LPM error event to the client.
+                //
+                psAudioDevice->pfnCallback(0, USB_EVENT_LPM_ERROR, 0,
+                                           (void *)0);
+            }
+            break;
+        }
+        default:
+        {
+            break;
+        }
+    }
+}
+
+//*****************************************************************************
+//
+// This function is called by the USB device stack whenever the device is
+// disconnected from the host.
+//
+//*****************************************************************************
+static void
+HandleDisconnect(void *pvAudioDevice)
+{
+    const tUSBDAudioDevice *psAudioDevice;
+
+    ASSERT(pvAudioDevice != 0);
+
+    //
+    // The audio device structure pointer.
+    //
+    psAudioDevice = (const tUSBDAudioDevice *)pvAudioDevice;
+
+    //
+    // Inform the application that the device has been disconnected.
+    //
+    psAudioDevice->pfnCallback(0, USB_EVENT_DISCONNECTED, 0, 0);
+}
+
+//*****************************************************************************
+//
+// This function is called by the USB device stack whenever the device
+// interface changes.  This occurs when the audio device transitions between
+// being active and inactive.  Interface AUDIO_INTERFACE_CONTROL is the
+// inactive interface that has no endpoints, while interface
+// AUDIO_INTERFACE_AUDIO has the single Isochronous OUT endpoint.
+//
+//*****************************************************************************
+static void
+InterfaceChange(void *pvAudioDevice, uint8_t ui8Interface,
+                uint8_t ui8AlternateSetting)
+{
+    const tUSBDAudioDevice *psAudioDevice;
+
+    ASSERT(pvAudioDevice != 0);
+
+    //
+    // The audio device structure pointer.
+    //
+    psAudioDevice = (const tUSBDAudioDevice *)pvAudioDevice;
+
+    //
+    // Check which interface to change into.
+    //
+    if(ui8AlternateSetting == 0)
+    {
+        //
+        // Alternate setting 0 is an inactive state.
+        //
+        if(psAudioDevice->pfnCallback)
+        {
+            psAudioDevice->pfnCallback(0, USBD_AUDIO_EVENT_IDLE, 0, 0);
+        }
+    }
+    else
+    {
+        //
+        // Alternate setting 1 is the active state.
+        //
+        if(psAudioDevice->pfnCallback)
+        {
+            psAudioDevice->pfnCallback(0, USBD_AUDIO_EVENT_ACTIVE, 0, 0);
+        }
+    }
+}
+
+//*****************************************************************************
+//
+// This function is called by the USB device stack whenever the device
+// configuration changes.
+//
+//*****************************************************************************
+static void
+ConfigChangeHandler(void *pvAudioDevice, uint32_t ui32Value)
+{
+    const tUSBDAudioDevice *psAudioDevice;
+
+    ASSERT(pvAudioDevice != 0);
+
+    //
+    // The audio device structure pointer.
+    //
+    psAudioDevice = (const tUSBDAudioDevice *)pvAudioDevice;
+
+    //
+    // If we have a control callback, let the client know we are open for
+    // business.
+    //
+    if(psAudioDevice->pfnCallback)
+    {
+        //
+        // Pass the connected event to the client.
+        //
+        psAudioDevice->pfnCallback(pvAudioDevice, USB_EVENT_CONNECTED, 0, 0);
+    }
+}
+
+//*****************************************************************************
+//
+//! This function should be called once for the audio class device to
+//! initialized basic operation and prepare for enumeration.
+//!
+//! \param ui32Index is the index of the USB controller to initialize for
+//! audio class device operation.
+//! \param psAudioDevice points to a structure containing parameters
+//! customizing the operation of the audio device.
+//!
+//! In order for an application to initialize the USB audio device class, it
+//! must first call this function with the a valid audio device class structure
+//! in the \e psAudioDevice parameter.  This allows this function to initialize
+//! the USB controller and device code to be prepared to enumerate and function
+//! as a USB audio device.
+//!
+//! This function returns a void pointer that must be passed in to all other
+//! APIs used by the audio class.
+//!
+//! See the documentation on the tUSBDAudioDevice structure for more
+//! information on how to properly fill the structure members.
+//!
+//! \return Returns 0 on failure or a non-zero void pointer on success.
+//
+//*****************************************************************************
+void *
+USBDAudioInit(uint32_t ui32Index, tUSBDAudioDevice *psAudioDevice)
+{
+    tConfigDescriptor *psConfigDesc;
+    tDeviceDescriptor *psDevDesc;
+
+    //
+    // Check parameter validity.
+    //
+    ASSERT(ui32Index == 0);
+    ASSERT(psAudioDevice);
+    ASSERT(psAudioDevice->ppui8StringDescriptors);
+
+    //
+    // Composite Init handles all initialization that is not specific to a
+    // multiple instance device.
+    //
+    USBDAudioCompositeInit(ui32Index, psAudioDevice, 0);
+
+    //
+    // Fix up the device descriptor with the client-supplied values.
+    //
+    psDevDesc = (tDeviceDescriptor *)g_pui8AudioDeviceDescriptor;
+    psDevDesc->idVendor = psAudioDevice->ui16VID;
+    psDevDesc->idProduct = psAudioDevice->ui16PID;
+
+    //
+    // Fix up the configuration descriptor with client-supplied values.
+    //
+    psConfigDesc = (tConfigDescriptor *)g_pui8AudioDescriptor;
+    psConfigDesc->bmAttributes = psAudioDevice->ui8PwrAttributes;
+    psConfigDesc->bMaxPower = (uint8_t)(psAudioDevice->ui16MaxPowermA / 2);
+
+    //
+    // All is well so now pass the descriptors to the lower layer and put
+    // the bulk device on the bus.
+    //
+    USBDCDInit(ui32Index, &psAudioDevice->sPrivateData.sDevInfo,
+               (void *)psAudioDevice);
+
+    //
+    // Configure the DMA for the OUT endpoint.
+    //
+    psAudioDevice->sPrivateData.ui8OUTDMA =
+        USBLibDMAChannelAllocate(psAudioDevice->sPrivateData.psDMAInstance,
+                                 psAudioDevice->sPrivateData.ui8OUTEndpoint,
+                                 ISOC_OUT_EP_MAX_SIZE,
+                                 USB_DMA_EP_RX | USB_DMA_EP_TYPE_ISOC |
+                                 USB_DMA_EP_DEVICE);
+
+    USBLibDMAUnitSizeSet(psAudioDevice->sPrivateData.psDMAInstance,
+                         psAudioDevice->sPrivateData.ui8OUTDMA, 32);
+    USBLibDMAArbSizeSet(psAudioDevice->sPrivateData.psDMAInstance,
+                        psAudioDevice->sPrivateData.ui8OUTDMA, 16);
+
+    //
+    // Return the pointer to the instance indicating that everything went well.
+    //
+    return((void *)psAudioDevice);
+}
+
+//*****************************************************************************
+//
+//! This function should be called once for the audio class device to
+//! initialized basic operation and prepare for enumeration.
+//!
+//! \param ui32Index is the index of the USB controller to initialize for
+//! audio class device operation.
+//! \param psAudioDevice points to a structure containing parameters
+//! customizing the operation of the audio device.
+//! \param psCompEntry is the composite device entry to initialize when
+//! creating a composite device.
+//!
+//! In order for an application to initialize the USB audio device class, it
+//! must first call this function with the a valid audio device class structure
+//! in the \e psAudioDevice parameter.  This allows this function to initialize
+//! the USB controller and device code to be prepared to enumerate and function
+//! as a USB audio device.  When this audio device is part of a composite
+//! device, then the \e psCompEntry should point to the composite device entry
+//! to initialize. This is part of the array that is passed to the
+//! USBDCompositeInit() function.
+//!
+//! This function returns a void pointer that must be passed in to all other
+//! APIs used by the audio class.
+//!
+//! See the documentation on the tUSBDAudioDevice structure for more
+//! information on how to properly fill the structure members.
+//!
+//! \return Returns zero on failure or a non-zero instance value that should be
+//! used with the remaining USB audio APIs.
+//
+//*****************************************************************************
+void *
+USBDAudioCompositeInit(uint32_t ui32Index, tUSBDAudioDevice *psAudioDevice,
+                       tCompositeEntry *psCompEntry)
+{
+    tAudioInstance *psInst;
+
+    //
+    // Check parameter validity.
+    //
+    ASSERT(ui32Index == 0);
+    ASSERT(psAudioDevice);
+    ASSERT(psAudioDevice->ppui8StringDescriptors);
+
+    //
+    // Initialize the workspace in the passed instance structure.
+    //
+    psInst = &psAudioDevice->sPrivateData;
+    psInst->ui32USBBase = USB0_BASE;
+
+    //
+    // Initialize the composite entry that is used by the composite device
+    // class.
+    //
+    if(psCompEntry != 0)
+    {
+        psCompEntry->psDevInfo = &psInst->sDevInfo;
+        psCompEntry->pvInstance = (void *)psAudioDevice;
+    }
+
+    //
+    // Initialize the device information structure.
+    //
+    psInst->sDevInfo.psCallbacks = &g_sAudioHandlers;
+    psInst->sDevInfo.pui8DeviceDescriptor = g_pui8AudioDeviceDescriptor;
+    psInst->sDevInfo.ppsConfigDescriptors = g_ppAudioConfigDescriptors;
+    psInst->sDevInfo.ppui8StringDescriptors = 0;
+    psInst->sDevInfo.ui32NumStringDescriptors = 0;
+
+    //
+    // Initialize the device info structure for the HID device.
+    //
+    USBDCDDeviceInfoInit(0, &psInst->sDevInfo);
+
+    //
+    // The Control interface is at index 0.
+    //
+    psInst->ui8InterfaceControl = AUDIO_INTERFACE_CONTROL;
+
+    //
+    // The Audio interface is at index 1.
+    //
+    psInst->ui8InterfaceAudio = AUDIO_INTERFACE_OUTPUT;
+
+    //
+    // Set the default Isochronous OUT endpoint.
+    //
+    psInst->ui8OUTEndpoint = ISOC_OUT_ENDPOINT;
+    psInst->ui8OUTDMA = 0;
+
+    //
+    // Set the initial buffer to null.
+    //
+    psInst->sBuffer.pvData = 0;
+
+    //
+    // Save the volume settings.
+    //
+    psInst->i16VolumeMax = psAudioDevice->i16VolumeMax;
+    psInst->i16VolumeMin = psAudioDevice->i16VolumeMin;
+    psInst->i16VolumeStep = psAudioDevice->i16VolumeStep;
+
+    //
+    // No update pending to any command.
+    //
+    psInst->ui16Update = 0;
+
+    //
+    // Plug in the client's string stable to the device information
+    // structure.
+    //
+    psInst->sDevInfo.ppui8StringDescriptors =
+                                    psAudioDevice->ppui8StringDescriptors;
+    psInst->sDevInfo.ui32NumStringDescriptors =
+                                    psAudioDevice->ui32NumStringDescriptors;
+
+    //
+    // Get the DMA instance pointer.
+    //
+    psInst->psDMAInstance = USBLibDMAInit(0);
+
+    //
+    // Return the pointer to the instance indicating that everything went well.
+    //
+    return((void *)psAudioDevice);
+}
+
+//*****************************************************************************
+//
+//! Shuts down the audio device.
+//!
+//! \param pvAudioDevice is the pointer to the device instance structure as
+//! returned by USBDAudioInit().
+//!
+//! This function terminates audio interface for the instance supplied.  This
+//! function should not be called if the audio device is part of a composite
+//! device and instead the USBDCompositeTerm() function should be called for
+//! the full composite device.
+//! Following this call, the \e pvAudioDevice instance should not me used in
+//! any other calls.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBDAudioTerm(void *pvAudioDevice)
+{
+    ASSERT(pvAudioDevice != 0);
+
+    //
+    // Cleanly exit device mode.
+    //
+    USBDCDTerm(0);
+}
+
+//*****************************************************************************
+//
+// This function is called by the USB device stack whenever a non-standard
+// request is received.
+//
+// \param pvAudioDevice is the instance data for this request.
+// \param psUSBRequest points to the request received.
+//
+// This call parses the provided request structure to the type of request and
+// will respond to all commands that are understood by the class.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+HandleRequests(void *pvAudioDevice, tUSBRequest *psUSBRequest)
+{
+    uint32_t ui32Control, ui32Recipient, ui32Stall;
+    tAudioInstance *psInst;
+    tUSBDAudioDevice *psAudioDevice;
+
+    ASSERT(pvAudioDevice != 0);
+
+    //
+    // The audio device structure pointer.
+    //
+    psAudioDevice = (tUSBDAudioDevice *)pvAudioDevice;
+
+    //
+    // Create a pointer to the audio instance data.
+    //
+    psInst = &psAudioDevice->sPrivateData;
+
+    //
+    // Make sure to acknowledge that the data was read, this will not send and
+    // ACK that has already been done at this point.  This just tells the
+    // hardware that the data was read.
+    //
+    MAP_USBDevEndpointDataAck(USB0_BASE, USB_EP_0, false);
+
+    //
+    // Don't stall by default.
+    //
+    ui32Stall = 0;
+
+    //
+    // Get the request type.
+    //
+    ui32Recipient = psUSBRequest->bmRequestType & USB_RTYPE_RECIPIENT_M;
+
+    //
+    // Save the request type and request value.
+    //
+    psInst->ui16RequestType = psUSBRequest->bmRequestType;
+    psInst->ui8Request = psUSBRequest->bRequest;
+
+    //
+    // Check if this is an endpoint request to the audio streaming endpoint.
+    //
+    if((ui32Recipient == USB_RTYPE_ENDPOINT) &&
+       (psUSBRequest->wIndex == USBEPToIndex(psInst->ui8OUTEndpoint)))
+    {
+        //
+        // Determine the type of request.
+        //
+        switch(psInst->ui8Request)
+        {
+            case USB_AC_SET_CUR:
+            {
+                //
+                // Handle retrieving the sample rate.
+                //
+                if(psUSBRequest->wValue == SAMPLING_FREQ_CONTROL)
+                {
+                    //
+                    // Retrieve the requested sample rate.
+                    //
+                    USBDCDRequestDataEP0(0,
+                                         (uint8_t *)&psInst->ui32SampleRate,
+                                         3);
+
+                    //
+                    // Save what we are updating.
+                    //
+                    psInst->ui16Update = SAMPLING_FREQ_CONTROL;
+                }
+                break;
+            }
+            case USB_AC_GET_CUR:
+            {
+                //
+                // Handle retrieving the sample rate.
+                //
+                if(psUSBRequest->wValue == SAMPLING_FREQ_CONTROL)
+                {
+                    //
+                    // Send back the current sample rate.
+                    //
+                    USBDCDSendDataEP0(0,
+                                      (uint8_t *)&psInst->ui32SampleRate,
+                                      3);
+                }
+                break;
+            }
+            default:
+            {
+                //
+                // Stall on unknown commands.
+                //
+                ui32Stall = 1;
+                break;
+            }
+        }
+    }
+    else if(ui32Recipient == USB_RTYPE_INTERFACE)
+    {
+        //
+        // Make sure the request was for the control interface.
+        //
+        if((uint8_t)psUSBRequest->wIndex != psInst->ui8InterfaceControl)
+        {
+            return;
+        }
+
+        //
+        // Extract the control value from the message.
+        //
+        ui32Control = psUSBRequest->wValue & USB_CS_CONTROL_M;
+
+        //
+        // Handle an audio control request to the feature control unit.
+        //
+        if((AUDIO_CONTROL_ID << 8) ==
+           (psUSBRequest->wIndex & USB_CS_CONTROL_M))
+        {
+            //
+            // Determine the type of request.
+            //
+            switch(psInst->ui8Request)
+            {
+                case USB_AC_GET_MAX:
+                {
+                    if(ui32Control == VOLUME_CONTROL)
+                    {
+                        //
+                        // Return the maximum volume setting.
+                        //
+                        USBDCDSendDataEP0(0,
+                                          (uint8_t *)&psInst->i16VolumeMax,
+                                          2);
+                    }
+                    else
+                    {
+                        //
+                        // Stall on unknown commands.
+                        //
+                        ui32Stall = 1;
+                    }
+                    break;
+                }
+                case USB_AC_GET_MIN:
+                {
+                    if(ui32Control == VOLUME_CONTROL)
+                    {
+                        //
+                        // Return the minimum volume setting.
+                        //
+                        USBDCDSendDataEP0(0,
+                                          (uint8_t *)&psInst->i16VolumeMin,
+                                          2);
+                    }
+                    else
+                    {
+                        //
+                        // Stall on unknown commands.
+                        //
+                        ui32Stall = 1;
+                    }
+                    break;
+                }
+                case USB_AC_GET_RES:
+                {
+                    if(ui32Control == VOLUME_CONTROL)
+                    {
+                        //
+                        // Return the volume step setting.
+                        //
+                        USBDCDSendDataEP0(0,
+                                          (uint8_t *)&psInst->i16VolumeStep,
+                                          2);
+                    }
+                    else
+                    {
+                        //
+                        // Stall on unknown commands.
+                        //
+                        ui32Stall = 1;
+                    }
+                    break;
+                }
+                case USB_AC_GET_CUR:
+                {
+                    if(ui32Control == VOLUME_CONTROL)
+                    {
+                        //
+                        // Send back the current volume level.
+                        //
+                        USBDCDSendDataEP0(0,
+                                          (uint8_t *)&psInst->i16Volume,
+                                          2);
+                    }
+                    else if(ui32Control == MUTE_CONTROL)
+                    {
+                        //
+                        // Send back the current mute value.
+                        //
+                        USBDCDSendDataEP0(0,
+                                          (uint8_t *)&psInst->ui8Mute, 1);
+                    }
+                    else
+                    {
+                        //
+                        // Stall on unknown commands.
+                        //
+                        ui32Stall = 1;
+                    }
+                    break;
+                }
+                case USB_AC_SET_CUR:
+                {
+                    if(ui32Control == VOLUME_CONTROL)
+                    {
+                        //
+                        // Read the new volume level.
+                        //
+                        USBDCDRequestDataEP0(0,
+                                             (uint8_t *)&psInst->i16Volume,
+                                             2);
+
+                        //
+                        // Save what we are updating.
+                        //
+                        psInst->ui16Update = VOLUME_CONTROL;
+                    }
+                    else if(ui32Control == MUTE_CONTROL)
+                    {
+                        //
+                        // Read the new mute setting.
+                        //
+                        USBDCDRequestDataEP0(0,
+                                             (uint8_t *)&psInst->ui8Mute,
+                                             1);
+
+                        //
+                        // Save what we are updating.
+                        //
+                        psInst->ui16Update = MUTE_CONTROL;
+                    }
+                    else
+                    {
+                        //
+                        // Stall on unknown commands.
+                        //
+                        ui32Stall = 1;
+                    }
+                    break;
+                }
+                case USB_AC_SET_RES:
+                {
+                    if(ui32Control == VOLUME_CONTROL)
+                    {
+                        //
+                        // Read the new volume step setting.
+                        //
+                        USBDCDRequestDataEP0(0,
+                            (uint8_t *)&psInst->i16VolumeStep, 2);
+
+                        //
+                        // Save what we are updating.
+                        //
+                        psInst->ui16Update = VOLUME_CONTROL;
+                    }
+                    else
+                    {
+                        //
+                        // Stall on unknown commands.
+                        //
+                        ui32Stall = 1;
+                    }
+                    break;
+                }
+                default:
+                {
+                    //
+                    // Stall on unknown commands.
+                    //
+                    ui32Stall = 1;
+                    break;
+                }
+            }
+        }
+    }
+
+    //
+    // Stall on all unknown commands.
+    //
+    if(ui32Stall)
+    {
+        USBDCDStallEP0(0);
+    }
+}
+
+//*****************************************************************************
+//
+//! This function is used to supply buffers to the audio class to be filled
+//! from the USB host device.
+//!
+//! \param pvAudioDevice is the pointer to the device instance structure as
+//! returned by USBDAudioInit() or USBDAudioCompositeInit().
+//! \param pvBuffer is a pointer to the buffer to fill with audio data.
+//! \param ui32Size is the size in bytes of the buffer pointed to by the
+//! \e pvBuffer
+//! parameter.
+//! \param pfnCallback is a callback that will provide notification when this
+//! buffer has valid data.
+//!
+//! This function fills the buffer pointed to by the \e pvBuffer parameter with
+//! at most \e ui32Size one packet of data from the host controller.  The
+//! \e ui32Size has a minimum value of \b ISOC_OUT_EP_MAX_SIZE since each USB
+//! packet can be at most \b ISOC_OUT_EP_MAX_SIZE bytes in size.  Since the
+//! audio data may not be received in amounts that evenly fit in the buffer
+//! provided, the buffer may not be completely filled.  The \e pfnCallback
+//! function will provide the amount of valid data that was actually stored in
+//! the buffer provided.  The function will return zero if the buffer could be
+//! scheduled to be filled, otherwise the function will return a non-zero value
+//! if there was some reason that the buffer could not be added.
+//!
+//! \return Returns 0 to indicate success any other value indicates that the
+//! buffer will not be filled.
+//
+//*****************************************************************************
+int32_t
+USBAudioBufferOut(void *pvAudioDevice, void *pvBuffer, uint32_t ui32Size,
+                  tUSBAudioBufferCallback pfnCallback)
+{
+    tAudioInstance *psInst;
+    tUSBDAudioDevice *psAudioDevice;
+
+    //
+    // Make sure we were not passed NULL pointers.
+    //
+    ASSERT(pvAudioDevice != 0);
+    ASSERT(pvBuffer != 0);
+
+    //
+    // Buffer must be at least one packet in size.
+    //
+    ASSERT(ui32Size >= ISOC_OUT_EP_MAX_SIZE);
+    ASSERT(pfnCallback);
+
+    //
+    // The audio device structure pointer.
+    //
+    psAudioDevice = (tUSBDAudioDevice *)pvAudioDevice;
+
+    //
+    // Create a pointer to the audio instance data.
+    //
+    psInst = &psAudioDevice->sPrivateData;
+
+    //
+    // Initialize the buffer instance.
+    //
+    psInst->sBuffer.pvData = pvBuffer;
+    psInst->sBuffer.ui32Size = ui32Size;
+    psInst->sBuffer.ui32NumBytes = 0;
+    psInst->sBuffer.pfnCallback = pfnCallback;
+
+    return(0);
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
+
diff --git a/bsp/tm4c129x/libraries/usblib/device/usbdaudio.h b/bsp/tm4c129x/libraries/usblib/device/usbdaudio.h
new file mode 100755
index 0000000..4f69249
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/device/usbdaudio.h
@@ -0,0 +1,382 @@
+//*****************************************************************************
+//
+// usbdaudio.h - USB audio device class driver.
+//
+// Copyright (c) 2009-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#ifndef __USBDAUDIO_H__
+#define __USBDAUDIO_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+//*****************************************************************************
+//
+//! \addtogroup audio_device_class_api
+//! @{
+//
+//*****************************************************************************
+
+typedef void (* tUSBAudioBufferCallback)(void *pvBuffer, uint32_t ui32Param,
+                                         uint32_t ui32Event);
+
+//*****************************************************************************
+//
+// PRIVATE
+//
+// This structure defines the private instance data and state variables for the
+// audio device class.  The memory for this structure is pointed to by
+// the pi16PrivateData field in the tUSBDAudioDevice structure passed on
+// USBDAudioInit() and should not be modified by any code outside of the audio
+// device.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    // Base address for the USB controller.
+    //
+    uint32_t ui32USBBase;
+
+    //
+    // The device info to interact with the lower level DCD code.
+    //
+    tDeviceInfo sDevInfo;
+
+    //
+    // The maximum volume expressed as an 8.8 signed value.
+    //
+    int16_t i16VolumeMax;
+
+    //
+    // The minimum volume expressed as an 8.8 signed value.
+    //
+    int16_t i16VolumeMin;
+
+    //
+    // The minimum volume step expressed as an 8.8 signed value.
+    //
+    int16_t i16VolumeStep;
+
+    struct
+    {
+        //
+        // Pointer to a buffer provided by caller.
+        //
+        void *pvData;
+
+        //
+        // Size of the data area provided in pvData in bytes.
+        //
+        uint32_t ui32Size;
+
+        //
+        // Number of valid bytes copied into the pvData area.
+        //
+        uint32_t ui32NumBytes;
+
+        //
+        // The buffer callback for this function.
+        //
+        tUSBAudioBufferCallback pfnCallback;
+    }
+    sBuffer;
+
+    //
+    // Pending request type.
+    //
+    uint16_t ui16RequestType;
+
+    //
+    // Pending request.
+    //
+    uint8_t ui8Request;
+
+    //
+    // Pending update value.
+    //
+    uint16_t ui16Update;
+
+    //
+    // Current Volume setting.
+    //
+    int16_t i16Volume;
+
+    //
+    // Current Mute setting.
+    //
+    uint8_t ui8Mute;
+
+    //
+    // Current Sample rate, this is not writable but the host will try.
+    //
+    uint32_t ui32SampleRate;
+
+    //
+    // The OUT endpoint in use by this instance.
+    //
+    uint8_t ui8OUTEndpoint;
+
+    //
+    // The OUT endpoint DMA channel in use by this instance.
+    //
+    uint8_t ui8OUTDMA;
+
+    //
+    // The control interface number associated with this instance.
+    //
+    uint8_t ui8InterfaceControl;
+
+    //
+    // The audio interface number associated with this instance.
+    //
+    uint8_t ui8InterfaceAudio;
+
+    //
+    // A copy of the DMA instance data used with calls to USBLibDMA functions.
+    //
+    tUSBDMAInstance *psDMAInstance;
+}
+tAudioInstance;
+
+//*****************************************************************************
+//
+// This is the size of the g_pui8IADAudioDescriptor array in bytes.
+//
+//*****************************************************************************
+#define AUDIODESCRIPTOR_SIZE    (8)
+
+//*****************************************************************************
+//
+// This is the size of the g_pui8AudioControlInterface array in bytes.
+//
+//*****************************************************************************
+#define CONTROLINTERFACE_SIZE   (52)
+
+//*****************************************************************************
+//
+// This is the size of the g_pui8AudioStreamInterface array in bytes.
+//
+//*****************************************************************************
+#define STREAMINTERFACE_SIZE    (52)
+
+//*****************************************************************************
+//
+//! The size of the memory that should be allocated to create a configuration
+//! descriptor for a single instance of the USB Audio Device.
+//! This does not include the configuration descriptor which is automatically
+//! ignored by the composite device class.
+//
+//*****************************************************************************
+#define COMPOSITE_DAUDIO_SIZE   (AUDIODESCRIPTOR_SIZE +                       \
+                                 CONTROLINTERFACE_SIZE + STREAMINTERFACE_SIZE)
+
+//*****************************************************************************
+//
+//! The structure used by the application to define operating parameters for
+//! the device audio class.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The vendor ID that this device is to present in the device descriptor.
+    //
+    const uint16_t ui16VID;
+
+    //
+    //! The product ID that this device is to present in the device descriptor.
+    //
+    const uint16_t ui16PID;
+
+    //
+    //! 8 byte vendor string.
+    //
+    const char pcVendor[8];
+
+    //
+    //! 16 byte vendor string.
+    //
+    const char pcProduct[16];
+
+    //
+    //! 4 byte vendor string.
+    //
+    const char pcVersion[4];
+
+    //
+    //! The maximum power consumption of the device, expressed in mA.
+    //
+    const uint16_t ui16MaxPowermA;
+
+    //
+    //! Indicates whether the device is self or bus-powered and whether or not
+    //! it supports remote wake up.  Valid values are USB_CONF_ATTR_SELF_PWR or
+    //! USB_CONF_ATTR_BUS_PWR, optionally ORed with USB_CONF_ATTR_RWAKE.
+    //
+    const uint8_t ui8PwrAttributes;
+
+    //
+    //! A pointer to the callback function which will be called to notify
+    //! the application of events relating to the operation of the audio
+    //! device.
+    //
+    const tUSBCallback pfnCallback;
+
+    //
+    //! A pointer to the string descriptor array for this device.  This array
+    //! must contain the following string descriptor pointers in this order.
+    //! Language descriptor, Manufacturer name string (language 1), Product
+    //! name string (language 1), Serial number string (language 1), Audio
+    //! Interface description string (language 1), Configuration description
+    //! string (language 1).
+    //!
+    //! If supporting more than 1 language, the descriptor block (except for
+    //! string descriptor 0) must be repeated for each language defined in the
+    //! language descriptor.
+    //!
+    //
+    const uint8_t * const *ppui8StringDescriptors;
+
+    //
+    //! The number of descriptors provided in the ppStringDescriptors
+    //! array.  This must be 1 + ((5 + (number of strings)) *
+    //!                           (number of languages)).
+    //
+    const uint32_t ui32NumStringDescriptors;
+
+    //
+    //! The maximum volume expressed as an 8.8 signed value.
+    //
+    const int16_t i16VolumeMax;
+
+    //
+    //! The minimum volume expressed as an 8.8 signed value.
+    //
+    const int16_t i16VolumeMin;
+
+    //
+    //! The minimum volume step expressed as an 8.8 signed value.
+    //
+    const int16_t i16VolumeStep;
+
+    //
+    //! The private instance data for the audio device.
+    //
+    tAudioInstance sPrivateData;
+}
+tUSBDAudioDevice;
+
+//*****************************************************************************
+//
+// Audio specific device class driver events
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! This USB audio event indicates that the device is connected but not active.
+//
+//*****************************************************************************
+#define USBD_AUDIO_EVENT_IDLE   (USBD_AUDIO_EVENT_BASE + 0)
+
+//*****************************************************************************
+//
+//! This USB audio event indicates that the device is connected and is now
+//! active.
+//
+//*****************************************************************************
+#define USBD_AUDIO_EVENT_ACTIVE (USBD_AUDIO_EVENT_BASE + 1)
+
+//*****************************************************************************
+//
+//! This USB audio event indicates that the device is returning a data buffer
+//! provided by the USBAudioBufferOut() function back to the application with
+//! valid audio data received from the USB host controller. The \e pvBuffer
+//! parameter holds the pointer to the buffer with the new audio data and
+//! the \e ui32Param value holds the amount of valid data in bytes that are
+//! contained in the \e pvBuffer parameter.
+//
+//*****************************************************************************
+#define USBD_AUDIO_EVENT_DATAOUT (USBD_AUDIO_EVENT_BASE + 2)
+
+//*****************************************************************************
+//
+//! This USB audio event indicates that a volume change has occurred.  The
+//! \e ui32Param value contains a signed 8.8 fixed point value that represents
+//! the current volume gain/attenuation in decibels(dB).  The provided message
+//! handler should be prepared to handle negative and positive values with the
+//! value 0x8000 indicating maximum attenuation.  The \e pvBuffer parameter
+//! should be ignored.
+//
+//*****************************************************************************
+#define USBD_AUDIO_EVENT_VOLUME (USBD_AUDIO_EVENT_BASE + 4)
+
+//*****************************************************************************
+//
+//! This USB audio event indicates that a mute request has occurred.  The
+//! \e ui32Param value will either be a 1 to indicate that the audio is now
+//! muted, and a value of 0 indicates that the audio has been unmuted.
+//
+//*****************************************************************************
+#define USBD_AUDIO_EVENT_MUTE   (USBD_AUDIO_EVENT_BASE + 5)
+
+//*****************************************************************************
+//
+// API Function Prototypes
+//
+//*****************************************************************************
+extern void *USBDAudioInit(uint32_t ui32Index,
+                           tUSBDAudioDevice *psAudioDevice);
+extern void *USBDAudioCompositeInit(uint32_t ui32Index,
+                                    tUSBDAudioDevice *psAudioDevice,
+                                    tCompositeEntry *psCompEntry);
+extern void USBDAudioTerm(void *pvAudioDevice);
+extern int32_t USBAudioBufferOut(void *pvAudioDevice, void *pvBuffer,
+                                 uint32_t ui32Size,
+                                 tUSBAudioBufferCallback pfnCallback);
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/bsp/tm4c129x/libraries/usblib/device/usbdbulk.c b/bsp/tm4c129x/libraries/usblib/device/usbdbulk.c
new file mode 100755
index 0000000..6bae0cc
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/device/usbdbulk.c
@@ -0,0 +1,1562 @@
+//*****************************************************************************
+//
+// usbdbulk.c - USB bulk device class driver.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "inc/hw_memmap.h"
+#include "inc/hw_types.h"
+#include "driverlib/debug.h"
+#include "driverlib/rom.h"
+#include "driverlib/rom_map.h"
+#include "driverlib/usb.h"
+#include "usblib/usblib.h"
+#include "usblib/usblibpriv.h"
+#include "usblib/device/usbdevice.h"
+#include "usblib/device/usbdbulk.h"
+#include "usblib/device/usbdcomp.h"
+#include "usblib/usblibpriv.h"
+
+//*****************************************************************************
+//
+//! \addtogroup bulk_device_class_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// The subset of endpoint status flags that we consider to be reception
+// errors.  These are passed to the client via USB_EVENT_ERROR if seen.
+//
+//*****************************************************************************
+#define USB_RX_ERROR_FLAGS      (USBERR_DEV_RX_DATA_ERROR |                   \
+                                 USBERR_DEV_RX_OVERRUN |                      \
+                                 USBERR_DEV_RX_FIFO_FULL)
+
+//*****************************************************************************
+//
+// Flags that may appear in ui16DeferredOpFlags to indicate some operation that
+// has been requested but could not be processed at the time it was received.
+// Each deferred operation is defined as the bit number that should be set in
+// tBulkInstance->ui16DeferredOpFlags to indicate that the operation is
+// pending.
+//
+//*****************************************************************************
+#define BULK_DO_PACKET_RX       5
+
+//*****************************************************************************
+//
+// Endpoints to use for each of the required endpoints in the driver.'
+//
+//*****************************************************************************
+#define DATA_IN_ENDPOINT        USB_EP_1
+#define DATA_OUT_ENDPOINT       USB_EP_1
+
+//*****************************************************************************
+//
+// Maximum packet size for the bulk endpoints used for bulk data
+// transmission and reception and the associated FIFO sizes to set aside
+// for each endpoint.
+//
+//*****************************************************************************
+#define DATA_IN_EP_FIFO_SIZE    USB_FIFO_SZ_64
+#define DATA_OUT_EP_FIFO_SIZE   USB_FIFO_SZ_64
+
+#define DATA_IN_EP_MAX_SIZE     USBFIFOSizeToBytes(DATA_IN_EP_FIFO_SIZE)
+#define DATA_OUT_EP_MAX_SIZE    USBFIFOSizeToBytes(DATA_OUT_EP_FIFO_SIZE)
+
+//*****************************************************************************
+//
+// Device Descriptor.  This is stored in RAM to allow several fields to be
+// changed at runtime based on the client's requirements.
+//
+//*****************************************************************************
+uint8_t g_pui8BulkDeviceDescriptor[] =
+{
+    18,                         // Size of this structure.
+    USB_DTYPE_DEVICE,           // Type of this structure.
+    USBShort(0x110),            // USB version 1.1 (if we say 2.0, hosts assume
+                                // high-speed - see USB 2.0 spec 9.2.6.6)
+    USB_CLASS_VEND_SPECIFIC,    // USB Device Class
+    0,                          // USB Device Sub-class
+    0,                          // USB Device protocol
+    64,                         // Maximum packet size for default pipe.
+    USBShort(0),                // Vendor ID (VID).
+    USBShort(0),                // Product ID (PID).
+    USBShort(0x100),            // Device Version BCD.
+    1,                          // Manufacturer string identifier.
+    2,                          // Product string identifier.
+    3,                          // Product serial number.
+    1                           // Number of configurations.
+};
+
+//*****************************************************************************
+//
+// Bulk device configuration descriptor.
+//
+// It is vital that the configuration descriptor bConfigurationValue field
+// (byte 6) is 1 for the first configuration and increments by 1 for each
+// additional configuration defined here.  This relationship is assumed in the
+// device stack for simplicity even though the USB 2.0 specification imposes
+// no such restriction on the bConfigurationValue values.
+//
+// Note that this structure is deliberately located in RAM since we need to
+// be able to patch some values in it based on client requirements.
+//
+//*****************************************************************************
+uint8_t g_pui8BulkDescriptor[] =
+{
+    //
+    // Configuration descriptor header.
+    //
+    9,                          // Size of the configuration descriptor.
+    USB_DTYPE_CONFIGURATION,    // Type of this descriptor.
+    USBShort(32),               // The total size of this full structure.
+    1,                          // The number of interfaces in this
+                                // configuration.
+    1,                          // The unique value for this configuration.
+    5,                          // The string identifier that describes this
+                                // configuration.
+    USB_CONF_ATTR_SELF_PWR,     // Bus Powered, Self Powered, remote wake up.
+    250,                        // The maximum power in 2mA increments.
+};
+
+//*****************************************************************************
+//
+// The remainder of the configuration descriptor is stored in flash since we
+// don't need to modify anything in it at runtime.
+//
+//*****************************************************************************
+const uint8_t g_pui8BulkInterface[BULKINTERFACE_SIZE] =
+{
+    //
+    // Vendor-specific Interface Descriptor.
+    //
+    9,                              // Size of the interface descriptor.
+    USB_DTYPE_INTERFACE,            // Type of this descriptor.
+    0,                              // The index for this interface.
+    0,                              // The alternate setting for this
+                                    // interface.
+    2,                              // The number of endpoints used by this
+                                    // interface.
+    USB_CLASS_VEND_SPECIFIC,        // The interface class
+    0,                              // The interface sub-class.
+    0,                              // The interface protocol for the sub-class
+                                    // specified above.
+    4,                              // The string index for this interface.
+
+    //
+    // Endpoint Descriptor
+    //
+    7,                              // The size of the endpoint descriptor.
+    USB_DTYPE_ENDPOINT,             // Descriptor type is an endpoint.
+    USB_EP_DESC_IN | USBEPToIndex(DATA_IN_ENDPOINT),
+    USB_EP_ATTR_BULK,               // Endpoint is a bulk endpoint.
+    USBShort(DATA_IN_EP_MAX_SIZE),  // The maximum packet size.
+    0,                              // The polling interval for this endpoint.
+
+    //
+    // Endpoint Descriptor
+    //
+    7,                               // The size of the endpoint descriptor.
+    USB_DTYPE_ENDPOINT,              // Descriptor type is an endpoint.
+    USB_EP_DESC_OUT | USBEPToIndex(DATA_OUT_ENDPOINT),
+    USB_EP_ATTR_BULK,                // Endpoint is a bulk endpoint.
+    USBShort(DATA_OUT_EP_MAX_SIZE),  // The maximum packet size.
+    0,                               // The polling interval for this endpoint.
+};
+
+//*****************************************************************************
+//
+// The bulk configuration descriptor is defined as two sections, one
+// containing just the 9 byte USB configuration descriptor and the other
+// containing everything else that is sent to the host along with it.
+//
+//*****************************************************************************
+const tConfigSection g_sBulkConfigSection =
+{
+    sizeof(g_pui8BulkDescriptor),
+    g_pui8BulkDescriptor
+};
+
+const tConfigSection g_sBulkInterfaceSection =
+{
+    sizeof(g_pui8BulkInterface),
+    g_pui8BulkInterface
+};
+
+//*****************************************************************************
+//
+// This array lists all the sections that must be concatenated to make a
+// single, complete bulk device configuration descriptor.
+//
+//*****************************************************************************
+const tConfigSection *g_psBulkSections[] =
+{
+    &g_sBulkConfigSection,
+    &g_sBulkInterfaceSection
+};
+
+#define NUM_BULK_SECTIONS       (sizeof(g_psBulkSections) /                   \
+                                 sizeof(g_psBulkSections[0]))
+
+//*****************************************************************************
+//
+// The header for the single configuration we support.  This is the root of
+// the data structure that defines all the bits and pieces that are pulled
+// together to generate the configuration descriptor.
+//
+//*****************************************************************************
+const tConfigHeader g_sBulkConfigHeader =
+{
+    NUM_BULK_SECTIONS,
+    g_psBulkSections
+};
+
+//*****************************************************************************
+//
+// Configuration Descriptor.
+//
+//*****************************************************************************
+const tConfigHeader * const g_ppBulkConfigDescriptors[] =
+{
+    &g_sBulkConfigHeader
+};
+
+//*****************************************************************************
+//
+// Forward references for device handler callbacks
+//
+//*****************************************************************************
+static void HandleConfigChange(void *pvBulkDevice, uint32_t ui32Info);
+static void HandleDisconnect(void *pvBulkDevice);
+static void HandleEndpoints(void *pvBulkDevice, uint32_t ui32Status);
+static void HandleSuspend(void *pvBulkDevice);
+static void HandleResume(void *pvBulkDevice);
+static void HandleDevice(void *pvBulkDevice, uint32_t ui32Request,
+                         void *pvRequestData);
+
+//*****************************************************************************
+//
+// Device event handler callbacks.
+//
+//*****************************************************************************
+const tCustomHandlers g_sBulkHandlers =
+{
+    //
+    // GetDescriptor
+    //
+    0,
+
+    //
+    // RequestHandler
+    //
+    0,
+
+    //
+    // InterfaceChange
+    //
+    0,
+
+    //
+    // ConfigChange
+    //
+    HandleConfigChange,
+
+    //
+    // DataReceived
+    //
+    0,
+
+    //
+    // DataSentCallback
+    //
+    0,
+
+    //
+    // ResetHandler
+    //
+    0,
+
+    //
+    // SuspendHandler
+    //
+    HandleSuspend,
+
+    //
+    // ResumeHandler
+    //
+    HandleResume,
+
+    //
+    // DisconnectHandler
+    //
+    HandleDisconnect,
+
+    //
+    // EndpointHandler
+    //
+    HandleEndpoints,
+
+    //
+    // Device handler
+    //
+    HandleDevice
+};
+
+//*****************************************************************************
+//
+// Set or clear deferred operation flags in an "atomic" manner.
+//
+// \param pui16DeferredOp points to the flags variable which is to be modified.
+// \param ui16Bit indicates which bit number is to be set or cleared.
+// \param bSet indicates the state that the flag must be set to.  If \b true,
+// the flag is set, if \b false, the flag is cleared.
+//
+// This function safely sets or clears a bit in a flag variable.  The operation
+// makes use of bitbanding to ensure that the operation is atomic (no read-
+// modify-write is required).
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+SetDeferredOpFlag(volatile uint16_t *pui16DeferredOp, uint16_t ui16Bit,
+                  bool bSet)
+{
+    //
+    // Set the flag bit to 1 or 0 using a bitband access.
+    //
+    HWREGBITH(pui16DeferredOp, ui16Bit) = bSet ? 1 : 0;
+}
+
+//*****************************************************************************
+//
+// Receives notifications related to data received from the host.
+//
+// \param psBulkDevice is the device instance whose endpoint is to be
+// processed.
+// \param ui32Status is the USB interrupt status that caused this function to
+// be called.
+//
+// This function is called from HandleEndpoints for all interrupts signaling
+// the arrival of data on the bulk OUT endpoint (in other words, whenever the
+// host has sent us a packet of data).  We inform the client that a packet
+// is available and, on return, check to see if the packet has been read.  If
+// not, we schedule another notification to the client for a later time.
+//
+// \return Returns \b true on success or \b false on failure.
+//
+//*****************************************************************************
+static bool
+ProcessDataFromHost(tUSBDBulkDevice *psBulkDevice, uint32_t ui32Status)
+{
+    uint32_t ui32EPStatus;
+    uint32_t ui32Size;
+    tBulkInstance *psInst;
+
+    //
+    // Get a pointer to the bulk device instance data pointer
+    //
+    psInst = &psBulkDevice->sPrivateData;
+
+    //
+    // Get the endpoint status to see why we were called.
+    //
+    ui32EPStatus = MAP_USBEndpointStatus(USB0_BASE, psInst->ui8OUTEndpoint);
+
+    //
+    // Clear the status bits.
+    //
+    MAP_USBDevEndpointStatusClear(USB0_BASE, psInst->ui8OUTEndpoint,
+                                  ui32EPStatus);
+
+    //
+    // Has a packet been received?
+    //
+    if(ui32EPStatus & USB_DEV_RX_PKT_RDY)
+    {
+        //
+        // Set the flag we use to indicate that a packet read is pending.  This
+        // will be cleared if the packet is read.  If the client does not read
+        // the packet in the context of the USB_EVENT_RX_AVAILABLE callback,
+        // the event will be signaled later during tick processing.
+        //
+        SetDeferredOpFlag(&psInst->ui16DeferredOpFlags, BULK_DO_PACKET_RX,
+                          true);
+
+        //
+        // How big is the packet we have just received?
+        //
+        ui32Size = MAP_USBEndpointDataAvail(psInst->ui32USBBase,
+                                            psInst->ui8OUTEndpoint);
+
+        //
+        // The receive channel is not blocked so let the caller know
+        // that a packet is waiting.  The parameters are set to indicate
+        // that the packet has not been read from the hardware FIFO yet.
+        //
+        psBulkDevice->pfnRxCallback(psBulkDevice->pvRxCBData,
+                                    USB_EVENT_RX_AVAILABLE,
+                                    ui32Size, (void *)0);
+    }
+    else
+    {
+        //
+        // No packet was received.  Some error must have been reported.  Check
+        // and pass this on to the client if necessary.
+        //
+        if(ui32EPStatus & USB_RX_ERROR_FLAGS)
+        {
+            //
+            // This is an error we report to the client so allow the callback
+            // to handle it.
+            //
+            psBulkDevice->pfnRxCallback(psBulkDevice->pvRxCBData,
+                                        USB_EVENT_ERROR,
+                                        (ui32EPStatus & USB_RX_ERROR_FLAGS),
+                                        (void *)0);
+        }
+        return(false);
+    }
+
+    return(true);
+}
+
+//*****************************************************************************
+//
+// Receives notifications related to data sent to the host.
+//
+// \param psBulkDevice is the device instance whose endpoint is to be
+// processed.
+// \param ui32Status is the USB interrupt status that caused this function to
+// be called.
+//
+// This function is called from HandleEndpoints for all interrupts originating
+// from the bulk IN endpoint (in other words, whenever data has been
+// transmitted to the USB host).  We examine the cause of the interrupt and,
+// if due to completion of a transmission, notify the client.
+//
+// \return Returns \b true on success or \b false on failure.
+//
+//*****************************************************************************
+static bool
+ProcessDataToHost(tUSBDBulkDevice *psBulkDevice, uint32_t ui32Status)
+{
+    tBulkInstance *psInst;
+    uint32_t ui32EPStatus, ui32Size;
+
+    //
+    // Get a pointer to the bulk device instance data pointer
+    //
+    psInst = &psBulkDevice->sPrivateData;
+
+    //
+    // Get the endpoint status to see why we were called.
+    //
+    ui32EPStatus = MAP_USBEndpointStatus(psInst->ui32USBBase,
+                                         psInst->ui8INEndpoint);
+
+    //
+    // Clear the status bits.
+    //
+    MAP_USBDevEndpointStatusClear(psInst->ui32USBBase, psInst->ui8INEndpoint,
+                                  ui32EPStatus);
+
+    //
+    // Our last transmission completed.  Clear our state back to idle and
+    // see if we need to send any more data.
+    //
+    psInst->iBulkTxState = eBulkStateIdle;
+
+    //
+    // Notify the client that the last transmission completed.
+    //
+    ui32Size = psInst->ui16LastTxSize;
+    psInst->ui16LastTxSize = 0;
+    psBulkDevice->pfnTxCallback(psBulkDevice->pvTxCBData,
+                                USB_EVENT_TX_COMPLETE, ui32Size, (void *)0);
+
+    return(true);
+}
+
+//*****************************************************************************
+//
+// Called by the USB stack for any activity involving one of our endpoints
+// other than EP0.  This function is a fan out that merely directs the call to
+// the correct handler depending upon the endpoint and transaction direction
+// signaled in ui32Status.
+//
+//*****************************************************************************
+static void
+HandleEndpoints(void *pvBulkDevice, uint32_t ui32Status)
+{
+    tUSBDBulkDevice *psBulkDevice;
+    tBulkInstance *psInst;
+
+    ASSERT(pvBulkDevice != 0);
+
+    //
+    // The bulk device structure pointer.
+    //
+    psBulkDevice = (tUSBDBulkDevice *)pvBulkDevice;
+
+    //
+    // Get a pointer to the bulk device instance data pointer
+    //
+    psInst = &psBulkDevice->sPrivateData;
+
+    //
+    // Handler for the bulk OUT data endpoint.
+    //
+    if(ui32Status & (0x10000 << USBEPToIndex(psInst->ui8OUTEndpoint)))
+    {
+        //
+        // Data is being sent to us from the host.
+        //
+        ProcessDataFromHost(psBulkDevice, ui32Status);
+    }
+
+    //
+    // Handler for the bulk IN data endpoint.
+    //
+    if(ui32Status & (1 << USBEPToIndex(psInst->ui8INEndpoint)))
+    {
+        ProcessDataToHost(psBulkDevice, ui32Status);
+    }
+}
+
+//*****************************************************************************
+//
+// Called by the USB stack whenever a configuration change occurs.
+//
+//*****************************************************************************
+static void
+HandleConfigChange(void *pvBulkDevice, uint32_t ui32Info)
+{
+    tBulkInstance *psInst;
+    tUSBDBulkDevice *psBulkDevice;
+
+    ASSERT(pvBulkDevice != 0);
+
+    //
+    // The bulk device structure pointer.
+    //
+    psBulkDevice = (tUSBDBulkDevice *)pvBulkDevice;
+
+    //
+    // Get a pointer to the bulk device instance data pointer
+    //
+    psInst = &psBulkDevice->sPrivateData;
+
+    //
+    // Set all our endpoints to idle state.
+    //
+    psInst->iBulkRxState = eBulkStateIdle;
+    psInst->iBulkTxState = eBulkStateIdle;
+
+    //
+    // If we have a control callback, let the client know we are open for
+    // business.
+    //
+    if(psBulkDevice->pfnRxCallback)
+    {
+        //
+        // Pass the connected event to the client.
+        //
+        psBulkDevice->pfnRxCallback(psBulkDevice->pvRxCBData,
+                                    USB_EVENT_CONNECTED, 0, (void *)0);
+    }
+
+    //
+    // Remember that we are connected.
+    //
+    psInst->bConnected = true;
+}
+
+//*****************************************************************************
+//
+// Device instance specific handler.
+//
+//*****************************************************************************
+static void
+HandleDevice(void *pvBulkDevice, uint32_t ui32Request, void *pvRequestData)
+{
+    tBulkInstance *psInst;
+    uint8_t *pui8Data;
+    tUSBDBulkDevice *psBulkDevice;
+
+    //
+    // The bulk device structure pointer.
+    //
+    psBulkDevice = (tUSBDBulkDevice *)pvBulkDevice;
+
+    //
+    // Get a pointer to the bulk device instance data pointer
+    //
+    psInst = &psBulkDevice->sPrivateData;
+
+    //
+    // Create the 8-bit array used by the events supported by the USB Bulk
+    // class.
+    //
+    pui8Data = (uint8_t *)pvRequestData;
+
+    switch(ui32Request)
+    {
+        //
+        // This was an interface change event.
+        //
+        case USB_EVENT_COMP_IFACE_CHANGE:
+        {
+            psInst->ui8Interface = pui8Data[1];
+            break;
+        }
+
+        //
+        // This was an endpoint change event.
+        //
+        case USB_EVENT_COMP_EP_CHANGE:
+        {
+            //
+            // Determine if this is an IN or OUT endpoint that has changed.
+            //
+            if(pui8Data[0] & USB_EP_DESC_IN)
+            {
+                psInst->ui8INEndpoint = IndexToUSBEP((pui8Data[1] & 0x7f));
+            }
+            else
+            {
+                //
+                // Extract the new endpoint number.
+                //
+                psInst->ui8OUTEndpoint = IndexToUSBEP(pui8Data[1] & 0x7f);
+            }
+            break;
+        }
+        case USB_EVENT_LPM_RESUME:
+        {
+            if(psBulkDevice->pfnRxCallback)
+            {
+                //
+                // Pass the LPM resume event to the client.
+                //
+                psBulkDevice->pfnRxCallback(psBulkDevice->pvRxCBData,
+                                            USB_EVENT_LPM_RESUME, 0,
+                                            (void *)0);
+            }
+            break;
+        }
+        case USB_EVENT_LPM_SLEEP:
+        {
+            if(psBulkDevice->pfnRxCallback)
+            {
+                //
+                // Pass the LPM sleep event to the client.
+                //
+                psBulkDevice->pfnRxCallback(psBulkDevice->pvRxCBData,
+                                            USB_EVENT_LPM_SLEEP, 0, (void *)0);
+            }
+            break;
+        }
+        case USB_EVENT_LPM_ERROR:
+        {
+            if(psBulkDevice->pfnRxCallback)
+            {
+                //
+                // Pass the LPM error event to the client.
+                //
+                psBulkDevice->pfnRxCallback(psBulkDevice->pvRxCBData,
+                                            USB_EVENT_LPM_ERROR, 0, (void *)0);
+            }
+            break;
+        }
+        default:
+        {
+            break;
+        }
+    }
+}
+
+//*****************************************************************************
+//
+// This function is called by the USB device stack whenever the device is
+// disconnected from the host.
+//
+//*****************************************************************************
+static void
+HandleDisconnect(void *pvBulkDevice)
+{
+    tUSBDBulkDevice *psBulkDevice;
+    tBulkInstance *psInst;
+
+    ASSERT(pvBulkDevice != 0);
+
+    //
+    // The bulk device structure pointer.
+    //
+    psBulkDevice = (tUSBDBulkDevice *)pvBulkDevice;
+
+    //
+    // Get a pointer to the bulk device instance data pointer
+    //
+    psInst = &psBulkDevice->sPrivateData;
+
+    //
+    // If we are not currently connected so let the client know we are open
+    // for business.
+    //
+    if(psInst->bConnected)
+    {
+        //
+        // Pass the disconnected event to the client.
+        //
+        psBulkDevice->pfnRxCallback(psBulkDevice->pvRxCBData,
+                                    USB_EVENT_DISCONNECTED, 0, (void *)0);
+    }
+
+    //
+    // Remember that we are no longer connected.
+    //
+    psInst->bConnected = false;
+}
+
+//*****************************************************************************
+//
+// This function is called by the USB device stack whenever the bus is put into
+// suspend state.
+//
+//*****************************************************************************
+static void
+HandleSuspend(void *pvBulkDevice)
+{
+    const tUSBDBulkDevice *psBulkDevice;
+
+    ASSERT(pvBulkDevice != 0);
+
+    //
+    // The bulk device structure pointer.
+    //
+    psBulkDevice = (const tUSBDBulkDevice *)pvBulkDevice;
+
+    //
+    // Pass the event on to the client.
+    //
+    psBulkDevice->pfnRxCallback(psBulkDevice->pvRxCBData, USB_EVENT_SUSPEND, 0,
+                                (void *)0);
+}
+
+//*****************************************************************************
+//
+// This function is called by the USB device stack whenever the bus is taken
+// out of suspend state.
+//
+//*****************************************************************************
+static void
+HandleResume(void *pvBulkDevice)
+{
+    const tUSBDBulkDevice *psBulkDevice;
+
+    ASSERT(pvBulkDevice != 0);
+
+    //
+    // The bulk device structure pointer.
+    //
+    psBulkDevice = (const tUSBDBulkDevice *)pvBulkDevice;
+
+    //
+    // Pass the event on to the client.
+    //
+    psBulkDevice->pfnRxCallback(psBulkDevice->pvRxCBData, USB_EVENT_RESUME, 0,
+                                (void *)0);
+}
+
+//*****************************************************************************
+//
+// This function is called periodically and provides us with a time reference
+// and method of implementing delayed or time-dependent operations.
+//
+// \param ui32Index is the index of the USB controller for which this tick
+// is being generated.
+// \param ui32TimemS is the elapsed time in milliseconds since the last call
+// to this function.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+BulkTickHandler(void *pvBulkDevice, uint32_t ui32TimemS)
+{
+    tBulkInstance *psInst;
+    uint32_t ui32Size;
+    tUSBDBulkDevice *psBulkDevice;
+
+    ASSERT(pvBulkDevice != 0);
+
+    //
+    // The bulk device structure pointer.
+    //
+    psBulkDevice = (tUSBDBulkDevice *)pvBulkDevice;
+
+    //
+    // Get a pointer to the bulk device instance data pointer
+    //
+    psInst = &psBulkDevice->sPrivateData;
+
+    //
+    // Do we have a deferred receive waiting
+    //
+    if(psInst->ui16DeferredOpFlags & (1 << BULK_DO_PACKET_RX))
+    {
+        //
+        // Yes - how big is the waiting packet?
+        //
+        ui32Size = MAP_USBEndpointDataAvail(psInst->ui32USBBase,
+                                            psInst->ui8OUTEndpoint);
+
+        //
+        // Tell the client that there is a packet waiting for it.
+        //
+        psBulkDevice->pfnRxCallback(psBulkDevice->pvRxCBData,
+                                    USB_EVENT_RX_AVAILABLE, ui32Size,
+                                    (void *)0);
+    }
+
+    return;
+}
+
+//*****************************************************************************
+//
+//! Initializes bulk device operation for a given USB controller.
+//!
+//! \param ui32Index is the index of the USB controller which is to be
+//! initialized for bulk device operation.
+//! \param psBulkDevice points to a structure containing parameters customizing
+//! the operation of the bulk device.
+//!
+//! An application wishing to make use of a USB bulk communication channel
+//! must call this function to initialize the USB controller and attach the
+//! device to the USB bus.  This function performs all required USB
+//! initialization.
+//!
+//! On successful completion, this function will return the \e psBulkDevice
+//! pointer passed to it.  This must be passed on all future calls to the
+//! device driver related to this device.
+//!
+//! The USBDBulk interface offers packet-based transmit and receive operation.
+//! If the application would rather use block based communication with
+//! transmit and receive buffers, USB buffers may be used above the bulk
+//! transmit and receive channels to offer this functionality.
+//!
+//! Transmit Operation:
+//!
+//! Calls to USBDBulkPacketWrite() must send no more than 64 bytes of data at a
+//! time and may only be made when no other transmission is currently
+//! outstanding.
+//!
+//! Once a packet of data has been acknowledged by the USB host, a
+//! \b USB_EVENT_TX_COMPLETE event is sent to the application callback to
+//! inform it that another packet may be transmitted.
+//!
+//! Receive Operation:
+//!
+//! An incoming USB data packet will result in a call to the application
+//! callback with event \b USBD_EVENT_RX_AVAILABLE.  The application must then
+//! call USBDBulkPacketRead(), passing a buffer capable of holding 64 bytes, to
+//! retrieve the data and acknowledge reception to the USB host.
+//!
+//! \note The application must not make any calls to the low level USB Device
+//! API if interacting with USB via the USB bulk device class API.  Doing so
+//! will cause unpredictable (though almost certainly unpleasant) behavior.
+//!
+//! \return Returns NULL on failure or void pointer that should be used with
+//! the remaining USB bulk class APSs.
+//
+//*****************************************************************************
+void *
+USBDBulkInit(uint32_t ui32Index, tUSBDBulkDevice *psBulkDevice)
+{
+    void *pvBulkDevice;
+    tDeviceDescriptor *psDevDesc;
+    tConfigDescriptor *psConfigDesc;
+
+    //
+    // Check parameter validity.
+    //
+    ASSERT(ui32Index == 0);
+    ASSERT(psBulkDevice);
+
+    pvBulkDevice = USBDBulkCompositeInit(ui32Index, psBulkDevice, 0);
+
+    if(pvBulkDevice)
+    {
+        //
+        // Fix up the device descriptor with the client-supplied values.
+        //
+        psDevDesc = (tDeviceDescriptor *)g_pui8BulkDeviceDescriptor;
+        psDevDesc->idVendor = psBulkDevice->ui16VID;
+        psDevDesc->idProduct = psBulkDevice->ui16PID;
+
+        //
+        // Fix up the configuration descriptor with client-supplied values.
+        //
+        psConfigDesc = (tConfigDescriptor *)g_pui8BulkDescriptor;
+        psConfigDesc->bmAttributes = psBulkDevice->ui8PwrAttributes;
+        psConfigDesc->bMaxPower = (uint8_t)(psBulkDevice->ui16MaxPowermA / 2);
+
+        //
+        // All is well so now pass the descriptors to the lower layer and put
+        // the bulk device on the bus.
+        //
+        USBDCDInit(ui32Index, &psBulkDevice->sPrivateData.sDevInfo,
+                   (void *)psBulkDevice);
+    }
+
+    //
+    // Return the pointer to the instance indicating that everything went well.
+    //
+    return(pvBulkDevice);
+}
+
+//*****************************************************************************
+//
+//! Initializes bulk device operation for a given USB controller.
+//!
+//! \param ui32Index is the index of the USB controller which is to be
+//! initialized for bulk device operation.
+//! \param psBulkDevice points to a structure containing parameters customizing
+//! the operation of the bulk device.
+//! \param psCompEntry is the composite device entry to initialize when
+//! creating a composite device.
+//!
+//! This call is very similar to USBDBulkInit() except that it is used for
+//! initializing an instance of the bulk device for use in a composite device.
+//! When this bulk device is part of a composite device, then the
+//! \e psCompEntry should point to the composite device entry to initialize.
+//! This is part of the array that is passed to the USBDCompositeInit()
+//! function.
+//!
+//! \return Returns zero on failure or a non-zero value that should be
+//! used with the remaining USB Bulk APIs.
+//
+//*****************************************************************************
+void *
+USBDBulkCompositeInit(uint32_t ui32Index, tUSBDBulkDevice *psBulkDevice,
+                      tCompositeEntry *psCompEntry)
+{
+    tBulkInstance *psInst;
+
+    //
+    // Check parameter validity.
+    //
+    ASSERT(ui32Index == 0);
+    ASSERT(psBulkDevice);
+    ASSERT(psBulkDevice->ppui8StringDescriptors);
+    ASSERT(psBulkDevice->pfnRxCallback);
+    ASSERT(psBulkDevice->pfnTxCallback);
+
+    //
+    // Initialize the workspace in the passed instance structure.
+    //
+    psInst = &psBulkDevice->sPrivateData;
+
+    //
+    // Initialize the composite entry that is used by the composite device
+    // class.
+    //
+    if(psCompEntry != 0)
+    {
+        psCompEntry->psDevInfo = &psInst->sDevInfo;
+        psCompEntry->pvInstance = (void *)psBulkDevice;
+    }
+
+    //
+    // Initialize the device information structure.
+    //
+    psInst->sDevInfo.psCallbacks = &g_sBulkHandlers;
+    psInst->sDevInfo.pui8DeviceDescriptor = g_pui8BulkDeviceDescriptor;
+    psInst->sDevInfo.ppsConfigDescriptors = g_ppBulkConfigDescriptors;
+    psInst->sDevInfo.ppui8StringDescriptors = 0;
+    psInst->sDevInfo.ui32NumStringDescriptors = 0;
+
+    //
+    // Set the basic state information for the class.
+    //
+    psInst->ui32USBBase = USB0_BASE;
+    psInst->iBulkRxState = eBulkStateUnconfigured;
+    psInst->iBulkTxState = eBulkStateUnconfigured;
+    psInst->ui16DeferredOpFlags = 0;
+    psInst->bConnected = false;
+
+    //
+    // Initialize the device info structure for the Bulk device.
+    //
+    USBDCDDeviceInfoInit(0, &psInst->sDevInfo);
+
+    //
+    // Set the default endpoint and interface assignments.
+    //
+    psInst->ui8INEndpoint = DATA_IN_ENDPOINT;
+    psInst->ui8OUTEndpoint = DATA_OUT_ENDPOINT;
+    psInst->ui8Interface = 0;
+
+    //
+    // Plug in the client's string stable to the device information
+    // structure.
+    //
+    psInst->sDevInfo.ppui8StringDescriptors =
+                                        psBulkDevice->ppui8StringDescriptors;
+    psInst->sDevInfo.ui32NumStringDescriptors =
+                                        psBulkDevice->ui32NumStringDescriptors;
+
+    //
+    // Initialize the USB tick module, this will prevent it from being
+    // initialized later in the call to USBDCDInit();
+    //
+    InternalUSBTickInit();
+
+    //
+    // Register our tick handler (this must be done after USBDCDInit).
+    //
+    InternalUSBRegisterTickHandler(BulkTickHandler, (void *)psBulkDevice);
+
+    //
+    // Return the pointer to the instance indicating that everything went well.
+    //
+    return((void *)psBulkDevice);
+}
+
+//*****************************************************************************
+//
+//! Shut down the bulk device.
+//!
+//! \param pvBulkDevice is the pointer to the device instance structure as
+//! returned by USBDBulkInit().
+//!
+//! This function terminates device operation for the instance supplied and
+//! removes the device from the USB bus.  This function should not be called
+//! if the bulk device is part of a composite device and instead the
+//! USBDCompositeTerm() function should be called for the full composite
+//! device.
+//!
+//! Following this call, the \e pvBulkDevice instance should not me used in any
+//! other calls.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBDBulkTerm(void *pvBulkDevice)
+{
+    tBulkInstance *psInst;
+
+    ASSERT(pvBulkDevice);
+
+    //
+    // Get a pointer to the bulk device instance data pointer
+    //
+    psInst = &((tUSBDBulkDevice *)pvBulkDevice)->sPrivateData;
+
+    //
+    // Terminate the requested instance.
+    //
+    USBDCDTerm(USBBaseToIndex(psInst->ui32USBBase));
+
+    psInst->ui32USBBase = 0;
+
+    return;
+}
+
+//*****************************************************************************
+//
+//! Sets the client-specific pointer parameter for the receive channel
+//! callback.
+//!
+//! \param pvBulkDevice is the pointer to the device instance structure as
+//! returned by USBDBulkInit().
+//! \param pvCBData is the pointer that client wishes to be provided on each
+//! event sent to the receive channel callback function.
+//!
+//! The client uses this function to change the callback pointer passed in
+//! the first parameter on all callbacks to the \e pfnRxCallback function
+//! passed on USBDBulkInit().
+//!
+//! If a client wants to make runtime changes in the callback pointer, it must
+//! ensure that the \e pvBulkDevice structure passed to USBDBulkInit() resides
+//! in RAM.  If this structure is in flash, callback pointer changes are not
+//! possible.
+//!
+//! \return Returns the previous callback pointer that was being used for
+//! this instance's receive callback.
+//
+//*****************************************************************************
+void *
+USBDBulkSetRxCBData(void *pvBulkDevice, void *pvCBData)
+{
+    void *pvOldValue;
+
+    ASSERT(pvBulkDevice);
+
+    //
+    // Set the callback data for the receive channel after remembering the
+    // previous value.
+    //
+    pvOldValue = ((tUSBDBulkDevice *)pvBulkDevice)->pvRxCBData;
+    ((tUSBDBulkDevice *)pvBulkDevice)->pvRxCBData = pvCBData;
+
+    //
+    // Return the previous callback pointer.
+    //
+    return(pvOldValue);
+}
+
+//*****************************************************************************
+//
+//! Sets the client-specific pointer parameter for the transmit callback.
+//!
+//! \param pvBulkDevice is the pointer to the device instance structure as
+//! returned by USBDBulkInit().
+//! \param pvCBData is the pointer that client wishes to be provided on each
+//! event sent to the transmit channel callback function.
+//!
+//! The client uses this function to change the callback pointer passed in
+//! the first parameter on all callbacks to the \e pfnTxCallback function
+//! passed on USBDBulkInit().
+//!
+//! If a client wants to make runtime changes in the callback pointer, it must
+//! ensure that the \e pvBulkDevice structure passed to USBDBulkInit() resides
+//! in RAM.  If this structure is in flash, callback pointer changes are not
+//! possible.
+//!
+//! \return Returns the previous callback pointer that was being used for
+//! this instance's transmit callback.
+//
+//*****************************************************************************
+void *
+USBDBulkSetTxCBData(void *pvBulkDevice, void *pvCBData)
+{
+    void *pvOldValue;
+
+    ASSERT(pvBulkDevice);
+
+    //
+    // Set the callback pointer for the transmit channel after remembering the
+    // previous value.
+    //
+    pvOldValue = ((tUSBDBulkDevice *)pvBulkDevice)->pvTxCBData;
+    ((tUSBDBulkDevice *)pvBulkDevice)->pvTxCBData = pvCBData;
+
+    //
+    // Return the previous callback pointer value.
+    //
+    return(pvOldValue);
+}
+
+//*****************************************************************************
+//
+//! Transmits a packet of data to the USB host via the bulk data interface.
+//!
+//! \param pvBulkDevice is the pointer to the device instance structure as
+//! returned by USBDBulkInit().
+//! \param pi8Data points to the first byte of data which is to be transmitted.
+//! \param ui32Length is the number of bytes of data to transmit.
+//! \param bLast indicates whether more data is to be written before a packet
+//! should be scheduled for transmission.  If \b true, the client will make
+//! a further call to this function.  If \b false, no further call will be
+//! made and the driver should schedule transmission of a short packet.
+//!
+//! This function schedules the supplied data for transmission to the USB
+//! host in a single USB packet.  If no transmission is currently ongoing,
+//! the data is immediately copied to the relevant USB endpoint FIFO for
+//! transmission.  Whenever a USB packet is acknowledged by the host, a
+//! \b USB_EVENT_TX_COMPLETE event will be sent to the transmit channel
+//! callback indicating that more data can now be transmitted.
+//!
+//! The maximum value for \e ui32Length is 64 bytes (the maximum USB packet
+//! size for the bulk endpoints in use by the device).  Attempts to send more
+//! data than this will result in a return code of 0 indicating that the data
+//! cannot be sent.
+//!
+//! The \e bLast parameter allows a client to make multiple calls to this
+//! function before scheduling transmission of the packet to the host.  This
+//! can be helpful if, for example, constructing a packet on the fly or
+//! writing a packet which spans the wrap point in a ring buffer.
+//!
+//! \return Returns the number of bytes actually sent.  At this level, this
+//! will either be the number of bytes passed (if less than or equal to the
+//! maximum packet size for the USB endpoint in use and no outstanding
+//! transmission ongoing) or 0 to indicate a failure.
+//
+//*****************************************************************************
+uint32_t
+USBDBulkPacketWrite(void *pvBulkDevice, uint8_t *pi8Data, uint32_t ui32Length,
+                    bool bLast)
+{
+    tBulkInstance *psInst;
+    int32_t i32Retcode;
+
+    ASSERT(pvBulkDevice);
+
+    //
+    // Get a pointer to the bulk device instance data pointer
+    //
+    psInst = &((tUSBDBulkDevice *)pvBulkDevice)->sPrivateData;
+
+    //
+    // Can we send the data provided?
+    //
+    if((ui32Length > DATA_IN_EP_MAX_SIZE) ||
+       (psInst->iBulkTxState != eBulkStateIdle))
+    {
+        //
+        // Either the packet was too big or we are in the middle of sending
+        // another packet.  Return 0 to indicate that we can't send this data.
+        //
+        return(0);
+    }
+
+    //
+    // Copy the data into the USB endpoint FIFO.
+    //
+    i32Retcode = MAP_USBEndpointDataPut(psInst->ui32USBBase,
+                                        psInst->ui8INEndpoint,
+                                        pi8Data, ui32Length);
+
+    //
+    // Did we copy the data successfully?
+    //
+    if(i32Retcode != -1)
+    {
+        //
+        // Remember how many bytes we sent.
+        //
+        psInst->ui16LastTxSize += (uint16_t)ui32Length;
+
+        //
+        // If this is the last call for this packet, schedule transmission.
+        //
+        if(bLast)
+        {
+            //
+            // Send the packet to the host if we have received all the data we
+            // can expect for this packet.
+            //
+            psInst->iBulkTxState = eBulkStateWaitData;
+            i32Retcode = MAP_USBEndpointDataSend(psInst->ui32USBBase,
+                                                 psInst->ui8INEndpoint,
+                                                 USB_TRANS_IN);
+        }
+    }
+
+    //
+    // Did an error occur while trying to send the data?
+    //
+    if(i32Retcode != -1)
+    {
+        //
+        // No - tell the caller we sent all the bytes provided.
+        //
+        return(ui32Length);
+    }
+    else
+    {
+        //
+        // Yes - tell the caller we could not send the data.
+        //
+        return(0);
+    }
+}
+
+//*****************************************************************************
+//
+//! Reads a packet of data received from the USB host via the bulk data
+//! interface.
+//!
+//! \param pvBulkDevice is the pointer to the device instance structure as
+//! returned by USBDBulkInit().
+//! \param pi8Data points to a buffer into which the received data will be
+//! written.
+//! \param ui32Length is the size of the buffer pointed to by pi8Data.
+//! \param bLast indicates whether the client will make a further call to
+//! read additional data from the packet.
+//!
+//! This function reads up to \e ui32Length bytes of data received from the USB
+//! host into the supplied application buffer.  If the driver detects that the
+//! entire packet has been read, it is acknowledged to the host.
+//!
+//! The \e bLast parameter is ignored in this implementation since the end of
+//! a packet can be determined without relying upon the client to provide
+//! this information.
+//!
+//! \return Returns the number of bytes of data read.
+//
+//*****************************************************************************
+uint32_t
+USBDBulkPacketRead(void *pvBulkDevice, uint8_t *pi8Data, uint32_t ui32Length,
+                   bool bLast)
+{
+    uint32_t ui32EPStatus, ui32Count, ui32Pkt;
+    tBulkInstance *psInst;
+    int32_t i32Retcode;
+
+    ASSERT(pvBulkDevice);
+
+    //
+    // Get our instance data pointer
+    //
+    psInst = &((tUSBDBulkDevice *)pvBulkDevice)->sPrivateData;
+
+    //
+    // Does the relevant endpoint FIFO have a packet waiting for us?
+    //
+    ui32EPStatus = MAP_USBEndpointStatus(psInst->ui32USBBase,
+                                         psInst->ui8OUTEndpoint);
+
+    if(ui32EPStatus & USB_DEV_RX_PKT_RDY)
+    {
+        //
+        // How many bytes are available for us to receive?
+        //
+        ui32Pkt = MAP_USBEndpointDataAvail(psInst->ui32USBBase,
+                                           psInst->ui8OUTEndpoint);
+
+        //
+        // Get as much data as we can.
+        //
+        ui32Count = ui32Length;
+        i32Retcode = MAP_USBEndpointDataGet(psInst->ui32USBBase,
+                                            psInst->ui8OUTEndpoint,
+                                            pi8Data, &ui32Count);
+
+        //
+        // Did we read the last of the packet data?
+        //
+        if(ui32Count == ui32Pkt)
+        {
+            //
+            // Clear the endpoint status so that we know no packet is
+            // waiting.
+            //
+            MAP_USBDevEndpointStatusClear(psInst->ui32USBBase,
+                                          psInst->ui8OUTEndpoint,
+                                          ui32EPStatus);
+
+            //
+            // Acknowledge the data, thus freeing the host to send the
+            // next packet.
+            //
+            MAP_USBDevEndpointDataAck(psInst->ui32USBBase,
+                                      psInst->ui8OUTEndpoint, true);
+
+            //
+            // Clear the flag we set to indicate that a packet read is
+            // pending.
+            //
+            SetDeferredOpFlag(&psInst->ui16DeferredOpFlags, BULK_DO_PACKET_RX,
+                              false);
+        }
+
+        //
+        // If all went well, tell the caller how many bytes they got.
+        //
+        if(i32Retcode != -1)
+        {
+            return(ui32Count);
+        }
+    }
+
+    //
+    // No packet was available or an error occurred while reading so tell
+    // the caller no bytes were returned.
+    //
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! Returns the number of free bytes in the transmit buffer.
+//!
+//! \param pvBulkDevice is the pointer to the device instance structure as
+//! returned by USBDBulkInit().
+//!
+//! This function returns the maximum number of bytes that can be passed on a
+//! call to USBDBulkPacketWrite() and accepted for transmission.  The value
+//! returned will be the maximum USB packet size (64) if no transmission is
+//! currently outstanding or 0 if a transmission is in progress.
+//!
+//! \return Returns the number of bytes available in the transmit buffer.
+//
+//*****************************************************************************
+uint32_t
+USBDBulkTxPacketAvailable(void *pvBulkDevice)
+{
+    tBulkInstance *psInst;
+
+    ASSERT(pvBulkDevice);
+
+    //
+    // Get our instance data pointer.
+    //
+    psInst = &((tUSBDBulkDevice *)pvBulkDevice)->sPrivateData;
+
+    //
+    // Do we have a packet transmission currently ongoing?
+    //
+    if(psInst->iBulkTxState != eBulkStateIdle)
+    {
+        //
+        // We are not ready to receive a new packet so return 0.
+        //
+        return(0);
+    }
+    else
+    {
+        //
+        // We can receive a packet so return the max packet size for the
+        // relevant endpoint.
+        //
+        return(DATA_IN_EP_MAX_SIZE);
+    }
+}
+
+//*****************************************************************************
+//
+//! Determines whether a packet is available and, if so, the size of the
+//! buffer required to read it.
+//!
+//! \param pvBulkDevice is the pointer to the device instance structure as
+//! returned by USBDBulkInit().
+//!
+//! This function may be used to determine if a received packet remains to be
+//! read and allows the application to determine the buffer size needed to
+//! read the data.
+//!
+//! \return Returns 0 if no received packet remains unprocessed or the
+//! size of the packet if a packet is waiting to be read.
+//
+//*****************************************************************************
+uint32_t
+USBDBulkRxPacketAvailable(void *pvBulkDevice)
+{
+    uint32_t ui32EPStatus, ui32Size;
+    tBulkInstance *psInst;
+
+    ASSERT(pvBulkDevice);
+
+    //
+    // Get a pointer to the bulk device instance data pointer
+    //
+    psInst = &((tUSBDBulkDevice *)pvBulkDevice)->sPrivateData;
+
+    //
+    // Does the relevant endpoint FIFO have a packet waiting for us?
+    //
+    ui32EPStatus = MAP_USBEndpointStatus(psInst->ui32USBBase,
+                                         psInst->ui8OUTEndpoint);
+
+    if(ui32EPStatus & USB_DEV_RX_PKT_RDY)
+    {
+        //
+        // Yes - a packet is waiting.  How big is it?
+        //
+        ui32Size = MAP_USBEndpointDataAvail(psInst->ui32USBBase,
+                                            psInst->ui8OUTEndpoint);
+
+        return(ui32Size);
+    }
+    else
+    {
+        //
+        // There is no packet waiting to be received.
+        //
+        return(0);
+    }
+}
+#ifndef DEPRECATED
+
+//*****************************************************************************
+//
+//! Reports the device power status (bus- or self-powered) to the USB library.
+//!
+//! \param pvBulkDevice is the pointer to the bulk device instance structure.
+//! \param ui8Power indicates the current power status, either
+//! \b USB_STATUS_SELF_PWR or \b USB_STATUS_BUS_PWR.
+//!
+//! Applications which support switching between bus- or self-powered
+//! operation should call this function whenever the power source changes
+//! to indicate the current power status to the USB library.  This information
+//! is required by the USB library to allow correct responses to be provided
+//! when the host requests status from the device.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBDBulkPowerStatusSet(void *pvBulkDevice, uint8_t ui8Power)
+{
+    ASSERT(pvBulkDevice);
+
+    //
+    // Pass the request through to the lower layer.
+    //
+    USBDCDPowerStatusSet(0, ui8Power);
+}
+#endif
+
+//*****************************************************************************
+//
+//! Requests a remote wake up to resume communication when in suspended state.
+//!
+//! \param pvBulkDevice is the pointer to the bulk device instance structure.
+//!
+//! When the bus is suspended, an application which supports remote wake up
+//! (advertised to the host via the configuration descriptor) may call this
+//! function to initiate remote wake up signaling to the host.  If the remote
+//! wake up feature has not been disabled by the host, this will cause the bus
+//! to resume operation within 20mS.  If the host has disabled remote wake up,
+//! \b false will be returned to indicate that the wake up request was not
+//! successful.
+//!
+//! \return Returns \b true if the remote wake up is not disabled and the
+//! signaling was started or \b false if remote wake up is disabled or if
+//! signaling is currently ongoing following a previous call to this function.
+//
+//*****************************************************************************
+bool
+USBDBulkRemoteWakeupRequest(void *pvBulkDevice)
+{
+    ASSERT(pvBulkDevice);
+
+    //
+    // Pass the request through to the lower layer.
+    //
+    return(USBDCDRemoteWakeupRequest(0));
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
diff --git a/bsp/tm4c129x/libraries/usblib/device/usbdbulk.h b/bsp/tm4c129x/libraries/usblib/device/usbdbulk.h
new file mode 100755
index 0000000..b0a53d1
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/device/usbdbulk.h
@@ -0,0 +1,300 @@
+//*****************************************************************************
+//
+// usbdcdc.h - USBLib support for a generic bulk device.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#ifndef __USBDBULK_H__
+#define __USBDBULK_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+//*****************************************************************************
+//
+//! \addtogroup bulk_device_class_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// PRIVATE
+//
+// The first few sections of this header are private defines that are used by
+// the USB Bulk example code and are here only to help with the application
+// allocating the correct amount of memory for the Bulk example device code.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// PRIVATE
+//
+// This enumeration holds the various states that the device can be in during
+// normal operation.
+//
+//*****************************************************************************
+typedef enum
+{
+    //
+    // Not configured.
+    //
+    eBulkStateUnconfigured,
+
+    //
+    // No outstanding transaction remains to be completed.
+    //
+    eBulkStateIdle,
+
+    //
+    // Waiting on completion of a send or receive transaction.
+    //
+    eBulkStateWaitData,
+
+    //
+    // Waiting for client to process data.
+    //
+    eBulkStateWaitClient
+}
+tBulkState;
+
+//*****************************************************************************
+//
+// PRIVATE
+//
+// This structure defines the private instance data and state variables for the
+// Bulk only example device.  The memory for this structure is inlcluded in
+// the sPrivateData field in the tUSBDBulkDevice structure passed on
+// USBDBulkInit().
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    // Base address for the USB controller.
+    //
+    uint32_t ui32USBBase;
+
+    //
+    // The device info to interact with the lower level DCD code.
+    //
+    tDeviceInfo sDevInfo;
+
+    //
+    // The state of the bulk receive channel.
+    //
+    volatile tBulkState iBulkRxState;
+
+    //
+    // The state of the bulk transmit channel.
+    //
+    volatile tBulkState iBulkTxState;
+
+    //
+    // State of any pending operations that could not be handled immediately
+    // upon receipt.
+    //
+    volatile uint16_t ui16DeferredOpFlags;
+
+    //
+    // Size of the last transmit.
+    //
+    uint16_t ui16LastTxSize;
+
+    //
+    // The connection status of the device.
+    //
+    volatile bool bConnected;
+
+    //
+    // The IN endpoint number, this is modified in composite devices.
+    //
+    uint8_t ui8INEndpoint;
+
+    //
+    // The OUT endpoint number, this is modified in composite devices.
+    //
+    uint8_t ui8OUTEndpoint;
+
+    //
+    // The bulk class interface number, this is modified in composite devices.
+    //
+    uint8_t ui8Interface;
+}
+tBulkInstance;
+
+//*****************************************************************************
+//
+// This is the size of the g_pui8BulkInterface array in bytes.
+//
+//*****************************************************************************
+#define BULKINTERFACE_SIZE      (23)
+
+//*****************************************************************************
+//
+//! The size of the memory that should be allocated to create a configuration
+//! descriptor for a single instance of the USB Bulk Device.
+//! This does not include the configuration descriptor which is automatically
+//! ignored by the composite device class.
+//
+//*****************************************************************************
+#define COMPOSITE_DBULK_SIZE    (BULKINTERFACE_SIZE)
+
+//*****************************************************************************
+//
+//! The structure used by the application to define operating parameters for
+//! the bulk device.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The vendor ID that this device is to present in the device descriptor.
+    //
+    const uint16_t ui16VID;
+
+    //
+    //! The product ID that this device is to present in the device descriptor.
+    //
+    const uint16_t ui16PID;
+
+    //
+    //! The maximum power consumption of the device, expressed in milliamps.
+    //
+    const uint16_t ui16MaxPowermA;
+
+    //
+    //! Indicates whether the device is self- or bus-powered and whether or not
+    //! it supports remote wakeup.  Valid values are USB_CONF_ATTR_SELF_PWR or
+    //! USB_CONF_ATTR_BUS_PWR, optionally ORed with USB_CONF_ATTR_RWAKE.
+    //
+    const uint8_t ui8PwrAttributes;
+
+    //
+    //! A pointer to the callback function which will be called to notify
+    //! the application of events related to the device's data receive channel.
+    //
+    const tUSBCallback pfnRxCallback;
+
+    //
+    //! A client-supplied pointer which will be sent as the first
+    //! parameter in all calls made to the receive channel callback,
+    //! pfnRxCallback.
+    //
+    void *pvRxCBData;
+
+    //
+    //! A pointer to the callback function which will be called to notify
+    //! the application of events related to the device's data transmit
+    //! channel.
+    //
+    const tUSBCallback pfnTxCallback;
+
+    //
+    //! A client-supplied pointer which will be sent as the first
+    //! parameter in all calls made to the transmit channel callback,
+    //! pfnTxCallback.
+    //
+    void *pvTxCBData;
+
+    //
+    //! A pointer to the string descriptor array for this device.  This array
+    //! must contain pointers to the following string descriptors in this
+    //! order.  Language descriptor, Manufacturer name string (language 1),
+    //! Product name string (language 1), Serial number string (language 1),
+    //! Interface description string (language 1) and Configuration description
+    //! string (language 1).
+    //!
+    //! If supporting more than 1 language, the strings for indices 1 through 5
+    //! must be repeated for each of the other languages defined in the
+    //! language descriptor.
+    //
+    const uint8_t * const *ppui8StringDescriptors;
+
+    //
+    //! The number of descriptors provided in the ppStringDescriptors array.
+    //! This must be 1 + (5 * number of supported languages).
+    //
+    const uint32_t ui32NumStringDescriptors;
+
+    //
+    //! The private instance data for this device.  This memory must
+    //! not be modified by any code outside the bulk class driver.
+    //
+    tBulkInstance sPrivateData;
+}
+tUSBDBulkDevice;
+
+//*****************************************************************************
+//
+// API Function Prototypes
+//
+//*****************************************************************************
+extern void *USBDBulkInit(uint32_t ui32Index, tUSBDBulkDevice *psBulkDevice);
+extern void *USBDBulkCompositeInit(uint32_t ui32Index,
+                                   tUSBDBulkDevice *psBulkDevice,
+                                   tCompositeEntry *psCompEntry);
+extern void USBDBulkTerm(void *pvBulkInstance);
+extern void *USBDBulkSetRxCBData(void *pvBulkInstance, void *pvCBData);
+extern void *USBDBulkSetTxCBData(void *pvBulkInstance, void *pvCBData);
+extern uint32_t USBDBulkPacketWrite(void *pvBulkInstance, uint8_t *pi8Data,
+                                    uint32_t ui32Length, bool bLast);
+extern uint32_t USBDBulkPacketRead(void *pvBulkInstance, uint8_t *pi8Data,
+                                   uint32_t ui32Length, bool bLast);
+extern uint32_t USBDBulkTxPacketAvailable(void *pvBulkInstance);
+extern uint32_t USBDBulkRxPacketAvailable(void *pvBulkInstance);
+extern bool USBDBulkRemoteWakeupRequest(void *pvBulkInstance);
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// The following APIs are deprecated.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+extern void USBDBulkPowerStatusSet(void *pvBulkInstance, uint8_t ui8Power);
+#endif
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __USBDBULK_H__
diff --git a/bsp/tm4c129x/libraries/usblib/device/usbdcdc.c b/bsp/tm4c129x/libraries/usblib/device/usbdcdc.c
new file mode 100755
index 0000000..1cd0042
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/device/usbdcdc.c
@@ -0,0 +1,3043 @@
+//*****************************************************************************
+//
+// usbdcdc.c - USB CDC ACM (serial) device class driver.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "inc/hw_memmap.h"
+#include "inc/hw_types.h"
+#include "driverlib/debug.h"
+#include "driverlib/rom.h"
+#include "driverlib/rom_map.h"
+#include "driverlib/usb.h"
+#include "usblib/usblib.h"
+#include "usblib/usbcdc.h"
+#include "usblib/usblibpriv.h"
+#include "usblib/device/usbdevice.h"
+#include "usblib/device/usbdcomp.h"
+#include "usblib/device/usbdcdc.h"
+
+//*****************************************************************************
+//
+//! \addtogroup cdc_device_class_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Some assumptions and deviations from the CDC specification
+// ----------------------------------------------------------
+//
+// 1.  Although the CDC specification indicates that the following requests
+// should be supported by ACM CDC devices, these don't seem relevant to a
+// virtual COM port implementation and are never seen when connecting to a
+// Windows host and running either Hyperterminal or TeraTerm.  As a result,
+// this implementation does not support them and stalls endpoint 0 if they are
+// received.
+//          - SEND_ENCAPSULATED_COMMAND
+//          - GET_ENCAPSULATED_RESPONSE
+//          - SET_COMM_FEATURE
+//          - GET_COMM_FEATURE
+//          - CLEAR_COMM_FEATURE
+//
+// 2.  The CDC specification is very clear on the fact that an ACM device
+// should offer two interfaces - a control interface offering an interrupt IN
+// endpoint and a data interface offering bulk IN and OUT endpoints.  Using
+// this descriptor configuration, however, Windows insists on enumerating the
+// device as two separate entities resulting in two virtual COM ports or one
+// COM port and an Unknown Device (depending upon INF contents) appearing
+// in Device Manager.  This implementation, derived by experimentation and
+// examination of other virtual COM and CDC solutions, uses only a single
+// interface combining all three endpoints.  This appears to satisfy
+// Windows2000, XP and Vista and operates as intended using the Hyperterminal
+// and TeraTerm terminal emulators.  Your mileage may vary with other
+// (untested) operating systems!
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// The subset of endpoint status flags that we consider to be reception
+// errors.  These are passed to the client via USB_EVENT_ERROR if seen.
+//
+//*****************************************************************************
+#define USB_RX_ERROR_FLAGS      (USBERR_DEV_RX_DATA_ERROR | \
+                                 USBERR_DEV_RX_OVERRUN |    \
+                                 USBERR_DEV_RX_FIFO_FULL)
+
+//*****************************************************************************
+//
+// Size of the buffer to hold request-specific data read from the host.  This
+// must be sized to accommodate the largest request structure that we intend
+// processing.
+//
+//*****************************************************************************
+#define MAX_REQUEST_DATA_SIZE   sizeof(tLineCoding)
+
+//*****************************************************************************
+//
+// Flags that may appear in ui16DeferredOpFlags to indicate some operation that
+// has been requested but could not be processed at the time it was received.
+//
+//*****************************************************************************
+#define CDC_DO_SERIAL_STATE_CHANGE                                            \
+                                0
+#define CDC_DO_SEND_BREAK       1
+#define CDC_DO_CLEAR_BREAK      2
+#define CDC_DO_LINE_CODING_CHANGE                                             \
+                                3
+#define CDC_DO_LINE_STATE_CHANGE                                              \
+                                4
+#define CDC_DO_PACKET_RX        5
+
+//*****************************************************************************
+//
+// The subset of deferred operations which result in the receive channel
+// being blocked.
+//
+//*****************************************************************************
+#define RX_BLOCK_OPS            ((1 << CDC_DO_SEND_BREAK) |                   \
+                                 (1 << CDC_DO_LINE_CODING_CHANGE) |           \
+                                 (1 << CDC_DO_LINE_STATE_CHANGE))
+
+//*****************************************************************************
+//
+// Endpoints to use for each of the required endpoints in the driver.
+//
+//*****************************************************************************
+#define CONTROL_ENDPOINT        USB_EP_1
+#define DATA_IN_ENDPOINT        USB_EP_2
+#define DATA_OUT_ENDPOINT       USB_EP_1
+
+//*****************************************************************************
+//
+// The following are the USB interface numbers for the CDC serial device.
+//
+//*****************************************************************************
+#define SERIAL_INTERFACE_CONTROL                                              \
+                                0
+#define SERIAL_INTERFACE_DATA   1
+
+//*****************************************************************************
+//
+// Maximum packet size for the bulk endpoints used for serial data
+// transmission and reception and the associated FIFO sizes to set aside
+// for each endpoint.
+//
+//*****************************************************************************
+#define DATA_IN_EP_FIFO_SIZE    USB_FIFO_SZ_64
+#define DATA_OUT_EP_FIFO_SIZE   USB_FIFO_SZ_64
+#define CTL_IN_EP_FIFO_SIZE     USB_FIFO_SZ_16
+
+#define DATA_IN_EP_MAX_SIZE     USBFIFOSizeToBytes(DATA_IN_EP_FIFO_SIZE)
+#define DATA_OUT_EP_MAX_SIZE    USBFIFOSizeToBytes(DATA_IN_EP_FIFO_SIZE)
+#define CTL_IN_EP_MAX_SIZE      USBFIFOSizeToBytes(CTL_IN_EP_FIFO_SIZE)
+
+//*****************************************************************************
+//
+// The collection of serial state flags indicating character errors.
+//
+//*****************************************************************************
+#define USB_CDC_SERIAL_ERRORS   (USB_CDC_SERIAL_STATE_OVERRUN |               \
+                                 USB_CDC_SERIAL_STATE_PARITY |                \
+                                 USB_CDC_SERIAL_STATE_FRAMING)
+
+//*****************************************************************************
+//
+// Device Descriptor.  This is stored in RAM to allow several fields to be
+// changed at runtime based on the client's requirements.
+//
+//*****************************************************************************
+uint8_t g_pui8CDCSerDeviceDescriptor[] =
+{
+    18,                             // Size of this structure.
+    USB_DTYPE_DEVICE,               // Type of this structure.
+    USBShort(0x110),                // USB version 1.1 (if we say 2.0, hosts
+                                    // assume high-speed - see USB 2.0 spec
+                                    // 9.2.6.6)
+    USB_CLASS_CDC,                  // USB Device Class (spec 5.1.1)
+    0,                              // USB Device Sub-class (spec 5.1.1)
+    USB_CDC_PROTOCOL_NONE,          // USB Device protocol (spec 5.1.1)
+    64,                             // Maximum packet size for default pipe.
+    USBShort(0),                    // Vendor ID (filled in during
+                                    // USBDCDCInit).
+    USBShort(0),                    // Product ID (filled in during
+                                    // USBDCDCInit).
+    USBShort(0x100),                // Device Version BCD.
+    1,                              // Manufacturer string identifier.
+    2,                              // Product string identifier.
+    3,                              // Product serial number.
+    1                               // Number of configurations.
+};
+
+//*****************************************************************************
+//
+// CDC Serial configuration descriptor.
+//
+// It is vital that the configuration descriptor bConfigurationValue field
+// (byte 6) is 1 for the first configuration and increments by 1 for each
+// additional configuration defined here.  This relationship is assumed in the
+// device stack for simplicity even though the USB 2.0 specification imposes
+// no such restriction on the bConfigurationValue values.
+//
+// Note that this structure is deliberately located in RAM since we need to
+// be able to patch some values in it based on client requirements.
+//
+//*****************************************************************************
+uint8_t g_pui8CDCSerDescriptor[] =
+{
+    //
+    // Configuration descriptor header.
+    //
+    9,                              // Size of the configuration descriptor.
+    USB_DTYPE_CONFIGURATION,        // Type of this descriptor.
+    USBShort(9),                    // The total size of this full structure,
+                                    // this will be patched so it is just set
+                                    // to the size of this structure.
+    2,                              // The number of interfaces in this
+                                    // configuration.
+    1,                              // The unique value for this configuration.
+    5,                              // The string identifier that describes
+                                    // this configuration.
+    USB_CONF_ATTR_SELF_PWR,         // Bus Powered, Self Powered, remote wake
+                                    // up.
+    250,                            // The maximum power in 2mA increments.
+};
+
+const tConfigSection g_sCDCSerConfigSection =
+{
+    sizeof(g_pui8CDCSerDescriptor),
+    g_pui8CDCSerDescriptor
+};
+
+//*****************************************************************************
+//
+// This is the Interface Association Descriptor for the serial device used in
+// composite devices.
+//
+//*****************************************************************************
+uint8_t g_pui8IADSerDescriptor[SERDESCRIPTOR_SIZE] =
+{
+
+    8,                              // Size of the interface descriptor.
+    USB_DTYPE_INTERFACE_ASC,        // Interface Association Type.
+    0x0,                            // Default starting interface is 0.
+    0x2,                            // Number of interfaces in this
+                                    // association.
+    USB_CLASS_CDC,                  // The device class for this association.
+    USB_CDC_SUBCLASS_ABSTRACT_MODEL,
+                                    // The device subclass for this
+                                    // association.
+    USB_CDC_PROTOCOL_V25TER,        // The protocol for this association.
+    0                               // The string index for this association.
+};
+
+const tConfigSection g_sIADSerConfigSection =
+{
+    sizeof(g_pui8IADSerDescriptor),
+    g_pui8IADSerDescriptor
+};
+
+//*****************************************************************************
+//
+// This is the control interface for the serial device.
+//
+//*****************************************************************************
+const uint8_t g_pui8CDCSerCommInterface[SERCOMMINTERFACE_SIZE] =
+{
+    //
+    // Communication Class Interface Descriptor.
+    //
+    9,                              // Size of the interface descriptor.
+    USB_DTYPE_INTERFACE,            // Type of this descriptor.
+    SERIAL_INTERFACE_CONTROL,       // The index for this interface.
+    0,                              // The alternate setting for this
+                                    // interface.
+    1,                              // The number of endpoints used by this
+                                    // interface.
+    USB_CLASS_CDC,                  // The interface class constant defined by
+                                    // USB-IF (spec 5.1.3).
+    USB_CDC_SUBCLASS_ABSTRACT_MODEL,
+                                    // The interface sub-class constant
+                                    // defined by USB-IF (spec 5.1.3).
+    USB_CDC_PROTOCOL_V25TER,        // The interface protocol for the sub-class
+                                    // specified above.
+    4,                              // The string index for this interface.
+
+    //
+    // Communication Class Interface Functional Descriptor - Header
+    //
+    5,                              // Size of the functional descriptor.
+    USB_CDC_CS_INTERFACE,           // CDC interface descriptor
+    USB_CDC_FD_SUBTYPE_HEADER,      // Header functional descriptor
+    USBShort(0x110),                // Complies with CDC version 1.1
+
+    //
+    // Communication Class Interface Functional Descriptor - ACM
+    //
+    4,                              // Size of the functional descriptor.
+    USB_CDC_CS_INTERFACE,           // CDC interface descriptor
+    USB_CDC_FD_SUBTYPE_ABSTRACT_CTL_MGMT,
+    USB_CDC_ACM_SUPPORTS_LINE_PARAMS | USB_CDC_ACM_SUPPORTS_SEND_BREAK,
+
+    //
+    // Communication Class Interface Functional Descriptor - Unions
+    //
+    5,                              // Size of the functional descriptor.
+    USB_CDC_CS_INTERFACE,           // CDC interface descriptor
+    USB_CDC_FD_SUBTYPE_UNION,
+    SERIAL_INTERFACE_CONTROL,
+    SERIAL_INTERFACE_DATA,          // Data interface number
+
+    //
+    // Communication Class Interface Functional Descriptor - Call Management
+    //
+    5,                              // Size of the functional descriptor.
+    USB_CDC_CS_INTERFACE,           // CDC interface descriptor
+    USB_CDC_FD_SUBTYPE_CALL_MGMT,
+    USB_CDC_CALL_MGMT_HANDLED,
+    SERIAL_INTERFACE_DATA,          // Data interface number
+
+    //
+    // Endpoint Descriptor (interrupt, IN)
+    //
+    7,                              // The size of the endpoint descriptor.
+    USB_DTYPE_ENDPOINT,             // Descriptor type is an endpoint.
+    USB_EP_DESC_IN | USBEPToIndex(CONTROL_ENDPOINT),
+    USB_EP_ATTR_INT,                // Endpoint is an interrupt endpoint.
+    USBShort(CTL_IN_EP_MAX_SIZE),   // The maximum packet size.
+    1                               // The polling interval for this endpoint.
+};
+
+const tConfigSection g_sCDCSerCommInterfaceSection =
+{
+    sizeof(g_pui8CDCSerCommInterface),
+    g_pui8CDCSerCommInterface
+};
+
+//*****************************************************************************
+//
+// This is the Data interface for the serial device.
+//
+//*****************************************************************************
+const uint8_t g_pui8CDCSerDataInterface[SERDATAINTERFACE_SIZE] =
+{
+    //
+    // Communication Class Data Interface Descriptor.
+    //
+    9,                              // Size of the interface descriptor.
+    USB_DTYPE_INTERFACE,            // Type of this descriptor.
+    SERIAL_INTERFACE_DATA,          // The index for this interface.
+    0,                              // The alternate setting for this
+                                    // interface.
+    2,                              // The number of endpoints used by this
+                                    // interface.
+    USB_CLASS_CDC_DATA,             // The interface class constant defined by
+                                    // USB-IF (spec 5.1.3).
+    0,                              // The interface sub-class constant
+                                    // defined by USB-IF (spec 5.1.3).
+    USB_CDC_PROTOCOL_NONE,          // The interface protocol for the sub-class
+                                    // specified above.
+    0,                              // The string index for this interface.
+
+    //
+    // Endpoint Descriptor
+    //
+    7,                              // The size of the endpoint descriptor.
+    USB_DTYPE_ENDPOINT,             // Descriptor type is an endpoint.
+    USB_EP_DESC_IN | USBEPToIndex(DATA_IN_ENDPOINT),
+    USB_EP_ATTR_BULK,               // Endpoint is a bulk endpoint.
+    USBShort(DATA_IN_EP_MAX_SIZE),  // The maximum packet size.
+    0,                              // The polling interval for this endpoint.
+
+    //
+    // Endpoint Descriptor
+    //
+    7,                              // The size of the endpoint descriptor.
+    USB_DTYPE_ENDPOINT,             // Descriptor type is an endpoint.
+    USB_EP_DESC_OUT | USBEPToIndex(DATA_OUT_ENDPOINT),
+    USB_EP_ATTR_BULK,               // Endpoint is a bulk endpoint.
+    USBShort(DATA_OUT_EP_MAX_SIZE), // The maximum packet size.
+    0,                              // The polling interval for this endpoint.
+};
+
+const tConfigSection g_sCDCSerDataInterfaceSection =
+{
+    sizeof(g_pui8CDCSerDataInterface),
+    g_pui8CDCSerDataInterface
+};
+
+//*****************************************************************************
+//
+// This array lists all the sections that must be concatenated to make a
+// single, complete CDC ACM configuration descriptor.
+//
+//*****************************************************************************
+const tConfigSection *g_psCDCSerSections[] =
+{
+    &g_sCDCSerConfigSection,
+    &g_sCDCSerCommInterfaceSection,
+    &g_sCDCSerDataInterfaceSection,
+};
+
+#define NUM_CDCSER_SECTIONS     (sizeof(g_psCDCSerSections) /                 \
+                                 sizeof(g_psCDCSerSections[0]))
+
+//*****************************************************************************
+//
+// The header for the single configuration.  This is the root of the data
+// structure that defines all the bits and pieces that are pulled together to
+// generate the configuration descriptor.
+//
+//*****************************************************************************
+const tConfigHeader g_sCDCSerConfigHeader =
+{
+    NUM_CDCSER_SECTIONS,
+    g_psCDCSerSections
+};
+
+//*****************************************************************************
+//
+// This array lists all the sections that must be concatenated to make a
+// single, complete CDC ACM configuration descriptor used in composite devices.
+// The only addition is the g_sIADSerConfigSection.
+//
+//*****************************************************************************
+const tConfigSection *g_psCDCCompSerSections[] =
+{
+    &g_sCDCSerConfigSection,
+    &g_sIADSerConfigSection,
+    &g_sCDCSerCommInterfaceSection,
+    &g_sCDCSerDataInterfaceSection,
+};
+
+#define NUM_COMP_CDCSER_SECTIONS (sizeof(g_psCDCCompSerSections) /            \
+                                  sizeof(g_psCDCCompSerSections[0]))
+
+//*****************************************************************************
+//
+// The header for the composite configuration.  This is the root of the data
+// structure that defines all the bits and pieces that are pulled together to
+// generate the configuration descriptor.
+//
+//*****************************************************************************
+const tConfigHeader g_sCDCCompSerConfigHeader =
+{
+    NUM_COMP_CDCSER_SECTIONS,
+    g_psCDCCompSerSections
+};
+
+//*****************************************************************************
+//
+// Configuration Descriptor for the CDC serial class device.
+//
+//*****************************************************************************
+const tConfigHeader * const g_ppCDCSerConfigDescriptors[] =
+{
+    &g_sCDCSerConfigHeader
+};
+
+//*****************************************************************************
+//
+// Configuration Descriptor for the CDC serial class device used in a composite
+// device.
+//
+//*****************************************************************************
+const tConfigHeader * const g_pCDCCompSerConfigDescriptors[] =
+{
+    &g_sCDCCompSerConfigHeader
+};
+
+//*****************************************************************************
+//
+// Forward references for device handler callbacks
+//
+//*****************************************************************************
+static void HandleRequests(void *pvCDCDevice, tUSBRequest *pUSBRequest);
+static void HandleConfigChange(void *pvCDCDevice, uint32_t ui32Info);
+static void HandleEP0Data(void *pvCDCDevice, uint32_t ui32DataSize);
+static void HandleDisconnect(void *pvCDCDevice);
+static void HandleEndpoints(void *pvCDCDevice, uint32_t ui32Status);
+static void HandleSuspend(void *pvCDCDevice);
+static void HandleResume(void *pvCDCDevice);
+static void HandleDevice(void *pvCDCDevice, uint32_t ui32Request,
+                         void *pvRequestData);
+
+//*****************************************************************************
+//
+// The device information structure for the USB serial device.
+//
+//*****************************************************************************
+const tCustomHandlers g_sCDCHandlers =
+{
+    //
+    // GetDescriptor
+    //
+    0,
+
+    //
+    // RequestHandler
+    //
+    HandleRequests,
+
+    //
+    // InterfaceChange
+    //
+    0,
+
+    //
+    // ConfigChange
+    //
+    HandleConfigChange,
+
+    //
+    // DataReceived
+    //
+    HandleEP0Data,
+
+    //
+    // DataSentCallback
+    //
+    0,
+
+    //
+    // ResetHandler
+    //
+    0,
+
+    //
+    // SuspendHandler
+    //
+    HandleSuspend,
+
+    //
+    // ResumeHandler
+    //
+    HandleResume,
+
+    //
+    // DisconnectHandler
+    //
+    HandleDisconnect,
+
+    //
+    // EndpointHandler
+    //
+    HandleEndpoints,
+
+    //
+    // Device handler.
+    //
+    HandleDevice
+};
+
+//*****************************************************************************
+//
+// Set or clear deferred operation flags in an "atomic" manner.
+//
+// \param pui16DeferredOp points to the flags variable which is to be modified.
+// \param ui16Bit indicates which bit number is to be set or cleared.
+// \param bSet indicates the state that the flag must be set to.  If \b true,
+// the flag is set, if \b false, the flag is cleared.
+//
+// This function safely sets or clears a bit in a flag variable.  The operation
+// makes use of bitbanding to ensure that the operation is atomic (no read-
+// modify-write is required).
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+SetDeferredOpFlag(volatile uint16_t *pui16DeferredOp, uint16_t ui16Bit,
+                  bool bSet)
+{
+    //
+    // Set the flag bit to 1 or 0 using a bitband access.
+    //
+    HWREGBITH(pui16DeferredOp, ui16Bit) = bSet ? 1 : 0;
+}
+
+//*****************************************************************************
+//
+// Determines whether or not a client has consumed all received data previously
+// passed to it.
+//
+//! \param psCDCDevice is the pointer to the device instance structure as returned
+//! by USBDCDCInit().
+//
+// This function is called to determine whether or not a device has consumed
+// all data previously passed to it via its receive callback.
+//
+// \return Returns \b true on success or \b false on failure.
+//
+//*****************************************************************************
+static bool
+DeviceConsumedAllData(const tUSBDCDCDevice *psCDCDevice)
+{
+    uint32_t ui32Remaining;
+
+    //
+    // Send the device an event requesting that it tell us how many bytes
+    // of data it still has to process.
+    //
+    ui32Remaining = psCDCDevice->pfnRxCallback(psCDCDevice->pvRxCBData,
+    USB_EVENT_DATA_REMAINING, 0, (void *)0);
+
+    //
+    // If any data remains to be processed, return false, else return true.
+    //
+    return(ui32Remaining ? false : true);
+}
+
+//*****************************************************************************
+//
+// Notifies the client that it should set or clear a break condition.
+//
+// \param psCDCDevice is the pointer to the device instance structure as returned
+// by USBDCDCInit().
+// \param bSend is \b true if a break condition is to be set or \b false if
+// it is to be cleared.
+//
+// This function is called to instruct the client to start or stop sending a
+// break condition on its serial transmit line.
+//
+// \return Returns \b true on success or \b false on failure.
+//
+//*****************************************************************************
+static void
+SendBreak(tUSBDCDCDevice *psCDCDevice, bool bSend)
+{
+    tCDCSerInstance *psInst;
+
+    //
+    // Get a pointer to the CDC device instance data pointer
+    //
+    psInst = &psCDCDevice->sPrivateData;
+
+    //
+    // Set the break state flags as necessary.  If we are turning the break on,
+    // set the flag to tell ourselves that we need to notify the client when
+    // it is time to turn it off again.
+    //
+    SetDeferredOpFlag(&psInst->ui16DeferredOpFlags, CDC_DO_SEND_BREAK, false);
+    SetDeferredOpFlag(&psInst->ui16DeferredOpFlags, CDC_DO_CLEAR_BREAK, bSend);
+
+    //
+    // Tell the client to start or stop sending the break.
+    //
+    psCDCDevice->pfnControlCallback(psCDCDevice->pvControlCBData,
+                                 (bSend ? USBD_CDC_EVENT_SEND_BREAK :
+                                          USBD_CDC_EVENT_CLEAR_BREAK), 0,
+                                 (void *)0);
+}
+
+//*****************************************************************************
+//
+// Notifies the client of a host request to set the serial communication
+// parameters.
+//
+// \param psCDCDevice is the device instance whose communication parameters are to
+// be set.
+//
+// This function is called to notify the client when the host requests a change
+// in the serial communication parameters (baud rate, parity, number of bits
+// per character and number of stop bits) to use.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+SendLineCodingChange(tUSBDCDCDevice *psCDCDevice)
+{
+    tCDCSerInstance *psInst;
+
+    //
+    // Get a pointer to the CDC device instance data pointer
+    //
+    psInst = &psCDCDevice->sPrivateData;
+
+    //
+    // Clear the flag we use to tell ourselves that the line coding change has
+    // yet to be notified to the client.
+    //
+    SetDeferredOpFlag(&psInst->ui16DeferredOpFlags, CDC_DO_LINE_CODING_CHANGE,
+                      false);
+
+    //
+    // Tell the client to update their serial line coding parameters.
+    //
+    psCDCDevice->pfnControlCallback(psCDCDevice->pvControlCBData,
+                                 USBD_CDC_EVENT_SET_LINE_CODING, 0,
+                                 &(psInst->sLineCoding));
+}
+
+//*****************************************************************************
+//
+// Notifies the client of a host request to set the RTS and DTR handshake line
+// states.
+//
+// \param psCDCDevice is the device instance whose break condition is to be set or
+// cleared.
+//
+// This function is called to notify the client when the host requests a change
+// in the state of one or other of the RTS and DTR handshake lines.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+SendLineStateChange(tUSBDCDCDevice *psCDCDevice)
+{
+    tCDCSerInstance *psInst;
+
+    //
+    // Get a pointer to the CDC device instance data pointer
+    //
+    psInst = &psCDCDevice->sPrivateData;
+
+    //
+    // Clear the flag we use to tell ourselves that the line coding change has
+    // yet to be notified to the client.
+    //
+    SetDeferredOpFlag(&psInst->ui16DeferredOpFlags, CDC_DO_LINE_STATE_CHANGE,
+                      false);
+
+    //
+    // Tell the client to update their serial line coding parameters.
+    //
+    psCDCDevice->pfnControlCallback(psCDCDevice->pvControlCBData,
+                                 USBD_CDC_EVENT_SET_CONTROL_LINE_STATE,
+                                 psInst->ui16ControlLineState,
+                                 (void *)0);
+}
+
+//*****************************************************************************
+//
+// Notifies the client of a break request if no data remains to be processed.
+//
+// \param psCDCDevice is the device instance that is to be commanded to send a
+// break condition.
+//
+// This function is called when the host requests that the device set a break
+// condition on the serial transmit line.  If no data received from the host
+// remains to be processed, the break request is passed to the control
+// callback.  If data is outstanding, the call is ignored (with the operation
+// being retried on the next timer tick).
+//
+// \return Returns \b true if the break notification was sent, \b false
+// otherwise.
+//
+//*****************************************************************************
+static bool
+CheckAndSendBreak(tUSBDCDCDevice *psCDCDevice, uint16_t ui16Duration)
+{
+    bool bCanSend;
+
+    //
+    // Has the client consumed all data received from the host yet?
+    //
+    bCanSend = DeviceConsumedAllData(psCDCDevice);
+
+    //
+    // Can we send the break request?
+    //
+    if(bCanSend)
+    {
+        //
+        // Pass the break request on to the client since no data remains to be
+        // consumed.
+        //
+        SendBreak(psCDCDevice, (ui16Duration ? true : false));
+    }
+
+    //
+    // Tell the caller whether or not we sent the notification.
+    //
+    return(bCanSend);
+}
+
+//*****************************************************************************
+//
+// Notifies the client of a request to change the serial line parameters if no
+// data remains to be processed.
+//
+// \param psCDCDevice is the device instance whose line coding parameters are to
+// be changed.
+//
+// This function is called when the host requests that the device change the
+// serial line coding parameters.  If no data received from the host remains
+// to be processed, the request is passed to the control callback.  If data is
+// outstanding, the call is ignored (with the operation being retried on the
+// next timer tick).
+//
+// \return Returns \b true if the notification was sent, \b false otherwise.
+//
+//*****************************************************************************
+static bool
+CheckAndSendLineCodingChange(tUSBDCDCDevice *psCDCDevice)
+{
+    bool bCanSend;
+
+    //
+    // Has the client consumed all data received from the host yet?
+    //
+    bCanSend = DeviceConsumedAllData(psCDCDevice);
+
+    //
+    // Can we send the break request?
+    //
+    if(bCanSend)
+    {
+        //
+        // Pass the request on to the client since no data remains to be
+        // consumed.
+        //
+        SendLineCodingChange(psCDCDevice);
+    }
+
+    //
+    // Tell the caller whether or not we sent the notification.
+    //
+    return(bCanSend);
+}
+
+//*****************************************************************************
+//
+// Notifies the client of a request to change the handshake line states if no
+// data remains to be processed.
+//
+// \param psCDCDevice is the device instance whose handshake line states are to
+// be changed.
+//
+// This function is called when the host requests that the device change the
+// state of one or other of the RTS or DTR handshake lines.  If no data
+// received from the host remains to be processed, the request is passed to
+// the control callback.  If data is outstanding, the call is ignored (with
+// the operation being retried on the next timer tick).
+//
+// \return Returns \b true if the notification was sent, \b false otherwise.
+//
+//*****************************************************************************
+static bool
+CheckAndSendLineStateChange(tUSBDCDCDevice *psCDCDevice)
+{
+    bool bCanSend;
+
+    //
+    // Has the client consumed all data received from the host yet?
+    //
+    bCanSend = DeviceConsumedAllData(psCDCDevice);
+
+    //
+    // Can we send the break request?
+    //
+    if(bCanSend)
+    {
+        //
+        // Pass the request on to the client since no data remains to be
+        // consumed.
+        //
+        SendLineStateChange(psCDCDevice);
+    }
+
+    //
+    // Tell the caller whether or not we sent the notification.
+    //
+    return(bCanSend);
+}
+
+//*****************************************************************************
+//
+// Notifies the client of a change in the serial line state.
+//
+// \param psInst is the instance whose serial state is to be reported.
+//
+// This function is called to send the current serial state information to
+// the host via the the interrupt IN endpoint.  This notification informs the
+// host of problems or conditions such as parity errors, breaks received,
+// framing errors, etc.
+//
+// \return Returns \b true on success or \b false on failure.
+//
+//*****************************************************************************
+static bool
+SendSerialState(tUSBDCDCDevice *psCDCDevice)
+{
+    tUSBRequest sRequest;
+    uint16_t ui16SerialState;
+    tCDCSerInstance *psInst;
+    int32_t i32Retcode;
+
+    //
+    // Get a pointer to the CDC device instance data pointer
+    //
+    psInst = &psCDCDevice->sPrivateData;
+
+    //
+    // Remember that we are in the middle of sending a notification.
+    //
+    psInst->iCDCInterruptState = eCDCStateWaitData;
+
+    //
+    // Clear the flag we use to indicate that a send is required.
+    //
+    SetDeferredOpFlag(&psInst->ui16DeferredOpFlags, CDC_DO_SERIAL_STATE_CHANGE,
+                      false);
+    //
+    // Take a snapshot of the serial state.
+    //
+    ui16SerialState = psInst->ui16SerialState;
+
+    //
+    // Build the request we will use to send the notification.
+    //
+    sRequest.bmRequestType = (USB_RTYPE_DIR_IN | USB_RTYPE_CLASS |
+                                USB_RTYPE_INTERFACE);
+    sRequest.bRequest = USB_CDC_NOTIFY_SERIAL_STATE;
+    sRequest.wValue = 0;
+    sRequest.wIndex = 0;
+    sRequest.wLength = USB_CDC_NOTIFY_SERIAL_STATE_SIZE;
+
+    //
+    // Write the request structure to the USB FIFO.
+    //
+    i32Retcode = MAP_USBEndpointDataPut(psInst->ui32USBBase,
+                                        psInst->ui8ControlEndpoint,
+                                        (uint8_t *)&sRequest,
+                                        sizeof(tUSBRequest));
+    i32Retcode = MAP_USBEndpointDataPut(psInst->ui32USBBase,
+                                        psInst->ui8ControlEndpoint,
+                                        (uint8_t *)&ui16SerialState,
+                                        USB_CDC_NOTIFY_SERIAL_STATE_SIZE);
+
+    //
+    // Did we correctly write the data to the endpoint FIFO?
+    //
+    if(i32Retcode != -1)
+    {
+        //
+        // We put the data into the FIFO so now schedule it to be
+        // sent.
+        //
+        i32Retcode = MAP_USBEndpointDataSend(psInst->ui32USBBase,
+                                             psInst->ui8ControlEndpoint,
+                                             USB_TRANS_IN);
+    }
+
+    //
+    // If an error occurred, mark the endpoint as idle (to prevent possible
+    // lockup) and return an error.
+    //
+    if(i32Retcode == -1)
+    {
+        psInst->iCDCInterruptState = eCDCStateIdle;
+        return(false);
+    }
+    else
+    {
+        //
+        // Everything went fine.  Clear the error bits that we just notified
+        // and return true.
+        //
+        psInst->ui16SerialState &= ~(ui16SerialState & USB_CDC_SERIAL_ERRORS);
+        return(true);
+    }
+}
+
+//*****************************************************************************
+//
+// Receives notifications related to data received from the host.
+//
+// \param psCDCDevice is the device instance whose endpoint is to be processed.
+// \param ui32Status is the USB interrupt status that caused this function to
+// be called.
+//
+// This function is called from HandleEndpoints for all interrupts signaling
+// the arrival of data on the bulk OUT endpoint (in other words, whenever the
+// host has sent us a packet of data).  We inform the client that a packet
+// is available and, on return, check to see if the packet has been read.  If
+// not, we schedule another notification to the client for a later time.
+//
+// \return Returns \b true on success or \b false on failure.
+//
+//*****************************************************************************
+bool
+ProcessDataFromHost(tUSBDCDCDevice *psCDCDevice, uint32_t ui32Status)
+{
+    uint32_t ui32EPStatus, ui32Size;
+    tCDCSerInstance *psInst;
+
+    //
+    // Get a pointer to the CDC device instance data pointer
+    //
+    psInst = &psCDCDevice->sPrivateData;
+
+    //
+    // Get the endpoint status to see why we were called.
+    //
+    ui32EPStatus = MAP_USBEndpointStatus(psInst->ui32USBBase,
+                                         psInst->ui8BulkOUTEndpoint);
+
+    //
+    // Clear the status bits.
+    //
+    MAP_USBDevEndpointStatusClear(psInst->ui32USBBase,
+                                  psInst->ui8BulkOUTEndpoint,
+                                  ui32EPStatus);
+
+    //
+    // Has a packet been received?
+    //
+    if(ui32EPStatus & USB_DEV_RX_PKT_RDY)
+    {
+        //
+        // Set the flag we use to indicate that a packet read is pending.  This
+        // will be cleared if the packet is read.  If the client doesn't read
+        // the packet in the context of the USB_EVENT_RX_AVAILABLE callback,
+        // the event will be notified later during tick processing.
+        //
+        SetDeferredOpFlag(&psInst->ui16DeferredOpFlags, CDC_DO_PACKET_RX,
+                          true);
+
+        //
+        // Is the receive channel currently blocked?
+        //
+        if(!psInst->bControlBlocked && !psInst->bRxBlocked)
+        {
+            //
+            // How big is the packet we have just been received?
+            //
+            ui32Size = MAP_USBEndpointDataAvail(psInst->ui32USBBase,
+                                                psInst->ui8BulkOUTEndpoint);
+
+            //
+            // The receive channel is not blocked so let the caller know
+            // that a packet is waiting.  The parameters are set to indicate
+            // that the packet has not been read from the hardware FIFO yet.
+            //
+            psCDCDevice->pfnRxCallback(psCDCDevice->pvRxCBData,
+                                    USB_EVENT_RX_AVAILABLE, ui32Size,
+                                    (void *)0);
+        }
+    }
+    else
+    {
+        //
+        // No packet was received.  Some error must have been reported.  Check
+        // and pass this on to the client if necessary.
+        //
+        if(ui32EPStatus & USB_RX_ERROR_FLAGS)
+        {
+            //
+            // This is an error we report to the client so...
+            //
+            psCDCDevice->pfnRxCallback(psCDCDevice->pvRxCBData, USB_EVENT_ERROR,
+                                    (ui32EPStatus & USB_RX_ERROR_FLAGS),
+                                    (void *)0);
+        }
+
+        return(false);
+    }
+
+    return(true);
+}
+
+//*****************************************************************************
+//
+// Receives notifications related to interrupt messages sent to the host.
+//
+// \param psCDCDevice is the device instance whose endpoint is to be processed.
+// \param ui32Status is the USB interrupt status that caused this function to
+// be called.
+//
+// This function is called from HandleEndpoints for all interrupts originating
+// from the interrupt IN endpoint (in other words, whenever a notification has
+// been transmitted to the USB host).
+//
+// \return Returns \b true on success or \b false on failure.
+//
+//*****************************************************************************
+bool
+ProcessNotificationToHost(tUSBDCDCDevice *psCDCDevice, uint32_t ui32Status)
+{
+    uint32_t ui32EPStatus;
+    tCDCSerInstance *psInst;
+    bool bRetcode;
+
+    //
+    // Assume all will go well until we have reason to believe otherwise.
+    //
+    bRetcode = true;
+
+    //
+    // Get a pointer to the CDC device instance data pointer
+    //
+    psInst = &psCDCDevice->sPrivateData;
+
+    //
+    // Get the endpoint status to see why we were called.
+    //
+    ui32EPStatus = MAP_USBEndpointStatus(psInst->ui32USBBase,
+                                         psInst->ui8ControlEndpoint);
+
+    //
+    // Clear the status bits.
+    //
+    MAP_USBDevEndpointStatusClear(psInst->ui32USBBase,
+                                  psInst->ui8ControlEndpoint, ui32EPStatus);
+
+    //
+    // Did the state change while we were waiting for the previous notification
+    // to complete?
+    //
+    if(psInst->ui16DeferredOpFlags & (1 << CDC_DO_SERIAL_STATE_CHANGE))
+    {
+        //
+        // The state changed while we were waiting so we need to schedule
+        // another notification immediately.
+        //
+        bRetcode = SendSerialState(psCDCDevice);
+    }
+    else
+    {
+        //
+        // Our last notification completed and we did not have any new
+        // notifications to make so the interrupt channel is now idle again.
+        //
+        psInst->iCDCInterruptState = eCDCStateIdle;
+    }
+
+    //
+    // Tell the caller how things went.
+    //
+    return(bRetcode);
+}
+
+//*****************************************************************************
+//
+// Receives notifications related to data sent to the host.
+//
+// \param psCDCDevice is the device instance whose endpoint is to be processed.
+// \param ui32Status is the USB interrupt status that caused this function to
+// be called.
+//
+// This function is called from HandleEndpoints for all interrupts originating
+// from the bulk IN endpoint (in other words, whenever data has been
+// transmitted to the USB host).  We examine the cause of the interrupt and,
+// if due to completion of a transmission, notify the client.
+//
+// \return Returns \b true on success or \b false on failure.
+//
+//*****************************************************************************
+bool
+ProcessDataToHost(tUSBDCDCDevice *psCDCDevice, uint32_t ui32Status)
+{
+    tCDCSerInstance *psInst;
+    uint32_t ui32EPStatus, ui32Size;
+    bool bSentFullPacket;
+
+    //
+    // Get a pointer to the CDC device instance data pointer
+    //
+    psInst = &psCDCDevice->sPrivateData;
+
+    //
+    // Get the endpoint status to see why we were called.
+    //
+    ui32EPStatus = MAP_USBEndpointStatus(psInst->ui32USBBase,
+                                         psInst->ui8BulkINEndpoint);
+
+    //
+    // Clear the status bits.
+    //
+    MAP_USBDevEndpointStatusClear(psInst->ui32USBBase,
+                                  psInst->ui8BulkINEndpoint, ui32EPStatus);
+
+    //
+    // Our last transmission completed.  Clear our state back to idle and
+    // see if we need to send any more data.
+    //
+    psInst->iCDCTxState = eCDCStateIdle;
+
+    //
+    // If this notification is not as a result of sending a zero-length packet,
+    // call back to the client to let it know we sent the last thing it passed
+    // us.
+    //
+    if(psInst->ui16LastTxSize)
+    {
+        //
+        // Have we just sent a 64 byte packet?
+        //
+        bSentFullPacket = (psInst->ui16LastTxSize == DATA_IN_EP_MAX_SIZE) ?
+                           true : false;
+
+        //
+        // Notify the client that the last transmission completed.
+        //
+        ui32Size = (uint32_t)psInst->ui16LastTxSize;
+        psInst->ui16LastTxSize = 0;
+        psCDCDevice->pfnTxCallback(psCDCDevice->pvTxCBData, USB_EVENT_TX_COMPLETE,
+                                ui32Size, (void *)0);
+
+        //
+        // If we had previously sent a full packet and the callback didn't
+        // schedule a new transmission, send a zero length packet to indicate
+        // the end of the transfer.
+        //
+        if(bSentFullPacket && !psInst->ui16LastTxSize)
+        {
+            //
+            // We can expect another transmit complete notification after doing
+            // this.
+            //
+            psInst->iCDCTxState = eCDCStateWaitData;
+
+            //
+            // Send the zero-length packet.
+            //
+            MAP_USBEndpointDataSend(psInst->ui32USBBase,
+                                    psInst->ui8BulkINEndpoint,
+                                    USB_TRANS_IN);
+        }
+    }
+
+    return(true);
+}
+
+//*****************************************************************************
+//
+// Called by the USB stack for any activity involving one of our endpoints
+// other than EP0.  This function is a fan out that merely directs the call to
+// the correct handler depending upon the endpoint and transaction direction
+// signaled in ui32Status.
+//
+//*****************************************************************************
+static void
+HandleEndpoints(void *pvCDCDevice, uint32_t ui32Status)
+{
+    tUSBDCDCDevice *psCDCDeviceInst;
+    tCDCSerInstance *psInst;
+
+    ASSERT(pvCDCDevice != 0);
+
+    //
+    // Determine if the serial device is in single or composite mode because
+    // the meaning of ui32Index is different in both cases.
+    //
+    psCDCDeviceInst = pvCDCDevice;
+    psInst = &psCDCDeviceInst->sPrivateData;
+
+    //
+    // Handler for the interrupt IN notification endpoint.
+    //
+    if(ui32Status & (1 << USBEPToIndex(psInst->ui8ControlEndpoint)))
+    {
+        //
+        // We have sent an interrupt notification to the host.
+        //
+        ProcessNotificationToHost(psCDCDeviceInst, ui32Status);
+    }
+
+    //
+    // Handler for the bulk OUT data endpoint.
+    //
+    if(ui32Status & (0x10000 << USBEPToIndex(psInst->ui8BulkOUTEndpoint)))
+    {
+        //
+        // Data is being sent to us from the host.
+        //
+        ProcessDataFromHost(psCDCDeviceInst, ui32Status);
+    }
+
+    //
+    // Handler for the bulk IN data endpoint.
+    //
+    if(ui32Status & (1 << USBEPToIndex(psInst->ui8BulkINEndpoint)))
+    {
+        ProcessDataToHost(psCDCDeviceInst, ui32Status);
+    }
+}
+
+//*****************************************************************************
+//
+// Called by the USB stack whenever a configuration change occurs.
+//
+//*****************************************************************************
+static void
+HandleConfigChange(void *pvCDCDevice, uint32_t ui32Info)
+{
+    tCDCSerInstance *psInst;
+    tUSBDCDCDevice *psCDCDevice;
+
+    ASSERT(pvCDCDevice != 0);
+
+    //
+    // The CDC device structure pointer.
+    //
+    psCDCDevice = (tUSBDCDCDevice *)pvCDCDevice;
+
+    //
+    // Get a pointer to the CDC device instance data pointer
+    //
+    psInst = &psCDCDevice->sPrivateData;
+
+    //
+    // Set all our endpoints to idle state.
+    //
+    psInst->iCDCInterruptState = eCDCStateIdle;
+    psInst->iCDCRequestState = eCDCStateIdle;
+    psInst->iCDCRxState = eCDCStateIdle;
+    psInst->iCDCTxState = eCDCStateIdle;
+
+    //
+    // If we are not currently connected so let the client know we are open
+    // for business.
+    //
+    if(!psInst->bConnected)
+    {
+        //
+        // Pass the connected event to the client.
+        //
+        psCDCDevice->pfnControlCallback(psCDCDevice->pvControlCBData,
+                                     USB_EVENT_CONNECTED, 0, (void *)0);
+    }
+
+    //
+    // Remember that we are connected.
+    //
+    psInst->bConnected = true;
+}
+
+//*****************************************************************************
+//
+// USB data received callback.
+//
+// This function is called by the USB stack whenever any data requested from
+// EP0 is received.
+//
+//*****************************************************************************
+static void
+HandleEP0Data(void *pvCDCDevice, uint32_t ui32DataSize)
+{
+    tUSBDCDCDevice *psCDCDevice;
+    tCDCSerInstance *psInst;
+    bool bRetcode;
+
+    ASSERT(pvCDCDevice != 0);
+
+    //
+    // The CDC device structure pointer.
+    //
+    psCDCDevice = (tUSBDCDCDevice *)pvCDCDevice;
+
+    //
+    // If we were not passed any data, just return.
+    //
+    if(ui32DataSize == 0)
+    {
+        return;
+    }
+
+    //
+    // Get a pointer to the CDC device instance data pointer
+    //
+    psInst = &psCDCDevice->sPrivateData;
+
+    //
+    // Make sure we are actually expecting something.
+    //
+    if(psInst->iCDCRequestState != eCDCStateWaitData)
+    {
+        return;
+    }
+
+    //
+    // Process the data received.  This will be a request-specific data
+    // block associated with the last request received.
+    //
+    switch (psInst->ui8PendingRequest)
+    {
+        //
+        // We just got the line coding structure.  Make sure the client has
+        // read all outstanding data then pass it back to initiate a change
+        // in the line state.
+        //
+        case USB_CDC_SET_LINE_CODING:
+        {
+            if(ui32DataSize != sizeof(tLineCoding))
+            {
+                USBDCDStallEP0(0);
+            }
+            else
+            {
+                //
+                // Set the flag telling us that we need to send a line coding
+                // notification to the client.
+                //
+                SetDeferredOpFlag(&psInst->ui16DeferredOpFlags,
+                                  CDC_DO_LINE_CODING_CHANGE, true);
+
+                //
+                // See if we can send the notification immediately.
+                //
+                bRetcode = CheckAndSendLineCodingChange(psCDCDevice);
+
+                //
+                // If we could not send the line coding change request to the
+                // client, block reception of more data from the host until
+                // previous data is processed and we send the change request.
+                //
+                if(!bRetcode)
+                {
+                    psInst->bRxBlocked = true;
+                }
+            }
+            break;
+        }
+
+            //
+            // Oops - we seem to be waiting on a request which has not yet been
+            // coded here.  Flag the error and stall EP0 anyway (even though
+            // this would indicate a coding error).
+            //
+        default:
+        {
+            USBDCDStallEP0(0);
+            ASSERT(0);
+            break;
+        }
+    }
+
+    //
+    // All is well.  Set the state back to IDLE.
+    //
+    psInst->iCDCRequestState = eCDCStateIdle;
+}
+
+//*****************************************************************************
+//
+// Device instance specific handler.
+//
+//*****************************************************************************
+static void
+HandleDevice(void *pvCDCDevice, uint32_t ui32Request, void *pvRequestData)
+{
+    tCDCSerInstance *psInst;
+    uint8_t *pui8Data;
+    tUSBDCDCDevice *psCDCDevice;
+
+    //
+    // The CDC device structure pointer.
+    //
+    psCDCDevice = (tUSBDCDCDevice *)pvCDCDevice;
+
+    //
+    // Get a pointer to the CDC device instance data pointer
+    //
+    psInst = &psCDCDevice->sPrivateData;
+
+    //
+    // Create the 8-bit array used by the events supported by the USB CDC
+    // serial class.
+    //
+    pui8Data = (uint8_t *)pvRequestData;
+
+    switch(ui32Request)
+    {
+        //
+        // This was an interface change event.
+        //
+        case USB_EVENT_COMP_IFACE_CHANGE:
+        {
+            //
+            // Save the change to the appropriate interface number.
+            //
+            if(pui8Data[0] == SERIAL_INTERFACE_CONTROL)
+            {
+                psInst->ui8InterfaceControl = pui8Data[1];
+            }
+            else if(pui8Data[0] == SERIAL_INTERFACE_DATA)
+            {
+                psInst->ui8InterfaceData = pui8Data[1];
+            }
+            break;
+        }
+
+        //
+        // This was an endpoint change event.
+        //
+        case USB_EVENT_COMP_EP_CHANGE:
+        {
+            //
+            // Determine if this is an IN or OUT endpoint that has changed.
+            //
+            if(pui8Data[0] & USB_EP_DESC_IN)
+            {
+                //
+                // Determine which IN endpoint to modify.
+                //
+                if((pui8Data[0] & 0x7f) == USBEPToIndex(CONTROL_ENDPOINT))
+                {
+                    psInst->ui8ControlEndpoint =
+                        IndexToUSBEP((pui8Data[1] & 0x7f));
+                }
+                else
+                {
+                    psInst->ui8BulkINEndpoint =
+                        IndexToUSBEP((pui8Data[1] & 0x7f));
+                }
+            }
+            else
+            {
+                //
+                // Extract the new endpoint number.
+                //
+                psInst->ui8BulkOUTEndpoint =
+                    IndexToUSBEP(pui8Data[1] & 0x7f);
+            }
+            break;
+        }
+
+        //
+        // Handle class specific reconfiguring of the configuration descriptor
+        // once the composite class has built the full descriptor.
+        //
+        case USB_EVENT_COMP_CONFIG:
+        {
+            //
+            // This sets the bFirstInterface of the Interface Association
+            // descriptor to the first interface which is the control
+            // interface used by this instance.
+            //
+            pui8Data[2] = psInst->ui8InterfaceControl;
+
+            //
+            // This sets the bMasterInterface of the Union descriptor to the
+            // Control interface and the bSlaveInterface of the Union
+            // Descriptor to the Data interface used by this instance.
+            //
+            pui8Data[29] = psInst->ui8InterfaceControl;
+            pui8Data[30] = psInst->ui8InterfaceData;
+
+            //
+            // This sets the bDataInterface of the Union descriptor to the
+            // Data interface used by this instance.
+            pui8Data[35] = psInst->ui8InterfaceData;
+            break;
+        }
+        case USB_EVENT_LPM_RESUME:
+        {
+            if(psCDCDevice->pfnControlCallback)
+            {
+                //
+                // Pass the LPM resume event to the client.
+                //
+                psCDCDevice->pfnControlCallback(psCDCDevice->pvControlCBData,
+                                                USB_EVENT_LPM_RESUME, 0,
+                                                (void *)0);
+            }
+            break;
+        }
+        case USB_EVENT_LPM_SLEEP:
+        {
+            if(psCDCDevice->pfnControlCallback)
+            {
+                //
+                // Pass the LPM sleep event to the client.
+                //
+                psCDCDevice->pfnControlCallback(psCDCDevice->pvControlCBData,
+                                                USB_EVENT_LPM_SLEEP, 0,
+                                                (void *)0);
+            }
+            break;
+        }
+        case USB_EVENT_LPM_ERROR:
+        {
+            if(psCDCDevice->pfnControlCallback)
+            {
+                //
+                // Pass the LPM error event to the client.
+                //
+                psCDCDevice->pfnControlCallback(psCDCDevice->pvControlCBData,
+                                                USB_EVENT_LPM_ERROR, 0,
+                                                (void *)0);
+            }
+            break;
+        }
+        default:
+        {
+            break;
+        }
+    }
+}
+
+//*****************************************************************************
+//
+// USB non-standard request callback.
+//
+// This function is called by the USB stack whenever any non-standard request
+// is made to the device.  The handler should process any requests that it
+// supports or stall EP0 in any unsupported cases.
+//
+//*****************************************************************************
+static void
+HandleRequests(void *pvCDCDevice, tUSBRequest *pUSBRequest)
+{
+    tUSBDCDCDevice *psCDCDevice;
+    tCDCSerInstance *psInst;
+    bool bRetcode;
+
+    ASSERT(pvCDCDevice != 0);
+
+    //
+    // The CDC device structure pointer.
+    //
+    psCDCDevice = (tUSBDCDCDevice *)pvCDCDevice;
+
+    //
+    // Get a pointer to the CDC device instance data pointer
+    //
+    psInst = &psCDCDevice->sPrivateData;
+
+    //
+    // Only handle requests meant for this interface.
+    //
+    if(pUSBRequest->wIndex != psInst->ui8InterfaceControl)
+    {
+        return;
+    }
+
+    //
+    // Handle each of the requests that we expect from the host.
+    //
+    switch(pUSBRequest->bRequest)
+    {
+        case USB_CDC_SEND_ENCAPSULATED_COMMAND:
+        {
+            //
+            // This implementation makes use of no communication protocol so
+            // this request is meaningless.  We stall endpoint 0 if we receive
+            // it.
+            //
+            USBDCDStallEP0(0);
+            break;
+        }
+
+        case USB_CDC_GET_ENCAPSULATED_RESPONSE:
+        {
+            //
+            // This implementation makes use of no communication protocol so
+            // this request is meaningless.  We stall endpoint 0 if we receive
+            // it.
+            //
+            USBDCDStallEP0(0);
+            break;
+        }
+
+        case USB_CDC_SET_COMM_FEATURE:
+        {
+            //
+            // This request is apparently required by an ACM device but does
+            // not appear relevant to a virtual COM port and is never used by
+            // Windows (or, at least, is not seen when using Hyperterminal or
+            // TeraTerm via a Windows virtual COM port).  We stall endpoint 0
+            // to indicate that we do not support the request.
+            //
+            USBDCDStallEP0(0);
+            break;
+        }
+
+        case USB_CDC_GET_COMM_FEATURE:
+        {
+            //
+            // This request is apparently required by an ACM device but does
+            // not appear relevant to a virtual COM port and is never used by
+            // Windows (or, at least, is not seen when using Hyperterminal or
+            // TeraTerm via a Windows virtual COM port).  We stall endpoint 0
+            // to indicate that we do not support the request.
+            //
+            USBDCDStallEP0(0);
+            break;
+        }
+
+        case USB_CDC_CLEAR_COMM_FEATURE:
+        {
+            //
+            // This request is apparently required by an ACM device but does
+            // not appear relevant to a virtual COM port and is never used by
+            // Windows (or, at least, is not seen when using Hyperterminal or
+            // TeraTerm via a Windows virtual COM port).  We stall endpoint 0
+            // to indicate that we do not support the request.
+            //
+            USBDCDStallEP0(0);
+            break;
+        }
+
+        //
+        // Set the serial communication parameters.
+        //
+        case USB_CDC_SET_LINE_CODING:
+        {
+            //
+            // Remember the request we are processing.
+            //
+            psInst->ui8PendingRequest = USB_CDC_SET_LINE_CODING;
+
+            //
+            // Set the state to indicate we are waiting for data.
+            //
+            psInst->iCDCRequestState = eCDCStateWaitData;
+
+            //
+            // Now read the payload of the request.  We handle the actual
+            // operation in the data callback once this data is received.
+            //
+            USBDCDRequestDataEP0(0, (uint8_t *)&psInst->sLineCoding,
+                                 sizeof(tLineCoding));
+
+            //
+            // ACK what we have already received.  We must do this after
+            // requesting the data or we get into a race condition where the
+            // data may return before we have set the stack state appropriately
+            // to receive it.
+            //
+            MAP_USBDevEndpointDataAck(psInst->ui32USBBase, USB_EP_0, false);
+
+            break;
+        }
+
+        //
+        // Return the serial communication parameters.
+        //
+        case USB_CDC_GET_LINE_CODING:
+        {
+            tLineCoding sLineCoding;
+
+            //
+            // ACK what we have already received
+            //
+            MAP_USBDevEndpointDataAck(psInst->ui32USBBase, USB_EP_0, false);
+
+            //
+            // Ask the client for the current line coding.
+            //
+            psCDCDevice->pfnControlCallback(psCDCDevice->pvControlCBData,
+                                         USBD_CDC_EVENT_GET_LINE_CODING, 0,
+                                         &sLineCoding);
+
+            //
+            // Send the line coding information back to the host.
+            //
+            USBDCDSendDataEP0(0, (uint8_t *)&sLineCoding, sizeof(tLineCoding));
+
+            break;
+        }
+
+        case USB_CDC_SET_CONTROL_LINE_STATE:
+        {
+            //
+            // ACK what we have already received
+            //
+            MAP_USBDevEndpointDataAck(psInst->ui32USBBase, USB_EP_0, false);
+
+            //
+            // Set the handshake lines as required.
+            //
+            psInst->ui16ControlLineState = pUSBRequest->wValue;
+
+            //
+            // Remember that we are due to notify the client of a line
+            // state change.
+            //
+            SetDeferredOpFlag(&psInst->ui16DeferredOpFlags,
+                              CDC_DO_LINE_STATE_CHANGE, true);
+
+            //
+            // See if we can notify now.
+            //
+            bRetcode = CheckAndSendLineStateChange(psCDCDevice);
+
+            //
+            // If we could not send the line state change request to the
+            // client, block reception of more data from the host until
+            // previous data is processed and we send the change request.
+            //
+            if(!bRetcode)
+            {
+                psInst->bRxBlocked = true;
+            }
+
+            break;
+        }
+
+        case USB_CDC_SEND_BREAK:
+        {
+            //
+            // ACK what we have already received
+            //
+            MAP_USBDevEndpointDataAck(psInst->ui32USBBase, USB_EP_0, false);
+
+            //
+            // Keep a copy of the requested break duration.
+            //
+            psInst->ui16BreakDuration = pUSBRequest->wValue;
+
+            //
+            // Remember that we need to send a break request.
+            //
+            SetDeferredOpFlag(&psInst->ui16DeferredOpFlags,
+                              CDC_DO_SEND_BREAK, true);
+
+            //
+            // Send the break request if all outstanding receive data has been
+            // processed.
+            //
+            bRetcode = CheckAndSendBreak(psCDCDevice, pUSBRequest->wValue);
+
+            //
+            // If we could not send the line coding change request to the
+            // client, block reception of more data from the host until
+            // previous data is processed and we send the change request.
+            //
+            if(!bRetcode)
+            {
+                psInst->bRxBlocked = true;
+            }
+
+            break;
+        }
+
+        //
+        // These are valid CDC requests but not ones that an ACM device should
+        // receive.
+        //
+        case USB_CDC_SET_AUX_LINE_STATE:
+        case USB_CDC_SET_HOOK_STATE:
+        case USB_CDC_PULSE_SETUP:
+        case USB_CDC_SEND_PULSE:
+        case USB_CDC_SET_PULSE_TIME:
+        case USB_CDC_RING_AUX_JACK:
+        case USB_CDC_SET_RINGER_PARMS:
+        case USB_CDC_GET_RINGER_PARMS:
+        case USB_CDC_SET_OPERATION_PARMS:
+        case USB_CDC_GET_OPERATION_PARMS:
+        case USB_CDC_SET_LINE_PARMS:
+        case USB_CDC_GET_LINE_PARMS:
+        case USB_CDC_DIAL_DIGITS:
+        case USB_CDC_SET_UNIT_PARAMETER:
+        case USB_CDC_GET_UNIT_PARAMETER:
+        case USB_CDC_CLEAR_UNIT_PARAMETER:
+        case USB_CDC_GET_PROFILE:
+        case USB_CDC_SET_ETHERNET_MULTICAST_FILTERS:
+        case USB_CDC_SET_ETHERNET_POWER_MANAGEMENT_PATTERN_FILTER:
+        case USB_CDC_GET_ETHERNET_POWER_MANAGEMENT_PATTERN_FILTER:
+        case USB_CDC_SET_ETHERNET_PACKET_FILTER:
+        case USB_CDC_GET_ETHERNET_STATISTIC:
+        case USB_CDC_SET_ATM_DATA_FORMAT:
+        case USB_CDC_GET_ATM_DEVICE_STATISTICS:
+        case USB_CDC_SET_ATM_DEFAULT_VC:
+        case USB_CDC_GET_ATM_VC_STATISTICS:
+        {
+            USBDCDStallEP0(0);
+            break;
+        }
+
+        default:
+        {
+            //
+            // This request is not part of the CDC specification.
+            //
+            USBDCDStallEP0(0);
+            break;
+        }
+    }
+}
+
+//*****************************************************************************
+//
+// This function is called by the USB device stack whenever the device is
+// disconnected from the host.
+//
+//*****************************************************************************
+static void
+HandleDisconnect(void *pvCDCDevice)
+{
+    tUSBDCDCDevice *psCDCDevice;
+    tCDCSerInstance *psInst;
+
+    ASSERT(pvCDCDevice != 0);
+
+    //
+    // The CDC device structure pointer.
+    //
+    psCDCDevice = (tUSBDCDCDevice *)pvCDCDevice;
+
+    //
+    // Get a pointer to the CDC device instance data pointer
+    //
+    psInst = &psCDCDevice->sPrivateData;
+
+    //
+    // If we are not currently connected and we have a control callback,
+    // let the client know we are open for business.
+    //
+    if(psInst->bConnected)
+    {
+        //
+        // Pass the disconnected event to the client.
+        //
+        psCDCDevice->pfnControlCallback(psCDCDevice->pvControlCBData,
+                                        USB_EVENT_DISCONNECTED, 0, (void *)0);
+    }
+
+    //
+    // Remember that we are no longer connected.
+    //
+    psInst->bConnected = false;
+}
+
+//*****************************************************************************
+//
+// This function is called by the USB device stack whenever the bus is put into
+// suspend state.
+//
+//*****************************************************************************
+static void
+HandleSuspend(void *pvCDCDevice)
+{
+    const tUSBDCDCDevice *psCDCDevice;
+
+    ASSERT(pvCDCDevice != 0);
+
+    //
+    // The CDC device structure pointer.
+    //
+    psCDCDevice = (const tUSBDCDCDevice *)pvCDCDevice;
+
+    //
+    // Pass the event on to the client.
+    //
+    psCDCDevice->pfnControlCallback(psCDCDevice->pvControlCBData,
+                                    USB_EVENT_SUSPEND, 0, (void *)0);
+}
+
+//*****************************************************************************
+//
+// This function is called by the USB device stack whenever the bus is taken
+// out of suspend state.
+//
+//*****************************************************************************
+static void
+HandleResume(void *pvCDCDevice)
+{
+    tUSBDCDCDevice *psCDCDevice;
+
+    ASSERT(pvCDCDevice != 0);
+
+    //
+    // The CDC device structure pointer.
+    //
+    psCDCDevice = (tUSBDCDCDevice *)pvCDCDevice;
+
+    //
+    // Pass the event on to the client.
+    //
+    psCDCDevice->pfnControlCallback(psCDCDevice->pvControlCBData,
+                                    USB_EVENT_RESUME, 0, (void *)0);
+}
+
+//*****************************************************************************
+//
+// This function is called periodically and provides us with a time reference
+// and method of implementing delayed or time-dependent operations.
+//
+// \param ui32Index is the index of the USB controller for which this tick
+// is being generated.
+// \param ui32TimemS is the elapsed time in milliseconds since the last call
+// to this function.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+CDCTickHandler(void *pvCDCDevice, uint32_t ui32TimemS)
+{
+    bool bCanSend;
+    tUSBDCDCDevice *psCDCDevice;
+    tCDCSerInstance *psInst;
+    uint32_t ui32Size;
+
+    ASSERT(pvCDCDevice != 0);
+
+    //
+    // The CDC device structure pointer.
+    //
+    psCDCDevice = (tUSBDCDCDevice *)pvCDCDevice;
+
+    //
+    // Get a pointer to the CDC device instance data pointer
+    //
+    psInst = &psCDCDevice->sPrivateData;
+
+    //
+    // Is there any outstanding operation that we should try to perform?
+    //
+    if(psInst->ui16DeferredOpFlags)
+    {
+        //
+        // Yes - we have at least one deferred operation pending.  First check
+        // to see if it is time to turn off a break condition.
+        //
+        if(psInst->ui16DeferredOpFlags & (1 << CDC_DO_CLEAR_BREAK))
+        {
+            //
+            // Will our break timer expire this time?
+            //
+            if(psInst->ui16BreakDuration <= ui32TimemS)
+            {
+                //
+                // Yes - turn off the break condition.
+                //
+                SendBreak(psCDCDevice, false);
+            }
+            else
+            {
+                //
+                // We have not timed out yet.  Decrement the break timer.
+                //
+                psInst->ui16BreakDuration -= (uint16_t)ui32TimemS;
+            }
+        }
+
+        // Now check to see if the client has any data remaining to be
+        // processed.  This information is needed by the remaining deferred
+        // operations which are waiting for the receive pipe to be emptied
+        // before they can be carried out.
+        //
+        bCanSend = DeviceConsumedAllData(psCDCDevice);
+
+        //
+        // Has all outstanding data been consumed?
+        //
+        if(bCanSend)
+        {
+            //
+            // Yes - go ahead and notify the client of the various things
+            // it has been asked to do while we waited for data to be
+            // consumed.
+            //
+
+            //
+            // Do we need to start sending a break condition?
+            //
+            if(psInst->ui16DeferredOpFlags & (1 << CDC_DO_SEND_BREAK))
+            {
+                SendBreak(psCDCDevice, true);
+            }
+
+            //
+            // Do we need to set the RTS/DTR states?
+            //
+            if(psInst->ui16DeferredOpFlags & (1 << CDC_DO_LINE_STATE_CHANGE))
+            {
+                SendLineStateChange(psCDCDevice);
+            }
+
+            //
+            // Do we need to change the line coding parameters?
+            //
+            if(psInst->ui16DeferredOpFlags & (1 << CDC_DO_LINE_CODING_CHANGE))
+            {
+                SendLineCodingChange(psCDCDevice);
+            }
+
+            //
+            // NOTE: We do not need to handle CDC_DO_SERIAL_STATE_CHANGE here
+            // since this is handled in the transmission complete notification
+            // for the control IN endpoint (ProcessNotificationToHost()).
+            //
+
+            //
+            // If all the deferred operations which caused the receive channel
+            // to be blocked are now handled, we can unblock receive and handle
+            // any packet that is currently waiting to be received.
+            //
+            if(!(psInst->ui16DeferredOpFlags & RX_BLOCK_OPS))
+            {
+                //
+                // We can remove the receive block.
+                //
+                psInst->bRxBlocked = false;
+            }
+        }
+
+        //
+        // Is the receive channel unblocked?
+        //
+        if(!psInst->bRxBlocked)
+        {
+            //
+            // Do we have a deferred receive waiting
+            //
+            if(psInst->ui16DeferredOpFlags & (1 << CDC_DO_PACKET_RX))
+            {
+                //
+                // Yes - how big is the waiting packet?
+                //
+                ui32Size = MAP_USBEndpointDataAvail(psInst->ui32USBBase,
+                                                    psInst->ui8BulkOUTEndpoint);
+
+                // Tell the client that there is a packet waiting for it.
+                //
+                psCDCDevice->pfnRxCallback(psCDCDevice->pvRxCBData,
+                                        USB_EVENT_RX_AVAILABLE, ui32Size,
+                                        (void *)0);
+            }
+        }
+    }
+
+    return;
+}
+
+//*****************************************************************************
+//
+//! Initializes CDC device operation when used with a composite device.
+//!
+//! \param ui32Index is the index of the USB controller in use.
+//! \param psCDCDevice points to a structure containing parameters customizing
+//! the operation of the CDC device.
+//! \param psCompEntry is the composite device entry to initialize when
+//! creating a composite device.
+//!
+//! This call is very similar to USBDCDCInit() except that it is used for
+//! initializing an instance of the serial device for use in a composite
+//! device.  When this CDC serial device is part of a composite device, then
+//! the \e psCompEntry should point to the composite device entry to
+//! initialize.  This is part of the array that is passed to the
+//! USBDCompositeInit() function.
+//!
+//! \return Returns zero on failure or a non-zero instance value that should be
+//! used with the remaining USB CDC APIs.
+//
+//*****************************************************************************
+void *
+USBDCDCCompositeInit(uint32_t ui32Index, tUSBDCDCDevice *psCDCDevice,
+                     tCompositeEntry *psCompEntry)
+{
+    tCDCSerInstance *psInst;
+
+    //
+    // Check parameter validity.
+    //
+    ASSERT(ui32Index == 0);
+    ASSERT(psCDCDevice);
+    ASSERT(psCDCDevice->pfnControlCallback);
+    ASSERT(psCDCDevice->pfnRxCallback);
+    ASSERT(psCDCDevice->pfnTxCallback);
+
+    //
+    // Get a pointer to the CDC device instance data pointer
+    //
+    psInst = &psCDCDevice->sPrivateData;
+
+    //
+    // Initialize the composite entry that is used by the composite device
+    // class.
+    //
+    if(psCompEntry != 0)
+    {
+        psCompEntry->psDevInfo = &psInst->sDevInfo;
+        psCompEntry->pvInstance = (void *)psCDCDevice;
+    }
+
+    //
+    // Initialize the device information structure.
+    //
+    psInst->sDevInfo.psCallbacks = &g_sCDCHandlers;
+    psInst->sDevInfo.pui8DeviceDescriptor = g_pui8CDCSerDeviceDescriptor;
+
+    //
+    // The CDC serial configuration is different for composite devices and
+    // stand alone devices.
+    //
+    if(psCompEntry == 0)
+    {
+        psInst->sDevInfo.ppsConfigDescriptors = g_ppCDCSerConfigDescriptors;
+    }
+    else
+    {
+        psInst->sDevInfo.ppsConfigDescriptors = g_pCDCCompSerConfigDescriptors;
+    }
+    psInst->sDevInfo.ppui8StringDescriptors = 0;
+    psInst->sDevInfo.ui32NumStringDescriptors = 0;
+
+    //
+    // Set the default endpoint and interface assignments.
+    //
+    psInst->ui8BulkINEndpoint = DATA_IN_ENDPOINT;
+    psInst->ui8BulkOUTEndpoint = DATA_OUT_ENDPOINT;
+    psInst->ui8InterfaceControl = SERIAL_INTERFACE_CONTROL;
+    psInst->ui8InterfaceData = SERIAL_INTERFACE_DATA;
+
+    //
+    // By default do not use the interrupt control endpoint.  The single
+    // instance CDC serial device will turn this on in USBDCDCInit();
+    //
+    psInst->ui8ControlEndpoint = CONTROL_ENDPOINT;
+
+    //
+    // Initialize the workspace in the passed instance structure.
+    //
+    psInst->ui32USBBase = USB0_BASE;
+    psInst->iCDCRxState = eCDCStateUnconfigured;
+    psInst->iCDCTxState = eCDCStateUnconfigured;
+    psInst->iCDCInterruptState = eCDCStateUnconfigured;
+    psInst->iCDCRequestState = eCDCStateUnconfigured;
+    psInst->ui8PendingRequest = 0;
+    psInst->ui16BreakDuration = 0;
+    psInst->ui16SerialState = 0;
+    psInst->ui16DeferredOpFlags = 0;
+    psInst->ui16ControlLineState = 0;
+    psInst->bRxBlocked = false;
+    psInst->bControlBlocked = false;
+    psInst->bConnected = false;
+
+    //
+    // Initialize the device info structure for the serial device.
+    //
+    USBDCDDeviceInfoInit(0, &psInst->sDevInfo);
+
+    //
+    // Plug in the client's string stable to the device information
+    // structure.
+    //
+    psInst->sDevInfo.ppui8StringDescriptors =
+                                        psCDCDevice->ppui8StringDescriptors;
+    psInst->sDevInfo.ui32NumStringDescriptors =
+                                        psCDCDevice->ui32NumStringDescriptors;
+
+    //
+    // Initialize the USB tick module, this will prevent it from being
+    // initialized later in the call to USBDCDInit();
+    //
+    InternalUSBTickInit();
+
+    //
+    // Register our tick handler (this must be done after USBDCDInit).
+    //
+    InternalUSBRegisterTickHandler(CDCTickHandler, (void *)psCDCDevice);
+
+    //
+    // Return the pointer to the instance indicating that everything went well.
+    //
+    return((void *)psCDCDevice);
+}
+
+//*****************************************************************************
+//
+//! Initializes CDC device operation for a given USB controller.
+//!
+//! \param ui32Index is the index of the USB controller which is to be
+//! initialized for CDC device operation.
+//! \param psCDCDevice points to a structure containing parameters customizing
+//! the operation of the CDC device.
+//!
+//! An application wishing to make use of a USB CDC communication channel and
+//! appear as a virtual serial port on the host system must call this function
+//! to initialize the USB controller and attach the device to the USB bus.
+//! This function performs all required USB initialization.
+//!
+//! The value returned by this function is the \e psCDCDevice pointer passed
+//! to it if successful.  This pointer must be passed to all later calls to the
+//! CDC class driver to identify the device instance.
+//!
+//! The USB CDC device class driver  offers packet-based transmit and receive
+//! operation.  If the application would rather use block based communication
+//! with transmit and receive buffers, USB buffers on the transmit and receive
+//! channels may be used to offer this functionality.
+//!
+//! Transmit Operation:
+//!
+//! Calls to USBDCDCPacketWrite() must send no more than 64 bytes of data at a
+//! time and may only be made when no other transmission is currently
+//! outstanding.
+//!
+//! Once a packet of data has been acknowledged by the USB host, a
+//! \b USB_EVENT_TX_COMPLETE event is sent to the application callback to
+//! inform it that another packet may be transmitted.
+//!
+//! Receive Operation:
+//!
+//! An incoming USB data packet will result in a call to the application
+//! callback with event \b USB_EVENT_RX_AVAILABLE.  The application must then
+//! call USBDCDCPacketRead(), passing a buffer capable of holding the received
+//! packet to retrieve the data and acknowledge reception to the USB host.  The
+//! size of the received packet may be queried by calling
+//! USBDCDCRxPacketAvailable().
+//!
+//! \note The application must not make any calls to the low level USB Device
+//! API if interacting with USB via the CDC device class API.  Doing so
+//! will cause unpredictable (though almost certainly unpleasant) behavior.
+//!
+//! \return Returns NULL on failure or the psCDCDevice pointer on success.
+//
+//*****************************************************************************
+void *
+USBDCDCInit(uint32_t ui32Index, tUSBDCDCDevice *psCDCDevice)
+{
+    void *pvRet;
+    tCDCSerInstance *psInst;
+    tDeviceDescriptor *psDevDesc;
+    tConfigDescriptor *psConfigDesc;
+
+    //
+    // Initialize the internal state for this class.
+    //
+    pvRet = USBDCDCCompositeInit(ui32Index, psCDCDevice, 0);
+
+    if(pvRet)
+    {
+        //
+        // Fix up the device descriptor with the client-supplied values.
+        //
+        psDevDesc = (tDeviceDescriptor *)g_pui8CDCSerDeviceDescriptor;
+        psDevDesc->idVendor = psCDCDevice->ui16VID;
+        psDevDesc->idProduct = psCDCDevice->ui16PID;
+
+        //
+        // Fix up the configuration descriptor with client-supplied values.
+        //
+        psConfigDesc = (tConfigDescriptor *)g_pui8CDCSerDescriptor;
+        psConfigDesc->bmAttributes = psCDCDevice->ui8PwrAttributes;
+        psConfigDesc->bMaxPower = (uint8_t)(psCDCDevice->ui16MaxPowermA / 2);
+
+        //
+        // Create an instance pointer to the private data area.
+        //
+        psInst = &psCDCDevice->sPrivateData;
+
+        //
+        // Enable the default interrupt control endpoint if this class is not
+        // being used in a composite device.
+        //
+        psInst->ui8ControlEndpoint = CONTROL_ENDPOINT;
+
+        //
+        // Use the configuration descriptor with the interrupt control
+        // endpoint.
+        //
+        psInst->sDevInfo.ppsConfigDescriptors = g_ppCDCSerConfigDescriptors;
+
+        //
+        // All is well so now pass the descriptors to the lower layer and put
+        // the CDC device on the bus.
+        //
+        USBDCDInit(ui32Index, &psInst->sDevInfo, (void *)psCDCDevice);
+    }
+
+    return(pvRet);
+}
+
+//*****************************************************************************
+//
+//! Shuts down the CDC device instance.
+//!
+//! \param pvCDCDevice is the pointer to the device instance structure as
+//! returned by USBDCDCInit().
+//!
+//! This function terminates CDC operation for the instance supplied and
+//! removes the device from the USB bus.  This function should not be called
+//! if the CDC device is part of a composite device and instead the
+//! USBDCompositeTerm() function should be called for the full composite
+//! device.
+//!
+//! Following this call, the \e pvCDCDevice instance should not me used in
+//! any other calls.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBDCDCTerm(void *pvCDCDevice)
+{
+    tCDCSerInstance *psInst;
+
+    ASSERT(pvCDCDevice);
+
+    //
+    // Get a pointer to the CDC device instance data pointer
+    //
+    psInst = &((tUSBDCDCDevice *)pvCDCDevice)->sPrivateData;
+
+    //
+    // Terminate the requested instance.
+    //
+    USBDCDTerm(USBBaseToIndex(psInst->ui32USBBase));
+
+    psInst->ui32USBBase = 0;
+
+    return;
+}
+
+//*****************************************************************************
+//
+//! Sets the client-specific pointer for the control callback.
+//!
+//! \param pvCDCDevice is the pointer to the device instance structure as
+//! returned by USBDCDCInit().
+//! \param pvCBData is the pointer that client wishes to be provided on each
+//! event sent to the control channel callback function.
+//!
+//! The client uses this function to change the callback pointer passed in
+//! the first parameter on all callbacks to the \e pfnControlCallback function
+//! passed on USBDCDCInit().
+//!
+//! If a client wants to make runtime changes in the callback pointer, it must
+//! ensure that the psCDCDevice structure passed to USBDCDCInit() resides in
+//! RAM.  If this structure is in flash, callback pointer changes will not be
+//! possible.
+//!
+//! \return Returns the previous callback pointer that was being used for
+//! this instance's control callback.
+//
+//*****************************************************************************
+void *
+USBDCDCSetControlCBData(void *pvCDCDevice, void *pvCBData)
+{
+    tUSBDCDCDevice *psBulkDevice;
+    void *pvOldValue;
+
+    ASSERT(pvCDCDevice);
+
+    //
+    // The CDC device structure pointer.
+    //
+    psBulkDevice = (tUSBDCDCDevice *)pvCDCDevice;
+
+    //
+    // Set the callback pointer for the control channel after remembering the
+    // previous value.
+    //
+    pvOldValue = psBulkDevice->pvControlCBData;
+    psBulkDevice->pvControlCBData = pvCBData;
+
+    //
+    // Return the previous callback data value.
+    //
+    return(pvOldValue);
+}
+
+//*****************************************************************************
+//
+//! Sets the client-specific data parameter for the receive channel callback.
+//!
+//! \param pvCDCDevice is the pointer to the device instance structure as
+//! returned by USBDCDCInit().
+//! \param pvCBData is the pointer that client wishes to be provided on each
+//! event sent to the receive channel callback function.
+//!
+//! The client uses this function to change the callback pointer passed in
+//! the first parameter on all callbacks to the \e pfnRxCallback function
+//! passed on USBDCDCInit().
+//!
+//! If a client wants to make runtime changes in the callback pointer, it must
+//! ensure that the psCDCDevice structure passed to USBDCDCInit() resides in
+//! RAM.  If this structure is in flash, callback data changes will not be
+//! possible.
+//!
+//! \return Returns the previous callback pointer that was being used for
+//! this instance's receive callback.
+//
+//*****************************************************************************
+void *
+USBDCDCSetRxCBData(void *pvCDCDevice, void *pvCBData)
+{
+    tUSBDCDCDevice *psBulkDevice;
+    void *pvOldValue;
+
+    ASSERT(pvCDCDevice);
+
+    //
+    // The CDC device structure pointer.
+    //
+    psBulkDevice = (tUSBDCDCDevice *)pvCDCDevice;
+
+    //
+    // Set the callback data for the receive channel after remembering the
+    // previous value.
+    //
+    pvOldValue = psBulkDevice->pvRxCBData;
+    psBulkDevice->pvRxCBData = pvCBData;
+
+    //
+    // Return the previous callback pointer.
+    //
+    return(pvOldValue);
+}
+
+//*****************************************************************************
+//
+//! Sets the client-specific data parameter for the transmit callback.
+//!
+//! \param pvCDCDevice is the pointer to the device instance structure as
+//! returned by USBDCDCInit().
+//! \param pvCBData is the pointer that client wishes to be provided on each
+//! event sent to the transmit channel callback function.
+//!
+//! The client uses this function to change the callback pointer passed in
+//! the first parameter on all callbacks to the \e pfnTxCallback function
+//! passed on USBDCDCInit().
+//!
+//! If a client wants to make runtime changes in the callback pointer, it must
+//! ensure that the psCDCDevice structure passed to USBDCDCInit() resides in
+//! RAM.  If this structure is in flash, callback data changes will not be
+//! possible.
+//!
+//! \return Returns the previous callback pointer that was being used for
+//! this instance's transmit callback.
+//
+//*****************************************************************************
+void *
+USBDCDCSetTxCBData(void *pvCDCDevice, void *pvCBData)
+{
+    tUSBDCDCDevice *psBulkDevice;
+    void *pvOldValue;
+
+    ASSERT(pvCDCDevice);
+
+    //
+    // The CDC device structure pointer.
+    //
+    psBulkDevice = (tUSBDCDCDevice *)pvCDCDevice;
+
+    //
+    // Set the callback data for the transmit channel after remembering the
+    // previous value.
+    //
+    pvOldValue = psBulkDevice->pvTxCBData;
+    psBulkDevice->pvTxCBData = pvCBData;
+
+    //
+    // Return the previous callback pointer.
+    //
+    return(pvOldValue);
+}
+
+//*****************************************************************************
+//
+//! Transmits a packet of data to the USB host via the CDC data interface.
+//!
+//! \param pvCDCDevice is the pointer to the device instance structure as
+//! returned by USBDCDCInit().
+//! \param pi8Data points to the first byte of data which is to be transmitted.
+//! \param ui32Length is the number of bytes of data to transmit.
+//! \param bLast indicates whether more data is to be written before a packet
+//! should be scheduled for transmission.  If \b true, the client will make
+//! a further call to this function.  If \b false, no further call will be
+//! made and the driver should schedule transmission of a short packet.
+//!
+//! This function schedules the supplied data for transmission to the USB
+//! host in a single USB packet.  If no transmission is currently ongoing
+//! the data is immediately copied to the relevant USB endpoint FIFO.  If the
+//! \e bLast parameter is \b true, the newly written packet is then scheduled
+//! for transmission.  Whenever a USB packet is acknowledged by the host, a
+//! \b USB_EVENT_TX_COMPLETE event will be sent to the application transmit
+//! callback indicating that more data can now be transmitted.
+//!
+//! The maximum value for \e ui32Length is 64 bytes (the maximum USB packet
+//! size for the bulk endpoints in use by CDC).  Attempts to send more data
+//! than this will result in a return code of 0 indicating that the data cannot
+//! be sent.
+//!
+//! \return Returns the number of bytes actually sent.  At this level, this
+//! will either be the number of bytes passed (if less than or equal to the
+//! maximum packet size for the USB endpoint in use and no outstanding
+//! transmission ongoing) or 0 to indicate a failure.
+//
+//*****************************************************************************
+uint32_t
+USBDCDCPacketWrite(void *pvCDCDevice, uint8_t *pi8Data, uint32_t ui32Length,
+                   bool bLast)
+{
+    tCDCSerInstance *psInst;
+    int32_t i32Retcode;
+
+    ASSERT(pvCDCDevice);
+
+    //
+    // Get a pointer to the CDC device instance data pointer
+    //
+    psInst = &((tUSBDCDCDevice *)pvCDCDevice)->sPrivateData;
+
+    //
+    // Can we send the data provided?
+    //
+    if((ui32Length > DATA_IN_EP_MAX_SIZE) ||
+       (psInst->iCDCTxState != eCDCStateIdle))
+    {
+        //
+        // Either the packet was too big or we are in the middle of sending
+        // another packet.  Return 0 to indicate that we can't send this data.
+        //
+        return(0);
+    }
+
+    //
+    // Copy the data into the USB endpoint FIFO.
+    //
+    i32Retcode = MAP_USBEndpointDataPut(psInst->ui32USBBase,
+                                        psInst->ui8BulkINEndpoint, pi8Data,
+                                        ui32Length);
+
+    //
+    // Did we copy the data successfully?
+    //
+    if(i32Retcode != -1)
+    {
+        //
+        // Remember how many bytes we sent.
+        //
+        psInst->ui16LastTxSize += (uint16_t)ui32Length;
+
+        //
+        // If this is the last call for this packet, schedule transmission.
+        //
+        if(bLast)
+        {
+            //
+            // Send the packet to the host if we have received all the data we
+            // can expect for this packet.
+            //
+            psInst->iCDCTxState = eCDCStateWaitData;
+            i32Retcode = MAP_USBEndpointDataSend(psInst->ui32USBBase,
+                                                 psInst->ui8BulkINEndpoint,
+                                                 USB_TRANS_IN);
+        }
+    }
+
+    //
+    // Did an error occur while trying to send the data?
+    //
+    if(i32Retcode != -1)
+    {
+        //
+        // No - tell the caller we sent all the bytes provided.
+        //
+        return(ui32Length);
+    }
+    else
+    {
+        //
+        // Yes - tell the caller we could not send the data.
+        //
+        return(0);
+    }
+}
+
+//*****************************************************************************
+//
+//! Reads a packet of data received from the USB host via the CDC data
+//! interface.
+//!
+//! \param pvCDCDevice is the pointer to the device instance structure as
+//! returned by USBDCDCInit().
+//! \param pi8Data points to a buffer into which the received data will be
+//! written.
+//! \param ui32Length is the size of the buffer pointed to by \e pi8Data.
+//! \param bLast indicates whether the client will make a further call to
+//! read additional data from the packet.
+//!
+//! This function reads up to ui32Length bytes of data received from the USB
+//! host into the supplied application buffer.
+//!
+//! \note The \e bLast parameter is ignored in this implementation since the
+//! end of a packet can be determined without relying upon the client to
+//! provide this information.
+//!
+//! \return Returns the number of bytes of data read.
+//
+//*****************************************************************************
+uint32_t
+USBDCDCPacketRead(void *pvCDCDevice, uint8_t *pi8Data, uint32_t ui32Length,
+                  bool bLast)
+{
+    uint32_t ui32EPStatus, ui32Count, ui32Pkt;
+    tCDCSerInstance *psInst;
+    int32_t i32Retcode;
+
+    ASSERT(pvCDCDevice);
+
+    //
+    // Get a pointer to the CDC device instance data pointer
+    //
+    psInst = &((tUSBDCDCDevice *)pvCDCDevice)->sPrivateData;
+
+    //
+    // Does the relevant endpoint FIFO have a packet waiting for us?
+    //
+    ui32EPStatus = MAP_USBEndpointStatus(psInst->ui32USBBase,
+                                         psInst->ui8BulkOUTEndpoint);
+
+    if(ui32EPStatus & USB_DEV_RX_PKT_RDY)
+    {
+        //
+        // If receive is currently blocked or the buffer we were passed is
+        // (potentially) too small, set the flag telling us that we have a
+        // packet waiting but return 0.
+        //
+        if(psInst->bRxBlocked || psInst->bControlBlocked)
+        {
+            SetDeferredOpFlag(&psInst->ui16DeferredOpFlags, CDC_DO_PACKET_RX,
+                              true);
+            return(0);
+        }
+        else
+        {
+            //
+            // It is OK to receive the new packet.  How many bytes are
+            // available for us to receive?
+            //
+            ui32Pkt = MAP_USBEndpointDataAvail(psInst->ui32USBBase,
+                                               psInst->ui8BulkOUTEndpoint);
+
+            //
+            // Get as much data as we can.
+            //
+            ui32Count = ui32Length;
+            i32Retcode = MAP_USBEndpointDataGet(psInst->ui32USBBase,
+                                                psInst->ui8BulkOUTEndpoint,
+                                                pi8Data, &ui32Count);
+
+            //
+            // Did we read the last of the packet data?
+            //
+            if(ui32Count == ui32Pkt)
+            {
+                //
+                // Clear the endpoint status so that we know no packet is
+                // waiting.
+                //
+                MAP_USBDevEndpointStatusClear(psInst->ui32USBBase,
+                                              psInst->ui8BulkOUTEndpoint,
+                                              ui32EPStatus);
+
+                //
+                // Acknowledge the data, thus freeing the host to send the
+                // next packet.
+                //
+                MAP_USBDevEndpointDataAck(psInst->ui32USBBase,
+                                          psInst->ui8BulkOUTEndpoint,
+                                          true);
+
+                //
+                // Clear the flag we set to indicate that a packet read is
+                // pending.
+                //
+                SetDeferredOpFlag(&psInst->ui16DeferredOpFlags,
+                                  CDC_DO_PACKET_RX, false);
+
+            }
+
+            //
+            // If all went well, tell the caller how many bytes they got.
+            //
+            if(i32Retcode != -1)
+            {
+                return(ui32Count);
+            }
+        }
+    }
+
+    //
+    // No packet was available or an error occurred while reading so tell
+    // the caller no bytes were returned.
+    //
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! Returns the number of free bytes in the transmit buffer.
+//!
+//! \param pvCDCDevice is the pointer to the device instance structure as
+//! returned by USBDCDCInit().
+//!
+//! This function returns the maximum number of bytes that can be passed on a
+//! call to USBDCDCPacketWrite() and accepted for transmission.  The value
+//! returned will be the maximum USB packet size if no transmission is
+//! currently outstanding or 0 if a transmission is in progress.
+//!
+//! \return Returns the number of bytes available in the transmit buffer.
+//
+//*****************************************************************************
+uint32_t
+USBDCDCTxPacketAvailable(void *pvCDCDevice)
+{
+    tCDCSerInstance *psInst;
+
+    ASSERT(pvCDCDevice);
+
+    //
+    // Get a pointer to the CDC device instance data pointer
+    //
+    psInst = &((tUSBDCDCDevice *)pvCDCDevice)->sPrivateData;
+
+    //
+    // Do we have a packet transmission currently ongoing?
+    //
+    if(psInst->iCDCTxState != eCDCStateIdle)
+    {
+        //
+        // We are not ready to receive a new packet so return 0.
+        //
+        return(0);
+    }
+    else
+    {
+        //
+        // We can receive a packet so return the max packet size for the
+        // relevant endpoint.
+        //
+        return(DATA_IN_EP_MAX_SIZE);
+    }
+}
+
+//*****************************************************************************
+//
+//! Determines whether a packet is available and, if so, the size of the
+//! buffer required to read it.
+//!
+//! \param pvCDCDevice is the pointer to the device instance structure as
+//! returned by USBDCDCInit().
+//!
+//! This function may be used to determine if a received packet remains to be
+//! read and allows the application to determine the buffer size needed to
+//! read the data.
+//!
+//! \return Returns 0 if no received packet remains unprocessed or the
+//! size of the packet if a packet is waiting to be read.
+//
+//*****************************************************************************
+uint32_t
+USBDCDCRxPacketAvailable(void *pvCDCDevice)
+{
+    uint32_t ui32EPStatus, ui32Size;
+    tCDCSerInstance *psInst;
+
+    ASSERT(pvCDCDevice);
+
+    //
+    // Get a pointer to the CDC device instance data pointer
+    //
+    psInst = &((tUSBDCDCDevice *)pvCDCDevice)->sPrivateData;
+
+    //
+    // If receive is currently blocked, return 0.
+    //
+    if(psInst->bRxBlocked || psInst->bControlBlocked)
+    {
+        return(0);
+    }
+
+    //
+    // Does the relevant endpoint FIFO have a packet waiting for us?
+    //
+    ui32EPStatus = MAP_USBEndpointStatus(psInst->ui32USBBase,
+                                         psInst->ui8BulkOUTEndpoint);
+
+    if(ui32EPStatus & USB_DEV_RX_PKT_RDY)
+    {
+        //
+        // Yes - a packet is waiting.  How big is it?
+        //
+        ui32Size = MAP_USBEndpointDataAvail(psInst->ui32USBBase,
+                                            psInst->ui8BulkOUTEndpoint);
+
+        return(ui32Size);
+    }
+    else
+    {
+        //
+        // There is no packet waiting to be received.
+        //
+        return(0);
+    }
+}
+
+//*****************************************************************************
+//
+//! Informs the CDC module of changes in the serial control line states or
+//! receive error conditions.
+//!
+//! \param pvCDCDevice is the pointer to the device instance structure as
+//! returned by USBDCDCInit().
+//! \param ui16State indicates the states of the various control lines and
+//! any receive errors detected.  Bit definitions are as for the USB CDC
+//! SerialState asynchronous notification and are defined in header file
+//! usbcdc.h.
+//!
+//! The application should call this function whenever the state of any of
+//! the incoming RS232 handshake signals changes or in response to a receive
+//! error or break condition.  The \e ui16State parameter is the ORed
+//! combination of the following flags with each flag indicating the presence
+//! of that condition.
+//!
+//! - USB_CDC_SERIAL_STATE_OVERRUN
+//! - USB_CDC_SERIAL_STATE_PARITY
+//! - USB_CDC_SERIAL_STATE_FRAMING
+//! - USB_CDC_SERIAL_STATE_RING_SIGNAL
+//! - USB_CDC_SERIAL_STATE_BREAK
+//! - USB_CDC_SERIAL_STATE_TXCARRIER
+//! - USB_CDC_SERIAL_STATE_RXCARRIER
+//!
+//! This function should be called only when the state of any flag changes.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBDCDCSerialStateChange(void *pvCDCDevice, uint16_t ui16State)
+{
+    tCDCSerInstance *psInst;
+
+    ASSERT(pvCDCDevice);
+
+    //
+    // Get a pointer to the CDC device instance data pointer
+    //
+    psInst = &((tUSBDCDCDevice *)pvCDCDevice)->sPrivateData;
+
+    //
+    // Add the newly reported state bits to the current collection.  We do this
+    // in case two state changes occur back-to-back before the first has been
+    // notified.  There are two distinct types of signals that we report here
+    // and we deal with them differently:
+    //
+    // 1.  Errors (overrun, parity, framing error) are ORed together so that
+    //     any reported error is sent on the next notification.
+    // 2.  Signal line states (RI, break, TX carrier, RX carrier) always
+    //     report the last state notified to us.  The implementation here will
+    //     send an interrupt showing the last state but, if two state changes
+    //     occur very quickly, the host may receive a notification containing
+    //     the same state that was last reported (in other words, a short pulse
+    //     will be lost).  It would be possible to reduce the likelihood of
+    //     this happening by building a queue of state changes and sending
+    //     these in order but you are left with exactly the same problem if the
+    //     queue fills up.  For now, therefore, we run the risk of missing very
+    //     short pulses on the "steady-state" signal lines.
+    //
+    psInst->ui16SerialState |= (ui16State & USB_CDC_SERIAL_ERRORS);
+    psInst->ui16SerialState &= ~USB_CDC_SERIAL_ERRORS;
+    psInst->ui16SerialState |= (ui16State & ~USB_CDC_SERIAL_ERRORS);
+
+    //
+    // Set the flag indicating that a serial state change is to be sent.
+    //
+    SetDeferredOpFlag(&psInst->ui16DeferredOpFlags, CDC_DO_SERIAL_STATE_CHANGE,
+                      true);
+
+    //
+    // Can we send the state change immediately?
+    //
+    if(psInst->iCDCInterruptState == eCDCStateIdle)
+    {
+        //
+        // The interrupt channel is free so send the notification immediately.
+        // If we can't do this, the tick timer will catch this next time
+        // round.
+        //
+        psInst->iCDCInterruptState = eCDCStateWaitData;
+        SendSerialState(pvCDCDevice);
+    }
+
+    return;
+}
+#ifndef DEPRECATED
+
+//*****************************************************************************
+//
+//! Reports the device power status (bus- or self-powered) to the USB library.
+//!
+//! \param pvCDCDevice is the pointer to the CDC device instance structure.
+//! \param ui8Power indicates the current power status, either \b
+//! USB_STATUS_SELF_PWR or \b USB_STATUS_BUS_PWR.
+//!
+//! Applications which support switching between bus- or self-powered
+//! operation should call this function whenever the power source changes
+//! to indicate the current power status to the USB library.  This information
+//! is required by the USB library to allow correct responses to be provided
+//! when the host requests status from the device.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBDCDCPowerStatusSet(void *pvCDCDevice, uint8_t ui8Power)
+{
+    ASSERT(pvCDCDevice);
+
+    //
+    // Pass the request through to the lower layer.
+    //
+    USBDCDPowerStatusSet(0, ui8Power);
+}
+#endif
+
+//*****************************************************************************
+//
+//! Requests a remote wakeup to resume communication when in suspended state.
+//!
+//! \param pvCDCDevice is the pointer to the CDC device instance structure.
+//!
+//! When the bus is suspended, an application which supports remote wakeup
+//! (advertised to the host via the configuration descriptor) may call this
+//! function to initiate remote wakeup signaling to the host.  If the remote
+//! wakeup feature has not been disabled by the host, this will cause the bus
+//! to resume operation within 20mS.  If the host has disabled remote wakeup,
+//! \b false will be returned to indicate that the wakeup request was not
+//! successful.
+//!
+//! \return Returns \b true if the remote wakeup is not disabled and the
+//! signaling was started or \b false if remote wakeup is disabled or if
+//! signaling is currently ongoing following a previous call to this function.
+//
+//*****************************************************************************
+bool
+USBDCDCRemoteWakeupRequest(void *pvCDCDevice)
+{
+    ASSERT(pvCDCDevice);
+
+    //
+    // Pass the request through to the lower layer.
+    //
+    return(USBDCDRemoteWakeupRequest(0));
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
diff --git a/bsp/tm4c129x/libraries/usblib/device/usbdcdc.h b/bsp/tm4c129x/libraries/usblib/device/usbdcdc.h
new file mode 100755
index 0000000..1c6f8e3
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/device/usbdcdc.h
@@ -0,0 +1,447 @@
+//*****************************************************************************
+//
+// usbdcdc.h - USBLib support for generic CDC ACM (serial) device.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#ifndef __USBDCDC_H__
+#define __USBDCDC_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+//*****************************************************************************
+//
+//! \addtogroup cdc_device_class_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// PRIVATE
+//
+// The first few sections of this header are private defines that are used by
+// the USB CDC Serial code and are here only to help with the application
+// allocating the correct amount of memory for the CDC Serial device code.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// PRIVATE
+//
+// This enumeration holds the various states that the device can be in during
+// normal operation.
+//
+//*****************************************************************************
+typedef enum
+{
+    //
+    // Unconfigured.
+    //
+    eCDCStateUnconfigured,
+
+    //
+    // No outstanding transaction remains to be completed.
+    //
+    eCDCStateIdle,
+
+    //
+    // Waiting on completion of a send or receive transaction.
+    //
+    eCDCStateWaitData,
+
+    //
+    // Waiting for client to process data.
+    //
+    eCDCStateWaitClient
+}
+tCDCState;
+
+//*****************************************************************************
+//
+// PRIVATE
+//
+// This structure defines the private instance data and state variables for the
+// CDC Serial device.  The memory for this structure is allocated in the
+// tUSBDCDCDevice structure passed on USBDCDCInit().
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    // Base address for the USB controller.
+    //
+    uint32_t ui32USBBase;
+
+    //
+    // The device info to interact with the lower level DCD code.
+    //
+    tDeviceInfo sDevInfo;
+
+    //
+    // The state of the serial receive state.
+    //
+    volatile tCDCState iCDCRxState;
+
+    //
+    // The state of the serial transmit state.
+    //
+    volatile tCDCState iCDCTxState;
+
+    //
+    // The state of the serial request state.
+    //
+    volatile tCDCState iCDCRequestState;
+
+    //
+    // The state of the serial interrupt state.
+    //
+    volatile tCDCState iCDCInterruptState;
+
+    //
+    // The current pending request.
+    //
+    volatile uint8_t ui8PendingRequest;
+
+    //
+    // The current break duration used during send break requests.
+    //
+    uint16_t ui16BreakDuration;
+
+    //
+    // The current line control state for the serial port.
+    //
+    uint16_t ui16ControlLineState;
+
+    //
+    // The general serial state.
+    //
+    uint16_t ui16SerialState;
+
+    //
+    // State of any pending operations that could not be handled immediately
+    // upon receipt.
+    //
+    volatile uint16_t ui16DeferredOpFlags;
+
+    //
+    // Size of the last transmit.
+    //
+    uint16_t ui16LastTxSize;
+
+    //
+    // The current serial line coding.
+    //
+    tLineCoding sLineCoding;
+
+    //
+    // Serial port receive is blocked.
+    //
+    volatile bool bRxBlocked;
+
+    //
+    // Serial control port is blocked.
+    //
+    volatile bool bControlBlocked;
+
+    //
+    // The connection status of the device.
+    //
+    volatile bool bConnected;
+
+    //
+    // The control endpoint number, this is modified in composite devices.
+    //
+    uint8_t ui8ControlEndpoint;
+
+    //
+    // The IN endpoint number, this is modified in composite devices.
+    //
+    uint8_t ui8BulkINEndpoint;
+
+    //
+    // The OUT endpoint number, this is modified in composite devices.
+    //
+    uint8_t ui8BulkOUTEndpoint;
+
+    //
+    // The interface number for the control interface, this is modified in
+    // composite devices.
+    //
+    uint8_t ui8InterfaceControl;
+
+    //
+    // The interface number for the data interface, this is modified in
+    // composite devices.
+    //
+    uint8_t ui8InterfaceData;
+}
+tCDCSerInstance;
+
+//*****************************************************************************
+//
+// The following defines are used when working with composite devices.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// This is the size of the g_pui8IADSerDescriptor array in bytes.
+//
+//*****************************************************************************
+#define SERDESCRIPTOR_SIZE      (8)
+
+//*****************************************************************************
+//
+// This is the size of the g_pui8CDCSerCommInterface array in bytes.
+//
+//*****************************************************************************
+#define SERCOMMINTERFACE_SIZE   (35)
+
+//*****************************************************************************
+//
+// This is the size of the g_pui8CDCSerDataInterface array in bytes.
+//
+//*****************************************************************************
+#define SERDATAINTERFACE_SIZE    (23)
+
+//*****************************************************************************
+//
+//! The size of the memory that should be allocated to create a configuration
+//! descriptor for a single instance of the USB Serial CDC Device.
+//! This does not include the configuration descriptor which is automatically
+//! ignored by the composite device class.
+//
+//*****************************************************************************
+#define COMPOSITE_DCDC_SIZE     (SERDESCRIPTOR_SIZE + SERCOMMINTERFACE_SIZE + \
+                                 SERDATAINTERFACE_SIZE)
+
+//*****************************************************************************
+//
+// CDC-specific events These events are provided to the application in the
+// \e ui32Msg parameter of the tUSBCallback function.
+//
+//*****************************************************************************
+
+//
+//! The host requests that the device send a BREAK condition on its
+//! serial communication channel.  The BREAK should remain active until
+//! a USBD_CDC_EVENT_CLEAR_BREAK event is received.
+//
+#define USBD_CDC_EVENT_SEND_BREAK (USBD_CDC_EVENT_BASE + 0)
+
+//
+//! The host requests that the device stop sending a BREAK condition on its
+//! serial communication channel.
+//
+#define USBD_CDC_EVENT_CLEAR_BREAK (USBD_CDC_EVENT_BASE + 1)
+
+//
+//! The host requests that the device set the RS232 signaling lines to
+//! a particular state.  The ui32MsgValue parameter contains the RTS and
+//! DTR control line states as defined in table 51 of the USB CDC class
+//! definition and is a combination of the following values:
+//!
+//! (RTS) USB_CDC_DEACTIVATE_CARRIER or USB_CDC_ACTIVATE_CARRIER
+//! (DTR) USB_CDC_DTE_NOT_PRESENT or USB_CDC_DTE_PRESENT
+//
+#define USBD_CDC_EVENT_SET_CONTROL_LINE_STATE (USBD_CDC_EVENT_BASE + 2)
+
+//
+//! The host requests that the device set the RS232 communication
+//! parameters.  The pvMsgData parameter points to a tLineCoding structure
+//! defining the required number of bits per character, parity mode,
+//! number of stop bits and the baud rate.
+//
+#define USBD_CDC_EVENT_SET_LINE_CODING (USBD_CDC_EVENT_BASE + 3)
+
+//
+//! The host is querying the current RS232 communication parameters.  The
+//! pvMsgData parameter points to a tLineCoding structure that the
+//! application must fill with the current settings prior to returning
+//! from the callback.
+//
+#define USBD_CDC_EVENT_GET_LINE_CODING (USBD_CDC_EVENT_BASE + 4)
+
+//*****************************************************************************
+//
+//! The structure used by the application to define operating parameters for
+//! the CDC device.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The vendor ID that this device is to present in the device descriptor.
+    //
+    const uint16_t ui16VID;
+
+    //
+    //! The product ID that this device is to present in the device descriptor.
+    //
+    const uint16_t ui16PID;
+
+    //
+    //! The maximum power consumption of the device, expressed in milliamps.
+    //
+    const uint16_t ui16MaxPowermA;
+
+    //
+    //! Indicates whether the device is self- or bus-powered and whether or not
+    //! it supports remote wakeup.  Valid values are USB_CONF_ATTR_SELF_PWR or
+    //! USB_CONF_ATTR_BUS_PWR, optionally ORed with USB_CONF_ATTR_RWAKE.
+    //
+    const uint8_t ui8PwrAttributes;
+
+    //
+    //! A pointer to the callback function which will be called to notify
+    //! the application of all asynchronous control events related to the
+    //! operation of the device.
+    //
+    const tUSBCallback pfnControlCallback;
+
+    //
+    //! A client-supplied pointer which will be sent as the first
+    //! parameter in all calls made to the control channel callback,
+    //! pfnControlCallback.
+    //
+    void *pvControlCBData;
+
+    //
+    //! A pointer to the callback function which will be called to notify
+    //! the application of events related to the device's data receive channel.
+    //
+    const tUSBCallback pfnRxCallback;
+
+    //
+    //! A client-supplied pointer which will be sent as the first
+    //! parameter in all calls made to the receive channel callback,
+    //! pfnRxCallback.
+    //
+    void *pvRxCBData;
+
+    //
+    //! A pointer to the callback function which will be called to notify
+    //! the application of events related to the device's data transmit
+    //! channel.
+    //
+    const tUSBCallback pfnTxCallback;
+
+    //
+    //! A client-supplied pointer which will be sent as the first
+    //! parameter in all calls made to the transmit channel callback,
+    //! pfnTxCallback.
+    //
+    void *pvTxCBData;
+
+    //
+    //! A pointer to the string descriptor array for this device.  This array
+    //! must contain the following string descriptor pointers in this order.
+    //! Language descriptor, Manufacturer name string (language 1), Product
+    //! name string (language 1), Serial number string (language 1),
+    //! Control interface description string (language 1), Configuration
+    //! description string (language 1).
+    //!
+    //! If supporting more than 1 language, the strings for indices 1 through 5
+    //! must be repeated for each of the other languages defined in the
+    //! language descriptor.
+    //
+    const uint8_t * const *ppui8StringDescriptors;
+
+    //
+    //! The number of descriptors provided in the ppStringDescriptors
+    //! array.  This must be 1 + (5 * number of supported languages).
+    //
+    const uint32_t ui32NumStringDescriptors;
+
+    //
+    //! The private instance data for this device.  This memory
+    //! must remain accessible for as long as the CDC device is in use and
+    //! must not be modified by any code outside the CDC class driver.
+    //
+    tCDCSerInstance sPrivateData;
+}
+tUSBDCDCDevice;
+
+//*****************************************************************************
+//
+// API Function Prototypes
+//
+//*****************************************************************************
+extern void *USBDCDCCompositeInit(uint32_t ui32Index,
+                                  tUSBDCDCDevice *psCDCDevice,
+                                  tCompositeEntry *psCompEntry);
+extern void *USBDCDCInit(uint32_t ui32Index,
+                         tUSBDCDCDevice *psCDCDevice);
+extern void USBDCDCTerm(void *pvCDCDevice);
+extern void *USBDCDCSetControlCBData(void *pvCDCDevice, void *pvCBData);
+extern void *USBDCDCSetRxCBData(void *pvCDCDevice, void *pvCBData);
+extern void *USBDCDCSetTxCBData(void *pvCDCDevice, void *pvCBData);
+extern uint32_t USBDCDCPacketWrite(void *pvCDCDevice, uint8_t *pi8Data,
+                                   uint32_t ui32Length, bool bLast);
+extern uint32_t USBDCDCPacketRead(void *pvCDCDevice, uint8_t *pi8Data,
+                                  uint32_t ui32Length, bool bLast);
+extern uint32_t USBDCDCTxPacketAvailable(void *pvCDCDevice);
+extern uint32_t USBDCDCRxPacketAvailable(void *pvCDCDevice);
+extern void USBDCDCSerialStateChange(void *pvCDCDevice, uint16_t ui16State);
+extern bool USBDCDCRemoteWakeupRequest(void *pvCDCDevice);
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// The following APIs are deprecated.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+
+//
+// Use USBDCDFeatureSet() or USBHCDFeatureSet() with \b USBLIB_FEATURE_POWER
+// configuration option.
+//
+extern void USBDCDCPowerStatusSet(void *pvCDCDevice, uint8_t ui8Power);
+#endif
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __USBDCDC_H__
diff --git a/bsp/tm4c129x/libraries/usblib/device/usbdcdesc.c b/bsp/tm4c129x/libraries/usblib/device/usbdcdesc.c
new file mode 100755
index 0000000..c9614a2
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/device/usbdcdesc.c
@@ -0,0 +1,643 @@
+//*****************************************************************************
+//
+// usbcdesc.c - Config descriptor parsing functions.
+//
+// Copyright (c) 2007-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "inc/hw_types.h"
+#include "driverlib/debug.h"
+#include "driverlib/usb.h"
+#include "usblib/usblib.h"
+#include "usblib/usblibpriv.h"
+#include "usblib/device/usbdevice.h"
+
+//*****************************************************************************
+//
+// The functions in this file mirror the descriptor parsing APIs available
+// in usblib.h but parse configuration descriptors defined in terms of a list
+// of sections rather than as a single block of descriptor data.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! \addtogroup device_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! \internal
+//!
+//! Walk to the next descriptor after the supplied one within a section-based
+//! config descriptor.
+//!
+//! \param psConfig points to the header structure for the configuration
+//! descriptor which contains \e pi16Desc.
+//! \param pui32Sec points to a variable containing the section within
+//! \e psConfig which contains \e pi16Desc.
+//! \param pi16Desc points to the descriptor that we want to step past.
+//!
+//! This function walks forward one descriptor within a configuration
+//! descriptor.  The value returned is a pointer to the header of the next
+//! descriptor after the descriptor supplied in \e pi16Desc.  If the next
+//! descriptor is in the next section, \e *pui32Sec will be incremented
+//! accordingly.
+//!
+//! \return Returns a pointer to the next descriptor in the configuration
+//! descriptor.
+//
+//*****************************************************************************
+static tDescriptorHeader *
+NextConfigDescGet(const tConfigHeader *psConfig, uint32_t *pui32Sec,
+                  tDescriptorHeader *psDesc)
+{
+    //
+    // Determine where the next descriptor after the supplied one should be
+    // assuming it is within the current section.
+    //
+    psDesc = NEXT_USB_DESCRIPTOR(psDesc);
+
+    //
+    // Did we run off the end of the section?
+    //
+    if((uint8_t *)psDesc >= (psConfig->psSections[*pui32Sec]->pui8Data +
+                             psConfig->psSections[*pui32Sec]->ui16Size))
+    {
+        //
+        // Yes - move to the next section.
+        //
+        (*pui32Sec)++;
+
+        //
+        // Are we still within the configuration descriptor?
+        //
+        if(*pui32Sec < psConfig->ui8NumSections)
+        {
+            //
+            // Yes - the new descriptor is at the start of the new section.
+            //
+            psDesc =
+                (tDescriptorHeader *)psConfig->psSections[*pui32Sec]->pui8Data;
+        }
+        else
+        {
+            //
+            // No - we ran off the end of the descriptor so return NULL.
+            //
+            psDesc = (tDescriptorHeader *)0;
+        }
+    }
+
+    //
+    // Return the new descriptor pointer.
+    //
+    return(psDesc);
+}
+
+//*****************************************************************************
+//
+//! \internal
+//!
+//! Returns a pointer to the n-th interface descriptor in a configuration
+//! descriptor with the supplied interface number.
+//!
+//! \param psConfig points to the header structure for the configuration
+//! descriptor to search.
+//! \param ui8InterfaceNumber is the interface number of the descriptor to
+//! query.
+//! \param ui32Index is the zero based index of the descriptor.
+//! \param pui32Section points to storage which is written with the index
+//! of the section containing the returned descriptor.
+//!
+//! This function returns a pointer to the n-th interface descriptor in the
+//! supplied configuration which has the requested interface number.  It may be
+//! used by a client to retrieve the descriptors for each alternate setting
+//! of a given interface within the configuration passed.
+//!
+//! \return Returns a pointer to the n-th interface descriptor with interface
+//! number as specified or NULL of this descriptor does not exist.
+//
+//*****************************************************************************
+static tInterfaceDescriptor *
+ConfigAlternateInterfaceGet(const tConfigHeader *psConfig,
+                            uint8_t ui8InterfaceNumber, uint32_t ui32Index,
+                            uint32_t *pui32Section)
+{
+    tDescriptorHeader *psDescCheck;
+    uint32_t ui32Count, ui32Sec;
+
+    //
+    // Set up for our descriptor counting loop.
+    //
+    psDescCheck = (tDescriptorHeader *)psConfig->psSections[0]->pui8Data;
+    ui32Count = 0;
+    ui32Sec = 0;
+
+    //
+    // Keep looking through the supplied data until we reach the end.
+    //
+    while(psDescCheck)
+    {
+        //
+        // Does this descriptor match the type passed (if a specific type
+        // has been specified)?
+        //
+        if((psDescCheck->bDescriptorType == USB_DTYPE_INTERFACE) &&
+            (((tInterfaceDescriptor *)psDescCheck)->bInterfaceNumber ==
+             ui8InterfaceNumber))
+        {
+            //
+            // This is an interface descriptor for interface
+            // ui8InterfaceNumber.  Determine if this is the n-th one we have
+            // found and, if so, return its pointer.
+            //
+            if(ui32Count == ui32Index)
+            {
+                //
+                // Found it - return the pointer and section number.
+                //
+                *pui32Section = ui32Sec;
+                return((tInterfaceDescriptor *)psDescCheck);
+            }
+
+            //
+            // Increment our count of matching descriptors found and go back
+            // to look for another since we have not yet reached the n-th
+            // match.
+            //
+            ui32Count++;
+        }
+
+        //
+        // Move on to the next descriptor.
+        //
+        psDescCheck = NextConfigDescGet(psConfig, &ui32Sec, psDescCheck);
+    }
+
+    //
+    // If we drop out the end of the loop, we did not find the requested
+    // descriptor so return NULL.
+    //
+    return((tInterfaceDescriptor *)0);
+}
+
+//*****************************************************************************
+//
+//! \internal
+//!
+//! Determines the total length of a configuration descriptor defined in terms
+//! of a collection of concatenated sections.
+//!
+//! \param psConfig points to the header structure for the configuration
+//! descriptor whose size is to be determined.
+//!
+//! \return Returns the number of bytes in the configuration descriptor will
+//! result from concatenating the required sections.
+//
+//*****************************************************************************
+uint32_t
+USBDCDConfigDescGetSize(const tConfigHeader *psConfig)
+{
+    uint32_t ui32Loop, ui32Len;
+
+    ui32Len = 0;
+
+    //
+    // Determine the size of the whole descriptor by adding the sizes of
+    // each section which will be concatenated to produce it.
+    //
+    for(ui32Loop = 0; ui32Loop < psConfig->ui8NumSections; ui32Loop++)
+    {
+        ui32Len += psConfig->psSections[ui32Loop]->ui16Size;
+    }
+
+    return(ui32Len);
+}
+
+//*****************************************************************************
+//
+//! \internal
+//!
+//! Determines the number of individual descriptors of a particular type within
+//! a supplied configuration descriptor.
+//!
+//! \param psConfig points to the header structure for the configuration
+//! descriptor that is to be searched.
+//! \param ui32Type identifies the type of descriptor that is to be counted.
+//! If the value is \b USB_DESC_ANY, the function returns the total number of
+//! descriptors regardless of type.
+//!
+//! This function can be used to count the number of descriptors of a
+//! particular type within a configuration descriptor.  The caller can provide
+//! a specific type value which the function matches against the second byte
+//! of each descriptor or, alternatively, can specify \b USB_DESC_ANY to have
+//! the function count all descriptors regardless of their type.
+//!
+//! The search performed by this function traverses through the list of
+//! sections comprising the configuration descriptor.  Note that the similar
+//! top-level function, USBDescGetNum(), searches through a single, contiguous
+//! block of data to perform the same enumeration.
+//!
+//! \return Returns the number of descriptors found in the supplied block of
+//! data.
+//
+//*****************************************************************************
+uint32_t
+USBDCDConfigDescGetNum(const tConfigHeader *psConfig, uint32_t ui32Type)
+{
+    uint32_t ui32Section, ui32NumDescs;
+
+    //
+    // Initialize our counts.
+    //
+    ui32NumDescs = 0;
+
+    //
+    // Determine the number of descriptors of the given type in each of the
+    // sections comprising the configuration descriptor.  Note that this
+    // assumes each section contains only whole descriptors!
+    //
+    for(ui32Section = 0; ui32Section < (uint32_t)psConfig->ui8NumSections;
+        ui32Section++)
+    {
+        ui32NumDescs += USBDescGetNum(
+            (tDescriptorHeader *)psConfig->psSections[ui32Section]->pui8Data,
+            psConfig->psSections[ui32Section]->ui16Size, ui32Type);
+    }
+
+    return(ui32NumDescs);
+}
+
+//*****************************************************************************
+//
+//! \internal
+//!
+//! Finds the n-th descriptor of a particular type within the supplied
+//! configuration descriptor.
+//!
+//! \param psConfig points to the header structure for the configuration
+//! descriptor that is to be searched.
+//! \param ui32Type identifies the type of descriptor that is to be found.  If
+//! the value is \b USB_DESC_ANY, the function returns a pointer to the n-th
+//! descriptor regardless of type.
+//! \param ui32Index is the zero based index of the descriptor whose pointer is
+//! to be returned.  For example, passing value 1 in \e ui32Index returns the
+//! second matching descriptor.
+//! \param pui32Section points to storage which will receive the section index
+//! containing the requested descriptor.
+//!
+//! Return a pointer to the n-th descriptor of a particular type found in the
+//! configuration descriptor passed.
+//!
+//! The search performed by this function traverses through the list of
+//! sections comprising the configuration descriptor.  Note that the similar
+//! top-level function, USBDescGet(), searches through a single, contiguous
+//! block of data to perform the same enumeration.
+//!
+//! \return Returns a pointer to the header of the required descriptor if
+//! found or NULL otherwise.
+//
+//*****************************************************************************
+tDescriptorHeader *
+USBDCDConfigDescGet(const tConfigHeader *psConfig, uint32_t ui32Type,
+                    uint32_t ui32Index, uint32_t *pui32Section)
+{
+    uint32_t ui32Section, ui32TotalDescs, ui32NumDescs;
+
+    //
+    // Initialize our counts.
+    //
+    ui32TotalDescs = 0;
+
+    //
+    // Determine the number of descriptors of the given type in each of the
+    // sections comprising the configuration descriptor.  This allows us to
+    // determine which section contains the descriptor we are being asked for.
+    //
+    for(ui32Section = 0; ui32Section < (uint32_t)psConfig->ui8NumSections;
+        ui32Section++)
+    {
+        //
+        // How many descriptors of the requested type exist in this section?
+        //
+        ui32NumDescs = USBDescGetNum(
+            (tDescriptorHeader *)psConfig->psSections[ui32Section]->pui8Data,
+            psConfig->psSections[ui32Section]->ui16Size, ui32Type);
+
+        //
+        // Does this section contain the descriptor whose index we are looking
+        // for?
+        //
+        if((ui32TotalDescs + ui32NumDescs) > ui32Index)
+        {
+            //
+            // We know the requested descriptor exists in the current
+            // block so write the section number to the caller's storage.
+            //
+            *pui32Section = ui32Section;
+
+            //
+            // Now find the actual descriptor requested and return its pointer.
+            //
+            return(USBDescGet(
+              (tDescriptorHeader *)psConfig->psSections[ui32Section]->pui8Data,
+               psConfig->psSections[ui32Section]->ui16Size,
+               ui32Type, ui32Index - ui32TotalDescs));
+        }
+
+        //
+        // We have not found the required descriptor yet.  Update our running
+        // count of the number of type matches found so far then move on to
+        // the next section.
+        //
+        ui32TotalDescs += ui32NumDescs;
+    }
+
+    //
+    // If we drop out of the loop, we can't find the requested descriptor
+    // so return NULL.
+    //
+    return((tDescriptorHeader *)0);
+}
+
+//*****************************************************************************
+//
+//! \internal
+//!
+//! Determines the number of different alternate configurations for a given
+//! interface within a configuration descriptor.
+//!
+//! \param psConfig points to the header structure for the configuration
+//! descriptor that is to be searched.
+//! \param ui8InterfaceNumber is the interface number for which the number of
+//! alternate configurations is to be counted.
+//!
+//! This function can be used to count the number of alternate settings for a
+//! specific interface within a configuration.
+//!
+//! The search performed by this function traverses through the list of
+//! sections comprising the configuration descriptor.  Note that the similar
+//! top-level function, USBDescGetNumAlternateInterfaces(), searches through
+//! a single, contiguous block of data to perform the same enumeration.
+//!
+//! \return Returns the number of alternate versions of the specified interface
+//! or 0 if the interface number supplied cannot be found in the configuration
+//! descriptor.
+//
+//*****************************************************************************
+uint32_t
+USBDCDConfigGetNumAlternateInterfaces(const tConfigHeader *psConfig,
+                                      uint8_t ui8InterfaceNumber)
+{
+    tDescriptorHeader *psDescCheck;
+    uint32_t ui32Count, ui32Sec;
+
+    //
+    // Set up for our descriptor counting loop.
+    //
+    psDescCheck = (tDescriptorHeader *)psConfig->psSections[0]->pui8Data;
+    ui32Sec = 0;
+    ui32Count = 0;
+
+    //
+    // Keep looking through the supplied data until we reach the end.
+    //
+    while(psDescCheck)
+    {
+        //
+        // Is this an interface descriptor with the required interface number?
+        //
+        if((psDescCheck->bDescriptorType == USB_DTYPE_INTERFACE) &&
+            (((tInterfaceDescriptor *)psDescCheck)->bInterfaceNumber ==
+             ui8InterfaceNumber))
+        {
+            //
+            // Yes - increment our count.
+            //
+            ui32Count++;
+        }
+
+        //
+        // Move on to the next descriptor.
+        //
+        psDescCheck = NextConfigDescGet(psConfig, &ui32Sec, psDescCheck);
+    }
+
+    //
+    // Return the descriptor count to the caller.
+    //
+    return(ui32Count);
+}
+
+//*****************************************************************************
+//
+//! \internal
+//!
+//! Returns a pointer to the n-th interface descriptor in a configuration
+//! descriptor that applies to the supplied alternate setting number.
+//!
+//! \param psConfig points to the header structure for the configuration
+//! descriptor that is to be searched.
+//! \param ui32Index is the zero based index of the interface that is to be
+//! found.  If \e ui32Alt is set to a value other than \b USB_DESC_ANY, this
+//! is equivalent to the interface number being searched for.
+//! \param ui32Alt is the alternate setting number which is to be
+//! searched for.  If this value is \b USB_DESC_ANY, the alternate setting
+//! is ignored and all interface descriptors are considered in the search.
+//! \param pui32Section points to storage which will receive the index of the
+//! config descriptor section which contains the requested interface
+//! descriptor.
+//!
+//! Return a pointer to the n-th interface descriptor found in the supplied
+//! configuration descriptor.  If \e ui32Alt is not \b USB_DESC_ANY, only
+//! interface descriptors which are part of the supplied alternate setting are
+//! considered in the search otherwise all interface descriptors are
+//! considered.
+//!
+//! Note that, although alternate settings can be applied on an interface-by-
+//! interface basis, the number of interfaces offered is fixed for a given
+//! config descriptor.  Hence, this function will correctly find the unique
+//! interface descriptor for that interface's alternate setting number \e
+//! ui32Alt if \e ui32Index is set to the required interface number and
+//! \e ui32Alt is set to a valid alternate setting number for that interface.
+//!
+//! The search performed by this function traverses through the list of
+//! sections comprising the configuration descriptor.  Note that the similar
+//! top-level function, USBDescGetInterface(), searches through a single,
+//! contiguous block of data to perform the same enumeration.
+//!
+//! \return Returns a pointer to the required interface descriptor if
+//! found or NULL otherwise.
+//
+//*****************************************************************************
+tInterfaceDescriptor *
+USBDCDConfigGetInterface(const tConfigHeader *psConfig, uint32_t ui32Index,
+                         uint32_t ui32Alt, uint32_t *pui32Section)
+{
+    //
+    // If we are being told to ignore the alternate configuration, this boils
+    // down to a very simple query.
+    //
+    if(ui32Alt == USB_DESC_ANY)
+    {
+        //
+        // Return the ui32Index-th interface descriptor we find in the
+        // configuration descriptor.
+        //
+        return((tInterfaceDescriptor *)USBDCDConfigDescGet(psConfig,
+                                                           USB_DTYPE_INTERFACE,
+                                                           ui32Index,
+                                                           pui32Section));
+    }
+    else
+    {
+        //
+        // In this case, a specific alternate setting number is required.
+        // Given that interface numbers are zero based indices, we can
+        // pass the supplied ui32Index parameter directly as the interface
+        // number to USBDescGetAlternateInterface() to retrieve the requested
+        // interface descriptor pointer.
+        //
+        return(ConfigAlternateInterfaceGet(psConfig, ui32Index, ui32Alt,
+                                           pui32Section));
+    }
+}
+
+//*****************************************************************************
+//
+//! \internal
+//!
+//! Return a pointer to the n-th endpoint descriptor in a particular interface
+//! within a configuration descriptor.
+//!
+//! \param psConfig points to the header structure for the configuration
+//! descriptor that is to be searched.
+//! \param ui32InterfaceNumber is the interface number whose endpoint is to be
+//! found.
+//! \param ui32AltCfg is the alternate setting number which is to be searched
+//! for.  This must be a valid alternate setting number for the requested
+//! interface.
+//! \param ui32Index is the zero based index of the endpoint that is to be
+//! found within the appropriate alternate setting for the interface.
+//!
+//! Return a pointer to the n-th endpoint descriptor found in the supplied
+//! interface descriptor.  If the \e ui32Index parameter is invalid (greater
+//! than or equal to the bNumEndpoints field of the interface descriptor) or
+//! the endpoint descriptor cannot be found, the function will return NULL.
+//!
+//! The search performed by this function traverses through the list of
+//! sections comprising the configuration descriptor.  Note that the similar
+//! top-level function, USBDescGetInterfaceEndpoint(), searches through a
+//! single, contiguous block of data to perform the same enumeration.
+//!
+//! \return Returns a pointer to the requested endpoint descriptor if
+//! found or NULL otherwise.
+//
+//*****************************************************************************
+tEndpointDescriptor *
+USBDCDConfigGetInterfaceEndpoint(const tConfigHeader *psConfig,
+                                 uint32_t ui32InterfaceNumber,
+                                 uint32_t ui32AltCfg, uint32_t ui32Index)
+{
+    tInterfaceDescriptor *psInterface;
+    tDescriptorHeader *psEndpoint;
+    uint32_t ui32Section, ui32Count;
+
+    //
+    // Find the requested interface descriptor.
+    //
+    psInterface = USBDCDConfigGetInterface(psConfig, ui32InterfaceNumber,
+                                           ui32AltCfg, &ui32Section);
+
+    //
+    // Did we find the requested interface?
+    //
+    if(psInterface)
+    {
+        //
+        // Is the index passed valid?
+        //
+        if(ui32Index >= psInterface->bNumEndpoints)
+        {
+            //
+            // It's out of bounds so return a NULL.
+            //
+            return((tEndpointDescriptor *)0);
+        }
+        else
+        {
+            //
+            // Endpoint index is valid so find the descriptor.  We start from
+            // the interface descriptor and look for following endpoint
+            // descriptors.
+            //
+            ui32Count = 0;
+            psEndpoint = (tDescriptorHeader *)psInterface;
+
+            while(psEndpoint)
+            {
+                if(psEndpoint->bDescriptorType == USB_DTYPE_ENDPOINT)
+                {
+                    //
+                    // We found an endpoint descriptor.  Have we reached the
+                    // one we want?
+                    //
+                    if(ui32Count == ui32Index)
+                    {
+                        //
+                        // Yes - return the descriptor pointer to the caller.
+                        //
+                        return((tEndpointDescriptor *)psEndpoint);
+                    }
+
+                    //
+                    // Move on to look for the next endpoint.
+                    //
+                    ui32Count++;
+                }
+
+                //
+                // Move to the next descriptor.
+                //
+                psEndpoint = NextConfigDescGet(psConfig, &ui32Section,
+                                               psEndpoint);
+            }
+        }
+    }
+
+    //
+    // We could not find the requested interface or we got to the end of the
+    // descriptor without finding the requested endpoint.
+    //
+    return((tEndpointDescriptor *)0);
+
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
diff --git a/bsp/tm4c129x/libraries/usblib/device/usbdcomp.c b/bsp/tm4c129x/libraries/usblib/device/usbdcomp.c
new file mode 100755
index 0000000..3e2de28
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/device/usbdcomp.c
@@ -0,0 +1,1544 @@
+//****************************************************************************
+//
+// usbdcomp.c - USB composite device class driver.
+//
+// Copyright (c) 2010-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "inc/hw_memmap.h"
+#include "inc/hw_types.h"
+#include "driverlib/debug.h"
+#include "driverlib/sysctl.h"
+#include "driverlib/rom.h"
+#include "driverlib/rom_map.h"
+#include "driverlib/usb.h"
+#include "usblib/usblib.h"
+#include "usblib/usblibpriv.h"
+#include "usblib/usb-ids.h"
+#include "usblib/usbcdc.h"
+#include "usblib/device/usbdevice.h"
+#include "usblib/device/usbdcdc.h"
+#include "usblib/device/usbdcomp.h"
+
+//****************************************************************************
+//
+//! \addtogroup composite_device_class_api
+//! @{
+//
+//****************************************************************************
+
+//****************************************************************************
+//
+// Device Descriptor.  This is stored in RAM to allow several fields to be
+// changed at runtime based on the client's requirements.
+//
+//****************************************************************************
+static uint8_t g_pui8CompDeviceDescriptor[] =
+{
+    18,                     // Size of this structure.
+    USB_DTYPE_DEVICE,       // Type of this structure.
+    USBShort(0x110),        // USB version 1.1 (if we say 2.0, hosts assume
+                            // high-speed - see USB 2.0 spec 9.2.6.6)
+    USB_CLASS_MISC,         // USB Device Class (spec 5.1.1)
+    USB_MISC_SUBCLASS_COMMON, // USB Device Sub-class (spec 5.1.1)
+    USB_MISC_PROTOCOL_IAD,  // USB Device protocol (spec 5.1.1)
+    64,                     // Maximum packet size for default pipe.
+    USBShort(0),            // Vendor ID (filled in during USBDCompositeInit).
+    USBShort(0),            // Product ID (filled in during USBDCompositeInit).
+    USBShort(0x100),        // Device Version BCD.
+    1,                      // Manufacturer string identifier.
+    2,                      // Product string identifier.
+    3,                      // Product serial number.
+    1                       // Number of configurations.
+};
+
+//****************************************************************************
+//
+// Composite class device configuration descriptor.
+//
+// It is vital that the configuration descriptor bConfigurationValue field
+// (byte 6) is 1 for the first configuration and increments by 1 for each
+// additional configuration defined here.  This relationship is assumed in the
+// device stack for simplicity even though the USB 2.0 specification imposes
+// no such restriction on the bConfigurationValue values.
+//
+// Note that this structure is deliberately located in RAM since we need to
+// be able to patch some values in it based on client requirements.
+//
+//****************************************************************************
+static const uint8_t g_pui8CompConfigDescriptor[] =
+{
+    //
+    // Configuration descriptor header.
+    //
+    9,                          // Size of the configuration descriptor.
+    USB_DTYPE_CONFIGURATION,    // Type of this descriptor.
+    USBShort(0),                // The total size of this full structure.
+    0,                          // The number of interfaces in this
+                                // configuration, this will be filled by
+                                // the class as it discovers all classes
+                                // supported.
+    1,                          // The unique value for this configuration.
+    0,                          // The string identifier that describes this
+                                // configuration.
+    USB_CONF_ATTR_BUS_PWR,      // .
+    250,                        // The maximum power in 2mA increments.
+};
+
+//****************************************************************************
+//
+// Byte offsets used to access various fields in our index/interface/endpoint
+// lookup table (tUSBDCompositeDevice.pui32DeviceWorkspace).  This workspace
+// contains one 4 byte entry per device. The LSB is the device index, next byte
+// is the number of the first interface not within this device, next byte is
+// the number of the first IN endpoint not within this device and the final
+// byte is the number of the first OUT endpoint not within this device.  Using
+// this simple table we can reasonably quickly cross-reference index with
+// interface and endpoint numbers.
+//
+//****************************************************************************
+#define LOOKUP_INDEX_BYTE       0
+#define LOOKUP_INTERFACE_BYTE   1
+#define LOOKUP_IN_END_BYTE      2
+#define LOOKUP_OUT_END_BYTE     3
+
+//****************************************************************************
+//
+// A marker used to indicate an invalid index into the device table.
+//
+//****************************************************************************
+#define INVALID_DEVICE_INDEX    0xFFFFFFFF
+
+//****************************************************************************
+//
+// Various internal handlers needed by this class.
+//
+//****************************************************************************
+static void HandleDisconnect(void *pvCompositeInstance);
+static void InterfaceChange(void *pvCompositeInstance, uint8_t ui8InterfaceNum,
+                            uint8_t ui8AlternateSetting);
+static void ConfigChangeHandler(void *pvCompositeInstance, uint32_t ui32Value);
+static void DataSent(void *pvCompositeInstance, uint32_t ui32Info);
+static void DataReceived(void *pvCompositeInstance, uint32_t ui32Info);
+static void HandleEndpoints(void *pvCompositeInstance, uint32_t ui32Status);
+static void HandleRequests(void *pvCompositeInstance, tUSBRequest *psUSBRequest);
+static void SuspendHandler(void *pvCompositeInstance);
+static void ResumeHandler(void *pvCompositeInstance);
+static void ResetHandler(void *pvCompositeInstance);
+static void HandleDevice(void *pvCompositeInstance, uint32_t ui32Request,
+                         void *pvRequestData);
+static void GetDescriptor(void *pvCompositeInstance, tUSBRequest *psUSBRequest);
+
+//****************************************************************************
+//
+// Configuration Descriptor.
+//
+//****************************************************************************
+tConfigHeader *g_ppCompConfigDescriptors[1];
+
+//****************************************************************************
+//
+// The device information structure for the USB Composite device.
+//
+//****************************************************************************
+const tCustomHandlers g_sCompHandlers =
+{
+    //
+    // GetDescriptor
+    //
+    GetDescriptor,
+
+    //
+    // RequestHandler
+    //
+    HandleRequests,
+
+    //
+    // InterfaceChange
+    //
+    InterfaceChange,
+
+    //
+    // ConfigChange
+    //
+    ConfigChangeHandler,
+
+    //
+    // DataReceived
+    //
+    DataReceived,
+
+    //
+    // DataSentCallback
+    //
+    DataSent,
+
+    //
+    // ResetHandler
+    //
+    ResetHandler,
+
+    //
+    // SuspendHandler
+    //
+    SuspendHandler,
+
+    //
+    // ResumeHandler
+    //
+    ResumeHandler,
+
+    //
+    // DisconnectHandler
+    //
+    HandleDisconnect,
+
+    //
+    // EndpointHandler
+    //
+    HandleEndpoints,
+
+    //
+    // DeviceHandler
+    //
+    HandleDevice,
+};
+
+//****************************************************************************
+//
+// Use the lookup table from the field pui32DeviceWorkspace in the
+// tUSBDCompositeDevice structure to determine which device to call given a
+// particular composite device interface number.
+//
+// The returned value is the index into psDevice->tCompositeEntry indicating
+// the device which contains this interface or INVALID_DEVICE_INDEX if no
+// device contains the passed interface number.
+//
+//****************************************************************************
+static uint32_t
+InterfaceToIndex(tUSBDCompositeDevice *psDevice, uint32_t ui32Interface)
+{
+    uint32_t ui32Loop;
+    uint32_t ui32Lookup;
+
+    //
+    // Check each lookup entry in turn.
+    //
+    for(ui32Loop = 0; ui32Loop < psDevice->ui32NumDevices; ui32Loop++)
+    {
+        //
+        // Get the look up value from the device.
+        //
+        ui32Lookup = psDevice->psDevices[ui32Loop].ui32DeviceWorkspace;
+        ui32Lookup = (ui32Lookup >> (8 * LOOKUP_INTERFACE_BYTE)) & 0xff;
+
+        //
+        // If the desired interface number is lower than the value in the
+        // current lookup table entry, we have found the desired device so
+        // return its index.
+        //
+        if(ui32Interface < ui32Lookup)
+        {
+            return(ui32Loop);
+        }
+    }
+
+    //
+    // If we get here, an invalid interface number was passed so return a
+    // marker to indicate this.
+    //
+    return(INVALID_DEVICE_INDEX);
+}
+
+//****************************************************************************
+//
+// Use the lookup table from the field pui32DeviceWorkspace in the
+// tUSBDCompositeDevice structure to determine which device to call given a
+// particular composite device endpoint number.
+//
+// The returned value is the index into psDevice->tCompositeEntry indicating
+// the device which contains this endpoint or INVALID_DEVICE_INDEX if no
+// device contains the passed endpoint number.
+//
+//****************************************************************************
+static uint32_t
+EndpointToIndex(tUSBDCompositeDevice *psDevice, uint32_t ui32Endpoint,
+                bool bInEndpoint)
+{
+    uint32_t ui32Loop, ui32EndpointByte, ui32Lookup;
+
+    //
+    // Are we considering an IN or OUT endpoint?
+    //
+    ui32EndpointByte = bInEndpoint ? LOOKUP_IN_END_BYTE : LOOKUP_OUT_END_BYTE;
+
+    //
+    // Check each lookup entry in turn.
+    //
+    for(ui32Loop = 0; ui32Loop < psDevice->ui32NumDevices; ui32Loop++)
+    {
+        //
+        // Get the look up byte from the device.
+        //
+        ui32Lookup = psDevice->psDevices[ui32Loop].ui32DeviceWorkspace;
+        ui32Lookup = (ui32Lookup >> (ui32EndpointByte * 8)) & 0xff;
+
+        //
+        // If the desired endpoint number is lower than the value in the
+        // current lookup table entry, we have found the desired device so
+        // return its index.
+        //
+        if(ui32Endpoint < ui32Lookup)
+        {
+            return(ui32Loop);
+        }
+    }
+
+    //
+    // If we get here, an invalid endpoint number was passed so return a
+    // marker to indicate this.
+    //
+    return(INVALID_DEVICE_INDEX);
+}
+
+
+//****************************************************************************
+//
+// This function will check if any device classes need a get descriptor
+// handler called.
+//
+//****************************************************************************
+static void
+GetDescriptor(void *pvCompositeInstance, tUSBRequest *psUSBRequest)
+{
+    uint32_t ui32Idx;
+    const tDeviceInfo *psDeviceInfo;
+    tUSBDCompositeDevice *psCompDevice;
+
+    //
+    // Create the composite device pointer.
+    //
+    psCompDevice = (tUSBDCompositeDevice *)pvCompositeInstance;
+
+    //
+    // Determine which device this request is intended for.  We have to be
+    // careful here to send this to the callback for the correct device
+    // depending upon whether it is a request sent to the device, the interface
+    // or the endpoint.
+    //
+    switch(psUSBRequest->bmRequestType & USB_RTYPE_RECIPIENT_M)
+    {
+        case USB_RTYPE_INTERFACE:
+        {
+            ui32Idx = InterfaceToIndex(psCompDevice,
+                                       (psUSBRequest->wIndex & 0xFF));
+            break;
+        }
+
+        case USB_RTYPE_ENDPOINT:
+        {
+            ui32Idx = EndpointToIndex(psCompDevice,
+                            (psUSBRequest->wIndex & 0x0F),
+                            (psUSBRequest->wIndex & 0x80) ? true : false);
+            break;
+        }
+
+        //
+        // Requests sent to the device or any other recipient can't be
+        // handled here since we have no way of telling where they are
+        // supposed to be handled.  As a result, we just stall them.
+        //
+        // If your composite device has some device-specific descriptors,
+        // you should add code here to handle them.
+        //
+        case USB_RTYPE_DEVICE:
+        case USB_RTYPE_OTHER:
+        default:
+        {
+            ui32Idx = INVALID_DEVICE_INDEX;
+            break;
+        }
+    }
+
+    //
+    // Did we find a device class to pass the request to?
+    //
+    if(ui32Idx != INVALID_DEVICE_INDEX)
+    {
+        //
+        // Get a pointer to the individual device instance.
+        //
+        psDeviceInfo = psCompDevice->psDevices[ui32Idx].psDevInfo;
+
+        //
+        // Does this device have a GetDescriptor callback?
+        //
+        if(psDeviceInfo->psCallbacks->pfnGetDescriptor)
+        {
+            //
+            // Remember this device index so that we can correctly route any
+            // data notification callbacks to it.
+            //
+            psCompDevice->sPrivateData.ui32EP0Owner = ui32Idx;
+
+            //
+            // Call the device to retrieve the descriptor.
+            //
+            psDeviceInfo->psCallbacks->pfnGetDescriptor(
+               psCompDevice->psDevices[ui32Idx].pvInstance, psUSBRequest);
+        }
+        else
+        {
+            //
+            // Oops - we can't satisfy the request so stall EP0 to indicate
+            // an error.
+            //
+            USBDCDStallEP0(USBBaseToIndex(
+                              psCompDevice->sPrivateData.ui32USBBase));
+        }
+    }
+    else
+    {
+        //
+        // We are unable to satisfy the descriptor request so stall EP0 to
+        // indicate an error.
+        //
+        USBDCDStallEP0(USBBaseToIndex(
+                              psCompDevice->sPrivateData.ui32USBBase));
+    }
+}
+
+//****************************************************************************
+//
+// This function will check if any device classes need an suspend handler
+// called.
+//
+//****************************************************************************
+static void
+SuspendHandler(void *pvCompositeInstance)
+{
+    uint32_t ui32Idx;
+    tUSBDCompositeDevice *psCompDevice;
+    const tDeviceInfo *psDeviceInfo;
+    void *pvDeviceInst;
+
+    ASSERT(pvCompositeInstance != 0);
+
+    //
+    // Create the device instance pointer.
+    //
+    psCompDevice = (tUSBDCompositeDevice *)pvCompositeInstance;
+
+    //
+    // Inform the application that the device has resumed.
+    //
+    if(psCompDevice->pfnCallback)
+    {
+        psCompDevice->pfnCallback(pvCompositeInstance, USB_EVENT_SUSPEND,
+                                       0, 0);
+    }
+
+    for(ui32Idx = 0; ui32Idx < psCompDevice->ui32NumDevices; ui32Idx++)
+    {
+        psDeviceInfo = psCompDevice->psDevices[ui32Idx].psDevInfo;
+        pvDeviceInst = psCompDevice->psDevices[ui32Idx].pvInstance;
+
+        if(psDeviceInfo->psCallbacks->pfnSuspendHandler)
+        {
+            psDeviceInfo->psCallbacks->pfnSuspendHandler(pvDeviceInst);
+        }
+    }
+}
+
+//****************************************************************************
+//
+// This function will check if any device classes need an resume handler
+// called.
+//
+//****************************************************************************
+static void
+ResumeHandler(void *pvCompositeInstance)
+{
+    uint32_t ui32Idx;
+    tUSBDCompositeDevice *psCompDevice;
+    const tDeviceInfo *psDeviceInfo;
+    void *pvDeviceInst;
+
+    ASSERT(pvCompositeInstance != 0);
+
+    //
+    // Create the device instance pointer.
+    //
+    psCompDevice = (tUSBDCompositeDevice *)pvCompositeInstance;
+
+    //
+    // Inform the application that the device has resumed.
+    //
+    if(psCompDevice->pfnCallback)
+    {
+        psCompDevice->pfnCallback(pvCompositeInstance, USB_EVENT_RESUME,
+                                       0, 0);
+    }
+
+    for(ui32Idx = 0; ui32Idx < psCompDevice->ui32NumDevices; ui32Idx++)
+    {
+        psDeviceInfo = psCompDevice->psDevices[ui32Idx].psDevInfo;
+        pvDeviceInst = psCompDevice->psDevices[ui32Idx].pvInstance;
+
+        if(psDeviceInfo->psCallbacks->pfnResumeHandler)
+        {
+            psDeviceInfo->psCallbacks->pfnResumeHandler(pvDeviceInst);
+        }
+    }
+}
+
+//****************************************************************************
+//
+// This function will check if any device classes need an reset handler
+// called.
+//
+//****************************************************************************
+static void
+ResetHandler(void *pvCompositeInstance)
+{
+    uint32_t ui32Idx;
+    tUSBDCompositeDevice *psCompDevice;
+    const tDeviceInfo *psDeviceInfo;
+    void *pvDeviceInst;
+
+    ASSERT(pvCompositeInstance != 0);
+
+    //
+    // Create the device instance pointer.
+    //
+    psCompDevice = (tUSBDCompositeDevice *)pvCompositeInstance;
+
+    //
+    // Inform the application that the device has been connected.
+    //
+    if(psCompDevice->pfnCallback)
+    {
+        psCompDevice->pfnCallback(pvCompositeInstance,
+                                       USB_EVENT_CONNECTED, 0, 0);
+    }
+
+    for(ui32Idx = 0; ui32Idx < psCompDevice->ui32NumDevices; ui32Idx++)
+    {
+        psDeviceInfo = psCompDevice->psDevices[ui32Idx].psDevInfo;
+        pvDeviceInst = psCompDevice->psDevices[ui32Idx].pvInstance;
+
+        if(psDeviceInfo->psCallbacks->pfnResetHandler)
+        {
+            psDeviceInfo->psCallbacks->pfnResetHandler(pvDeviceInst);
+        }
+    }
+}
+
+//****************************************************************************
+//
+// This function is called to handle data being set to the host so that the
+// application callback can be called when the data has been transferred.
+//
+//****************************************************************************
+static void
+DataSent(void *pvCompositeInstance, uint32_t ui32Info)
+{
+    uint32_t ui32Idx;
+    const tDeviceInfo *psDeviceInfo;
+    tUSBDCompositeDevice *psCompDevice;
+
+    //
+    // Create the device instance pointer.
+    //
+    psCompDevice = (tUSBDCompositeDevice *)pvCompositeInstance;
+
+    //
+    // Pass this notification on to the device which last handled a
+    // transaction on endpoint 0 (assuming we know who that was).
+    //
+    ui32Idx = psCompDevice->sPrivateData.ui32EP0Owner;
+
+    if(ui32Idx != INVALID_DEVICE_INDEX)
+    {
+        psDeviceInfo = psCompDevice->psDevices[ui32Idx].psDevInfo;
+
+        if(psDeviceInfo->psCallbacks->pfnDataSent)
+        {
+            psDeviceInfo->psCallbacks->pfnDataSent(
+                psCompDevice->psDevices[ui32Idx].pvInstance, ui32Info);
+        }
+    }
+}
+
+//****************************************************************************
+//
+// This function is called to handle data being received back from the host so
+// that the application callback can be called when the new data is ready.
+//
+//****************************************************************************
+static void
+DataReceived(void *pvCompositeInstance, uint32_t ui32Info)
+{
+    uint32_t ui32Idx;
+    const tDeviceInfo *psDeviceInfo;
+    tUSBDCompositeDevice *psCompDevice;
+
+    //
+    // Create the device instance pointer.
+    //
+    psCompDevice = (tUSBDCompositeDevice *)pvCompositeInstance;
+
+    //
+    // Pass this notification on to the device which last handled a
+    // transaction on endpoint 0 (assuming we know who that was).
+    //
+    ui32Idx = psCompDevice->sPrivateData.ui32EP0Owner;
+
+    if(ui32Idx != INVALID_DEVICE_INDEX)
+    {
+        psDeviceInfo = psCompDevice->psDevices[ui32Idx].psDevInfo;
+
+        if(psDeviceInfo->psCallbacks->pfnDataReceived)
+        {
+            psDeviceInfo->psCallbacks->pfnDataReceived(
+                psCompDevice->psDevices[ui32Idx].pvInstance, ui32Info);
+        }
+    }
+}
+
+//****************************************************************************
+//
+// This function will check if any device classes need an endpoint handler
+// called.
+//
+//****************************************************************************
+static void
+HandleEndpoints(void *pvCompositeInstance, uint32_t ui32Status)
+{
+    uint32_t ui32Idx;
+    const tDeviceInfo *psDeviceInfo;
+    tUSBDCompositeDevice *psCompDevice;
+
+    ASSERT(pvCompositeInstance != 0);
+
+    //
+    // Create the device instance pointer.
+    //
+    psCompDevice = (tUSBDCompositeDevice *)pvCompositeInstance;
+
+    //
+    // Call each of the endpoint handlers.  This may seem odd since we should
+    // only call the handler whose endpoint needs service.  Unfortunately, if
+    // the device class driver is using uDMA, we have no way of knowing which
+    // handler to call (since ui32Status will be 0).  Since the handlers are
+    // set up to ignore any callback that is not for them, this is safe.
+    //
+    for(ui32Idx = 0; ui32Idx < psCompDevice->ui32NumDevices; ui32Idx++)
+    {
+        psDeviceInfo = psCompDevice->psDevices[ui32Idx].psDevInfo;
+
+        if(psDeviceInfo->psCallbacks->pfnEndpointHandler)
+        {
+            psDeviceInfo->psCallbacks->pfnEndpointHandler(
+                psCompDevice->psDevices[ui32Idx].pvInstance, ui32Status);
+        }
+    }
+}
+
+//*****************************************************************************
+//
+// Device instance specific handler.
+//
+//*****************************************************************************
+static void
+HandleDevice(void *pvCompositeInstance, uint32_t ui32Request,
+             void *pvRequestData)
+{
+    uint32_t ui32Idx;
+    tUSBDCompositeDevice *psCompDevice;
+    const tDeviceInfo *psDeviceInfo;
+
+    ASSERT(pvCompositeInstance != 0);
+
+    //
+    // Create the device instance pointer.
+    //
+    psCompDevice = (tUSBDCompositeDevice *)pvCompositeInstance;
+
+    for(ui32Idx = 0; ui32Idx < psCompDevice->ui32NumDevices; ui32Idx++)
+    {
+        psDeviceInfo = psCompDevice->psDevices[ui32Idx].psDevInfo;
+
+        if(psDeviceInfo->psCallbacks->pfnDeviceHandler)
+        {
+            psDeviceInfo->psCallbacks->pfnDeviceHandler(
+                psCompDevice->psDevices[ui32Idx].pvInstance, ui32Request,
+                pvRequestData);
+        }
+    }
+
+    if(psCompDevice->pfnCallback)
+    {
+        switch(ui32Request)
+        {
+            case USB_EVENT_LPM_RESUME:
+            {
+                //
+                // Pass the LPM resume event to the client.
+                //
+                psCompDevice->pfnCallback(0, USB_EVENT_LPM_RESUME, 0,
+                                               (void *)0);
+                break;
+            }
+            case USB_EVENT_LPM_SLEEP:
+            {
+                //
+                // Pass the LPM sleep event to the client.
+                //
+                psCompDevice->pfnCallback(0, USB_EVENT_LPM_SLEEP, 0,
+                                               (void *)0);
+                break;
+            }
+            case USB_EVENT_LPM_ERROR:
+            {
+                //
+                // Pass the LPM error event to the client.
+                //
+                psCompDevice->pfnCallback(0, USB_EVENT_LPM_ERROR, 0,
+                                               (void *)0);
+                break;
+            }
+            default:
+            {
+                break;
+            }
+        }
+    }
+}
+
+//****************************************************************************
+//
+// This function is called by the USB device stack whenever the device is
+// disconnected from the host.
+//
+//****************************************************************************
+static void
+HandleDisconnect(void *pvCompositeInstance)
+{
+    uint32_t ui32Idx;
+    const tDeviceInfo *psDeviceInfo;
+    tUSBDCompositeDevice *psCompDevice;
+
+    ASSERT(pvCompositeInstance != 0);
+
+    //
+    // Create the device instance pointer.
+    //
+    psCompDevice = (tUSBDCompositeDevice *)pvCompositeInstance;
+
+    //
+    // Inform the application that the device has been disconnected.
+    //
+    if(psCompDevice->pfnCallback)
+    {
+        psCompDevice->pfnCallback(pvCompositeInstance,
+                                       USB_EVENT_DISCONNECTED, 0, 0);
+    }
+
+    for(ui32Idx = 0; ui32Idx < psCompDevice->ui32NumDevices; ui32Idx++)
+    {
+        psDeviceInfo = psCompDevice->psDevices[ui32Idx].psDevInfo;
+
+        if(psDeviceInfo->psCallbacks->pfnDisconnectHandler)
+        {
+            psDeviceInfo->psCallbacks->pfnDisconnectHandler(
+                psCompDevice->psDevices[ui32Idx].pvInstance);
+        }
+    }
+}
+
+//****************************************************************************
+//
+// This function is called by the USB device stack whenever the device
+// interface changes.  It will be passed on to the device classes if they have
+// a handler for this function.
+//
+//****************************************************************************
+static void
+InterfaceChange(void *pvCompositeInstance, uint8_t ui8InterfaceNum,
+                uint8_t ui8AlternateSetting)
+{
+    uint32_t ui32Idx;
+    const tDeviceInfo *psDeviceInfo;
+    tUSBDCompositeDevice *psCompDevice;
+
+    ASSERT(pvCompositeInstance != 0);
+
+    //
+    // Create the device instance pointer.
+    //
+    psCompDevice = (tUSBDCompositeDevice *)pvCompositeInstance;
+    for(ui32Idx = 0; ui32Idx < psCompDevice->ui32NumDevices; ui32Idx++)
+    {
+        psDeviceInfo = psCompDevice->psDevices[ui32Idx].psDevInfo;
+
+        if(psDeviceInfo->psCallbacks->pfnInterfaceChange)
+        {
+            psDeviceInfo->psCallbacks->pfnInterfaceChange(
+                psCompDevice->psDevices[ui32Idx].pvInstance,
+                ui8InterfaceNum, ui8AlternateSetting);
+        }
+    }
+}
+
+//****************************************************************************
+//
+// This function is called by the USB device stack whenever the device
+// configuration changes. It will be passed on to the device classes if they
+// have a handler for this function.
+//
+//****************************************************************************
+static void
+ConfigChangeHandler(void *pvCompositeInstance, uint32_t ui32Value)
+{
+    uint32_t ui32Idx;
+    const tDeviceInfo *psDeviceInfo;
+    tUSBDCompositeDevice *psCompDevice;
+
+    ASSERT(pvCompositeInstance != 0);
+
+    //
+    // Create the device instance pointer.
+    //
+    psCompDevice = (tUSBDCompositeDevice *)pvCompositeInstance;
+
+    for(ui32Idx = 0; ui32Idx < psCompDevice->ui32NumDevices; ui32Idx++)
+    {
+        psDeviceInfo = psCompDevice->psDevices[ui32Idx].psDevInfo;
+
+        if(psDeviceInfo->psCallbacks->pfnConfigChange)
+        {
+            psDeviceInfo->psCallbacks->pfnConfigChange(
+                psCompDevice->psDevices[ui32Idx].pvInstance, ui32Value);
+        }
+    }
+}
+
+//****************************************************************************
+//
+// This function is called by the USB device stack whenever a non-standard
+// request is received.
+//
+// \param pvCompositeInstance
+// \param psUSBRequest points to the request received.
+//
+// This call  will be passed on to the device classes if they have a handler
+// for this function.
+//
+// \return None.
+//
+//****************************************************************************
+static void
+HandleRequests(void *pvCompositeInstance, tUSBRequest *psUSBRequest)
+{
+    uint32_t ui32Idx;
+    const tDeviceInfo *psDeviceInfo;
+    tUSBDCompositeDevice *psCompDevice;
+
+    //
+    // Create the device instance pointer.
+    //
+    psCompDevice = (tUSBDCompositeDevice *)pvCompositeInstance;
+
+    //
+    // Determine which device this request is intended for.  We have to be
+    // careful here to send this to the callback for the correct device
+    // depending upon whether it is a request sent to the device, the interface
+    // or the endpoint.
+    //
+    switch(psUSBRequest->bmRequestType & USB_RTYPE_RECIPIENT_M)
+    {
+        case USB_RTYPE_INTERFACE:
+        {
+            ui32Idx = InterfaceToIndex(psCompDevice,
+                                       (psUSBRequest->wIndex & 0xFF));
+            break;
+        }
+
+        case USB_RTYPE_ENDPOINT:
+        {
+            ui32Idx = EndpointToIndex(psCompDevice,
+                             (psUSBRequest->wIndex & 0x0F),
+                             (psUSBRequest->wIndex & 0x80) ? true : false);
+            break;
+        }
+
+        //
+        // Requests sent to the device or any other recipient can't be
+        // handled here since we have no way of telling where they are
+        // supposed to be handled.  As a result, we just stall them.
+        //
+        // If your composite device has some device-specific requests that need
+        // to be handled at the device (rather than interface or endpoint)
+        // level, you should add code here to handle them.
+        //
+        case USB_RTYPE_DEVICE:
+        case USB_RTYPE_OTHER:
+        default:
+        {
+            ui32Idx = INVALID_DEVICE_INDEX;
+            break;
+        }
+    }
+
+    //
+    // Did we find a device class to pass the request to?
+    //
+    if(ui32Idx != INVALID_DEVICE_INDEX)
+    {
+        //
+        // Get a pointer to the individual device instance.
+        //
+        psDeviceInfo = psCompDevice->psDevices[ui32Idx].psDevInfo;
+
+        //
+        // Does this device have a RequestHandler callback?
+        //
+        if(psDeviceInfo->psCallbacks->pfnRequestHandler)
+        {
+            //
+            // Remember this device index so that we can correctly route any
+            // data notification callbacks to it.
+            //
+            psCompDevice->sPrivateData.ui32EP0Owner = ui32Idx;
+
+            //
+            // Yes - call the device to retrieve the descriptor.
+            //
+            psDeviceInfo->psCallbacks->pfnRequestHandler(
+                    psCompDevice->psDevices[ui32Idx].pvInstance,
+                    psUSBRequest);
+        }
+        else
+        {
+            //
+            // Oops - we can't satisfy the request so stall EP0 to indicate
+            // an error.
+            //
+            USBDCDStallEP0(USBBaseToIndex(
+                              psCompDevice->sPrivateData.ui32USBBase));
+        }
+    }
+    else
+    {
+        //
+        // We are unable to satisfy the descriptor request so stall EP0 to
+        // indicate an error.
+        //
+        USBDCDStallEP0(USBBaseToIndex(
+                              psCompDevice->sPrivateData.ui32USBBase));
+    }
+}
+
+//****************************************************************************
+//
+// This function handles sending interface number changes to device instances.
+//
+//****************************************************************************
+static void
+CompositeIfaceChange(tCompositeEntry *psCompDevice, uint8_t ui8Old,
+                     uint8_t ui8New)
+{
+    uint8_t pui8Interfaces[2];
+
+    if(psCompDevice->psDevInfo->psCallbacks->pfnDeviceHandler)
+    {
+        //
+        // Create the data to pass to the device handler.
+        //
+        pui8Interfaces[0] = ui8Old;
+        pui8Interfaces[1] = ui8New;
+
+        //
+        // Call the device handler to inform the class of the interface number
+        // change.
+        //
+        psCompDevice->psDevInfo->psCallbacks->pfnDeviceHandler(
+            psCompDevice->pvInstance, USB_EVENT_COMP_IFACE_CHANGE,
+            (void *)pui8Interfaces);
+    }
+}
+
+//****************************************************************************
+//
+// This function handles sending endpoint number changes to device instances.
+//
+//****************************************************************************
+static void
+CompositeEPChange(tCompositeEntry *psCompDevice, uint8_t ui8Old,
+                     uint8_t ui8New)
+{
+    uint8_t pui8Interfaces[2];
+
+    if(psCompDevice->psDevInfo->psCallbacks->pfnDeviceHandler)
+    {
+        //
+        // Create the data to pass to the device handler.
+        //
+        pui8Interfaces[0] = ui8Old;
+        pui8Interfaces[1] = ui8New;
+
+        ui8New--;
+
+        //
+        // Call the device handler to inform the class of the interface number
+        // change.
+        //
+        psCompDevice->psDevInfo->psCallbacks->pfnDeviceHandler(
+            psCompDevice->pvInstance, USB_EVENT_COMP_EP_CHANGE,
+            (void *)pui8Interfaces);
+    }
+}
+
+//****************************************************************************
+//
+// This function merges the configuration descriptors into a single multiple
+// instance device.
+//
+//****************************************************************************
+uint32_t
+BuildCompositeDescriptor(tUSBDCompositeDevice *psCompDevice)
+{
+    uint32_t ui32Idx, ui32Offset, ui32CPIdx, ui32FixINT, ui32Dev;
+    uint16_t ui16TotalLength, ui16Bytes;
+    uint8_t ui8Interface, ui8INEndpoint, ui8OUTEndpoint;
+    uint8_t *pui8Data, *pui8Config;
+    const tConfigHeader *psConfigHeader;
+    tDescriptorHeader *psHeader;
+    const uint8_t *pui8Descriptor;
+    tInterfaceDescriptor *psInterface;
+    tEndpointDescriptor *psEndpoint;
+    const tDeviceInfo *psDevice;
+
+    //
+    // Save the number of devices to look through.
+    //
+    ui32Dev = 0;
+    ui32Idx = 0;
+    ui8Interface = 0;
+    ui8INEndpoint = 1;
+    ui8OUTEndpoint = 1;
+    ui32Offset = 0;
+    ui32FixINT = 0;
+
+    //
+    // This puts the first section pointer in the first entry in the list
+    // of sections.
+    //
+    psCompDevice->sPrivateData.ppsCompSections[0] =
+        &psCompDevice->sPrivateData.psCompSections[0];
+
+    //
+    // Put the pointer to this instances configuration descriptor into the
+    // front of the list.
+    //
+    psCompDevice->sPrivateData.ppsCompSections[0]->pui8Data =
+        (uint8_t *)&psCompDevice->sPrivateData.sConfigDescriptor;
+
+    psCompDevice->sPrivateData.ppsCompSections[0]->ui16Size =
+        psCompDevice->sPrivateData.sConfigDescriptor.bLength;
+
+    //
+    // The configuration descriptor is 9 bytes so initialize the total length
+    // to 9 bytes.
+    //
+    ui16TotalLength = 9;
+
+    //
+    // Copy the section pointer into the section array for the composite
+    // device.  This is awkward but is required given the definition
+    // of the structures.
+    //
+    psCompDevice->sPrivateData.ppsCompSections[1] =
+        &psCompDevice->sPrivateData.psCompSections[1];
+
+    //
+    // Copy the pointer to the application supplied space into the section
+    // list.
+    //
+    psCompDevice->sPrivateData.ppsCompSections[1]->ui16Size = 0;
+    psCompDevice->sPrivateData.ppsCompSections[1]->pui8Data =
+        psCompDevice->sPrivateData.pui8Data;
+
+    //
+    // Create a local pointer to the data that is used to copy data from
+    // the other devices into the composite descriptor.
+    //
+    pui8Data = psCompDevice->sPrivateData.pui8Data;
+
+    //
+    // Consider each device in turn.
+    //
+    while(ui32Dev < psCompDevice->ui32NumDevices)
+    {
+        //
+        // Save the current starting address of this descriptor.
+        //
+        pui8Config = pui8Data + ui32Offset;
+
+        //
+        // Create a local pointer to the configuration header.
+        //
+        psDevice = psCompDevice->psDevices[ui32Dev].psDevInfo;
+        psConfigHeader = psDevice->ppsConfigDescriptors[0];
+
+        //
+        // Loop through each of the sections in this device's configuration
+        // descriptor.
+        //
+        for(ui32Idx = 0; ui32Idx < psConfigHeader->ui8NumSections; ui32Idx++)
+        {
+            //
+            // Initialize the local offset in this descriptor.  We include
+            // a special case here to ignore the initial 9 byte configuration
+            // descriptor since this has already been handled.
+            //
+            if(ui32Idx)
+            {
+                //
+                // This is not the first section so we handle everything in
+                // it.
+                //
+                ui16Bytes = 0;
+            }
+            else
+            {
+                //
+                // This is the first section for this device so skip the 9
+                // byte configuration descriptor since we've already handled
+                // this.
+                //
+                ui16Bytes = 9;
+
+                //
+                // If this section includes only the configuration descriptor,
+                // skip it entirely.
+                //
+                if(psConfigHeader->psSections[ui32Idx]->ui16Size <= ui16Bytes)
+                {
+                    continue;
+                }
+            }
+
+            //
+            // Get a pointer to the configuration descriptor.
+            //
+            pui8Descriptor = psConfigHeader->psSections[ui32Idx]->pui8Data;
+
+            //
+            // Bounds check the allocated space and return if there is not
+            // enough space.
+            //
+            if(ui32Offset > psCompDevice->sPrivateData.ui32DataSize)
+            {
+                return(1);
+            }
+
+            //
+            // Copy the descriptor from the device into the descriptor list.
+            //
+            for(ui32CPIdx = 0;
+                ui32CPIdx < psConfigHeader->psSections[ui32Idx]->ui16Size;
+                ui32CPIdx++)
+            {
+                pui8Data[ui32CPIdx + ui32Offset] = pui8Descriptor[ui32CPIdx];
+            }
+
+            //
+            // Read out the descriptors in this section.
+            //
+            while(ui16Bytes < psConfigHeader->psSections[ui32Idx]->ui16Size)
+            {
+                //
+                // Create a descriptor header pointer.
+                //
+                psHeader = (tDescriptorHeader *)&pui8Data[ui32Offset +
+                                                          ui16Bytes];
+
+                //
+                // Check for interface descriptors and modify the numbering to
+                // match the composite device.
+                //
+                if(psHeader->bDescriptorType == USB_DTYPE_INTERFACE)
+                {
+                    psInterface = (tInterfaceDescriptor *)psHeader;
+
+                    //
+                    // See if this is an alternate setting or the initial
+                    // setting.
+                    //
+                    if(psInterface->bAlternateSetting != 0)
+                    {
+                        //
+                        // If this is an alternate setting then use the
+                        // previous interface number because the current one
+                        // has already been incremented.
+                        //
+                        psInterface->bInterfaceNumber = ui8Interface - 1;
+                    }
+                    else
+                    {
+                        //
+                        // Notify the class that it's interface number has
+                        // changed.
+                        //
+                        CompositeIfaceChange(
+                                         &psCompDevice->psDevices[ui32Dev],
+                                         psInterface->bInterfaceNumber,
+                                         ui8Interface);
+                        //
+                        // This was the non-alternate setting so save the
+                        // value and move to the next interface number.
+                        //
+                        psInterface->bInterfaceNumber = ui8Interface;
+
+                        //
+                        // No strings allowed on interface descriptors for
+                        // composite devices.
+                        //
+                        psInterface->iInterface = 0;
+
+                        ui8Interface++;
+                    }
+                }
+                //
+                // Check for endpoint descriptors and modify the numbering to
+                // match the composite device.
+                //
+                else if(psHeader->bDescriptorType == USB_DTYPE_ENDPOINT)
+                {
+                    psEndpoint = (tEndpointDescriptor *)psHeader;
+
+                    //
+                    // Check if this is an IN or OUT endpoint.
+                    //
+                    if(psEndpoint->bEndpointAddress & USB_RTYPE_DIR_IN)
+                    {
+                        //
+                        // Check if this is the special Fixed Interrupt class
+                        // and this is the interrupt endpoint.
+                        //
+                        if(((psEndpoint->bmAttributes & USB_EP_ATTR_TYPE_M) ==
+                            USB_EP_ATTR_INT) &&
+                           (psCompDevice->ui16PID == USB_PID_COMP_SERIAL))
+                        {
+                            //
+                            // Check if the Fixed Interrupt endpoint has been
+                            // set yet.
+                            //
+                            if(ui32FixINT == 0)
+                            {
+                                //
+                                // Allocate the fixed interrupt endpoint and
+                                // save its number.
+                                //
+                                ui32FixINT = ui8INEndpoint++;
+                            }
+
+                            CompositeEPChange(
+                                        &psCompDevice->psDevices[ui32Dev],
+                                        psEndpoint->bEndpointAddress,
+                                        ui32FixINT);
+
+                            psEndpoint->bEndpointAddress = ui32FixINT |
+                                                           USB_RTYPE_DIR_IN;
+                        }
+                        else
+                        {
+                            //
+                            // Notify the class that it's interface number has
+                            // changed.
+                            //
+                            CompositeEPChange(
+                                        &psCompDevice->psDevices[ui32Dev],
+                                        psEndpoint->bEndpointAddress,
+                                        ui8INEndpoint);
+
+                            psEndpoint->bEndpointAddress = ui8INEndpoint++ |
+                                                           USB_RTYPE_DIR_IN;
+                        }
+                    }
+                    else
+                    {
+                        //
+                        // Notify the class that it's interface number has
+                        // changed.
+                        //
+                        CompositeEPChange(&psCompDevice->psDevices[ui32Dev],
+                                          psEndpoint->bEndpointAddress,
+                                          ui8OUTEndpoint);
+                        psEndpoint->bEndpointAddress = ui8OUTEndpoint++;
+                    }
+                }
+
+                //
+                // Move on to the next descriptor.
+                //
+                ui16Bytes += psHeader->bLength;
+            }
+
+            ui32Offset += psConfigHeader->psSections[ui32Idx]->ui16Size;
+
+            ui16TotalLength += ui16Bytes;
+        }
+
+        //
+        // Allow the device class to make adjustments to the configuration
+        // descriptor.
+        //
+        psCompDevice->psDevices[ui32Dev].psDevInfo->psCallbacks->pfnDeviceHandler(
+                psCompDevice->psDevices[ui32Dev].pvInstance,
+                USB_EVENT_COMP_CONFIG, (void *)pui8Config);
+
+        //
+        // Add an entry into the device workspace array to allow us to quickly
+        // map interface and endpoint numbers to device instances later.
+        //
+        psCompDevice->psDevices[ui32Dev].ui32DeviceWorkspace =
+            (ui32Dev << (LOOKUP_INDEX_BYTE * 8)) |
+            (ui8Interface << (LOOKUP_INTERFACE_BYTE * 8)) |
+            (ui8OUTEndpoint << (LOOKUP_OUT_END_BYTE * 8)) |
+            (ui8INEndpoint << (LOOKUP_IN_END_BYTE * 8));
+
+        //
+        // Move on to the next device.
+        //
+        ui32Dev++;
+    }
+
+    //
+    // Modify the configuration descriptor to match the number of interfaces
+    // and the new total size.
+    //
+    psCompDevice->sPrivateData.sCompConfigHeader.ui8NumSections = 2;
+    psCompDevice->sPrivateData.ppsCompSections[1]->ui16Size = ui32Offset;
+    psCompDevice->sPrivateData.sConfigDescriptor.bNumInterfaces =
+       ui8Interface;
+    psCompDevice->sPrivateData.sConfigDescriptor.wTotalLength =
+       ui16TotalLength;
+
+
+    return(0);
+}
+
+//****************************************************************************
+//
+//! This function should be called once for the composite class device to
+//! initialize basic operation and prepare for enumeration.
+//!
+//! \param ui32Index is the index of the USB controller to initialize for
+//! composite device operation.
+//! \param psDevice points to a structure containing parameters customizing
+//! the operation of the composite device.
+//! \param ui32Size is the size in bytes of the data pointed to by the
+//! \e pui8Data parameter.
+//! \param pui8Data is the data area that the composite class can use to build
+//! up descriptors.
+//!
+//! In order for an application to initialize the USB composite device class,
+//! it must first call this function with the a valid composite device class
+//! structure in the \e psDevice parameter.  This allows this function to
+//! initialize the USB controller and device code to be prepared to enumerate
+//! and function as a USB composite device.  The \e ui32Size and \e pui8Data
+//! parameters should be large enough to hold all of the class instances
+//! passed in via the \e psDevice structure.  This is typically the full size
+//! of the configuration descriptor for a device minus its configuration
+//! header(9 bytes).
+//!
+//! This function returns a void pointer that must be passed in to all other
+//! APIs used by the composite class.
+//!
+//! See the documentation on the tUSBDCompositeDevice structure for more
+//! information on how to properly fill the structure members.
+//!
+//! \return This function returns 0 on failure or a non-zero void pointer on
+//! success.
+//
+//****************************************************************************
+void *
+USBDCompositeInit(uint32_t ui32Index, tUSBDCompositeDevice *psDevice,
+                  uint32_t ui32Size, uint8_t *pui8Data)
+{
+    tCompositeInstance *psInst;
+    int32_t i32Idx;
+    uint8_t *pui8Temp;
+
+    //
+    // Check parameter validity.
+    //
+    ASSERT(ui32Index == 0);
+    ASSERT(psDevice);
+    ASSERT(psDevice->ppui8StringDescriptors);
+
+    //
+    // Initialize the work space in the passed instance structure.
+    //
+    psInst = &psDevice->sPrivateData;
+    psInst->ui32DataSize = ui32Size;
+    psInst->pui8Data = pui8Data;
+
+    //
+    // Save the base address of the USB controller.
+    //
+    psInst->ui32USBBase = USBIndexToBase(ui32Index);
+
+    //
+    // No device is currently transferring data on EP0.
+    //
+    psInst->ui32EP0Owner = INVALID_DEVICE_INDEX;
+
+    //
+    // Initialize the device information structure.
+    //
+    psInst->sDevInfo.psCallbacks = &g_sCompHandlers;
+    psInst->sDevInfo.pui8DeviceDescriptor = g_pui8CompDeviceDescriptor;
+    psInst->sDevInfo.ppsConfigDescriptors =
+                    (const tConfigHeader * const *)g_ppCompConfigDescriptors;
+    psInst->sDevInfo.ppui8StringDescriptors = 0;
+    psInst->sDevInfo.ui32NumStringDescriptors = 0;
+
+    //
+    // Initialize the device info structure for the composite device.
+    //
+    USBDCDDeviceInfoInit(0, &psInst->sDevInfo);
+
+    g_ppCompConfigDescriptors[0] = &psInst->sCompConfigHeader;
+    g_ppCompConfigDescriptors[0]->ui8NumSections = 0;
+    g_ppCompConfigDescriptors[0]->psSections =
+      (const tConfigSection * const *)psDevice->sPrivateData.ppsCompSections;
+
+    //
+    // Create a byte pointer to use with the copy.
+    //
+    pui8Temp = (uint8_t *)&psInst->sConfigDescriptor;
+
+    //
+    // Copy the default configuration descriptor into the instance data.
+    //
+    for(i32Idx = 0; i32Idx < g_pui8CompConfigDescriptor[0]; i32Idx++)
+    {
+        pui8Temp[i32Idx] = g_pui8CompConfigDescriptor[i32Idx];
+    }
+
+    //
+    // Create a byte pointer to use with the copy.
+    //
+    pui8Temp = (uint8_t *)&psInst->sDeviceDescriptor;
+
+    //
+    // Copy the default configuration descriptor into the instance data.
+    //
+    for(i32Idx = 0; i32Idx < g_pui8CompDeviceDescriptor[0]; i32Idx++)
+    {
+        pui8Temp[i32Idx] = g_pui8CompDeviceDescriptor[i32Idx];
+    }
+
+    //
+    // Fix up the device descriptor with the client-supplied values.
+    //
+    psInst->sDeviceDescriptor.idVendor = psDevice->ui16VID;
+    psInst->sDeviceDescriptor.idProduct = psDevice->ui16PID;
+
+    //
+    // Fix up the configuration descriptor with client-supplied values.
+    //
+    psInst->sConfigDescriptor.bmAttributes = psDevice->ui8PwrAttributes;
+    psInst->sConfigDescriptor.bMaxPower =
+        (uint8_t)(psDevice->ui16MaxPowermA>>1);
+
+    psInst->sDevInfo.pui8DeviceDescriptor =
+                                (const uint8_t *)&psInst->sDeviceDescriptor;
+
+    //
+    // Plug in the client's string table to the device information
+    // structure.
+    //
+    psInst->sDevInfo.ppui8StringDescriptors =
+                                            psDevice->ppui8StringDescriptors;
+    psInst->sDevInfo.ui32NumStringDescriptors =
+                                            psDevice->ui32NumStringDescriptors;
+
+    //
+    // Enable Clocking to the USB controller so that changes to the USB
+    // controller can be made in the BuildCompositeDescriptor() function.
+    //
+    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_USB0);
+
+    //
+    // Create the combined descriptors.
+    //
+    if(BuildCompositeDescriptor(psDevice))
+    {
+        return(0);
+    }
+
+    //
+    // All is well so now pass the descriptors to the lower layer and put
+    // the bulk device on the bus.
+    //
+    USBDCDInit(ui32Index, &psInst->sDevInfo, (void *)psDevice);
+
+    //
+    // Return the pointer to the instance indicating that everything went
+    // well.
+    //
+    return((void *)psDevice);
+}
+
+//****************************************************************************
+//
+//! Shuts down the composite device.
+//!
+//! \param pvCompositeInstance is the pointer to the device instance structure
+//! as returned by USBDCompositeInit().
+//!
+//! This function terminates composite device interface for the instance
+//! not me supplied. Following this call, the \e pvCompositeInstance instance
+//! should not be used in any other calls.
+//!
+//! \return None.
+//
+//****************************************************************************
+void
+USBDCompositeTerm(void *pvCompositeInstance)
+{
+    ASSERT(pvCompositeInstance != 0);
+
+}
+
+//****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//****************************************************************************
+
diff --git a/bsp/tm4c129x/libraries/usblib/device/usbdcomp.h b/bsp/tm4c129x/libraries/usblib/device/usbdcomp.h
new file mode 100755
index 0000000..7dc219c
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/device/usbdcomp.h
@@ -0,0 +1,261 @@
+//*****************************************************************************
+//
+// usbdcomp.h - USB composite device class driver.
+//
+// Copyright (c) 2010-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#ifndef __USBDCOMP_H__
+#define __USBDCOMP_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+//*****************************************************************************
+//
+// Return to default packing when using the IAR Embedded Workbench compiler.
+//
+//*****************************************************************************
+#ifdef ewarm
+#pragma pack()
+#endif
+
+//*****************************************************************************
+//
+//! \addtogroup composite_device_class_api
+//! @{
+//
+//*****************************************************************************
+
+//
+// Defines a single entry in a table of device types supported by the composite
+// device.
+//
+typedef struct
+{
+    //
+    // This is set internally by the composite class so it can be left
+    // uninitialized by the application.
+    //
+    const tDeviceInfo *psDeviceInfo;
+
+    //
+    // This should be the header to the configuration header for a class.
+    //
+    const tConfigHeader *psConfigHeader;
+
+    //
+    // The offset to this devices interface, filled in by the composite class.
+    //
+    uint8_t ui8IfaceOffset;
+}
+tUSBDCompositeEntry;
+
+//*****************************************************************************
+//
+// PRIVATE
+//
+// This structure defines the private instance data and state variables for the
+// composite device class.  The memory for this structure is included in
+// the sPrivateData field in the tUSBDCompositeDevice structure passed on
+// USBDCompositeInit() and should not be modified by any code outside of the
+// composite device code.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    // Saves which USB controller is in use.
+    //
+    uint32_t ui32USBBase;
+
+    //
+    // The device information pointer.
+    //
+    tDeviceInfo sDevInfo;
+
+    //
+    // This is the configuration descriptor for this instance.
+    //
+    tConfigDescriptor sConfigDescriptor;
+
+    //
+    // This is the device descriptor for this instance.
+    //
+    tDeviceDescriptor sDeviceDescriptor;
+
+    //
+    // The configuration header for this instance.
+    //
+    tConfigHeader sCompConfigHeader;
+
+    //
+    // These are the configuration sections that will be built from the
+    // Configuration Descriptor header and the descriptors from the devices
+    // that are part of this composite device.
+    //
+    tConfigSection psCompSections[2];
+    tConfigSection *ppsCompSections[2];
+
+    //
+    // The size and pointer to the data used by the instance.
+    //
+    uint32_t ui32DataSize;
+    uint8_t *pui8Data;
+
+    //
+    // The current "owner" of endpoint 0.  This is used to track the device
+    // class which is currently transferring data on EP0.
+    //
+    uint32_t ui32EP0Owner;
+}
+tCompositeInstance;
+
+//*****************************************************************************
+//
+//! The structure used by the application to define operating parameters for
+//! the composite device class.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The vendor ID that this device is to present in the device descriptor.
+    //
+    const uint16_t ui16VID;
+
+    //
+    //! The product ID that this device is to present in the device descriptor.
+    //
+    const uint16_t ui16PID;
+
+    //
+    //! The maximum power consumption of the device, expressed in mA.
+    //
+    const uint16_t ui16MaxPowermA;
+
+    //
+    //! Indicates whether the device is self or bus-powered and whether or not
+    //! it supports remote wake up.  Valid values are \b USB_CONF_ATTR_SELF_PWR
+    //! or \b USB_CONF_ATTR_BUS_PWR, optionally ORed with
+    //! \b USB_CONF_ATTR_RWAKE.
+    //
+    const uint8_t ui8PwrAttributes;
+
+    //
+    //! A pointer to the callback function which will be called to notify
+    //! the application of events relating to the operation of the composite
+    //! device.
+    //
+    const tUSBCallback pfnCallback;
+
+    //
+    //! A pointer to the string descriptor array for this device.  This array
+    //! must contain the following string descriptor pointers in this order.
+    //! Language descriptor, Manufacturer name string (language 1), Product
+    //! name string (language 1), Serial number string (language 1), Composite
+    //! device interface description string (language 1), Configuration
+    //! description string (language 1).
+    //!
+    //! If supporting more than 1 language, the descriptor block (except for
+    //! string descriptor 0) must be repeated for each language defined in the
+    //! language descriptor.
+    //!
+    //
+    const uint8_t * const *ppui8StringDescriptors;
+
+    //
+    //! The number of descriptors provided in the ppStringDescriptors
+    //! array.  This must be 1 + ((5 + (number of strings)) *
+    //!                           (number of languages)).
+    //
+    const uint32_t ui32NumStringDescriptors;
+
+    //
+    //! The number of devices in the psDevices array.
+    //
+    const uint32_t ui32NumDevices;
+
+    //
+    //! This application supplied array holds the the top level device class
+    //! information as well as the Instance data for that class.
+    //
+    tCompositeEntry * const psDevices;
+
+    //
+    //! The private data for this device instance.  This memory must remain
+    //! accessible for as long as the composite device is in use and must
+    //! not be modified by any code outside the composite class driver.
+    //
+    tCompositeInstance sPrivateData;
+}
+tUSBDCompositeDevice;
+
+//*****************************************************************************
+//
+// Return to default packing when using the IAR Embedded Workbench compiler.
+//
+//*****************************************************************************
+#ifdef ewarm
+#pragma pack()
+#endif
+
+//*****************************************************************************
+//
+// Composite specific device class driver events
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// API Function Prototypes
+//
+//*****************************************************************************
+extern void *USBDCompositeInit(uint32_t ui32Index,
+                               tUSBDCompositeDevice *psCompDevice,
+                               uint32_t ui32Size, uint8_t *pui8Data);
+extern void USBDCompositeTerm(void *pvInstance);
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/bsp/tm4c129x/libraries/usblib/device/usbdconfig.c b/bsp/tm4c129x/libraries/usblib/device/usbdconfig.c
new file mode 100755
index 0000000..11761de
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/device/usbdconfig.c
@@ -0,0 +1,555 @@
+//*****************************************************************************
+//
+// usbdconfig.c - High level USB device configuration function.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "inc/hw_memmap.h"
+#include "inc/hw_types.h"
+#include "driverlib/debug.h"
+#include "driverlib/usb.h"
+#include "usblib/usblib.h"
+#include "usblib/usblibpriv.h"
+#include "usblib/device/usbdevice.h"
+#include "usblib/device/usbdevicepriv.h"
+
+//*****************************************************************************
+//
+//! \addtogroup device_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Structure used in compiling FIFO size and endpoint properties from a
+// configuration descriptor.
+//
+//*****************************************************************************
+typedef struct
+{
+    uint32_t pui32Size[2];
+}
+tUSBEndpointInfo;
+
+//*****************************************************************************
+//
+// Indices used when accessing the tUSBEndpointInfo structure.
+//
+//*****************************************************************************
+#define EP_INFO_IN              0
+#define EP_INFO_OUT             1
+
+//*****************************************************************************
+//
+// Given a maximum packet size and the user's FIFO scaling requirements,
+// determine the flags to use to configure the endpoint FIFO and the number
+// of bytes of FIFO space occupied.
+//
+//*****************************************************************************
+static uint32_t
+GetEndpointFIFOSize(uint32_t ui32MaxPktSize, uint32_t *pupBytesUsed)
+{
+    uint32_t ui32Loop, ui32FIFOSize;
+
+    //
+    // Now we need to find the nearest supported size that accommodates the
+    // requested size.  Step through each of the supported sizes until we
+    // find one that will do.
+    //
+    for(ui32Loop = USB_FIFO_SZ_8; ui32Loop <= USB_FIFO_SZ_2048; ui32Loop++)
+    {
+        //
+        // How many bytes does this FIFO value represent?
+        //
+        ui32FIFOSize = USBFIFOSizeToBytes(ui32Loop);
+
+        //
+        // Is this large enough to hold one packet.
+        //
+        if(ui32FIFOSize >= ui32MaxPktSize)
+        {
+            //
+            // Return the FIFO size setting and the USB_FIFO_SZ_ value.
+            //
+            *pupBytesUsed = ui32FIFOSize;
+
+            return(ui32Loop);
+        }
+    }
+
+    //
+    // If we drop out, we can't support the FIFO size requested.  Signal a
+    // problem by returning 0 in the pBytesUsed
+    //
+    *pupBytesUsed = 0;
+
+    return(USB_FIFO_SZ_8);
+}
+
+//*****************************************************************************
+//
+// Translate a USB endpoint descriptor into the values we need to pass to the
+// USBDevEndpointConfigSet() API.
+//
+//*****************************************************************************
+static void
+GetEPDescriptorType(tEndpointDescriptor *psEndpoint, uint32_t *pui32EPIndex,
+                    uint32_t *pui32MaxPktSize, uint32_t *pui32Flags)
+{
+    //
+    // Get the endpoint index.
+    //
+    *pui32EPIndex = psEndpoint->bEndpointAddress & USB_EP_DESC_NUM_M;
+
+    //
+    // Extract the maximum packet size.
+    //
+    *pui32MaxPktSize = psEndpoint->wMaxPacketSize & USB_EP_MAX_PACKET_COUNT_M;
+
+    //
+    // Is this an IN or an OUT endpoint?
+    //
+    *pui32Flags = (psEndpoint->bEndpointAddress & USB_EP_DESC_IN) ?
+                  USB_EP_DEV_IN : USB_EP_DEV_OUT;
+
+    //
+    // Set the endpoint mode.
+    //
+    switch(psEndpoint->bmAttributes & USB_EP_ATTR_TYPE_M)
+    {
+        case USB_EP_ATTR_CONTROL:
+        {
+            *pui32Flags |= USB_EP_MODE_CTRL;
+            break;
+        }
+        case USB_EP_ATTR_BULK:
+        {
+            *pui32Flags |= USB_EP_MODE_BULK;
+            break;
+        }
+        case USB_EP_ATTR_INT:
+        {
+            *pui32Flags |= USB_EP_MODE_INT;
+            break;
+        }
+        case USB_EP_ATTR_ISOC:
+        {
+            *pui32Flags |= USB_EP_MODE_ISOC;
+            break;
+        }
+    }
+}
+
+//*****************************************************************************
+//
+//! Configure the USB controller appropriately for the device whose
+//! configuration descriptor is passed.
+//!
+//! \param psDevInst is a pointer to the device instance being configured.
+//! \param psConfig is a pointer to the configuration descriptor that the
+//! USB controller is to be set up to support.
+//!
+//! This function may be used to initialize a USB controller to operate as
+//! the device whose configuration descriptor is passed.  The function
+//! enables the USB controller, partitions the FIFO appropriately and
+//! configures each endpoint required by the configuration.  If the supplied
+//! configuration supports multiple alternate settings for any interface,
+//! the USB FIFO is set up assuming the worst case use (largest packet size
+//! for a given endpoint in any alternate setting using that endpoint) to
+//! allow for on-the-fly alternate setting changes later.  On return from this
+//! function, the USB controller is configured for correct operation of
+//! the default configuration of the device described by the descriptor passed.
+//!
+//! \return Returns \b true on success or \b false on failure.
+//
+//*****************************************************************************
+bool
+USBDeviceConfig(tDCDInstance *psDevInst, const tConfigHeader *psConfig)
+{
+    uint32_t ui32Loop, ui32Count, ui32NumInterfaces, ui32EpIndex, ui32EpType,
+             ui32MaxPkt, ui32NumEndpoints, ui32Flags, ui32BytesUsed,
+             ui32Section;
+    tInterfaceDescriptor *psInterface;
+    tEndpointDescriptor *psEndpoint;
+    tUSBEndpointInfo psEPInfo[NUM_USB_EP - 1];
+
+    //
+    // A valid device instance is required.
+    //
+    ASSERT(psDevInst != 0);
+
+    //
+    // Catch bad pointers in a debug build.
+    //
+    ASSERT(psConfig);
+
+    //
+    // Clear out our endpoint info.
+    //
+    for(ui32Loop = 0; ui32Loop < (NUM_USB_EP - 1); ui32Loop++)
+    {
+        psEPInfo[ui32Loop].pui32Size[EP_INFO_IN] = 0;
+        psEPInfo[ui32Loop].pui32Size[EP_INFO_OUT] = 0;
+    }
+
+    //
+    // How many (total) endpoints does this configuration describe?
+    //
+    ui32NumEndpoints = USBDCDConfigDescGetNum(psConfig,
+                                              USB_DTYPE_ENDPOINT);
+
+    //
+    // How many interfaces are included?
+    //
+    ui32NumInterfaces = USBDCDConfigDescGetNum(psConfig,
+                                               USB_DTYPE_INTERFACE);
+
+    //
+    // Look at each endpoint and determine the largest max packet size for
+    // each endpoint.  This will determine how we partition the USB FIFO.
+    //
+    for(ui32Loop = 0; ui32Loop < ui32NumEndpoints; ui32Loop++)
+    {
+        //
+        // Get a pointer to the endpoint descriptor.
+        //
+        psEndpoint = (tEndpointDescriptor *)USBDCDConfigDescGet(
+                                psConfig, USB_DTYPE_ENDPOINT, ui32Loop,
+                                &ui32Section);
+
+        //
+        // Extract the endpoint number and whether it is an IN or OUT
+        // endpoint.
+        //
+        ui32EpIndex = (uint32_t)
+                        psEndpoint->bEndpointAddress & USB_EP_DESC_NUM_M;
+        ui32EpType = (psEndpoint->bEndpointAddress & USB_EP_DESC_IN) ?
+                     EP_INFO_IN : EP_INFO_OUT;
+
+        //
+        // Make sure the endpoint number is valid for our controller.  If not,
+        // return false to indicate an error.  Note that 0 is invalid since
+        // you shouldn't reference endpoint 0 in the config descriptor.
+        //
+        if((ui32EpIndex >= NUM_USB_EP) || (ui32EpIndex == 0))
+        {
+            return(false);
+        }
+
+        //
+        // Does this endpoint have a max packet size requirement larger than
+        // any previous use we have seen?
+        //
+        if(psEndpoint->wMaxPacketSize >
+           psEPInfo[ui32EpIndex - 1].pui32Size[ui32EpType])
+        {
+            //
+            // Yes - remember the new maximum packet size.
+            //
+            psEPInfo[ui32EpIndex - 1].pui32Size[ui32EpType] =
+                psEndpoint->wMaxPacketSize;
+        }
+    }
+
+    //
+    // At this point, we have determined the maximum packet size required
+    // for each endpoint by any possible alternate setting of any interface
+    // in this configuration.  Now determine the endpoint settings required
+    // for the interface setting we are actually going to use.
+    //
+    for(ui32Loop = 0; ui32Loop < ui32NumInterfaces; ui32Loop++)
+    {
+        //
+        // Get the next interface descriptor in the configuration descriptor.
+        //
+        psInterface = USBDCDConfigGetInterface(psConfig, ui32Loop,
+                                               USB_DESC_ANY, &ui32Section);
+
+        //
+        // Is this the default interface (bAlternateSetting set to 0)?
+        //
+        if(psInterface && (psInterface->bAlternateSetting == 0))
+        {
+            //
+            // This is an interface we are interested in so gather the
+            // information on its endpoints.
+            //
+            ui32NumEndpoints = (uint32_t)psInterface->bNumEndpoints;
+
+            //
+            // Walk through each endpoint in this interface and configure
+            // it appropriately.
+            //
+            for(ui32Count = 0; ui32Count < ui32NumEndpoints; ui32Count++)
+            {
+                //
+                // Get a pointer to the endpoint descriptor.
+                //
+                psEndpoint = USBDCDConfigGetInterfaceEndpoint(psConfig,
+                                            psInterface->bInterfaceNumber,
+                                            psInterface->bAlternateSetting,
+                                            ui32Count);
+
+                //
+                // Make sure we got a good pointer.
+                //
+                if(psEndpoint)
+                {
+                    //
+                    // Determine maximum packet size and flags from the
+                    // endpoint descriptor.
+                    //
+                    GetEPDescriptorType(psEndpoint, &ui32EpIndex, &ui32MaxPkt,
+                                        &ui32Flags);
+
+                    //
+                    // Make sure no-one is trying to configure endpoint 0.
+                    //
+                    if(!ui32EpIndex)
+                    {
+                        return(false);
+                    }
+
+                    //
+                    // Set the endpoint configuration.
+                    //
+                    USBDevEndpointConfigSet(USB0_BASE,
+                                            IndexToUSBEP(ui32EpIndex),
+                                            ui32MaxPkt, ui32Flags);
+                }
+            }
+        }
+    }
+
+    //
+    // At this point, we have configured all the endpoints that are to be
+    // used by this configuration's alternate setting 0.  Now we go on and
+    // partition the FIFO based on the maximum packet size information we
+    // extracted earlier.  Endpoint 0 is automatically configured to use the
+    // first MAX_PACKET_SIZE_EP0 bytes of the FIFO so we start from there.
+    //
+    ui32Count = MAX_PACKET_SIZE_EP0;
+    for(ui32Loop = 1; ui32Loop < NUM_USB_EP; ui32Loop++)
+    {
+        //
+        // Configure the IN endpoint at this index if it is referred to
+        // anywhere.
+        //
+        if(psEPInfo[ui32Loop - 1].pui32Size[EP_INFO_IN])
+        {
+            //
+            // What FIFO size flag do we use for this endpoint?
+            //
+            ui32MaxPkt = GetEndpointFIFOSize(
+                                psEPInfo[ui32Loop - 1].pui32Size[EP_INFO_IN],
+                                &ui32BytesUsed);
+
+            //
+            // The FIFO space could not be allocated.
+            //
+            if(ui32BytesUsed == 0)
+            {
+                return(false);
+            }
+
+            //
+            // Now actually configure the FIFO for this endpoint.
+            //
+            USBFIFOConfigSet(USB0_BASE, IndexToUSBEP(ui32Loop), ui32Count,
+                             ui32MaxPkt, USB_EP_DEV_IN);
+            ui32Count += ui32BytesUsed;
+        }
+
+        //
+        // Configure the OUT endpoint at this index.
+        //
+        if(psEPInfo[ui32Loop - 1].pui32Size[EP_INFO_OUT])
+        {
+            //
+            // What FIFO size flag do we use for this endpoint?
+            //
+            ui32MaxPkt = GetEndpointFIFOSize(
+                                psEPInfo[ui32Loop - 1].pui32Size[EP_INFO_OUT],
+                                &ui32BytesUsed);
+
+            //
+            // The FIFO space could not be allocated.
+            //
+            if(ui32BytesUsed == 0)
+            {
+                return(false);
+            }
+
+            //
+            // Now actually configure the FIFO for this endpoint.
+            //
+            USBFIFOConfigSet(USB0_BASE, IndexToUSBEP(ui32Loop), ui32Count,
+                             ui32MaxPkt, USB_EP_DEV_OUT);
+            ui32Count += ui32BytesUsed;
+        }
+
+    }
+
+    //
+    // If we get to the end, all is well.
+    //
+    return(true);
+}
+
+//*****************************************************************************
+//
+//! Configure the affected USB endpoints appropriately for one alternate
+//! interface setting.
+//!
+//! \param psDevInst is a pointer to the device instance being configured.
+//! \param psConfig is a pointer to the configuration descriptor that contains
+//! the interface whose alternate settings is to be configured.
+//! \param ui8InterfaceNum is the number of the interface whose alternate
+//! setting is to be configured.  This number corresponds to the
+//! bInterfaceNumber field in the desired interface descriptor.
+//! \param ui8AlternateSetting is the alternate setting number for the desired
+//! interface.  This number corresponds to the bAlternateSetting field in the
+//! desired interface descriptor.
+//!
+//! This function may be used to reconfigure the endpoints of an interface
+//! for operation in one of the interface's alternate settings.  Note that this
+//! function assumes that the endpoint FIFO settings will not need to change
+//! and only the endpoint mode is changed.  This assumption is valid if the
+//! USB controller was initialized using a previous call to USBDCDConfig().
+//!
+//! In reconfiguring the interface endpoints, any additional configuration
+//! bits set in the endpoint configuration other than the direction (\b
+//! USB_EP_DEV_IN or \b USB_EP_DEV_OUT) and mode (\b USB_EP_MODE_MASK) are
+//! preserved.
+//!
+//! \return Returns \b true on success or \b false on failure.
+//
+//*****************************************************************************
+bool
+USBDeviceConfigAlternate(tDCDInstance *psDevInst,
+                         const tConfigHeader *psConfig,
+                         uint8_t ui8InterfaceNum,
+                         uint8_t ui8AlternateSetting)
+{
+    uint32_t ui32NumInterfaces, ui32NumEndpoints, ui32Loop, ui32Count,
+             ui32MaxPkt, ui32Flags, ui32Section, ui32EpIndex;
+    tInterfaceDescriptor *psInterface;
+    tEndpointDescriptor *psEndpoint;
+
+    //
+    // How many interfaces are included in the descriptor?
+    //
+    ui32NumInterfaces = USBDCDConfigDescGetNum(psConfig,
+                                               USB_DTYPE_INTERFACE);
+
+    //
+    // Find the interface descriptor for the supplied interface and alternate
+    // setting numbers.
+    //
+
+    for(ui32Loop = 0; ui32Loop < ui32NumInterfaces; ui32Loop++)
+    {
+        //
+        // Get the next interface descriptor in the configuration descriptor.
+        //
+        psInterface = USBDCDConfigGetInterface(psConfig, ui32Loop,
+                                               USB_DESC_ANY, &ui32Section);
+
+        //
+        // Is this the default interface (bAlternateSetting set to 0)?
+        //
+        if(psInterface &&
+           (psInterface->bInterfaceNumber == ui8InterfaceNum) &&
+           (psInterface->bAlternateSetting == ui8AlternateSetting))
+        {
+            //
+            // This is an interface we are interested in and the descriptor
+            // representing the alternate setting we want so go ahead and
+            // reconfigure the endpoints.
+            //
+
+            //
+            // How many endpoints does this interface have?
+            //
+            ui32NumEndpoints = (uint32_t)psInterface->bNumEndpoints;
+
+            //
+            // Walk through each endpoint in turn.
+            //
+            for(ui32Count = 0; ui32Count < ui32NumEndpoints; ui32Count++)
+            {
+                //
+                // Get a pointer to the endpoint descriptor.
+                //
+                psEndpoint = USBDCDConfigGetInterfaceEndpoint(psConfig,
+                                              psInterface->bInterfaceNumber,
+                                              psInterface->bAlternateSetting,
+                                              ui32Count);
+
+                //
+                // Make sure we got a good pointer.
+                //
+                if(psEndpoint)
+                {
+                    //
+                    // Determine maximum packet size and flags from the
+                    // endpoint descriptor.
+                    //
+                    GetEPDescriptorType(psEndpoint, &ui32EpIndex, &ui32MaxPkt,
+                                        &ui32Flags);
+
+                    //
+                    // Make sure no-one is trying to configure endpoint 0.
+                    //
+                    if(!ui32EpIndex)
+                    {
+                        return(false);
+                    }
+
+                    //
+                    // Set the endpoint configuration.
+                    //
+                    USBDevEndpointConfigSet(USB0_BASE,
+                                            IndexToUSBEP(ui32EpIndex),
+                                            ui32MaxPkt, ui32Flags);
+                }
+            }
+
+            //
+            // At this point, we have reconfigured the desired interface so
+            // return indicating all is well.
+            //
+            return(true);
+        }
+    }
+
+    return(false);
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
diff --git a/bsp/tm4c129x/libraries/usblib/device/usbddfu-rt.c b/bsp/tm4c129x/libraries/usblib/device/usbddfu-rt.c
new file mode 100755
index 0000000..89a6988
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/device/usbddfu-rt.c
@@ -0,0 +1,661 @@
+//*****************************************************************************
+//
+// usbddfu-rt.c - USB Device Firmware Update runtime device class driver.
+//
+// Copyright (c) 2010-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "inc/hw_memmap.h"
+#include "inc/hw_types.h"
+#include "inc/hw_nvic.h"
+#include "driverlib/debug.h"
+#include "driverlib/usb.h"
+#include "driverlib/sysctl.h"
+#include "driverlib/systick.h"
+#include "driverlib/interrupt.h"
+#include "driverlib/rom.h"
+#include "driverlib/rom_map.h"
+#include "usblib/usblib.h"
+#include "usblib/usblibpriv.h"
+#include "usblib/usbdfu.h"
+#include "usblib/usb-ids.h"
+#include "usblib/device/usbdevice.h"
+#include "usblib/device/usbddfu-rt.h"
+#include "usblib/usblibpriv.h"
+
+//*****************************************************************************
+//
+//! \addtogroup dfu_device_class_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// DFU Device Descriptor.  This is a dummy structure since runtime DFU must be
+// a part of a composite device and cannot be instantiated on its own.
+//
+//*****************************************************************************
+const uint8_t g_pui8DFUDeviceDescriptor[] =
+{
+    18,                             // Size of this structure.
+    USB_DTYPE_DEVICE,               // Type of this structure.
+    USBShort(0x110),                // USB version 1.1 (if we say 2.0, hosts
+                                    // assume
+                                    // high-speed - see USB 2.0 spec 9.2.6.6)
+    USB_CLASS_VEND_SPECIFIC,        // USB Device Class
+    0,                              // USB Device Sub-class
+    0,                              // USB Device protocol
+    64,                             // Maximum packet size for default pipe.
+    USBShort(0),                    // Vendor ID (VID).
+    USBShort(0),                    // Product ID (PID).
+    USBShort(0),                    // Device Release Number BCD.
+    0,                              // Manufacturer string identifier.
+    0,                              // Product string identifier.
+    0,                              // Product serial number.
+    1                               // Number of configurations.
+};
+
+//*****************************************************************************
+//
+// DFU device runtime configuration descriptor.  This is also a dummy structure
+// since the primary device class configuration will be used when DFU is added
+// to the composite device.
+//
+//*****************************************************************************
+uint8_t g_pui8DFUConfigDescriptor[] =
+{
+    //
+    // Configuration descriptor header.
+    //
+    9,                              // Size of the configuration descriptor.
+    USB_DTYPE_CONFIGURATION,        // Type of this descriptor.
+    USBShort(27),                   // The total size of this full structure.
+    1,                              // The number of interfaces in this
+                                    // configuration.
+    1,                              // The unique value for this configuration.
+    0,                              // The string identifier that describes
+                                    // this configuration.
+    USB_CONF_ATTR_SELF_PWR,         // Bus Powered, Self Powered, remote wake
+                                    // up.
+    250,                            // The maximum power in 2mA increments.
+};
+
+//*****************************************************************************
+//
+// The DFU runtime interface descriptor.
+//
+//*****************************************************************************
+uint8_t g_pui8DFUInterface[DFUINTERFACE_SIZE] =
+{
+    //
+    // Interface descriptor for runtime DFU operation.
+    //
+    9,                              // Length of this descriptor.
+    USB_DTYPE_INTERFACE,            // This is an interface descriptor.
+    0,                              // Interface number .
+    0,                              // Alternate setting number.
+    0,                              // Number of endpoints (only endpoint 0
+                                    // used)
+    USB_CLASS_APP_SPECIFIC,         // Application specific interface class
+    USB_DFU_SUBCLASS,               // Device Firmware Upgrade subclass
+    USB_DFU_RUNTIME_PROTOCOL,       // DFU runtime protocol
+    0,                              // No string descriptor for this interface.
+};
+
+//*****************************************************************************
+//
+// The DFU functional descriptor.
+//
+//*****************************************************************************
+uint8_t g_pui8DFUFunctionalDesc[DFUFUNCTIONALDESC_SIZE] =
+{
+    //
+    // Device Firmware Upgrade functional descriptor.
+    //
+    9,                              // Length of this descriptor.
+    USB_DFU_FUNC_DESCRIPTOR_TYPE,   // DFU Functional descriptor type
+    (DFU_ATTR_CAN_DOWNLOAD |        // DFU attributes.
+     DFU_ATTR_CAN_UPLOAD |
+     DFU_ATTR_WILL_DETACH |
+     DFU_ATTR_MANIFEST_TOLERANT),
+    USBShort(0xFFFF),               // Detach timeout (set to maximum).
+    USBShort(DFU_TRANSFER_SIZE),    // Transfer size 1KB.
+    USBShort(0x0110)                // DFU Version 1.1
+};
+
+//*****************************************************************************
+//
+// The DFU runtime configuration descriptor is defined as two sections.
+// These sections are:
+//
+// 1.  The 9 byte configuration descriptor.
+// 2.  The interface descriptor + DFU functional descriptor.
+//
+//*****************************************************************************
+const tConfigSection g_sDFUConfigSection =
+{
+    sizeof(g_pui8DFUConfigDescriptor),
+    g_pui8DFUConfigDescriptor
+};
+
+const tConfigSection g_sDFUInterfaceSection =
+{
+    sizeof(g_pui8DFUInterface),
+    g_pui8DFUInterface
+};
+
+const tConfigSection g_sDFUFunctionalDescSection =
+{
+    sizeof(g_pui8DFUFunctionalDesc),
+    g_pui8DFUFunctionalDesc
+};
+
+//*****************************************************************************
+//
+// This array lists all the sections that must be concatenated to make a
+// single, complete DFU runtime configuration descriptor.
+//
+//*****************************************************************************
+const tConfigSection *g_psDFUSections[] =
+{
+    &g_sDFUConfigSection,
+    &g_sDFUInterfaceSection,
+    &g_sDFUFunctionalDescSection
+};
+
+#define NUM_DFU_SECTIONS        (sizeof(g_psDFUSections) /                    \
+                                 sizeof(g_psDFUSections[0]))
+
+//*****************************************************************************
+//
+// The header for the single configuration we support.  This is the root of
+// the data structure that defines all the bits and pieces that are pulled
+// together to generate the configuration descriptor.
+//
+//*****************************************************************************
+tConfigHeader g_sDFUConfigHeader =
+{
+    NUM_DFU_SECTIONS,
+    g_psDFUSections
+};
+
+//*****************************************************************************
+//
+// Configuration Descriptor.
+//
+//*****************************************************************************
+const tConfigHeader * const g_ppsDFUConfigDescriptors[] =
+{
+    &g_sDFUConfigHeader
+};
+
+//*****************************************************************************
+//
+// Forward references for device handler callbacks
+//
+//*****************************************************************************
+static void HandleGetDescriptor(void *pvDFUInstance, tUSBRequest *psUSBRequest);
+static void HandleRequest(void *pvDFUInstance, tUSBRequest *psUSBRequest);
+static void HandleDevice(void *pvDFUInstance, uint32_t ui32Request,
+                         void *pvRequestData);
+
+//*****************************************************************************
+//
+// The device information structure for the USB DFU devices.
+//
+//*****************************************************************************
+static const tCustomHandlers g_sDFUHandlers =
+{
+    //
+    // GetDescriptor
+    //
+    HandleGetDescriptor,
+
+    //
+    // RequestHandler
+    //
+    HandleRequest,
+
+    //
+    // InterfaceChange
+    //
+    0,
+
+    //
+    // ConfigChange
+    //
+    0,
+
+    //
+    // DataReceived
+    //
+    0,
+
+    //
+    // DataSentCallback
+    //
+    0,
+
+    //
+    // ResetHandler
+    //
+    0,
+
+    //
+    // SuspendHandler
+    //
+    0,
+
+    //
+    //
+
+    //
+    // ResumeHandler
+    //
+    0,
+
+    //
+    // DisconnectHandler
+    //
+    0,
+
+    //
+    // EndpointHandler
+    //
+    0,
+
+    //
+    // Device handler.
+    //
+    HandleDevice,
+};
+
+//*****************************************************************************
+//
+// Device instance specific handler.  This callback received notifications of
+// events related to handling interface, endpoint and string identifiers when
+// a device is part of a composite device.  In this case, the only resource we
+// need which may be renumbered is the DFU runtime interface.
+//
+//*****************************************************************************
+static void
+HandleDevice(void *pvDFUInstance, uint32_t ui32Request, void *pvRequestData)
+{
+    tDFUInstance *psInst;
+    uint8_t *pui8Data;
+
+    //
+    // Get a pointer to the DFU device instance data pointer
+    //
+    psInst = &((tUSBDDFUDevice *)pvDFUInstance)->sPrivateData;
+
+    //
+    // Get a byte pointer to the data.
+    //
+    pui8Data = (uint8_t *)pvRequestData;
+
+    //
+    // Which request event have we been passed?
+    //
+    switch(ui32Request)
+    {
+        //
+        // This was an interface change event.
+        //
+        case USB_EVENT_COMP_IFACE_CHANGE:
+        {
+            //
+            // Save the change to the interface number.
+            //
+            psInst->ui8Interface = pui8Data[1];
+            break;
+        }
+
+        //
+        // We are not interested in any other event.
+        //
+        default:
+        {
+            break;
+        }
+    }
+}
+
+//*****************************************************************************
+//
+// This function is called by the USB device stack whenever a request for a
+// non-standard descriptor is received.
+//
+// \param pvDFUInstance is the instance data for this request.
+// \param psUSBRequest points to the request received.
+//
+// This call parses the provided request structure and determines which
+// descriptor is being requested.  Assuming the descriptor can be found, it is
+// scheduled for transmission via endpoint zero.  If the descriptor cannot be
+// found, the endpoint is stalled to indicate an error to the host.
+//
+//*****************************************************************************
+static void
+HandleGetDescriptor(void *pvDFUInstance, tUSBRequest *psUSBRequest)
+{
+    uint32_t ui32Size;
+
+    ASSERT(pvDFUInstance != 0);
+
+    //
+    // Which type of class descriptor are we being asked for?  We only support
+    // 1 type - the DFU functional descriptor.
+    //
+    if(((psUSBRequest->wValue >> 8) == USB_DFU_FUNC_DESCRIPTOR_TYPE) &&
+       ((psUSBRequest->wValue & 0xFF) == 0))
+    {
+        //
+        // If there is more data to send than the host requested then just
+        // send the requested amount of data.
+        //
+        if((uint16_t)g_pui8DFUFunctionalDesc[0] > psUSBRequest->wLength)
+        {
+            ui32Size = (uint32_t)psUSBRequest->wLength;
+        }
+        else
+        {
+            ui32Size = (uint32_t)g_pui8DFUFunctionalDesc[0];
+        }
+
+        //
+        // Send the data via endpoint 0.
+        //
+        USBDCDSendDataEP0(0, g_pui8DFUFunctionalDesc, ui32Size);
+    }
+    else
+    {
+        //
+        // This was an unknown or invalid request so stall.
+        //
+        USBDCDStallEP0(0);
+    }
+}
+
+//*****************************************************************************
+//
+// This function is called by the USB device stack whenever a non-standard
+// request is received.
+//
+// \param pvDFUInstance is the instance data for this HID device.
+// \param psUSBRequest points to the request received.
+//
+// This call parses the provided request structure.  Assuming the request is
+// understood, it is handled and any required response generated.  If the
+// request cannot be handled by this device class, endpoint zero is stalled to
+// indicate an error to the host.
+//
+//*****************************************************************************
+static void
+HandleRequest(void *pvDFUInstance, tUSBRequest *psUSBRequest)
+{
+    tDFUInstance *psInst;
+    tUSBDDFUDevice *psDevice;
+
+    ASSERT(pvDFUInstance != 0);
+
+    //
+    // Get a pointer to the DFU device structure
+    //
+    psDevice = pvDFUInstance;
+
+    //
+    // Get a pointer to the DFU device instance data pointer
+    //
+    psInst = &psDevice->sPrivateData;
+
+    //
+    // Make sure the request was for this interface.
+    //
+    if(psUSBRequest->wIndex != psInst->ui8Interface)
+    {
+        return;
+    }
+
+    //
+    // Determine the type of request.
+    //
+    switch(psUSBRequest->bRequest)
+    {
+        //
+        // We have been asked to detach.  In this case, we call back to the
+        // application telling it to tidy up and re-enter the boot loader.  We
+        // rely upon it doing this on our behalf since this must be done from a
+        // non-interrupt context and this call is most likely in interrupt
+        // context.
+        //
+        case USBD_DFU_REQUEST_DETACH:
+        {
+            //
+            // Tell the application it's time to reenter the boot loader.
+            //
+            psDevice->pfnCallback(psDevice->pvCBData, USBD_DFU_EVENT_DETACH,
+                                  0, (void *)0);
+            break;
+        }
+
+        //
+        // This request was not recognized so stall.
+        //
+        default:
+        {
+            USBDCDStallEP0(0);
+            break;
+        }
+    }
+}
+
+//*****************************************************************************
+//
+//! Initializes DFU device operation for a given USB controller.
+//!
+//! \param ui32Index is the index of the USB controller which is to be
+//! initialized for DFU runtime device operation.
+//! \param psDFUDevice points to a structure containing parameters customizing
+//! the operation of the DFU device.
+//! \param psCompEntry is the composite device entry to initialize when
+//! creating a composite device.
+//!
+//! The \e psCompEntry should point to the composite device entry to
+//! initialize. This is part of the array that is passed to the
+//! USBDCompositeInit() function.
+//!
+//! \return Returns zero on failure or a non-zero instance value that should be
+//! used with the remaining USB DFU APIs.
+//
+//*****************************************************************************
+void *
+USBDDFUCompositeInit(uint32_t ui32Index, tUSBDDFUDevice *psDFUDevice,
+                     tCompositeEntry *psCompEntry)
+{
+    tDFUInstance *psInst;
+
+    //
+    // Check parameter validity.
+    //
+    ASSERT(ui32Index == 0);
+    ASSERT(psDFUDevice);
+    ASSERT(psCompEntry != 0);
+
+    //
+    // Get a pointer to the DFU device instance data pointer
+    //
+    psInst = &psDFUDevice->sPrivateData;
+
+    //
+    // Initialize the composite entry that is used by the composite device
+    // class.
+    //
+    if(psCompEntry != 0)
+    {
+        psCompEntry->psDevInfo = &psInst->sDevInfo;
+        psCompEntry->pvInstance = (void *)psDFUDevice;
+    }
+
+    //
+    // Initialize the device information structure.
+    //
+    psInst->sDevInfo.psCallbacks = &g_sDFUHandlers;
+    psInst->sDevInfo.pui8DeviceDescriptor = g_pui8DFUDeviceDescriptor;
+    psInst->sDevInfo.ppsConfigDescriptors = g_ppsDFUConfigDescriptors;
+    psInst->sDevInfo.ppui8StringDescriptors = 0;
+    psInst->sDevInfo.ui32NumStringDescriptors = 0;
+
+    psInst->ui32USBBase = USB0_BASE;
+    psInst->bConnected = false;
+    psInst->ui8Interface = 0;
+
+    //
+    // Initialize the device info structure for the DFU device.
+    //
+    USBDCDDeviceInfoInit(0, &psInst->sDevInfo);
+
+    //
+    // Return the pointer to the instance indicating that everything went well.
+    //
+    return((void *)psDFUDevice);
+}
+
+//*****************************************************************************
+//
+//! Shuts down the DFU device.
+//!
+//! \param pvDFUInstance is the pointer to the device instance structure as
+//! returned by USBDDFUCompositeInit().
+//!
+//! This function terminates DFU operation for the instance supplied and
+//! removes the device from the USB bus.
+//!
+//! Following this call, the \e pvDFUInstance instance should not me used in
+//! any other calls.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBDDFUCompositeTerm(void *pvDFUInstance)
+{
+    tDFUInstance *psInst;
+
+    ASSERT(pvDFUInstance);
+
+    //
+    // Get a pointer to our instance data.
+    //
+    psInst = &((tUSBDDFUDevice *)pvDFUInstance)->sPrivateData;
+
+    //
+    // Terminate the requested instance.
+    //
+    USBDCDTerm(0);
+
+    psInst->ui32USBBase = 0;
+}
+
+//*****************************************************************************
+//
+//! Removes the current USB device from the bus and transfers control to the
+//! DFU boot loader.
+//!
+//! This function should be called from the application's main loop (i.e. not
+//! in interrupt context) following a callback to the USB DFU callback function
+//! notifying the application of a DETACH request from the host.  The function
+//! will prepare the system to switch to DFU mode and transfer control to the
+//! boot loader in preparation for a firmware upgrade from the host.
+//!
+//! The application must ensure that it has completed all necessary shutdown
+//! activities (saved any required data, etc.) before making this call since
+//! the function will not return.
+//!
+//! \return This function does not return.
+//
+//*****************************************************************************
+void
+USBDDFUUpdateBegin(void)
+{
+    //
+    // Terminate the USB device and take us off the bus.
+    //
+    USBDCDTerm(0);
+
+    //
+    // Disable all interrupts.
+    //
+    MAP_IntMasterDisable();
+
+    //
+    // We must make sure we turn off SysTick and its interrupt
+    // before entering the boot loader!
+    //
+    MAP_SysTickIntDisable();
+    MAP_SysTickDisable();
+
+    //
+    // Disable all processor interrupts.  Instead of disabling them
+    // one at a time, a direct write to NVIC is done to disable all
+    // peripheral interrupts.
+    //
+    HWREG(NVIC_DIS0) = 0xffffffff;
+    HWREG(NVIC_DIS1) = 0xffffffff;
+
+    //
+    // Reset the USB peripheral
+    //
+    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_USB0);
+    MAP_SysCtlPeripheralReset(SYSCTL_PERIPH_USB0);
+    MAP_SysCtlPeripheralDisable(SYSCTL_PERIPH_USB0);
+
+    //
+    // Wait for about a second.
+    //
+    MAP_SysCtlDelay(MAP_SysCtlClockGet() / 3);
+
+    //
+    // Re-enable interrupts at the NVIC level.
+    //
+    MAP_IntMasterEnable();
+
+    //
+    // Return control to the boot loader.  This is a call to the SVC
+    // handler in the boot loader.
+    //
+    (*((void (*)(void))(*(uint32_t *)0x2c)))();
+
+    //
+    // Should never get here, but just in case.
+    //
+    while(1)
+    {
+    }
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
diff --git a/bsp/tm4c129x/libraries/usblib/device/usbddfu-rt.h b/bsp/tm4c129x/libraries/usblib/device/usbddfu-rt.h
new file mode 100755
index 0000000..9ec6d6b
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/device/usbddfu-rt.h
@@ -0,0 +1,184 @@
+//*****************************************************************************
+//
+// usbddfu-rt.h - Definitions used by runtime DFU class devices.
+//
+// Copyright (c) 2010-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#ifndef __USBDDFURT_H__
+#define __USBDDFURT_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+//*****************************************************************************
+//
+//! \addtogroup dfu_device_class_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// This is the size of the g_pui8DFUInterface array in bytes.
+//
+//*****************************************************************************
+#define DFUINTERFACE_SIZE       (9)
+
+//*****************************************************************************
+//
+// This is the size of the g_pui8DFUFunctionalDesc array in bytes.
+//
+//*****************************************************************************
+#define DFUFUNCTIONALDESC_SIZE  (9)
+
+//*****************************************************************************
+//
+//! The size of the memory that should be allocated to create a configuration
+//! descriptor for a single instance of the DFU runtime device.  This does not
+//! include the configuration descriptor which is automatically ignored by the
+//! composite device class.
+//!
+//! This label is used to compute the value which will be passed to the
+//! USBDCompositeInit function in the ui32Size parameter.
+//
+//*****************************************************************************
+#define COMPOSITE_DDFU_SIZE     (DFUINTERFACE_SIZE + DFUFUNCTIONALDESC_SIZE)
+
+//*****************************************************************************
+//
+//! This value is passed to the client via the callback function provided in
+//! the tUSBDDFUDevice structure and indicates that the host has sent a DETACH
+//! request to the DFU interface. This request indicates that the device detach
+//! from the USB bus and reattach in DFU mode in preparation for a firmware
+//! upgrade.  Currently, this is the only event that the DFU runtime class
+//! reports to the client.
+//!
+//! When this event is received, the client should call USBDDFUUpdateBegin()
+//! from a non-interrupt context at its earliest opportunity.
+//
+//*****************************************************************************
+#define USBD_DFU_EVENT_DETACH (USBD_DFU_EVENT_BASE + 0)
+
+//*****************************************************************************
+//
+// PRIVATE
+//
+// This structure defines the private instance data and state variables for
+// DFU devices.  The memory for this structure is included in the
+// sPrivateData field in the tUSBDDFUDevice structure passed in the
+// USBDDFUCompositeInit() function.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    // Base address for the USB controller.
+    //
+    uint32_t ui32USBBase;
+
+    //
+    // The device info to interact with the lower level DCD code.
+    //
+    tDeviceInfo sDevInfo;
+
+    //
+    // The DFU class interface number, this is modified in composite devices.
+    //
+    uint8_t ui8Interface;
+
+    //
+    // The connection status of the device.
+    //
+    bool bConnected;
+}
+tDFUInstance;
+
+//*****************************************************************************
+//
+//! The structure used by the application to define operating parameters for
+//! the DFU device.  Note that, unlike all other devices, this structure does
+//! not contain any fields which configure the device descriptor sent back to
+//! the host.  The DFU runtime device class must be used as part of a composite
+//! device since all it provides is the capability to signal the device to
+//! switch into DFU mode in preparation for a firmware upgrade.  Creating a
+//! device with nothing but DFU runtime mode capability is rather pointless
+//! so this is not supported.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! A pointer to the callback function which will be called to notify
+    //! the application of DETACH requests.
+    //
+    const tUSBCallback pfnCallback;
+
+    //
+    //! A client-supplied pointer which will be sent as the first
+    //! parameter in all calls made to the pfnCallback function.
+    //
+    void * const pvCBData;
+
+    //
+    //! The private instance data for this device class.  This
+    //! memory must remain accessible for as long as the DFU device is in use
+    //! and must not be modified by any code outside the DFU class driver.
+    //
+    tDFUInstance sPrivateData;
+}
+tUSBDDFUDevice;
+
+//*****************************************************************************
+//
+// API Function Prototypes
+//
+//*****************************************************************************
+extern void *USBDDFUCompositeInit(uint32_t ui32Index,
+                                  tUSBDDFUDevice *psDFUDevice,
+                                  tCompositeEntry *psCompEntry);
+extern void USBDDFUCompositeTerm(void *pvDFUInstance);
+extern void USBDDFUUpdateBegin(void);
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __USBDDFURT_H__
diff --git a/bsp/tm4c129x/libraries/usblib/device/usbdenum.c b/bsp/tm4c129x/libraries/usblib/device/usbdenum.c
new file mode 100755
index 0000000..719beb0
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/device/usbdenum.c
@@ -0,0 +1,3190 @@
+//*****************************************************************************
+//
+// usbenum.c - Enumeration code to handle all endpoint zero traffic.
+//
+// Copyright (c) 2007-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "inc/hw_ints.h"
+#include "inc/hw_memmap.h"
+#include "inc/hw_types.h"
+#include "inc/hw_sysctl.h"
+#include "driverlib/debug.h"
+#include "driverlib/interrupt.h"
+#include "driverlib/rom.h"
+#include "driverlib/rom_map.h"
+#include "driverlib/sysctl.h"
+#include "driverlib/usb.h"
+#include "driverlib/rtos_bindings.h"
+#include "usblib/usblib.h"
+#include "usblib/usblibpriv.h"
+#include "usblib/usbulpi.h"
+#include "usblib/device/usbdevice.h"
+#include "usblib/device/usbdevicepriv.h"
+#include "usblib/usblibpriv.h"
+
+//*****************************************************************************
+//
+// External prototypes.
+//
+//*****************************************************************************
+extern tUSBMode g_iUSBMode;
+
+//*****************************************************************************
+//
+// Local functions prototypes.
+//
+//*****************************************************************************
+static void USBDGetStatus(void *pvInstance, tUSBRequest *psUSBRequest);
+static void USBDClearFeature(void *pvInstance, tUSBRequest *psUSBRequest);
+static void USBDSetFeature(void *pvInstance, tUSBRequest *psUSBRequest);
+static void USBDSetAddress(void *pvInstance, tUSBRequest *psUSBRequest);
+static void USBDGetDescriptor(void *pvInstance, tUSBRequest *psUSBRequest);
+static void USBDSetDescriptor(void *pvInstance, tUSBRequest *psUSBRequest);
+static void USBDGetConfiguration(void *pvInstance,
+                                 tUSBRequest *psUSBRequest);
+static void USBDSetConfiguration(void *pvInstance,
+                                 tUSBRequest *psUSBRequest);
+static void USBDGetInterface(void *pvInstance, tUSBRequest *psUSBRequest);
+static void USBDSetInterface(void *pvInstance, tUSBRequest *psUSBRequest);
+static void USBDSyncFrame(void *pvInstance, tUSBRequest *psUSBRequest);
+static void USBDEP0StateTx(uint32_t ui32Index);
+static void USBDEP0StateTxConfig(uint32_t ui32Index);
+static int32_t USBDStringIndexFromRequest(uint16_t ui16Lang,
+                                          uint16_t ui16Index);
+
+//*****************************************************************************
+//
+//! \addtogroup device_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Indices into the ppui8Halt array to select the IN or OUT endpoint group.
+//
+//*****************************************************************************
+#define HALT_EP_IN              0
+#define HALT_EP_OUT             1
+
+//*****************************************************************************
+//
+// Define the max packet size for endpoint zero.
+//
+//*****************************************************************************
+#define EP0_MAX_PACKET_SIZE     64
+
+//*****************************************************************************
+//
+// This is a flag used with g_sUSBDeviceState.ui32DevAddress to indicate that a
+// device address change is pending.
+//
+//*****************************************************************************
+#define DEV_ADDR_PENDING        0x80000000
+
+//*****************************************************************************
+//
+// This label defines the default configuration number to use after a bus
+// reset.  This may be overridden by calling USBDCDSetDefaultConfiguration()
+// during processing of the device reset handler if required.
+//
+//*****************************************************************************
+#define DEFAULT_CONFIG_ID       1
+
+//*****************************************************************************
+//
+// This label defines the number of milliseconds that the remote wake up signal
+// must remain asserted before removing it. Section 7.1.7.7 of the USB 2.0 spec
+// states that "the remote wake up device must hold the resume signaling for at
+// least 1ms but for no more than 15ms" so 10mS seems a reasonable choice.
+//
+//*****************************************************************************
+#define REMOTE_WAKEUP_PULSE_MS 10
+
+//*****************************************************************************
+//
+// This label defines the number of milliseconds between the point where we
+// assert the remote wake up signal and calling the client back to tell it that
+// bus operation has been resumed.  This value is based on the timings provided
+// in section 7.1.7.7 of the USB 2.0 specification which indicates that the
+// host (which takes over resume signaling when the device's initial signal is
+// detected) must hold the resume signaling for at least 20mS.
+//
+//*****************************************************************************
+#define REMOTE_WAKEUP_READY_MS 20
+
+//*****************************************************************************
+//
+// The LPM states.
+//
+//*****************************************************************************
+#define USBLIB_LPM_STATE_DISABLED   0x00000000
+#define USBLIB_LPM_STATE_AWAKE      0x00000001
+#define USBLIB_LPM_STATE_SLEEP      0x00000002
+
+//*****************************************************************************
+//
+// The buffer for reading data coming into EP0
+//
+//*****************************************************************************
+static uint8_t g_pui8DataBufferIn[EP0_MAX_PACKET_SIZE];
+
+//*****************************************************************************
+//
+// This is 480000000/60000000 or a PLL Divide of 8.
+//
+//*****************************************************************************
+static uint32_t g_ui32PLLDiv = 8;
+
+//*****************************************************************************
+//
+// Holds the ULPI configuration.
+//
+//*****************************************************************************
+static uint32_t g_ui32ULPISupport;
+
+//*****************************************************************************
+//
+// This is the instance data for the USB controller itself and not a USB
+// device class.
+//
+//*****************************************************************************
+tDCDInstance g_psDCDInst[1];
+
+//*****************************************************************************
+//
+// This is the currently active class in use by USBLib.  There is only one
+// of these per USB controller and no device has more than one controller.
+//
+//*****************************************************************************
+tDeviceInfo *g_ppsDevInfo[1];
+
+//*****************************************************************************
+//
+// Function table to handle standard requests.
+//
+//*****************************************************************************
+static const tStdRequest g_psUSBDStdRequests[] =
+{
+    USBDGetStatus,
+    USBDClearFeature,
+    0,
+    USBDSetFeature,
+    0,
+    USBDSetAddress,
+    USBDGetDescriptor,
+    USBDSetDescriptor,
+    USBDGetConfiguration,
+    USBDSetConfiguration,
+    USBDGetInterface,
+    USBDSetInterface,
+    USBDSyncFrame
+};
+
+//*****************************************************************************
+//
+// Functions accessible by USBLIB clients.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! Initialize an instance of the tDeviceInfo structure.
+//!
+//! \param ui32Index is the index of the USB controller which is to be
+//! initialized.
+//! \param psDeviceInfo is a pointer to the tDeviceInfo structure that needs
+//! to be initialized.
+//!
+//! This function must be called by a USB device class
+//! instance to initialize the basic tDeviceInfo required for all USB device
+//! class modules.  This is typically called in the initialization routine for
+//! USB device class.  For example in usbdaudio.c that supports USB device
+//! audio classes, this function is called in the USBDAudioCompositeInit()
+//! function which is used for both composite and non-composites instances of
+//! the USB audio class.
+//!
+//! \note This function should not be called directly by applications.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBDCDDeviceInfoInit(uint32_t ui32Index, tDeviceInfo *psDeviceInfo)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ui32Index == 0);
+    ASSERT(psDeviceInfo != 0);
+
+    //
+    // Save the USB interrupt number.
+    //
+    g_psDCDInst[0].ui32IntNum = INT_USB0_TM4C123;
+
+    //
+    // These devices have a different USB interrupt number.
+    //
+    if(CLASS_IS_TM4C129)
+    {
+        g_psDCDInst[0].ui32IntNum = INT_USB0_TM4C129;
+    }
+
+    //
+    // Disable LPM support by default.
+    //
+    g_psDCDInst[0].ui32LPMState = 0;
+
+    //
+    // Initialize a couple of fields in the device state structure.
+    //
+    g_psDCDInst[0].ui32Configuration = DEFAULT_CONFIG_ID;
+    g_psDCDInst[0].ui32DefaultConfiguration = DEFAULT_CONFIG_ID;
+
+    g_psDCDInst[0].iEP0State = eUSBStateIdle;
+
+    //
+    // Default to the state where remote wake up is disabled.
+    //
+    g_psDCDInst[0].ui8Status = 0;
+    g_psDCDInst[0].bRemoteWakeup = false;
+
+    //
+    // Determine the self- or bus-powered state based on the flags the
+    // user provided.
+    //
+    g_psDCDInst[0].bPwrSrcSet = false;
+}
+
+//*****************************************************************************
+//
+//! Initialize the USB library device control driver for a given hardware
+//! controller.
+//!
+//! \param ui32Index is the index of the USB controller which is to be
+//! initialized.
+//! \param psDevice is a pointer to a structure containing information that
+//! the USB library requires to support operation of this application's
+//! device.  The structure contains event handler callbacks and pointers to the
+//! various standard descriptors that the device wishes to publish to the
+//! host.
+//! \param pvDCDCBData is the callback data for any device callbacks.
+//!
+//! This function must be called by a device class which wishes to operate
+//! as a USB device and is not typically called by an application.  This
+//! function initializes the USB device control driver for the given
+//! controller and saves the device information for future use.  Prior to
+//! returning from this function, the device is connected to the USB bus.
+//! Following return, the caller can expect to receive a callback to the
+//! supplied <tt>pfnResetHandler</tt> function when a host connects to the
+//! device.  The \e pvDCDCBData contains a pointer to data that is returned
+//! with the DCD calls back to the function in the psDevice->psCallbacks()
+//! functions.
+//!
+//! The device information structure passed in \e psDevice must remain
+//! unchanged between this call and any matching call to USBDCDTerm() because
+//! it is not copied by the USB library.
+//!
+//! The USBStackModeSet() function can be called with eUSBModeForceDevice in
+//! order to cause the USB library to force the USB operating mode to a device
+//! controller.  This allows the application to used the USBVBUS and USBID pins
+//! as GPIOs on devices that support forcing OTG to operate as a device only
+//! controller.  By default the USB library will assume that the USBVBUS and
+//! USBID pins are configured as USB pins and not GPIOs.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBDCDInit(uint32_t ui32Index, tDeviceInfo *psDevice, void *pvDCDCBData)
+{
+    const tConfigHeader *psHdr;
+    const tConfigDescriptor *psDesc;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(ui32Index == 0);
+    ASSERT(psDevice != 0);
+
+    g_ppsDevInfo[0] = psDevice;
+    g_psDCDInst[0].pvCBData = pvDCDCBData;
+
+    //
+    // Initialize the Device Info structure for a USB device instance.
+    //
+    USBDCDDeviceInfoInit(ui32Index, psDevice);
+
+    //
+    // Should not call this if the stack is in host mode.
+    //
+    ASSERT(g_iUSBMode != eUSBModeHost);
+    ASSERT(g_iUSBMode != eUSBModeForceHost);
+
+    //
+    // Default to device mode if no mode was set.
+    //
+    if(g_iUSBMode == eUSBModeNone)
+    {
+        g_iUSBMode = eUSBModeDevice;
+    }
+
+    //
+    // Only do hardware update if the stack is in not in OTG mode.
+    //
+    if(g_iUSBMode != eUSBModeOTG)
+    {
+        //
+        // Reset the USB controller.
+        //
+        MAP_SysCtlPeripheralReset(SYSCTL_PERIPH_USB0);
+
+        //
+        // Enable Clocking to the USB controller.
+        //
+        MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_USB0);
+
+        //
+        // Turn on USB Phy clock.
+        //
+        MAP_SysCtlUSBPLLEnable();
+
+        //
+        // Set the PLL to USB clock divider.
+        //
+        USBClockEnable(USB0_BASE, g_ui32PLLDiv, USB_CLOCK_INTERNAL);
+
+        //
+        // Configure ULPI support.
+        //
+        if(g_ui32ULPISupport != USBLIB_FEATURE_ULPI_NONE)
+        {
+            USBULPIEnable(USB0_BASE);
+
+            if(g_ui32ULPISupport & USBLIB_FEATURE_ULPI_HS)
+            {
+                ULPIConfigSet(USB0_BASE, ULPI_CFG_HS);
+            }
+            else
+            {
+                ULPIConfigSet(USB0_BASE, ULPI_CFG_FS);
+            }
+        }
+        else
+        {
+            USBULPIDisable(USB0_BASE);
+        }
+
+        //
+        // Force device mode if requested.
+        //
+        if(g_iUSBMode == eUSBModeForceDevice)
+        {
+            MAP_USBDevMode(USB0_BASE);
+        }
+        else if(g_iUSBMode == eUSBModeDevice)
+        {
+            //
+            // To run in active device mode the OTG signals must be active.
+            // This allows disconnect to be detected by the controller.
+            //
+            MAP_USBOTGMode(USB0_BASE);
+        }
+
+        //
+        // In all other cases, set the mode to device this function should not
+        // be called in OTG mode.
+        //
+        g_iUSBMode = eUSBModeDevice;
+
+        //
+        // Enable or disable LPM functionality.
+        //
+        if(g_psDCDInst[0].ui32Features & USBLIB_FEATURE_LPM_EN)
+        {
+            //
+            // Enable full LPM support and all LPM related interrupts.
+            // USB_INTLPM_ERROR is not enabled since there is no response to
+            // this interrupt.
+            //
+            USBDevLPMConfig(USB0_BASE, USB_DEV_LPM_EN);
+            USBLPMIntEnable(USB0_BASE, USB_INTLPM_RESUME | USB_INTLPM_ERROR |
+                                       USB_INTLPM_ACK | USB_INTLPM_NYET);
+            USBDevLPMEnable(USB0_BASE);
+
+            //
+            // Awake by default.
+            //
+            g_psDCDInst[0].ui32LPMState = USBLIB_LPM_STATE_AWAKE;
+        }
+        else
+        {
+            USBDevLPMDisable(USB0_BASE);
+            USBDevLPMConfig(USB0_BASE, USB_DEV_LPM_NONE);
+            g_psDCDInst[0].ui32LPMState = USBLIB_LPM_STATE_DISABLED;
+        }
+    }
+
+    //
+    // Initialize the USB DMA interface.
+    //
+    g_psDCDInst[0].psDMAInstance = USBLibDMAInit(0);
+
+    //
+    // Initialize the USB tick module.
+    //
+    InternalUSBTickInit();
+
+    //
+    // Get a pointer to the default configuration descriptor.
+    //
+    psHdr = psDevice->ppsConfigDescriptors[
+                                g_psDCDInst[0].ui32DefaultConfiguration - 1];
+    psDesc = (const tConfigDescriptor *)(psHdr->psSections[0]->pui8Data);
+
+    if((psDesc->bmAttributes & USB_CONF_ATTR_PWR_M) == USB_CONF_ATTR_SELF_PWR)
+    {
+        g_psDCDInst[0].ui8Status |= USB_STATUS_SELF_PWR;
+    }
+    else
+    {
+        g_psDCDInst[0].ui8Status &= ~USB_STATUS_SELF_PWR;
+    }
+
+    //
+    // Only do hardware update if the stack is not in OTG mode.
+    //
+    if(g_iUSBMode != eUSBModeOTG)
+    {
+        //
+        // Get the current interrupt status.to clear all pending USB
+        // interrupts.
+        //
+        MAP_USBIntStatusControl(USB0_BASE);
+        MAP_USBIntStatusEndpoint(USB0_BASE);
+
+        //
+        // Enable USB Interrupts.
+        //
+        MAP_USBIntEnableControl(USB0_BASE, USB_INTCTRL_RESET |
+                                           USB_INTCTRL_DISCONNECT |
+                                           USB_INTCTRL_RESUME |
+                                           USB_INTCTRL_SUSPEND |
+                                           USB_INTCTRL_SOF);
+        MAP_USBIntEnableEndpoint(USB0_BASE, USB_INTEP_ALL);
+
+        //
+        // Attach the device using the soft connect.
+        //
+        MAP_USBDevConnect(USB0_BASE);
+
+        //
+        // Enable the USB interrupt.
+        //
+        OS_INT_ENABLE(g_psDCDInst[0].ui32IntNum);
+    }
+}
+
+//*****************************************************************************
+//
+//! Free the USB library device control driver for a given hardware controller.
+//!
+//! \param ui32Index is the index of the USB controller which is to be
+//! freed.
+//!
+//! This function should be called by an application if it no longer requires
+//! the use of a given USB controller to support its operation as a USB device.
+//! It frees the controller for use by another client.
+//!
+//! It is the caller's responsibility to remove its device from the USB bus
+//! prior to calling this function.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBDCDTerm(uint32_t ui32Index)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ui32Index == 0);
+
+    //
+    // Disable the USB interrupts.
+    //
+    OS_INT_DISABLE(g_psDCDInst[0].ui32IntNum);
+
+    //
+    // Reset the tick handlers so that they can be reconfigured when and if
+    // USBDCDInit() is called.
+    //
+    InternalUSBTickReset();
+
+    //
+    // No active device.
+    //
+    g_ppsDevInfo[0] = 0;
+
+    MAP_USBIntDisableControl(USB0_BASE, USB_INTCTRL_ALL);
+    MAP_USBIntDisableEndpoint(USB0_BASE, USB_INTEP_ALL);
+
+    //
+    // Detach the device using the soft connect.
+    //
+    MAP_USBDevDisconnect(USB0_BASE);
+
+    //
+    // Clear any pending interrupts.
+    //
+    MAP_USBIntStatusControl(USB0_BASE);
+    MAP_USBIntStatusEndpoint(USB0_BASE);
+
+    //
+    // Turn off USB Phy clock.
+    //
+    MAP_SysCtlUSBPLLDisable();
+
+    //
+    // Disable the USB peripheral
+    //
+    MAP_SysCtlPeripheralDisable(SYSCTL_PERIPH_USB0);
+}
+
+//*****************************************************************************
+//
+//! This function starts the request for data from the host on endpoint zero.
+//!
+//! \param ui32Index is the index of the USB controller from which the data
+//! is being requested.
+//! \param pui8Data is a pointer to the buffer to fill with data from the USB
+//! host.
+//! \param ui32Size is the size of the buffer or data to return from the USB
+//! host.
+//!
+//! This function handles retrieving data from the host when a custom command
+//! has been issued on endpoint zero.  If the application needs notification
+//! when the data has been received,
+//! <tt>psCallbacks->pfnDataReceived()</tt> in the tDeviceInfo structure
+//! must contain valid function pointer.  In nearly all cases this is necessary
+//! because the caller of this function would likely need to know that the data
+//! requested was received.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBDCDRequestDataEP0(uint32_t ui32Index, uint8_t *pui8Data, uint32_t ui32Size)
+{
+    ASSERT(ui32Index == 0);
+
+    //
+    // Enter the RX state on end point 0.
+    //
+    g_psDCDInst[0].iEP0State = eUSBStateRx;
+
+    //
+    // Save the pointer to the data.
+    //
+    g_psDCDInst[0].pui8EP0Data = pui8Data;
+
+    //
+    // Location to save the current number of bytes received.
+    //
+    g_psDCDInst[0].ui32OUTDataSize = ui32Size;
+
+    //
+    // Bytes remaining to be received.
+    //
+    g_psDCDInst[0].ui32EP0DataRemain = ui32Size;
+}
+
+//*****************************************************************************
+//
+//! This function requests transfer of data to the host on endpoint zero.
+//!
+//! \param ui32Index is the index of the USB controller which is to be used to
+//! send the data.
+//! \param pui8Data is a pointer to the buffer to send via endpoint zero.
+//! \param ui32Size is the amount of data to send in bytes.
+//!
+//! This function handles sending data to the host when a custom command is
+//! issued or non-standard descriptor has been requested on endpoint zero.  If
+//! the application needs notification when this is complete,
+//! <tt>psCallbacks->pfnDataSent</tt> in the tDeviceInfo structure must
+//! contain a valid function pointer.  This callback could be used to free up
+//! the buffer passed into this function in the \e pui8Data parameter.  The
+//! contents of the \e pui8Data buffer must remain unchanged until the
+//! <tt>pfnDataSent</tt> callback is received.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBDCDSendDataEP0(uint32_t ui32Index, uint8_t *pui8Data, uint32_t ui32Size)
+{
+    ASSERT(ui32Index == 0);
+
+    //
+    // Return the externally provided device descriptor.
+    //
+    g_psDCDInst[0].pui8EP0Data = pui8Data;
+
+    //
+    // The size of the device descriptor is in the first byte.
+    //
+    g_psDCDInst[0].ui32EP0DataRemain = ui32Size;
+
+    //
+    // Save the total size of the data sent.
+    //
+    g_psDCDInst[0].ui32OUTDataSize = ui32Size;
+
+    //
+    // Now in the transmit data state.
+    //
+    USBDEP0StateTx(0);
+}
+
+//*****************************************************************************
+//
+//! This function sets the default configuration for the device.
+//!
+//! \param ui32Index is the index of the USB controller whose default
+//! configuration is to be set.
+//! \param ui32DefaultConfig is the configuration identifier (byte 6 of the
+//! standard configuration descriptor) which is to be presented to the host
+//! as the default configuration in cases where the configuration descriptor is
+//! queried prior to any specific configuration being set.
+//!
+//! This function allows a device to override the default configuration
+//! descriptor that will be returned to a host whenever it is queried prior
+//! to a specific configuration having been set.  The parameter passed must
+//! equal one of the configuration identifiers found in the
+//! <tt>ppsConfigDescriptors</tt> array for the device.
+//!
+//! If this function is not called, the USB library will return the first
+//! configuration in the <tt>ppsConfigDescriptors</tt> array as the default
+//! configuration.
+//!
+//! \note The USB device stack assumes that the configuration IDs (byte 6 of
+//! the configuration descriptor, <tt>bConfigurationValue</tt>) stored within
+//! the configuration descriptor array, <tt>ppsConfigDescriptors</tt>,
+//! are equal to the array index + 1.  In other words, the first entry in the
+//! array must contain a descriptor with <tt>bConfigurationValue</tt> 1, the
+//! second must have <tt>bConfigurationValue</tt> 2 and so on.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBDCDSetDefaultConfiguration(uint32_t ui32Index, uint32_t ui32DefaultConfig)
+{
+    ASSERT(ui32Index == 0);
+
+    g_psDCDInst[0].ui32DefaultConfiguration = ui32DefaultConfig;
+}
+
+//*****************************************************************************
+//
+//! This function generates a stall condition on endpoint zero.
+//!
+//! \param ui32Index is the index of the USB controller whose endpoint zero is
+//! to be stalled.
+//!
+//! This function is typically called to signal an error condition to the host
+//! when an unsupported request is received by the device.  It should be
+//! called from within the callback itself (in interrupt context) and not
+//! deferred until later since it affects the operation of the endpoint zero
+//! state machine in the USB library.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBDCDStallEP0(uint32_t ui32Index)
+{
+    ASSERT(ui32Index == 0);
+
+    //
+    // Stall the endpoint in question.
+    //
+    MAP_USBDevEndpointStall(USB0_BASE, USB_EP_0, USB_EP_DEV_OUT);
+
+    //
+    // Enter the stalled state.
+    //
+    g_psDCDInst[0].iEP0State = eUSBStateStall;
+}
+#ifndef DEPRECATED
+
+//*****************************************************************************
+//
+//! Reports the device power status (bus- or self-powered) to the library.
+//!
+//! \param ui32Index is the index of the USB controller whose device power
+//! status is being reported.
+//! \param ui8Power indicates the current power status, either
+//! \b USB_STATUS_SELF_PWR or \b USB_STATUS_BUS_PWR.
+//!
+//! Applications which support switching between bus- or self-powered
+//! operation should call this function whenever the power source changes
+//! to indicate the current power status to the USB library.  This information
+//! is required by the library to allow correct responses to be provided when
+//! the host requests status from the device.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBDCDPowerStatusSet(uint32_t ui32Index, uint8_t ui8Power)
+{
+    //
+    // Check for valid parameters.
+    //
+    ASSERT((ui8Power == USB_STATUS_BUS_PWR) ||
+           (ui8Power == USB_STATUS_SELF_PWR));
+    ASSERT(ui32Index == 0);
+
+    //
+    // Update the device status with the new power status flag.
+    //
+    g_psDCDInst[0].bPwrSrcSet = true;
+    g_psDCDInst[0].ui8Status &= ~USB_STATUS_PWR_M;
+    g_psDCDInst[0].ui8Status |= ui8Power;
+}
+#endif
+
+//*****************************************************************************
+//
+//! This function is used to enable/disable features of the USB library.
+//!
+//! \param ui32Index is the index of the USB controller whose device power
+//! status is being reported.
+//! \param ui32Feature indicates which feature is being changed.
+//! \param pvFeature holds the data that controls the feature request.
+//!
+//! Applications can change the support levels of some USB library features by
+//! calling this function to enable/disable certain features.  This function
+//! should normally be called before class initialization functions since the
+//! settings need to be in place before enumeration starts.  This allows the
+//! USB library to properly respond to all enumeration requests. The
+//! \e ui32Feature value is one of the \b USBLIB_FEATURE_* defines which
+//! controls the type of request being made.  The \e pvFeature is a feature
+//! specific data structure that is determined by the value passed in the
+//! \e ui32Feature parameter.
+//!
+//! \return Returns \b true if the feature was successfully changed and returns
+//! \b false if the feature was not able to be changed or is not supported.
+//
+//*****************************************************************************
+bool
+USBDCDFeatureSet(uint32_t ui32Index, uint32_t ui32Feature, void *pvFeature)
+{
+    bool bRetCode;
+    tLPMFeature *psLPMFeature;
+
+    bRetCode = true;
+
+    switch(ui32Feature)
+    {
+        case USBLIB_FEATURE_LPM:
+        {
+            //
+            // Save the LPM setting.
+            //
+            psLPMFeature = (tLPMFeature *)pvFeature;
+
+            if(psLPMFeature->ui32Features & USBLIB_FEATURE_LPM_EN)
+            {
+                g_psDCDInst[0].ui32Features |= USBLIB_FEATURE_LPM_EN;
+            }
+            else
+            {
+                g_psDCDInst[0].ui32Features &= ~USBLIB_FEATURE_LPM_EN;
+            }
+
+            break;
+        }
+        case USBLIB_FEATURE_USBPLL:
+        {
+            //
+            // If the PLL rate is not evenly divisible by 60MHz then
+            // do not set it.
+            //
+            if((*(uint32_t *)pvFeature % 60000000) != 0)
+            {
+                bRetCode = false;
+            }
+            else
+            {
+                //
+                // Save the new PLL rate.
+                //
+                g_ui32PLLDiv = (*(uint32_t *)pvFeature / 60000000);
+            }
+            break;
+        }
+        case USBLIB_FEATURE_USBULPI:
+        {
+            //
+            // Save the ULPI support level.
+            //
+            g_ui32ULPISupport = *(uint32_t *)pvFeature;
+
+            break;
+        }
+        case USBLIB_FEATURE_POWER:
+        {
+            //
+            // Update the device status with the new power status flag.
+            //
+            g_psDCDInst[0].bPwrSrcSet = true;
+            g_psDCDInst[0].ui8Status &= ~USBLIB_FEATURE_POWER_SELF;
+            g_psDCDInst[0].ui8Status |= (uint8_t)(*(uint32_t *)pvFeature);
+
+            break;
+        }
+        default:
+        {
+            bRetCode = false;
+            break;
+        }
+    }
+    return(bRetCode);
+}
+
+//*****************************************************************************
+//
+//! Requests an LPM remote wake up to resume communication when in an LPM sleep
+//! state.
+//!
+//! \param ui32Index is the index of the USB controller that will request
+//! a bus wake up.
+//!
+//! When the host controller puts the device into an LPM sleep state, the
+//! device can call this function to initiate LPM remote wake up signaling to
+//! the host.  If the remote wake up feature has been enabled by the host, this
+//! will cause the host to respond to the LPM remote wake request and resume
+//! normal operation.  If the host has disabled remote wake up, \b false is
+//! returned to indicate that the wake up request was not successful.
+//!
+//! \return Returns \b true if the remote wake up request has been sent or
+//!\b false if LPM remote wake up is disabled.
+//
+//*****************************************************************************
+bool
+USBDCDRemoteWakeLPM(uint32_t ui32Index)
+{
+    if(USBLPMRemoteWakeEnabled(USB0_BASE))
+    {
+        USBDevLPMRemoteWake(USB0_BASE);
+        return(true);
+    }
+    return(false);
+}
+
+//*****************************************************************************
+//
+//! Requests a remote wake up to resume communication when in suspended state.
+//!
+//! \param ui32Index is the index of the USB controller that will request
+//! a bus wake up.
+//!
+//! When the bus is suspended, an application which supports remote wake up
+//! (advertised to the host via the configuration descriptor) may call this
+//! function to initiate remote wake up signaling to the host.  If the remote
+//! wake up feature has not been disabled by the host, this will cause the bus
+//! to resume operation within 20mS.  If the host has disabled remote wake up,
+//! \b false will be returned to indicate that the wake up request was not
+//! successful.
+//!
+//! \return Returns \b true if the remote wake up is not disabled and the
+//! signaling was started or \b false if remote wake up is disabled or if
+//! signaling is currently ongoing following a previous call to this function.
+//
+//*****************************************************************************
+bool
+USBDCDRemoteWakeupRequest(uint32_t ui32Index)
+{
+    //
+    // Check for parameter validity.
+    //
+    ASSERT(ui32Index == 0);
+
+    //
+    // Is remote wake up signaling currently enabled?
+    //
+    if(g_psDCDInst[0].ui8Status & USB_STATUS_REMOTE_WAKE)
+    {
+        //
+        // The host has not disabled remote wake up. Are we still in the
+        // middle of a previous wake up sequence?
+        //
+        if(!g_psDCDInst[0].bRemoteWakeup)
+        {
+            //
+            // No - we are not in the middle of a wake up sequence so start
+            // one here.
+            //
+            g_psDCDInst[0].ui8RemoteWakeupCount = 0;
+            g_psDCDInst[0].bRemoteWakeup = true;
+            MAP_USBHostResume(USB0_BASE, true);
+            return(true);
+        }
+    }
+
+    //
+    // If we drop through to here, signaling was not initiated so return
+    // false.
+    return(false);
+}
+
+//*****************************************************************************
+//
+// Internal Functions, not to be called by applications
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// This internal function is called on the SOF interrupt to process any
+// outstanding remote wake up requests.
+//
+// \return None.
+//
+//*****************************************************************************
+void
+USBDeviceResumeTickHandler(tDCDInstance *psDevInst)
+{
+    if(g_psDCDInst[0].bRemoteWakeup)
+    {
+        //
+        // Increment the millisecond counter we use to time the resume
+        // signaling.
+        //
+        g_psDCDInst[0].ui8RemoteWakeupCount++;
+
+        //
+        // Have we reached the 10mS mark? If so, we need to turn the signaling
+        // off again.
+        //
+        if(g_psDCDInst[0].ui8RemoteWakeupCount == REMOTE_WAKEUP_PULSE_MS)
+        {
+            MAP_USBHostResume(USB0_BASE, false);
+        }
+
+        //
+        // Have we reached the point at which we can tell the client that the
+        // bus has resumed? The controller does not give us an interrupt if we
+        // initiated the wake up signaling so we just wait until 20mS have
+        // passed then tell the client all is well.
+        //
+        if(g_psDCDInst[0].ui8RemoteWakeupCount == REMOTE_WAKEUP_READY_MS)
+        {
+            //
+            // We are now finished with the remote wake up signaling.
+            //
+            g_psDCDInst[0].bRemoteWakeup = false;
+
+            //
+            // If the client has registered a resume callback, call it.  In the
+            // case of a remote wake up request, we do not get a resume
+            // interrupt from the controller so we need to fake it here.
+            //
+            if(g_ppsDevInfo[0]->psCallbacks->pfnResumeHandler)
+            {
+                g_ppsDevInfo[0]->psCallbacks->pfnResumeHandler(
+                                                    g_psDCDInst[0].pvCBData);
+            }
+        }
+    }
+}
+
+//*****************************************************************************
+//
+// This internal function reads a request data packet and dispatches it to
+// either a standard request handler or the registered device request
+// callback depending upon the request type.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+USBDReadAndDispatchRequest(uint32_t ui32Index)
+{
+    uint32_t ui32Size;
+    tUSBRequest *psRequest;
+
+    //
+    // Cast the buffer to a request structure.
+    //
+    psRequest = (tUSBRequest *)g_pui8DataBufferIn;
+
+    //
+    // Set the buffer size.
+    //
+    ui32Size = EP0_MAX_PACKET_SIZE;
+
+    //
+    // Get the data from the USB controller end point 0.
+    //
+    MAP_USBEndpointDataGet(USB0_BASE, USB_EP_0, g_pui8DataBufferIn,
+                           &ui32Size);
+
+    //
+    // If there was a null setup packet then just return.
+    //
+    if(!ui32Size)
+    {
+        return;
+    }
+
+    //
+    // See if this is a standard request or not.
+    //
+    if((psRequest->bmRequestType & USB_RTYPE_TYPE_M) != USB_RTYPE_STANDARD)
+    {
+        //
+        // Since this is not a standard request, see if there is
+        // an external handler present.
+        //
+        if(g_ppsDevInfo[0]->psCallbacks->pfnRequestHandler)
+        {
+            g_ppsDevInfo[0]->psCallbacks->pfnRequestHandler(
+                                                    g_psDCDInst[0].pvCBData,
+                                                    psRequest);
+        }
+        else
+        {
+            //
+            // If there is no handler then stall this request.
+            //
+            USBDCDStallEP0(0);
+        }
+    }
+    else
+    {
+        //
+        // Assure that the jump table is not out of bounds.
+        //
+        if((psRequest->bRequest <
+           (sizeof(g_psUSBDStdRequests) / sizeof(tStdRequest))) &&
+           (g_psUSBDStdRequests[psRequest->bRequest] != 0))
+        {
+            //
+            // Jump table to the appropriate handler.
+            //
+            g_psUSBDStdRequests[psRequest->bRequest](&g_psDCDInst[0],
+                                                     psRequest);
+        }
+        else
+        {
+            //
+            // If there is no handler then stall this request.
+            //
+            USBDCDStallEP0(0);
+        }
+    }
+}
+
+//*****************************************************************************
+//
+// This is interrupt handler for endpoint zero.
+//
+// This function handles all interrupts on endpoint zero in order to maintain
+// the state needed for the control endpoint on endpoint zero.  In order to
+// successfully enumerate and handle all USB standard requests, all requests
+// on endpoint zero must pass through this function.  The endpoint has the
+// following states: \b eUSBStateIdle, \b eUSBStateTx, \b eUSBStateRx,
+// \b eUSBStateStall, and \b eUSBStateStatus.  In the \b eUSBStateIdle
+// state the USB controller has not received the start of a request, and once
+// it does receive the data for the request it will either enter the
+// \b eUSBStateTx, \b eUSBStateRx, or \b eUSBStateStall depending on the
+// command.  If the controller enters the \b eUSBStateTx or \b eUSBStateRx
+// then once all data has been sent or received, it must pass through the
+// \b eUSBStateStatus state to allow the host to acknowledge completion of
+// the request.  The \b eUSBStateStall is entered from \b eUSBStateIdle in
+// the event that the USB request was not valid.  Both the \b eUSBStateStall
+// and \b eUSBStateStatus are transitional states that return to the
+// \b eUSBStateIdle state.
+//
+// \return None.
+//
+// eUSBStateIdle -*--> eUSBStateTx -*-> eUSBStateStatus -*->eUSBStateIdle
+//                |                 |                    |
+//                |--> eUSBStateRx                       |
+//                |                                      |
+//                |--> eUSBStateStall ---------->--------
+//
+//  ----------------------------------------------------------------
+// | Current State       | State 0           | State 1              |
+// | --------------------|-------------------|----------------------
+// | eUSBStateIdle       | eUSBStateTx/RX    | eUSBStateStall       |
+// | eUSBStateTx         | eUSBStateStatus   |                      |
+// | eUSBStateRx         | eUSBStateStatus   |                      |
+// | eUSBStateStatus     | eUSBStateIdle     |                      |
+// | eUSBStateStall      | eUSBStateIdle     |                      |
+//  ----------------------------------------------------------------
+//
+//*****************************************************************************
+void
+USBDeviceEnumHandler(tDCDInstance *pDevInstance)
+{
+    uint32_t ui32EPStatus, ui32DataSize;
+
+    //
+    // Get the end point 0 status.
+    //
+    ui32EPStatus = MAP_USBEndpointStatus(USB0_BASE, USB_EP_0);
+
+    switch(pDevInstance->iEP0State)
+    {
+        //
+        // Handle the status state, this is a transitory state from
+        // eUSBStateTx or eUSBStateRx back to eUSBStateIdle.
+        //
+        case eUSBStateStatus:
+        {
+            //
+            // Just go back to the idle state.
+            //
+            pDevInstance->iEP0State = eUSBStateIdle;
+
+            //
+            // If there is a pending address change then set the address.
+            //
+            if(pDevInstance->ui32DevAddress & DEV_ADDR_PENDING)
+            {
+                //
+                // Clear the pending address change and set the address.
+                //
+                pDevInstance->ui32DevAddress &= ~DEV_ADDR_PENDING;
+                MAP_USBDevAddrSet(USB0_BASE, pDevInstance->ui32DevAddress);
+            }
+
+            //
+            // If a new packet is already pending, we need to read it
+            // and handle whatever request it contains.
+            //
+            if(ui32EPStatus & USB_DEV_EP0_OUT_PKTRDY)
+            {
+                //
+                // Process the newly arrived packet.
+                //
+                USBDReadAndDispatchRequest(0);
+            }
+            break;
+        }
+
+        //
+        // In the IDLE state the code is waiting to receive data from the host.
+        //
+        case eUSBStateIdle:
+        {
+            //
+            // Is there a packet waiting for us?
+            //
+            if(ui32EPStatus & USB_DEV_EP0_OUT_PKTRDY)
+            {
+                //
+                // Yes - process it.
+                //
+                USBDReadAndDispatchRequest(0);
+            }
+            break;
+        }
+
+        //
+        // Data is still being sent to the host so handle this in the
+        // EP0StateTx() function.
+        //
+        case eUSBStateTx:
+        {
+            USBDEP0StateTx(0);
+            break;
+        }
+
+        //
+        // We are still in the middle of sending the configuration descriptor
+        // so handle this in the EP0StateTxConfig() function.
+        //
+        case eUSBStateTxConfig:
+        {
+            USBDEP0StateTxConfig(0);
+            break;
+        }
+
+        //
+        // Handle the receive state for commands that are receiving data on
+        // endpoint zero.
+        //
+        case eUSBStateRx:
+        {
+            //
+            // Set the number of bytes to get out of this next packet.
+            //
+            if(pDevInstance->ui32EP0DataRemain > EP0_MAX_PACKET_SIZE)
+            {
+                //
+                // Don't send more than EP0_MAX_PACKET_SIZE bytes.
+                //
+                ui32DataSize = EP0_MAX_PACKET_SIZE;
+            }
+            else
+            {
+                //
+                // There was space so send the remaining bytes.
+                //
+                ui32DataSize = pDevInstance->ui32EP0DataRemain;
+            }
+
+            //
+            // Get the data from the USB controller end point 0.
+            //
+            MAP_USBEndpointDataGet(USB0_BASE, USB_EP_0,
+                                   pDevInstance->pui8EP0Data, &ui32DataSize);
+
+            //
+            // If there we not more that EP0_MAX_PACKET_SIZE or more bytes
+            // remaining then this transfer is complete.  If there were exactly
+            // EP0_MAX_PACKET_SIZE remaining then there still needs to be
+            // null packet sent before this is complete.
+            //
+            if(pDevInstance->ui32EP0DataRemain < EP0_MAX_PACKET_SIZE)
+            {
+                //
+                // Return to the idle state.
+                //
+                pDevInstance->iEP0State =  eUSBStateStatus;
+
+                //
+                // If there is a receive callback then call it.
+                //
+                if((g_ppsDevInfo[0]->psCallbacks->pfnDataReceived) &&
+                   (pDevInstance->ui32OUTDataSize != 0))
+                {
+                    //
+                    // Call the custom receive handler to handle the data
+                    // that was received.
+                    //
+                    g_ppsDevInfo[0]->psCallbacks->pfnDataReceived(
+                                                g_psDCDInst[0].pvCBData,
+                                                pDevInstance->ui32OUTDataSize);
+
+                    //
+                    // Indicate that there is no longer any data being waited
+                    // on.
+                    //
+                    pDevInstance->ui32OUTDataSize = 0;
+                }
+
+                //
+                // Need to ACK the data on end point 0 in this case and set the
+                // data end as this is the last of the data.
+                //
+                MAP_USBDevEndpointDataAck(USB0_BASE, USB_EP_0, true);
+            }
+            else
+            {
+                //
+                // Need to ACK the data on end point 0 in this case
+                // without setting data end because more data is coming.
+                //
+                MAP_USBDevEndpointDataAck(USB0_BASE, USB_EP_0, false);
+            }
+
+            //
+            // Advance the pointer.
+            //
+            pDevInstance->pui8EP0Data += ui32DataSize;
+
+            //
+            // Decrement the number of bytes that are being waited on.
+            //
+            pDevInstance->ui32EP0DataRemain -= ui32DataSize;
+
+            break;
+        }
+        //
+        // The device stalled endpoint zero so check if the stall needs to be
+        // cleared once it has been successfully sent.
+        //
+        case eUSBStateStall:
+        {
+            //
+            // If we sent a stall then acknowledge this interrupt.
+            //
+            if(ui32EPStatus & USB_DEV_EP0_SENT_STALL)
+            {
+                //
+                // Clear the Setup End condition.
+                //
+                MAP_USBDevEndpointStatusClear(USB0_BASE, USB_EP_0,
+                                              USB_DEV_EP0_SENT_STALL);
+
+                //
+                // Reset the global end point 0 state to IDLE.
+                //
+                pDevInstance->iEP0State = eUSBStateIdle;
+
+            }
+            break;
+        }
+        //
+        // Halt on an unknown state, but only in DEBUG mode builds.
+        //
+        default:
+        {
+            ASSERT(0);
+            break;
+        }
+    }
+}
+
+//*****************************************************************************
+//
+// This function handles bus reset notifications.
+//
+// This function is called from the low level USB interrupt handler whenever
+// a bus reset is detected.  It performs tidy-up as required and resets the
+// configuration back to defaults in preparation for descriptor queries from
+// the host.
+//
+// \return None.
+//
+//*****************************************************************************
+void
+USBDeviceEnumResetHandler(tDCDInstance *pDevInstance)
+{
+    uint32_t ui32Loop;
+
+    //
+    // Disable remote wake up signaling (as per USB 2.0 spec 9.1.1.6).
+    //
+    pDevInstance->ui8Status &= ~USB_STATUS_REMOTE_WAKE;
+    pDevInstance->bRemoteWakeup = false;
+
+    //
+    // Call the device dependent code to indicate a bus reset has occurred.
+    //
+    if(g_ppsDevInfo[0]->psCallbacks->pfnResetHandler)
+    {
+        g_ppsDevInfo[0]->psCallbacks->pfnResetHandler(g_psDCDInst[0].pvCBData);
+    }
+
+    //
+    // Reset the default configuration identifier and alternate function
+    // selections.
+    //
+    pDevInstance->ui32Configuration = pDevInstance->ui32DefaultConfiguration;
+
+    for(ui32Loop = 0; ui32Loop < USB_MAX_INTERFACES_PER_DEVICE; ui32Loop++)
+    {
+        pDevInstance->pui8AltSetting[ui32Loop] = (uint8_t)0;
+    }
+}
+
+//*****************************************************************************
+//
+// This function handles the GET_STATUS standard USB request.
+//
+// \param pvInstance is the USB device controller instance data.
+// \param psUSBRequest holds the request type and endpoint number if endpoint
+// status is requested.
+//
+// This function handles responses to a Get Status request from the host
+// controller.  A status request can be for the device, an interface or an
+// endpoint.  If any other type of request is made this function will cause
+// a stall condition to indicate that the command is not supported.  The
+// \e psUSBRequest structure holds the type of the request in the
+// bmRequestType field.  If the type indicates that this is a request for an
+// endpoint's status, then the wIndex field holds the endpoint number.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+USBDGetStatus(void *pvInstance, tUSBRequest *psUSBRequest)
+{
+    uint16_t ui16Data, ui16Index;
+    uint32_t ui32Dir;
+    tDCDInstance *psUSBControl;
+
+    ASSERT(psUSBRequest != 0);
+    ASSERT(pvInstance != 0);
+
+    //
+    // Create the device information pointer.
+    //
+    psUSBControl = (tDCDInstance *)pvInstance;
+
+    //
+    // Need to ACK the data on end point 0 without setting last data as there
+    // will be a data phase.
+    //
+    MAP_USBDevEndpointDataAck(USB0_BASE, USB_EP_0, false);
+
+    //
+    // Determine what type of status was requested.
+    //
+    switch(psUSBRequest->bmRequestType & USB_RTYPE_RECIPIENT_M)
+    {
+        //
+        // This was a Device Status request.
+        //
+        case USB_RTYPE_DEVICE:
+        {
+            //
+            // Return the current status for the device.
+            //
+            ui16Data = (uint16_t)psUSBControl->ui8Status;
+
+            break;
+        }
+
+        //
+        // This was a Interface status request.
+        //
+        case USB_RTYPE_INTERFACE:
+        {
+            //
+            // Interface status always returns 0.
+            //
+            ui16Data = (uint16_t)0;
+
+            break;
+        }
+
+        //
+        // This was an endpoint status request.
+        //
+        case USB_RTYPE_ENDPOINT:
+        {
+            //
+            // Which endpoint are we dealing with?
+            //
+            ui16Index = psUSBRequest->wIndex & USB_REQ_EP_NUM_M;
+
+            //
+            // Check if this was a valid endpoint request.
+            //
+            if((ui16Index == 0) || (ui16Index >= NUM_USB_EP))
+            {
+                USBDCDStallEP0(0);
+                return;
+            }
+            else
+            {
+                //
+                // Are we dealing with an IN or OUT endpoint?
+                //
+                ui32Dir = ((psUSBRequest->wIndex & USB_REQ_EP_DIR_M) ==
+                           USB_REQ_EP_DIR_IN) ? HALT_EP_IN : HALT_EP_OUT;
+
+                //
+                // Get the current halt status for this endpoint.
+                //
+                ui16Data =
+                    (uint16_t)psUSBControl->ppui8Halt[ui32Dir][ui16Index - 1];
+            }
+            break;
+        }
+
+        //
+        // This was an unknown request.
+        //
+        default:
+        {
+            //
+            // Anything else causes a stall condition to indicate that the
+            // command was not supported.
+            //
+            USBDCDStallEP0(0);
+            return;
+        }
+    }
+
+    //
+    // Send the two byte status response.
+    //
+    psUSBControl->ui32EP0DataRemain = 2;
+    psUSBControl->pui8EP0Data = (uint8_t *)&ui16Data;
+
+    //
+    // Send the response.
+    //
+    USBDEP0StateTx(0);
+}
+
+//*****************************************************************************
+//
+// This function handles the CLEAR_FEATURE standard USB request.
+//
+// \param pvInstance is the USB device controller instance data.
+// \param psUSBRequest holds the options for the Clear Feature USB request.
+//
+// This function handles device or endpoint clear feature requests.  The
+// \e psUSBRequest structure holds the type of the request in the bmRequestType
+// field and the feature is held in the wValue field.  The device can only
+// clear the Remote Wake feature.  This device request should only be made if
+// the descriptor indicates that Remote Wake is implemented by the device.
+// Endpoints can only clear a halt on a given endpoint.  If any other
+// requests are made, then the device will stall the request to indicate to
+// the host that the command was not supported.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+USBDClearFeature(void *pvInstance, tUSBRequest *psUSBRequest)
+{
+    tDCDInstance *psUSBControl;
+    uint32_t ui32Dir;
+    uint16_t ui16Index;
+
+    ASSERT(psUSBRequest != 0);
+    ASSERT(pvInstance != 0);
+
+    //
+    // Create the device information pointer.
+    //
+    psUSBControl = (tDCDInstance *)pvInstance;
+
+    //
+    // Need to ACK the data on end point 0 with last data set as this has no
+    // data phase.
+    //
+    MAP_USBDevEndpointDataAck(USB0_BASE, USB_EP_0, true);
+
+    //
+    // Determine what type of status was requested.
+    //
+    switch(psUSBRequest->bmRequestType & USB_RTYPE_RECIPIENT_M)
+    {
+        //
+        // This is a clear feature request at the device level.
+        //
+        case USB_RTYPE_DEVICE:
+        {
+            //
+            // Only remote wake is can be cleared by this function.
+            //
+            if(USB_FEATURE_REMOTE_WAKE & psUSBRequest->wValue)
+            {
+                //
+                // Clear the remote wake up state.
+                //
+                psUSBControl->ui8Status &= ~USB_STATUS_REMOTE_WAKE;
+            }
+            else
+            {
+                USBDCDStallEP0(0);
+            }
+            break;
+        }
+
+        //
+        // This is a clear feature request at the endpoint level.
+        //
+        case USB_RTYPE_ENDPOINT:
+        {
+            //
+            // Which endpoint are we dealing with?
+            //
+            ui16Index = psUSBRequest->wIndex & USB_REQ_EP_NUM_M;
+
+            //
+            // Not a valid endpoint.
+            //
+            if((ui16Index == 0) || (ui16Index > NUM_USB_EP))
+            {
+                USBDCDStallEP0(0);
+            }
+            else
+            {
+                //
+                // Only the halt feature is supported.
+                //
+                if(USB_FEATURE_EP_HALT == psUSBRequest->wValue)
+                {
+                    //
+                    // Are we dealing with an IN or OUT endpoint?
+                    //
+                    ui32Dir = ((psUSBRequest->wIndex & USB_REQ_EP_DIR_M) ==
+                               USB_REQ_EP_DIR_IN) ? HALT_EP_IN : HALT_EP_OUT;
+
+                    //
+                    // Clear the halt condition on this endpoint.
+                    //
+                    psUSBControl->ppui8Halt[ui32Dir][ui16Index - 1] = 0;
+
+                    if(ui32Dir == HALT_EP_IN)
+                    {
+                        MAP_USBDevEndpointStallClear(USB0_BASE,
+                                                     IndexToUSBEP(ui16Index),
+                                                     USB_EP_DEV_IN);
+                    }
+                    else
+                    {
+                        MAP_USBDevEndpointStallClear(USB0_BASE,
+                                                     IndexToUSBEP(ui16Index),
+                                                     USB_EP_DEV_OUT);
+                    }
+                }
+                else
+                {
+                    //
+                    // If any other feature is requested, this is an error.
+                    //
+                    USBDCDStallEP0(0);
+                    return;
+                }
+            }
+            break;
+        }
+
+        //
+        // This is an unknown request.
+        //
+        default:
+        {
+            USBDCDStallEP0(0);
+            return;
+        }
+    }
+}
+
+//*****************************************************************************
+//
+// This function handles the SET_FEATURE standard USB request.
+//
+// \param pvInstance is the USB device controller instance data.
+// \param psUSBRequest holds the feature in the wValue field of the USB
+// request.
+//
+// This function handles device or endpoint set feature requests.  The
+// \e psUSBRequest structure holds the type of the request in the bmRequestType
+// field and the feature is held in the wValue field.  The device can only
+// set the Remote Wake feature.  This device request should only be made if the
+// descriptor indicates that Remote Wake is implemented by the device.
+// Endpoint requests can only issue a halt on a given endpoint.  If any other
+// requests are made, then the device will stall the request to indicate to the
+// host that the command was not supported.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+USBDSetFeature(void *pvInstance, tUSBRequest *psUSBRequest)
+{
+    tDCDInstance *psUSBControl;
+    uint16_t ui16Index;
+    uint32_t ui32Dir;
+
+    ASSERT(psUSBRequest != 0);
+    ASSERT(pvInstance != 0);
+
+    //
+    // Create the device information pointer.
+    //
+    psUSBControl = (tDCDInstance *)pvInstance;
+
+    //
+    // Need to ACK the data on end point 0 with last data set as this has no
+    // data phase.
+    //
+    MAP_USBDevEndpointDataAck(USB0_BASE, USB_EP_0, true);
+
+    //
+    // Determine what type of status was requested.
+    //
+    switch(psUSBRequest->bmRequestType & USB_RTYPE_RECIPIENT_M)
+    {
+        //
+        // This is a set feature request at the device level.
+        //
+        case USB_RTYPE_DEVICE:
+        {
+            //
+            // Only remote wake is the only feature that can be set by this
+            // function.
+            //
+            if(USB_FEATURE_REMOTE_WAKE & psUSBRequest->wValue)
+            {
+                //
+                // Set the remote wake up state.
+                //
+                psUSBControl->ui8Status |= USB_STATUS_REMOTE_WAKE;
+            }
+            else
+            {
+                USBDCDStallEP0(0);
+            }
+            break;
+        }
+
+        //
+        // This is a set feature request at the endpoint level.
+        //
+        case USB_RTYPE_ENDPOINT:
+        {
+            //
+            // Which endpoint are we dealing with?
+            //
+            ui16Index = psUSBRequest->wIndex & USB_REQ_EP_NUM_M;
+
+            //
+            // Not a valid endpoint?
+            //
+            if((ui16Index == 0) || (ui16Index >= NUM_USB_EP))
+            {
+                USBDCDStallEP0(0);
+            }
+            else
+            {
+                //
+                // Only the Halt feature can be set.
+                //
+                if(USB_FEATURE_EP_HALT == psUSBRequest->wValue)
+                {
+                    //
+                    // Are we dealing with an IN or OUT endpoint?
+                    //
+                    ui32Dir = ((psUSBRequest->wIndex & USB_REQ_EP_DIR_M) ==
+                               USB_REQ_EP_DIR_IN) ? HALT_EP_IN : HALT_EP_OUT;
+
+                    //
+                    // Clear the halt condition on this endpoint.
+                    //
+                    psUSBControl->ppui8Halt[ui32Dir][ui16Index - 1] = 1;
+                }
+                else
+                {
+                    //
+                    // No other requests are supported.
+                    //
+                    USBDCDStallEP0(0);
+                    return;
+                }
+            }
+            break;
+        }
+
+        //
+        // This is an unknown request.
+        //
+        default:
+        {
+            USBDCDStallEP0(0);
+            return;
+        }
+    }
+}
+
+//*****************************************************************************
+//
+// This function handles the SET_ADDRESS standard USB request.
+//
+// \param pvInstance is the USB device controller instance data.
+// \param psUSBRequest holds the new address to use in the wValue field of the
+// USB request.
+//
+// This function is called to handle the change of address request from the
+// host controller.  This can only start the sequence as the host must
+// acknowledge that the device has changed address.  Thus this function sets
+// the address change as pending until the status phase of the request has
+// been completed successfully.  This prevents the devices address from
+// changing and not properly responding to the status phase.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+USBDSetAddress(void *pvInstance, tUSBRequest *psUSBRequest)
+{
+    tDCDInstance *psUSBControl;
+
+    ASSERT(psUSBRequest != 0);
+    ASSERT(pvInstance != 0);
+
+    //
+    // Create the device information pointer.
+    //
+    psUSBControl = (tDCDInstance *)pvInstance;
+
+    //
+    // Need to ACK the data on end point 0 with last data set as this has no
+    // data phase.
+    //
+    MAP_USBDevEndpointDataAck(USB0_BASE, USB_EP_0, true);
+
+    //
+    // Save the device address as we cannot change address until the status
+    // phase is complete.
+    //
+    psUSBControl->ui32DevAddress = psUSBRequest->wValue | DEV_ADDR_PENDING;
+
+    //
+    // Transition directly to the status state since there is no data phase
+    // for this request.
+    //
+    psUSBControl->iEP0State = eUSBStateStatus;
+}
+
+//*****************************************************************************
+//
+// This function handles the GET_DESCRIPTOR standard USB request.
+//
+// \param pvInstance is the USB device controller instance data.
+// \param psUSBRequest holds the data for this request.
+//
+// This function will return most of the descriptors requested by the host
+// controller.  The descriptor specified by \e
+// pvInstance->psInfo->pui8DeviceDescriptor will be returned when the device
+// descriptor is requested.  If a request for a specific configuration
+// descriptor is made, then the appropriate descriptor from the \e
+// g_pConfigDescriptors will be returned.  When a request for a string
+// descriptor is made, the appropriate string from the
+// \e pvInstance->psInfo->pStringDescriptors will be returned.  If the
+// \e pvInstance->psInfo->psCallbacks->GetDescriptor is specified it will be
+// called to handle the request.  In this case it must call the
+// USBDCDSendDataEP0() function to send the data to the host controller.  If
+// the callback is not specified, and the descriptor request is not for a
+// device, configuration, or string descriptor then this function will stall
+// the request to indicate that the request was not supported by the device.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+USBDGetDescriptor(void *pvInstance, tUSBRequest *psUSBRequest)
+{
+    bool bConfig;
+    tDCDInstance *psUSBControl;
+    tDeviceInfo *psDevice;
+    const tConfigHeader *psConfig;
+    const tDeviceDescriptor *psDeviceDesc;
+    uint8_t ui8Index;
+    int32_t i32Index;
+
+    ASSERT(psUSBRequest != 0);
+    ASSERT(pvInstance != 0);
+
+    //
+    // Create the device information pointer.
+    //
+    psUSBControl = (tDCDInstance *)pvInstance;
+    psDevice = g_ppsDevInfo[0];
+
+    //
+    // Need to ACK the data on end point 0 without setting last data as there
+    // will be a data phase.
+    //
+    MAP_USBDevEndpointDataAck(USB0_BASE, USB_EP_0, false);
+
+    //
+    // Assume we are not sending the configuration descriptor until we
+    // determine otherwise.
+    //
+    bConfig = false;
+
+    //
+    // Which descriptor are we being asked for?
+    //
+    switch(psUSBRequest->wValue >> 8)
+    {
+        //
+        // This request was for a device descriptor.
+        //
+        case USB_DTYPE_DEVICE:
+        {
+            //
+            // Return the externally provided device descriptor.
+            //
+            psUSBControl->pui8EP0Data =
+                                    (uint8_t *)psDevice->pui8DeviceDescriptor;
+
+            //
+            // The size of the device descriptor is in the first byte.
+            //
+            psUSBControl->ui32EP0DataRemain =
+                psDevice->pui8DeviceDescriptor[0];
+
+            break;
+        }
+
+        //
+        // This request was for a configuration descriptor.
+        //
+        case USB_DTYPE_CONFIGURATION:
+        {
+            //
+            // Which configuration are we being asked for?
+            //
+            ui8Index = (uint8_t)(psUSBRequest->wValue & 0xFF);
+
+            //
+            // Is this valid?
+            //
+            psDeviceDesc =
+                (const tDeviceDescriptor *)psDevice->pui8DeviceDescriptor;
+
+            if(ui8Index >= psDeviceDesc->bNumConfigurations)
+            {
+                //
+                // This is an invalid configuration index.  Stall EP0 to
+                // indicate a request error.
+                //
+                USBDCDStallEP0(0);
+                psUSBControl->pui8EP0Data = 0;
+                psUSBControl->ui32EP0DataRemain = 0;
+            }
+            else
+            {
+                //
+                // Return the externally specified configuration descriptor.
+                //
+                psConfig = psDevice->ppsConfigDescriptors[ui8Index];
+
+                //
+                // Start by sending data from the beginning of the first
+                // descriptor.
+                //
+                psUSBControl->ui8ConfigSection = 0;
+                psUSBControl->ui16SectionOffset = 0;
+                psUSBControl->pui8EP0Data =
+                                (uint8_t *)psConfig->psSections[0]->pui8Data;
+
+                //
+                // Determine the total size of the configuration descriptor
+                // by counting the sizes of the sections comprising it.
+                //
+                psUSBControl->ui32EP0DataRemain =
+                                            USBDCDConfigDescGetSize(psConfig);
+
+                //
+                // Remember that we need to send the configuration descriptor
+                // and which descriptor we need to send.
+                //
+                psUSBControl->ui8ConfigIndex = ui8Index;
+
+                bConfig = true;
+            }
+            break;
+        }
+
+        //
+        // This request was for a string descriptor.
+        //
+        case USB_DTYPE_STRING:
+        {
+            //
+            // Determine the correct descriptor index based on the requested
+            // language ID and index.
+            //
+            i32Index = USBDStringIndexFromRequest(psUSBRequest->wIndex,
+                                                  psUSBRequest->wValue & 0xFF);
+
+            //
+            // If the mapping function returned -1 then stall the request to
+            // indicate that the request was not valid.
+            //
+            if(i32Index == -1)
+            {
+                USBDCDStallEP0(0);
+                break;
+            }
+
+            //
+            // Return the externally specified configuration descriptor.
+            //
+            psUSBControl->pui8EP0Data =
+                (uint8_t *)psDevice->ppui8StringDescriptors[i32Index];
+
+            //
+            // The total size of a string descriptor is in byte 0.
+            //
+            psUSBControl->ui32EP0DataRemain =
+                psDevice->ppui8StringDescriptors[i32Index][0];
+
+            break;
+        }
+
+        //
+        // Any other request is not handled by the default enumeration handler
+        // so see if it needs to be passed on to another handler.
+        //
+        default:
+        {
+            //
+            // If there is a handler for requests that are not handled then
+            // call it.
+            //
+            if(psDevice->psCallbacks->pfnGetDescriptor)
+            {
+                psDevice->psCallbacks->pfnGetDescriptor(g_psDCDInst[0].pvCBData,
+                                                      psUSBRequest);
+            }
+            else
+            {
+                //
+                // Whatever this was this handler does not understand it so
+                // just stall the request.
+                //
+                USBDCDStallEP0(0);
+            }
+
+            return;
+        }
+    }
+
+    //
+    // If this request has data to send, then send it.
+    //
+    if(psUSBControl->pui8EP0Data)
+    {
+        //
+        // If there is more data to send than is requested then just
+        // send the requested amount of data.
+        //
+        if(psUSBControl->ui32EP0DataRemain > psUSBRequest->wLength)
+        {
+            psUSBControl->ui32EP0DataRemain = psUSBRequest->wLength;
+        }
+
+        //
+        // Now in the transmit data state.  Be careful to call the correct
+        // function since we need to handle the configuration descriptor
+        // differently from the others.
+        //
+        if(!bConfig)
+        {
+            USBDEP0StateTx(0);
+        }
+        else
+        {
+            USBDEP0StateTxConfig(0);
+        }
+    }
+}
+
+//*****************************************************************************
+//
+// This function determines which string descriptor to send to satisfy a
+// request for a given index and language.
+//
+// \param ui16Lang is the requested string language ID.
+// \param ui16Index is the requested string descriptor index.
+//
+// When a string descriptor is requested, the host provides a language ID and
+// index to identify the string ("give me string number 5 in French").  This
+// function maps these two parameters to an index within our device's string
+// descriptor array which is arranged as multiple groups of strings with
+// one group for each language advertised via string descriptor 0.
+//
+// We assume that there are an equal number of strings per language and
+// that the first descriptor is the language descriptor and use this fact to
+// perform the mapping.
+//
+// \return The index of the string descriptor to return or -1 if the string
+// could not be found.
+//
+//*****************************************************************************
+static int32_t
+USBDStringIndexFromRequest(uint16_t ui16Lang, uint16_t ui16Index)
+{
+    tString0Descriptor *pLang;
+    uint32_t ui32NumLangs, ui32NumStringi16PerLang, ui32Loop;
+
+    //
+    // Make sure we have a string table at all.
+    //
+    if((g_ppsDevInfo[0] == 0) ||
+       (g_ppsDevInfo[0]->ppui8StringDescriptors == 0))
+    {
+        return(-1);
+    }
+
+    //
+    // First look for the trivial case where descriptor 0 is being
+    // requested.  This is the special case since descriptor 0 contains the
+    // language codes supported by the device.
+    //
+    if(ui16Index == 0)
+    {
+        return(0);
+    }
+
+    //
+    // How many languages does this device support?  This is determined by
+    // looking at the length of the first descriptor in the string table,
+    // subtracting 2 for the header and dividing by two (the size of each
+    // language code).
+    //
+    ui32NumLangs =
+            (g_ppsDevInfo[0]->ppui8StringDescriptors[0][0] - 2) / 2;
+
+    //
+    // We assume that the table includes the same number of strings for each
+    // supported language.  We know the number of entries in the string table,
+    // so how many are there for each language?  This may seem an odd way to
+    // do this (why not just have the application tell us in the device info
+    // structure?) but it's needed since we didn't want to change the API
+    // after the first release which did not support multiple languages.
+    //
+    ui32NumStringi16PerLang =
+        ((g_ppsDevInfo[0]->ui32NumStringDescriptors - 1) /ui32NumLangs);
+
+    //
+    // Just to be sure, make sure that the calculation indicates an equal
+    // number of strings per language.  We expect the string table to contain
+    // (1 + (strings_per_language * languages)) entries.
+    //
+    if((1 + (ui32NumStringi16PerLang * ui32NumLangs)) !=
+            g_ppsDevInfo[0]->ui32NumStringDescriptors)
+    {
+        return(-1);
+    }
+
+    //
+    // Now determine which language we are looking for.  It is assumed that
+    // the order of the groups of strings per language in the table is the
+    // same as the order of the language IDs listed in the first descriptor.
+    //
+    pLang = (tString0Descriptor *)
+                        (g_ppsDevInfo[0]->ppui8StringDescriptors[0]);
+
+    //
+    // Look through the supported languages looking for the one we were asked
+    // for.
+    //
+    for(ui32Loop = 0; ui32Loop < ui32NumLangs; ui32Loop++)
+    {
+        //
+        // Have we found the requested language?
+        //
+        if(pLang->wLANGID[ui32Loop] == ui16Lang)
+        {
+            //
+            // Yes - calculate the index of the descriptor to send.
+            //
+            return((ui32NumStringi16PerLang * ui32Loop) + ui16Index);
+        }
+    }
+
+    //
+    // If we drop out of the loop, the requested language was not found so
+    // return -1 to indicate the error.
+    //
+    return(-1);
+}
+
+//*****************************************************************************
+//
+// This function handles the SET_DESCRIPTOR standard USB request.
+//
+// \param pvInstance is the USB device controller instance data.
+// \param psUSBRequest holds the data for this request.
+//
+// This function currently is not supported and will respond with a Stall
+// to indicate that this command is not supported by the device.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+USBDSetDescriptor(void *pvInstance, tUSBRequest *psUSBRequest)
+{
+    //
+    // Need to ACK the data on end point 0 without setting last data as there
+    // will be a data phase.
+    //
+    MAP_USBDevEndpointDataAck(USB0_BASE, USB_EP_0, false);
+
+    //
+    // This function is not handled by default.
+    //
+    USBDCDStallEP0(0);
+}
+
+//*****************************************************************************
+//
+// This function handles the GET_CONFIGURATION standard USB request.
+//
+// \param pvInstance is the USB device controller instance data.
+// \param psUSBRequest holds the data for this request.
+//
+// This function responds to a host request to return the current
+// configuration of the USB device.  The function will send the configuration
+// response to the host and return.  This value will either be 0 or the last
+// value received from a call to SetConfiguration().
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+USBDGetConfiguration(void *pvInstance, tUSBRequest *psUSBRequest)
+{
+    uint8_t ui8Value;
+    tDCDInstance *psUSBControl;
+
+    ASSERT(psUSBRequest != 0);
+    ASSERT(pvInstance != 0);
+
+    //
+    // Create the device information pointer.
+    //
+    psUSBControl = (tDCDInstance *)pvInstance;
+
+    //
+    // Need to ACK the data on end point 0 without setting last data as there
+    // will be a data phase.
+    //
+    MAP_USBDevEndpointDataAck(USB0_BASE, USB_EP_0, false);
+
+    //
+    // If we still have an address pending then the device is still not
+    // configured.
+    //
+    if(psUSBControl->ui32DevAddress & DEV_ADDR_PENDING)
+    {
+        ui8Value = 0;
+    }
+    else
+    {
+        ui8Value = (uint8_t)psUSBControl->ui32Configuration;
+    }
+
+    psUSBControl->ui32EP0DataRemain = 1;
+    psUSBControl->pui8EP0Data = &ui8Value;
+
+    //
+    // Send the single byte response.
+    //
+    USBDEP0StateTx(0);
+}
+
+//*****************************************************************************
+//
+// This function handles the SET_CONFIGURATION standard USB request.
+//
+// \param pvInstance is the USB device controller instance data.
+// \param psUSBRequest holds the data for this request.
+//
+// This function responds to a host request to change the current
+// configuration of the USB device.  The actual configuration number is taken
+// from the structure passed in via \e psUSBRequest.  This number should be one
+// of the configurations that was specified in the descriptors.  If the
+// \e ConfigChange callback is specified in \e pvInstance->psInfo->psCallbacks->
+// it will be called so that the application can respond to a change in
+// configuration.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+USBDSetConfiguration(void *pvInstance, tUSBRequest *psUSBRequest)
+{
+    tDCDInstance *psUSBControl;
+    tDeviceInfo *psDevice;
+    const tConfigHeader *psHdr;
+    const tConfigDescriptor *psDesc;
+
+
+    //
+    // Create the device information pointer.
+    //
+    psUSBControl = (tDCDInstance *)pvInstance;
+    psDevice = g_ppsDevInfo[0];
+
+    //
+    // Need to ACK the data on end point 0 with last data set as this has no
+    // data phase.
+    //
+    MAP_USBDevEndpointDataAck(USB0_BASE, USB_EP_0, true);
+
+    //
+    // Cannot set the configuration to one that does not exist so check the
+    // enumeration structure to see how many valid configurations are present.
+    //
+    if(psUSBRequest->wValue > psDevice->pui8DeviceDescriptor[17])
+    {
+        //
+        // The passed configuration number is not valid.  Stall the endpoint to
+        // signal the error to the host.
+        //
+        USBDCDStallEP0(0);
+    }
+    else
+    {
+        //
+        // Save the configuration.
+        //
+        psUSBControl->ui32Configuration = psUSBRequest->wValue;
+
+        //
+        // If passed a configuration other than 0 (which tells us that we are
+        // not currently configured), configure the endpoints (other than EP0)
+        // appropriately.
+        //
+        if(psUSBControl->ui32Configuration)
+        {
+            //
+            // Get a pointer to the configuration descriptor.  This will always
+            // be the first section in the current configuration.
+            //
+            psHdr = psDevice->ppsConfigDescriptors[psUSBRequest->wValue - 1];
+            psDesc =
+                (const tConfigDescriptor *)(psHdr->psSections[0]->pui8Data);
+
+            //
+            // Remember the new self- or bus-powered state if the user has not
+            // already called us to tell us the state to report.
+            //
+            if(!psUSBControl->bPwrSrcSet)
+            {
+                if((psDesc->bmAttributes & USB_CONF_ATTR_PWR_M) ==
+                    USB_CONF_ATTR_SELF_PWR)
+                {
+                    psUSBControl->ui8Status |= USB_STATUS_SELF_PWR;
+                }
+                else
+                {
+                    psUSBControl->ui8Status &= ~USB_STATUS_SELF_PWR;
+                }
+            }
+
+            //
+            // Configure endpoints for the new configuration.
+            //
+            USBDeviceConfig(psUSBControl,
+                    psDevice->ppsConfigDescriptors[psUSBRequest->wValue - 1]);
+        }
+
+        //
+        // If there is a configuration change callback then call it.
+        //
+        if(psDevice->psCallbacks->pfnConfigChange)
+        {
+            psDevice->psCallbacks->pfnConfigChange(g_psDCDInst[0].pvCBData,
+                                            psUSBControl->ui32Configuration);
+        }
+    }
+}
+
+//*****************************************************************************
+//
+// This function handles the GET_INTERFACE standard USB request.
+//
+// \param pvInstance is the USB device controller instance data.
+// \param psUSBRequest holds the data for this request.
+//
+// This function is called when the host controller request the current
+// interface that is in use by the device.  This simply returns the value set
+// by the last call to SetInterface().
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+USBDGetInterface(void *pvInstance, tUSBRequest *psUSBRequest)
+{
+    uint8_t ui8Value;
+    tDCDInstance *psUSBControl;
+
+    ASSERT(psUSBRequest != 0);
+    ASSERT(pvInstance != 0);
+
+    //
+    // Create the device information pointer.
+    //
+    psUSBControl = (tDCDInstance *)pvInstance;
+
+    //
+    // Need to ACK the data on end point 0 without setting last data as there
+    // will be a data phase.
+    //
+    MAP_USBDevEndpointDataAck(USB0_BASE, USB_EP_0, false);
+
+    //
+    // If we still have an address pending then the device is still not
+    // configured.
+    //
+    if(psUSBControl->ui32DevAddress & DEV_ADDR_PENDING)
+    {
+        ui8Value = (uint8_t)0;
+    }
+    else
+    {
+        //
+        // Is the interface number valid?
+        //
+        if(psUSBRequest->wIndex < USB_MAX_INTERFACES_PER_DEVICE)
+        {
+            //
+            // Read the current alternate setting for the required interface.
+            //
+            ui8Value = psUSBControl->pui8AltSetting[psUSBRequest->wIndex];
+        }
+        else
+        {
+            //
+            // An invalid interface number was specified.
+            //
+            USBDCDStallEP0(0);
+            return;
+        }
+    }
+
+    //
+    // Send the single byte response.
+    //
+    psUSBControl->ui32EP0DataRemain = 1;
+    psUSBControl->pui8EP0Data = &ui8Value;
+
+    //
+    // Send the single byte response.
+    //
+    USBDEP0StateTx(0);
+}
+
+//*****************************************************************************
+//
+// This function handles the SET_INTERFACE standard USB request.
+//
+// \param pvInstance is the USB device controller instance data.
+// \param psUSBRequest holds the data for this request.
+//
+// This function is called when a standard request for changing the interface
+// is received from the host controller.  If this is a valid request the
+// function will call the function specified by the InterfaceChange in the
+// \e pvInstance->psInfo->psCallbacks->variable to notify the application that
+// the interface has changed and will pass it the new alternate interface
+// number.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+USBDSetInterface(void *pvInstance, tUSBRequest *psUSBRequest)
+{
+    const tConfigHeader *psConfig;
+    tInterfaceDescriptor *psInterface;
+    uint32_t ui32Loop, ui32Section, ui32NumInterfaces;
+    uint8_t ui8Interface;
+    bool bRetcode;
+    tDCDInstance *psUSBControl;
+    tDeviceInfo *psDevice;
+
+    ASSERT(psUSBRequest != 0);
+    ASSERT(pvInstance != 0);
+
+    //
+    // Create the device information pointer.
+    //
+    psUSBControl = (tDCDInstance *)pvInstance;
+    psDevice = g_ppsDevInfo[0];
+
+    //
+    // Need to ACK the data on end point 0 with last data set as this has no
+    // data phase.
+    //
+    MAP_USBDevEndpointDataAck(USB0_BASE, USB_EP_0, true);
+
+    //
+    // Use the current configuration.
+    //
+    psConfig =
+        psDevice->ppsConfigDescriptors[psUSBControl->ui32Configuration - 1];
+
+    //
+    // How many interfaces are included in the descriptor?
+    //
+    ui32NumInterfaces = USBDCDConfigDescGetNum(psConfig, USB_DTYPE_INTERFACE);
+
+    //
+    // Find the interface descriptor for the supplied interface and alternate
+    // setting numbers.
+    //
+    for(ui32Loop = 0; ui32Loop < ui32NumInterfaces; ui32Loop++)
+    {
+        //
+        // Get the next interface descriptor in the configuration descriptor.
+        //
+        psInterface = USBDCDConfigGetInterface(psConfig, ui32Loop,
+                                               USB_DESC_ANY, &ui32Section);
+
+        //
+        // Is this the required interface with the correct alternate setting?
+        //
+        if(psInterface &&
+           (psInterface->bInterfaceNumber == psUSBRequest->wIndex) &&
+           (psInterface->bAlternateSetting == psUSBRequest->wValue))
+        {
+            ui8Interface = psInterface->bInterfaceNumber;
+
+            //
+            // Make sure we don't write outside the bounds of the
+            // pui8AltSetting array (in a debug build, anyway, since this
+            // indicates an error in the device descriptor).
+            //
+            ASSERT(ui8Interface < USB_MAX_INTERFACES_PER_DEVICE);
+
+            //
+            // This is the correct interface descriptor so save the
+            // setting.
+            //
+            psUSBControl->pui8AltSetting[ui8Interface] =
+                                            psInterface->bAlternateSetting;
+
+            //
+            // Reconfigure the endpoints to match the requirements of the
+            // new alternate setting for the interface.
+            //
+            bRetcode = USBDeviceConfigAlternate(psUSBControl, psConfig,
+                                            ui8Interface,
+                                            psInterface->bAlternateSetting);
+
+            //
+            // If there is a callback then notify the application of the
+            // change to the alternate interface.
+            //
+            if(bRetcode && psDevice->psCallbacks->pfnInterfaceChange)
+            {
+                psDevice->psCallbacks->pfnInterfaceChange(
+                                                g_psDCDInst[0].pvCBData,
+                                                psUSBRequest->wIndex,
+                                                psUSBRequest->wValue);
+            }
+
+            //
+            // All done.
+            //
+            return;
+        }
+    }
+
+    //
+    // If we drop out of the loop, we didn't find an interface descriptor
+    // matching the requested number and alternate setting or there was an
+    // error while trying to set up for the new alternate setting.
+    //
+    USBDCDStallEP0(0);
+}
+
+//*****************************************************************************
+//
+// This function handles the SYNC_FRAME standard USB request.
+//
+// \param pvInstance is the USB device controller instance data.
+// \param psUSBRequest holds the data for this request.
+//
+// This is currently a stub function that will stall indicating that the
+// command is not supported.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+USBDSyncFrame(void *pvInstance, tUSBRequest *psUSBRequest)
+{
+    //
+    // Need to ACK the data on end point 0 with last data set as this has no
+    // data phase.
+    //
+    MAP_USBDevEndpointDataAck(USB0_BASE, USB_EP_0, true);
+
+    //
+    // Not handled yet so stall this request.
+    //
+    USBDCDStallEP0(0);
+}
+
+//*****************************************************************************
+//
+// This internal function handles sending data on endpoint zero.
+//
+// \param ui32Index is the index of the USB controller which is to be
+// initialized.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+USBDEP0StateTx(uint32_t ui32Index)
+{
+    uint32_t ui32NumBytes;
+    uint8_t *pui8Data;
+
+    ASSERT(ui32Index == 0);
+
+    //
+    // In the TX state on endpoint zero.
+    //
+    g_psDCDInst[0].iEP0State = eUSBStateTx;
+
+    //
+    // Set the number of bytes to send this iteration.
+    //
+    ui32NumBytes = g_psDCDInst[0].ui32EP0DataRemain;
+
+    //
+    // Limit individual transfers to 64 bytes.
+    //
+    if(ui32NumBytes > EP0_MAX_PACKET_SIZE)
+    {
+        ui32NumBytes = EP0_MAX_PACKET_SIZE;
+    }
+
+    //
+    // Save the pointer so that it can be passed to the USBEndpointDataPut()
+    // function.
+    //
+    pui8Data = (uint8_t *)g_psDCDInst[0].pui8EP0Data;
+
+    //
+    // Advance the data pointer and counter to the next data to be sent.
+    //
+    g_psDCDInst[0].ui32EP0DataRemain -= ui32NumBytes;
+    g_psDCDInst[0].pui8EP0Data += ui32NumBytes;
+
+    //
+    // Put the data in the correct FIFO.
+    //
+    MAP_USBEndpointDataPut(USB0_BASE, USB_EP_0, pui8Data, ui32NumBytes);
+
+    //
+    // If this is exactly 64 then don't set the last packet yet.
+    //
+    if(ui32NumBytes == EP0_MAX_PACKET_SIZE)
+    {
+        //
+        // There is more data to send or exactly 64 bytes were sent, this
+        // means that there is either more data coming or a null packet needs
+        // to be sent to complete the transaction.
+        //
+        MAP_USBEndpointDataSend(USB0_BASE, USB_EP_0, USB_TRANS_IN);
+    }
+    else
+    {
+        //
+        // Now go to the status state and wait for the transmit to complete.
+        //
+        g_psDCDInst[0].iEP0State = eUSBStateStatus;
+
+        //
+        // Send the last bit of data.
+        //
+        MAP_USBEndpointDataSend(USB0_BASE, USB_EP_0, USB_TRANS_IN_LAST);
+
+        //
+        // If there is a sent callback then call it.
+        //
+        if((g_ppsDevInfo[0]->psCallbacks->pfnDataSent) &&
+           (g_psDCDInst[0].ui32OUTDataSize != 0))
+        {
+            //
+            // Call the custom handler.
+            //
+            g_ppsDevInfo[0]->psCallbacks->pfnDataSent(
+                                            g_psDCDInst[0].pvCBData,
+                                            g_psDCDInst[0].ui32OUTDataSize);
+
+            //
+            // There is no longer any data pending to be sent.
+            //
+            g_psDCDInst[0].ui32OUTDataSize = 0;
+        }
+    }
+}
+
+//*****************************************************************************
+//
+// This internal function handles sending the configuration descriptor on
+// endpoint zero.
+//
+// \param ui32Index is the index of the USB controller.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+USBDEP0StateTxConfig(uint32_t ui32Index)
+{
+    uint32_t ui32NumBytes, ui32SecBytes, ui32ToSend;
+    uint8_t *pui8Data;
+    tConfigDescriptor sConfDesc;
+    const tConfigHeader *psConfig;
+    const tConfigSection *psSection;
+
+    ASSERT(ui32Index == 0);
+
+    //
+    // In the TX state on endpoint zero.
+    //
+    g_psDCDInst[0].iEP0State = eUSBStateTxConfig;
+
+    //
+    // Find the current configuration descriptor definition.
+    //
+    psConfig = g_ppsDevInfo[0]->ppsConfigDescriptors[
+                                            g_psDCDInst[0].ui8ConfigIndex];
+
+    //
+    // Set the number of bytes to send this iteration.
+    //
+    ui32NumBytes = g_psDCDInst[0].ui32EP0DataRemain;
+
+    //
+    // Limit individual transfers to 64 bytes.
+    //
+    if(ui32NumBytes > EP0_MAX_PACKET_SIZE)
+    {
+        ui32NumBytes = EP0_MAX_PACKET_SIZE;
+    }
+
+    //
+    // If this is the first call, we need to fix up the total length of the
+    // configuration descriptor.  This has already been determined and set in
+    // g_sUSBDeviceState.ui32EP0DataRemain.
+    //
+    if((g_psDCDInst[0].ui16SectionOffset == 0) &&
+       (g_psDCDInst[0].ui8ConfigSection == 0))
+    {
+        //
+        // Copy the USB configuration descriptor from the beginning of the
+        // first section of the current configuration.
+        //
+        sConfDesc = *(tConfigDescriptor *)g_psDCDInst[0].pui8EP0Data;
+
+        //
+        // Update the total size.
+        //
+        sConfDesc.wTotalLength = (uint16_t)USBDCDConfigDescGetSize(psConfig);
+
+        //
+        // Write the descriptor to the USB FIFO.
+        //
+        ui32ToSend = (ui32NumBytes < sizeof(tConfigDescriptor)) ? ui32NumBytes:
+                        sizeof(tConfigDescriptor);
+        MAP_USBEndpointDataPut(USB0_BASE, USB_EP_0, (uint8_t *)&sConfDesc,
+                               ui32ToSend);
+
+        //
+        // Did we reach the end of the first section?
+        //
+        if(psConfig->psSections[0]->ui16Size == ui32ToSend)
+        {
+            //
+            // Update our tracking indices to point to the start of the next
+            // section.
+            //
+            g_psDCDInst[0].ui16SectionOffset = 0;
+            g_psDCDInst[0].ui8ConfigSection = 1;
+        }
+        else
+        {
+            //
+            // Note that we have sent the first few bytes of the descriptor.
+            //
+            g_psDCDInst[0].ui16SectionOffset = (uint8_t)ui32ToSend;
+        }
+
+        //
+        // How many bytes do we have remaining to send on this iteration?
+        //
+        ui32ToSend = ui32NumBytes - ui32ToSend;
+    }
+    else
+    {
+        //
+        // Set the number of bytes we still have to send on this call.
+        //
+        ui32ToSend = ui32NumBytes;
+    }
+
+    //
+    // Add the relevant number of bytes to the USB FIFO
+    //
+    while(ui32ToSend)
+    {
+        //
+        // Get a pointer to the current configuration section.
+        //
+        psSection = psConfig->psSections[g_psDCDInst[0].ui8ConfigSection];
+
+        //
+        // Calculate bytes are available in the current configuration section.
+        //
+        ui32SecBytes = (uint32_t)(psSection->ui16Size -
+                                  g_psDCDInst[0].ui16SectionOffset);
+
+        //
+        // Save the pointer so that it can be passed to the
+        // USBEndpointDataPut() function.
+        //
+        pui8Data = (uint8_t *)psSection->pui8Data +
+                              g_psDCDInst[0].ui16SectionOffset;
+
+        //
+        // Are there more bytes in this section that we still have to send?
+        //
+        if(ui32SecBytes > ui32ToSend)
+        {
+            //
+            // Yes - send only the remaining bytes in the transfer.
+            //
+            ui32SecBytes = ui32ToSend;
+        }
+
+        //
+        // Put the data in the correct FIFO.
+        //
+        MAP_USBEndpointDataPut(USB0_BASE, USB_EP_0, pui8Data, ui32SecBytes);
+
+        //
+        // Fix up our pointers for the next iteration.
+        //
+        ui32ToSend -= ui32SecBytes;
+        g_psDCDInst[0].ui16SectionOffset += (uint8_t)ui32SecBytes;
+
+        //
+        // Have we reached the end of a section?
+        //
+        if(g_psDCDInst[0].ui16SectionOffset == psSection->ui16Size)
+        {
+            //
+            // Yes - move to the next one.
+            //
+            g_psDCDInst[0].ui8ConfigSection++;
+            g_psDCDInst[0].ui16SectionOffset = 0;
+        }
+    }
+
+    //
+    // Fix up the number of bytes remaining to be sent and the start pointer.
+    //
+    g_psDCDInst[0].ui32EP0DataRemain -= ui32NumBytes;
+
+    //
+    // If we ran out of bytes in the configuration section, bail and just
+    // send out what we have.
+    //
+    if(psConfig->ui8NumSections <= g_psDCDInst[0].ui8ConfigSection)
+    {
+        g_psDCDInst[0].ui32EP0DataRemain = 0;
+    }
+
+    //
+    // If there is no more data don't keep looking or ui8ConfigSection might
+    // overrun the available space.
+    //
+    if(g_psDCDInst[0].ui32EP0DataRemain != 0)
+    {
+        pui8Data =(uint8_t *)
+            psConfig->psSections[g_psDCDInst[0].ui8ConfigSection]->pui8Data;
+        ui32ToSend = g_psDCDInst[0].ui16SectionOffset;
+        g_psDCDInst[0].pui8EP0Data = (pui8Data + ui32ToSend);
+    }
+
+    //
+    // If this is exactly 64 then don't set the last packet yet.
+    //
+    if(ui32NumBytes == EP0_MAX_PACKET_SIZE)
+    {
+        //
+        // There is more data to send or exactly 64 bytes were sent, this
+        // means that there is either more data coming or a null packet needs
+        // to be sent to complete the transaction.
+        //
+        MAP_USBEndpointDataSend(USB0_BASE, USB_EP_0, USB_TRANS_IN);
+    }
+    else
+    {
+        //
+        // Send the last bit of data.
+        //
+        MAP_USBEndpointDataSend(USB0_BASE, USB_EP_0, USB_TRANS_IN_LAST);
+
+        //
+        // If there is a sent callback then call it.
+        //
+        if((g_ppsDevInfo[0]->psCallbacks->pfnDataSent) &&
+           (g_psDCDInst[0].ui32OUTDataSize != 0))
+        {
+            //
+            // Call the custom handler.
+            //
+            g_ppsDevInfo[0]->psCallbacks->pfnDataSent(g_psDCDInst[0].pvCBData,
+                                            g_psDCDInst[0].ui32OUTDataSize);
+
+            //
+            // There is no longer any data pending to be sent.
+            //
+            g_psDCDInst[0].ui32OUTDataSize = 0;
+        }
+
+        //
+        // Now go to the status state and wait for the transmit to complete.
+        //
+        g_psDCDInst[0].iEP0State = eUSBStateStatus;
+    }
+}
+
+//*****************************************************************************
+//
+// The internal USB device interrupt handler.
+//
+// \param ui32Index is the USB controller associated with this interrupt.
+// \param ui32Status is the current interrupt status as read via a call to
+// USBIntStatusControl().
+//
+// This function is called from either \e USB0DualModeIntHandler() or
+// \e USB0DeviceIntHandler() to process USB interrupts when in device mode.
+// This handler will branch the interrupt off to the appropriate application or
+// stack handlers depending on the current status of the USB controller.
+//
+// The two-tiered structure for the interrupt handler ensures that it is
+// possible to use the same handler code in both device and OTG modes and
+// means that host code can be excluded from applications that only require
+// support for USB device mode operation.
+//
+// \return None.
+//
+//*****************************************************************************
+void
+USBDeviceIntHandlerInternal(uint32_t ui32Index, uint32_t ui32Status)
+{
+    static uint32_t ui32SOFDivide = 0;
+    void *pvInstance;
+    uint32_t ui32DMAIntStatus;
+    uint32_t ui32LPMStatus;
+
+    //
+    // If device initialization has not been performed then just disconnect
+    // from the USB bus and return from the handler.
+    //
+    if(g_ppsDevInfo[0] == 0)
+    {
+        MAP_USBDevDisconnect(USB0_BASE);
+        return;
+    }
+
+    pvInstance = g_psDCDInst[0].pvCBData;
+
+    //
+    // Received a reset from the host.
+    //
+    if(ui32Status & USB_INTCTRL_RESET)
+    {
+        USBDeviceEnumResetHandler(&g_psDCDInst[0]);
+    }
+
+    //
+    // Suspend was signaled on the bus.
+    //
+    if(ui32Status & USB_INTCTRL_SUSPEND)
+    {
+        //
+        // Call the SuspendHandler() if it was specified.
+        //
+        if(g_ppsDevInfo[0]->psCallbacks->pfnSuspendHandler)
+        {
+            g_ppsDevInfo[0]->psCallbacks->pfnSuspendHandler(pvInstance);
+        }
+    }
+
+    //
+    // Resume was signaled on the bus.
+    //
+    if(ui32Status & USB_INTCTRL_RESUME)
+    {
+        //
+        // Call the ResumeHandler() if it was specified.
+        //
+        if(g_ppsDevInfo[0]->psCallbacks->pfnResumeHandler)
+        {
+            g_ppsDevInfo[0]->psCallbacks->pfnResumeHandler(pvInstance);
+        }
+    }
+
+    //
+    // USB device was disconnected.
+    //
+    if(ui32Status & USB_INTCTRL_DISCONNECT)
+    {
+        //
+        // Call the DisconnectHandler() if it was specified.
+        //
+        if(g_ppsDevInfo[0]->psCallbacks->pfnDisconnectHandler)
+        {
+            g_ppsDevInfo[0]->psCallbacks->pfnDisconnectHandler(pvInstance);
+        }
+    }
+
+    //
+    // Start of Frame was received.
+    //
+    if(ui32Status & USB_INTCTRL_SOF)
+    {
+        //
+        // Increment the global Start of Frame counter.
+        //
+        g_ui32USBSOFCount++;
+
+        //
+        // Increment our SOF divider.
+        //
+        ui32SOFDivide++;
+
+        //
+        // Handle resume signaling if required.
+        //
+        USBDeviceResumeTickHandler(&g_psDCDInst[0]);
+
+        //
+        // Have we counted enough SOFs to allow us to call the tick function?
+        //
+        if(ui32SOFDivide == USB_SOF_TICK_DIVIDE)
+        {
+            //
+            // Yes - reset the divider and call the SOF tick handler.
+            //
+            ui32SOFDivide = 0;
+            InternalUSBStartOfFrameTick(USB_SOF_TICK_DIVIDE);
+        }
+    }
+
+    //
+    // Handle LPM interrupts.
+    //
+    ui32LPMStatus = USBLPMIntStatus(USB0_BASE);
+
+    //
+    // The host LPM resume request has been acknowledged, allow the device
+    // class to handle the sleep state.
+    //
+    if((g_psDCDInst[0].ui32LPMState == USBLIB_LPM_STATE_SLEEP) &&
+       ((ui32LPMStatus & (USB_INTLPM_ACK | USB_INTLPM_RESUME)) ==
+        USB_INTLPM_RESUME))
+    {
+        //
+        // Notify the class of the wake from LPM L1.
+        //
+        if(g_ppsDevInfo[0]->psCallbacks->pfnDeviceHandler)
+        {
+            g_ppsDevInfo[0]->psCallbacks->pfnDeviceHandler(pvInstance,
+                                                USB_EVENT_LPM_RESUME,
+                                                (void *)0);
+        }
+
+        //
+        // Now back in the awake state.
+        //
+        g_psDCDInst[0].ui32LPMState = USBLIB_LPM_STATE_AWAKE;
+
+        //
+        // Enable receiving of LPM packet.
+        //
+        USBDevLPMEnable(USB0_BASE);
+    }
+    //
+    // The host LPM sleep request has been acknowledged, allow the device
+    // class to handle the sleep state.
+    //
+    else if((g_psDCDInst[0].ui32LPMState == USBLIB_LPM_STATE_AWAKE) &&
+            ((ui32LPMStatus & (USB_INTLPM_ACK | USB_INTLPM_RESUME)) ==
+             USB_INTLPM_ACK))
+    {
+        if(g_ppsDevInfo[0]->psCallbacks->pfnDeviceHandler)
+        {
+            g_ppsDevInfo[0]->psCallbacks->pfnDeviceHandler(pvInstance,
+                                                USB_EVENT_LPM_SLEEP,
+                                                (void *)0);
+        }
+
+        //
+        // Now back in the sleep state.
+        //
+        g_psDCDInst[0].ui32LPMState = USBLIB_LPM_STATE_SLEEP;
+    }
+    else if(ui32LPMStatus & USB_INTLPM_NYET)
+    {
+        //
+        // The device has held off the sleep state because LPM
+        // responses are disabled.
+        //
+        if(g_ppsDevInfo[0]->psCallbacks->pfnDeviceHandler)
+        {
+            g_ppsDevInfo[0]->psCallbacks->pfnDeviceHandler(pvInstance,
+                                                USB_EVENT_LPM_ERROR,
+                                                (void *)0);
+        }
+    }
+
+    //
+    // Get the controller interrupt status.
+    //
+    ui32Status = MAP_USBIntStatusEndpoint(USB0_BASE);
+
+    //
+    // Handle end point 0 interrupts.
+    //
+    if(ui32Status & USB_INTEP_0)
+    {
+        USBDeviceEnumHandler(&g_psDCDInst[0]);
+        ui32Status &= ~USB_INTEP_0;
+    }
+
+    //
+    // Check to see if any DMA transfers are pending
+    //
+    ui32DMAIntStatus = USBLibDMAIntStatus(g_psDCDInst[0].psDMAInstance);
+
+    if(ui32DMAIntStatus)
+    {
+        //
+        // Handle any DMA interrupt processing.
+        //
+        USBLibDMAIntHandler(g_psDCDInst[0].psDMAInstance, ui32DMAIntStatus);
+    }
+
+    //
+    // Because there is no way to detect if a uDMA interrupt has occurred,
+    // check for an endpoint callback and call it if it is available.
+    //
+    if((g_ppsDevInfo[0]->psCallbacks->pfnEndpointHandler) &&
+       ((ui32Status != 0) || (ui32DMAIntStatus != 0)))
+    {
+        g_ppsDevInfo[0]->psCallbacks->pfnEndpointHandler(pvInstance, ui32Status);
+    }
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
diff --git a/bsp/tm4c129x/libraries/usblib/device/usbdevice.h b/bsp/tm4c129x/libraries/usblib/device/usbdevice.h
new file mode 100755
index 0000000..da9ec4a
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/device/usbdevice.h
@@ -0,0 +1,232 @@
+//*****************************************************************************
+//
+// usbdevice.h - types and definitions used during USB enumeration.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#ifndef __USBDEVICE_H__
+#define __USBDEVICE_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+//*****************************************************************************
+//
+//! \addtogroup device_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! The maximum number of independent interfaces that any single device
+//! implementation can support.  Independent interfaces means interface
+//! descriptors with different \e bInterfaceNumber values - several interface
+//! descriptors offering different alternative settings but the same interface
+//! number count as a single interface.
+//
+//*****************************************************************************
+#define USB_MAX_INTERFACES_PER_DEVICE 8
+
+#include "usbdevicepriv.h"
+
+//*****************************************************************************
+//
+//! This structure is passed to the USB library on a call to USBDCDInit and
+//! provides the library with information about the device that the
+//! application is implementing.  It contains functions pointers for the
+//! various USB event handlers and pointers to each of the standard device
+//! descriptors.
+//
+//*****************************************************************************
+struct tDeviceInfo
+{
+    //
+    //! A pointer to a structure containing pointers to event handler functions
+    //! provided by the client to support the operation of this device.
+    //
+    const tCustomHandlers * psCallbacks;
+
+    //
+    //! A pointer to the device descriptor for this device.
+    //
+    const uint8_t *pui8DeviceDescriptor;
+
+    //
+    //! A pointer to an array of configuration descriptor pointers.  Each entry
+    //! in the array corresponds to one configuration that the device may be
+    //! set to use by the USB host.  The number of entries in the array must
+    //! match the bNumConfigurations value in the device descriptor
+    //! array, \e pui8DeviceDescriptor.
+    //
+    const tConfigHeader * const *ppsConfigDescriptors;
+
+    //
+    //! A pointer to the string descriptor array for this device.  This array
+    //! must be arranged as follows:
+    //!
+    //!   [0]   - Standard descriptor containing supported language codes.
+    //!
+    //!   [1]   - String 1 for the first language listed in descriptor 0.
+    //!
+    //!   [2]   - String 2 for the first language listed in descriptor 0.
+    //!
+    //!   ...
+    //!
+    //!   [n]   - String n for the first language listed in descriptor 0.
+    //!
+    //!   [n+1] - String 1 for the second language listed in descriptor 0.
+    //!
+    //!   ...
+    //!
+    //!   [2n]  - String n for the second language listed in descriptor 0.
+    //!
+    //!   [2n+1]- String 1 for the third language listed in descriptor 0.
+    //!
+    //!   ...
+    //!
+    //!   [3n]  - String n for the third language listed in descriptor 0.
+    //!
+    //! and so on.
+    //
+    const uint8_t * const *ppui8StringDescriptors;
+
+    //
+    //! The total number of descriptors provided in the ppStringDescriptors
+    //! array.
+    //
+    uint32_t ui32NumStringDescriptors;
+};
+
+//*****************************************************************************
+//
+//! This type is used by an application to describe and instance of a device
+//! and an instance data pointer for that class.  The psDevice pointer should
+//! be a pointer to a valid device class to include in the composite device.
+//! The pvInstance pointer should be a pointer to an instance pointer for the
+//! device in the psDevice pointer.
+//!
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! This is the top level device information structure.
+    //
+    const tDeviceInfo *psDevInfo;
+
+    //
+    //! This is the instance data for the device structure.
+    //
+    void *pvInstance;
+
+    //
+    //! A per-device workspace used by the composite device.
+    //
+    uint32_t ui32DeviceWorkspace;
+}
+tCompositeEntry;
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Public APIs offered by the USB library device control driver.
+//
+//*****************************************************************************
+extern void USBDCDInit(uint32_t ui32Index, tDeviceInfo *psDevice,
+                       void *pvDCDCBData);
+extern void USBDCDTerm(uint32_t ui32Index);
+extern void USBDCDStallEP0(uint32_t ui32Index);
+extern void USBDCDRequestDataEP0(uint32_t ui32Index, uint8_t *pui8Data,
+                                 uint32_t ui32Size);
+extern void USBDCDSendDataEP0(uint32_t ui32Index, uint8_t *pui8Data,
+                              uint32_t ui32Size);
+extern void USBDCDSetDefaultConfiguration(uint32_t ui32Index,
+                                          uint32_t ui32DefaultConfig);
+extern uint32_t USBDCDConfigDescGetSize(const tConfigHeader *psConfig);
+extern uint32_t USBDCDConfigDescGetNum(const tConfigHeader *psConfig,
+                                       uint32_t ui32Type);
+extern tDescriptorHeader *USBDCDConfigDescGet(const tConfigHeader *psConfig,
+                                              uint32_t ui32Type,
+                                              uint32_t ui32Index,
+                                              uint32_t *pui32Section);
+extern uint32_t
+       USBDCDConfigGetNumAlternateInterfaces(const tConfigHeader *psConfig,
+                                             uint8_t ui8InterfaceNumber);
+extern tInterfaceDescriptor *
+       USBDCDConfigGetInterface(const tConfigHeader *psConfig,
+                                uint32_t ui32Index, uint32_t ui32AltCfg,
+                                uint32_t *pui32Section);
+extern tEndpointDescriptor *
+       USBDCDConfigGetInterfaceEndpoint(const tConfigHeader *psConfig,
+                                        uint32_t ui32InterfaceNumber,
+                                        uint32_t ui32AltCfg,
+                                        uint32_t ui32Index);
+extern bool USBDCDRemoteWakeupRequest(uint32_t ui32Index);
+extern bool USBDCDFeatureSet(uint32_t ui32Index, uint32_t ui32Feature,
+                             void *pvFeature);
+extern bool USBDCDRemoteWakeLPM(uint32_t ui32Index);
+
+//*****************************************************************************
+//
+// Device mode interrupt handler for controller index 0.
+//
+//*****************************************************************************
+extern void USB0DeviceIntHandler(void);
+
+//*****************************************************************************
+//
+// The following APIs are deprecated.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+
+//
+// Use USBDCDFeatureSet() or USBHCDFeatureSet() with \b USBLIB_FEATURE_POWER
+// configuration option.
+//
+extern void USBDCDPowerStatusSet(uint32_t ui32Index, uint8_t ui8Power);
+#endif
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __USBENUM_H__
diff --git a/bsp/tm4c129x/libraries/usblib/device/usbdevicepriv.h b/bsp/tm4c129x/libraries/usblib/device/usbdevicepriv.h
new file mode 100755
index 0000000..bd507b0
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/device/usbdevicepriv.h
@@ -0,0 +1,248 @@
+//*****************************************************************************
+//
+// usbdevicepriv.h - Private header file used to share internal variables and
+//                   function prototypes between the various device-related
+//                   modules in the USB library.  This header MUST NOT be
+//                   used by application code.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#ifndef __USBDEVICEPRIV_H__
+#define __USBDEVICEPRIV_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+//*****************************************************************************
+//
+// The states for endpoint zero during enumeration.
+//
+//*****************************************************************************
+typedef enum
+{
+    //
+    // The USB device is waiting on a request from the host controller on
+    // endpoint zero.
+    //
+    eUSBStateIdle,
+
+    //
+    // The USB device is sending data back to the host due to an IN request.
+    //
+    eUSBStateTx,
+
+    //
+    // The USB device is sending the configuration descriptor back to the host
+    // due to an IN request.
+    //
+    eUSBStateTxConfig,
+
+    //
+    // The USB device is receiving data from the host due to an OUT
+    // request from the host.
+    //
+    eUSBStateRx,
+
+    //
+    // The USB device has completed the IN or OUT request and is now waiting
+    // for the host to acknowledge the end of the IN/OUT transaction.  This
+    // is the status phase for a USB control transaction.
+    //
+    eUSBStateStatus,
+
+    //
+    // This endpoint has signaled a stall condition and is waiting for the
+    // stall to be acknowledged by the host controller.
+    //
+    eUSBStateStall
+}
+tEP0State;
+
+typedef struct tDeviceInfo tDeviceInfo;
+
+//*****************************************************************************
+//
+// The USB controller device information.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    // The current state of endpoint zero.
+    //
+    volatile tEP0State iEP0State;
+
+    //
+    // The devices current address, this also has a change pending bit in the
+    // MSB of this value specified by DEV_ADDR_PENDING.
+    //
+    volatile uint32_t ui32DevAddress;
+
+    //
+    // This holds the current active configuration for this device.
+    //
+    uint32_t ui32Configuration;
+
+    //
+    // This holds the configuration id that will take effect after a reset.
+    //
+    uint32_t ui32DefaultConfiguration;
+
+    //
+    // This holds the current alternate interface for this device.
+    //
+    uint8_t pui8AltSetting[USB_MAX_INTERFACES_PER_DEVICE];
+
+    //
+    // This is the pointer to the current data being sent out or received
+    // on endpoint zero.
+    //
+    uint8_t *pui8EP0Data;
+
+    //
+    // This is the number of bytes that remain to be sent from or received
+    // into the g_sUSBDeviceState.pui8EP0Data data buffer.
+    //
+    volatile uint32_t ui32EP0DataRemain;
+
+    //
+    // The amount of data being sent/received due to a custom request.
+    //
+    uint32_t ui32OUTDataSize;
+
+    //
+    // Holds the current device status.
+    //
+    uint8_t ui8Status;
+
+    //
+    // Holds the endpoint status for the HALT condition.  This array is sized
+    // to hold halt status for all IN and OUT endpoints.
+    //
+    uint8_t ppui8Halt[2][USBLIB_NUM_EP - 1];
+
+    //
+    // Holds the configuration descriptor section number currently being sent
+    // to the host.
+    //
+    uint8_t ui8ConfigSection;
+
+    //
+    // Holds the offset within the configuration descriptor section currently
+    // being sent to the host.
+    //
+    uint16_t ui16SectionOffset;
+
+    //
+    // Holds the index of the configuration that we are currently sending back
+    // to the host.
+    //
+    uint8_t ui8ConfigIndex;
+
+    //
+    // This flag is set to true if the client has called USBDPowerStatusSet()
+    // and tells the USB library not to try to determine the current power
+    // status from the configuration descriptor.
+    //
+    bool bPwrSrcSet;
+
+    //
+    // This flag indicates whether or not remote wake up signaling is in
+    // progress.
+    //
+    bool bRemoteWakeup;
+
+    //
+    // During remote wake up signaling, this counter is used to track the
+    // number of milliseconds since the signaling was initiated.
+    //
+    uint8_t ui8RemoteWakeupCount;
+
+    //
+    // The DMA instance information for this USB controller.
+    //
+    tUSBDMAInstance *psDMAInstance;
+
+    //
+    // The interrupt number for this instance.
+    //
+    uint32_t ui32IntNum;
+
+    //
+    // Pointer to the device supplied call back data.
+    //
+    void *pvCBData;
+
+    //
+    // This holds the state of the LPM support for the device.
+    //
+    uint32_t ui32LPMState;
+
+    //
+    // Device feature flags.
+    //
+    uint32_t ui32Features;
+}
+tDCDInstance;
+
+extern tDCDInstance g_psDCDInst[];
+extern tDeviceInfo *g_ppsDevInfo[];
+
+//*****************************************************************************
+//
+// Device enumeration functions provided by device/usbenum.c and called from
+// the interrupt handler in device/usbhandler.c
+//
+//*****************************************************************************
+extern bool USBDeviceConfig(tDCDInstance *psDevInst,
+                            const tConfigHeader *psConfig);
+extern bool USBDeviceConfigAlternate(tDCDInstance *psDevInst,
+                                     const tConfigHeader *psConfig,
+                                     uint8_t ui8InterfaceNum,
+                                     uint8_t ui8AlternateSetting);
+
+extern void USBDCDDeviceInfoInit(uint32_t ui32Index, tDeviceInfo *psDevice);
+
+//*****************************************************************************
+//
+// Macro access function to device information.
+//
+//*****************************************************************************
+#define DCDGetDMAInstance(psDevInfo)    (&(psDevInfo->psDCDInst->sDMAInstance))
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __USBDEVICEPRIV_H__
diff --git a/bsp/tm4c129x/libraries/usblib/device/usbdhandler.c b/bsp/tm4c129x/libraries/usblib/device/usbdhandler.c
new file mode 100755
index 0000000..052627a
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/device/usbdhandler.c
@@ -0,0 +1,85 @@
+//*****************************************************************************
+//
+// usbhandler.c - General USB handling routines.
+//
+// Copyright (c) 2007-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "inc/hw_memmap.h"
+#include "inc/hw_types.h"
+#include "driverlib/rom.h"
+#include "driverlib/rom_map.h"
+#include "driverlib/usb.h"
+#include "usblib/usblib.h"
+#include "usblib/usblibpriv.h"
+#include "usblib/device/usbdevice.h"
+#include "usblib/device/usbdevicepriv.h"
+#include "usblib/usblibpriv.h"
+
+//*****************************************************************************
+//
+//! \addtogroup device_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! The USB device interrupt handler.
+//!
+//! This the main USB interrupt handler entry point for use in USB device
+//! applications.  This top-level handler will branch the interrupt off to the
+//! appropriate application or stack handlers depending on the current status
+//! of the USB controller.
+//!
+//! Applications which operate purely as USB devices (rather than dual mode
+//! applications which can operate in either device or host mode at different
+//! times) must ensure that a pointer to this function is installed in the
+//! interrupt vector table entry for the USB0 interrupt.  For dual mode
+//! operation, the vector should be set to point to \e USB0DualModeIntHandler()
+//! instead.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USB0DeviceIntHandler(void)
+{
+    uint32_t ui32Status;
+
+    //
+    // Get the controller interrupt status.
+    //
+    ui32Status = MAP_USBIntStatusControl(USB0_BASE);
+
+    //
+    // Call the internal handler.
+    //
+    USBDeviceIntHandlerInternal(0, ui32Status);
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
diff --git a/bsp/tm4c129x/libraries/usblib/device/usbdhid.c b/bsp/tm4c129x/libraries/usblib/device/usbdhid.c
new file mode 100755
index 0000000..57f3f3a
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/device/usbdhid.c
@@ -0,0 +1,2502 @@
+//*****************************************************************************
+//
+// usbdhid.c - USB HID device class driver.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "inc/hw_memmap.h"
+#include "inc/hw_types.h"
+#include "driverlib/debug.h"
+#include "driverlib/usb.h"
+#include "driverlib/rom.h"
+#include "driverlib/rom_map.h"
+#include "usblib/usblib.h"
+#include "usblib/usblibpriv.h"
+#include "usblib/usbhid.h"
+#include "usblib/device/usbdevice.h"
+#include "usblib/device/usbdhid.h"
+#include "usblib/usblibpriv.h"
+
+//*****************************************************************************
+//
+//! \addtogroup hid_device_class_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// The subset of endpoint status flags that we consider to be reception
+// errors.  These are passed to the client via USB_EVENT_ERROR if seen.
+//
+//*****************************************************************************
+#define USB_RX_ERROR_FLAGS      (USBERR_DEV_RX_DATA_ERROR |                   \
+                                 USBERR_DEV_RX_OVERRUN |                      \
+                                 USBERR_DEV_RX_FIFO_FULL)
+
+//*****************************************************************************
+//
+// Marker used to indicate that a given HID descriptor cannot be found in the
+// client-supplied list.
+//
+//*****************************************************************************
+#define HID_NOT_FOUND           0xFFFFFFFF
+
+//*****************************************************************************
+//
+// Flags that may appear in ui16DeferredOpFlags to indicate some operation that
+// has been requested but could not be processed at the time it was received.
+// Each deferred operation is defined as the bit number that should be set in
+// tHIDInstance->ui16DeferredOpFlags to indicate that the operation is pending.
+//
+//*****************************************************************************
+#define HID_DO_PACKET_RX        5
+#define HID_DO_SEND_IDLE_REPORT 6
+
+//*****************************************************************************
+//
+// Endpoints to use for each of the required endpoints in the driver.
+//
+//*****************************************************************************
+#define INT_IN_ENDPOINT         USB_EP_3
+#define INT_OUT_ENDPOINT        USB_EP_3
+
+//*****************************************************************************
+//
+// Device Descriptor.  This is stored in RAM to allow several fields to be
+// changed at runtime based on the client's requirements.
+//
+//*****************************************************************************
+uint8_t g_pui8HIDDeviceDescriptor[] =
+{
+    18,                         // Size of this structure.
+    USB_DTYPE_DEVICE,           // Type of this structure.
+    USBShort(0x110),            // USB version 1.1 (if we say 2.0, hosts assume
+                                // high-speed - see USB 2.0 spec 9.2.6.6)
+    USB_CLASS_DEVICE,           // USB Device Class
+    0,                          // USB Device Sub-class
+    USB_HID_PROTOCOL_NONE,      // USB Device protocol
+    USBDHID_MAX_PACKET,         // Maximum packet size for default pipe.
+    USBShort(0),                // Vendor ID (VID).
+    USBShort(0),                // Product ID (PID).
+    USBShort(0x100),            // Device Version BCD.
+    1,                          // Manufacturer string identifier.
+    2,                          // Product string identifier.
+    3,                          // Product serial number.
+    1                           // Number of configurations.
+};
+
+//*****************************************************************************
+//
+// Forward references for device handler callbacks
+//
+//*****************************************************************************
+static void HandleGetDescriptor(void *pvHIDInstance, tUSBRequest *psUSBRequest);
+static void HandleRequest(void *pvHIDInstance, tUSBRequest *psUSBRequest);
+static void HandleConfigChange(void *pvHIDInstance, uint32_t ui32Info);
+static void HandleEP0DataReceived(void *pvHIDInstance, uint32_t ui32Info);
+static void HandleEP0DataSent(void *pvHIDInstance, uint32_t ui32Info);
+static void HandleReset(void *pvHIDInstance);
+static void HandleSuspend(void *pvHIDInstance);
+static void HandleResume(void *pvHIDInstance);
+static void HandleDisconnect(void *pvHIDInstance);
+static void HandleEndpoints(void *pvHIDInstance, uint32_t ui32Status);
+static void HandleDevice(void *pvHIDInstance, uint32_t ui32Request,
+                         void *pvRequestData);
+
+//*****************************************************************************
+//
+// The device information structure for the USB HID devices.
+//
+//*****************************************************************************
+const tCustomHandlers g_sHIDHandlers =
+{
+    //
+    // GetDescriptor
+    //
+    HandleGetDescriptor,
+
+    //
+    // RequestHandler
+    //
+    HandleRequest,
+
+    //
+    // InterfaceChange
+    //
+    0,
+
+    //
+    // ConfigChange
+    //
+    HandleConfigChange,
+
+    //
+    // DataReceived
+    //
+    HandleEP0DataReceived,
+
+    //
+    // DataSentCallback
+    //
+    HandleEP0DataSent,
+
+    //
+    // ResetHandler
+    //
+    HandleReset,
+
+    //
+    // SuspendHandler
+    //
+    HandleSuspend,
+
+    //
+    // ResumeHandler
+    //
+    HandleResume,
+
+    //
+    // DisconnectHandler
+    //
+    HandleDisconnect,
+
+    //
+    // EndpointHandler
+    //
+    HandleEndpoints,
+
+    //
+    // Device handler.
+    //
+    HandleDevice
+};
+
+//*****************************************************************************
+//
+// Set or clear deferred operation flags in an "atomic" manner.
+//
+// \param pui16DeferredOp points to the flags variable which is to be modified.
+// \param ui16Bit indicates which bit number is to be set or cleared.
+// \param bSet indicates the state that the flag must be set to.  If \b true,
+// the flag is set, if \b false, the flag is cleared.
+//
+// This function safely sets or clears a bit in a flag variable.  The operation
+// makes use of bitbanding to ensure that the operation is atomic (no read-
+// modify-write is required).
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+SetDeferredOpFlag(volatile uint16_t *pui16DeferredOp, uint16_t ui16Bit,
+                  bool bSet)
+{
+    //
+    // Set the flag bit to 1 or 0 using a bitband access.
+    //
+    HWREGBITH(pui16DeferredOp, ui16Bit) = bSet ? 1 : 0;
+}
+
+//*****************************************************************************
+//
+// This function is called to clear the counter used to keep track of the time
+// elapsed since a given report was last sent.
+//
+// \param psHIDDevice points to the HID device structure whose report timer is
+// to be cleared.
+// \param ui8ReportID is the first byte of the report to be sent.  If this
+// device offers more than one input report, this value is used to find the
+// relevant report timer structure in the psHIDDevice structure.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+ClearReportTimer(const tUSBDHIDDevice *psHIDDevice, uint8_t ui8ReportID)
+{
+    uint32_t ui32Loop;
+
+    if(psHIDDevice->ui8NumInputReports > 1)
+    {
+        //
+        // We have more than 1 input report so the report must begin with a
+        // byte containing the report ID.  Scan the table we were provided
+        // when the device was initialized to find the entry for this report.
+        //
+        for(ui32Loop = 0; ui32Loop < psHIDDevice->ui8NumInputReports;
+            ui32Loop++)
+        {
+            if(psHIDDevice->psReportIdle[ui32Loop].ui8ReportID == ui8ReportID)
+            {
+                break;
+            }
+        }
+    }
+    else
+    {
+        ui32Loop = 0;
+    }
+
+    //
+    // If we drop out of the loop with an index less than ui8NumInputReports,
+    // we found the relevant report so clear its timer.
+    //
+    if(ui32Loop < psHIDDevice->ui8NumInputReports)
+    {
+        psHIDDevice->psReportIdle[ui32Loop].ui32TimeSinceReportmS = 0;
+    }
+}
+
+//*****************************************************************************
+//
+// This function is called to clear the idle period timers for each input
+// report supported by the device.
+//
+// \param psHIDDevice points to the HID device structure whose timers are to be
+// cleared.
+// \param ui32TimemS is the elapsed time in milliseconds since the last call
+// to this function.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+ClearIdleTimers(const tUSBDHIDDevice *psHIDDevice)
+{
+    uint32_t ui32Loop;
+
+    //
+    // Clear the "time till next report" counters for each input report.
+    //
+    for(ui32Loop = 0; ui32Loop < psHIDDevice->ui8NumInputReports; ui32Loop++)
+    {
+        psHIDDevice->psReportIdle[ui32Loop].ui16TimeTillNextmS =
+                        psHIDDevice->psReportIdle[ui32Loop].ui8Duration4mS * 4;
+    }
+}
+
+//*****************************************************************************
+//
+// This function is called periodically to allow us to process the report idle
+// timers.
+//
+// \param psHIDDevice points to the HID device structure whose timers are to be
+// updated.
+// \param ui32ElapsedmS indicates the number of milliseconds that have elapsed
+// since the last call to this function.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+ProcessIdleTimers(const tUSBDHIDDevice *psHIDDevice, uint32_t ui32ElapsedmS)
+{
+    uint32_t ui32Loop, ui32SizeReport;
+    void *pvReport;
+    tHIDInstance *psInst;
+    bool bDeferred;
+
+    //
+    // Get our instance data pointer
+    //
+    psInst = &((tUSBDHIDDevice *)psHIDDevice)->sPrivateData;
+
+    //
+    // We have not had to defer any report transmissions yet.
+    //
+    bDeferred = false;
+
+    //
+    // Look at each of the input report idle timers in turn.
+    //
+    for(ui32Loop = 0; ui32Loop < psHIDDevice->ui8NumInputReports; ui32Loop++)
+    {
+        //
+        // Update the time since the last report was sent.
+        //
+        psHIDDevice->psReportIdle[ui32Loop].ui32TimeSinceReportmS +=
+                                                                ui32ElapsedmS;
+
+        //
+        // Is this timer running?
+        //
+        if(psHIDDevice->psReportIdle[ui32Loop].ui8Duration4mS)
+        {
+            //
+            // Yes - is it about to expire?
+            //
+            if(psHIDDevice->psReportIdle[ui32Loop].ui16TimeTillNextmS <=
+               ui32ElapsedmS)
+            {
+                //
+                // The timer is about to expire.  Can we send a report right
+                // now?
+                //
+                if((psInst->iHIDTxState == eHIDStateIdle) &&
+                   (psInst->bSendInProgress == false))
+                {
+                    //
+                    // We can send a report so send a message to the
+                    // application to retrieve its latest report for
+                    // transmission to the host.
+                    //
+                    ui32SizeReport = psHIDDevice->pfnRxCallback(
+                               psHIDDevice->pvRxCBData,
+                               USBD_HID_EVENT_IDLE_TIMEOUT,
+                               psHIDDevice->psReportIdle[ui32Loop].ui8ReportID,
+                               &pvReport);
+
+                    //
+                    // Schedule the report for transmission.
+                    //
+                    USBDHIDReportWrite((void *)psHIDDevice, pvReport,
+                                       ui32SizeReport, true);
+
+                    //
+                    // Reload the timer for the next period.
+                    //
+                    psHIDDevice->psReportIdle[ui32Loop].ui16TimeTillNextmS =
+                        psHIDDevice->psReportIdle[ui32Loop].ui8Duration4mS * 4;
+                }
+                else
+                {
+                    //
+                    // We can't send the report straight away so flag it for
+                    // transmission as soon as the previous transmission ends.
+                    //
+                    psHIDDevice->psReportIdle[ui32Loop].ui16TimeTillNextmS = 0;
+                    bDeferred = true;
+                }
+            }
+            else
+            {
+                //
+                // The timer is not about to expire.  Update the time till the
+                // next report transmission.
+                //
+                psHIDDevice->psReportIdle[ui32Loop].ui16TimeTillNextmS -=
+                                                                ui32ElapsedmS;
+            }
+        }
+    }
+
+    //
+    // If we had to defer transmission of any report, remember this so that we
+    // will process it as soon as possible.
+    //
+    SetDeferredOpFlag(&psInst->ui16DeferredOpFlags, HID_DO_SEND_IDLE_REPORT,
+                      bDeferred);
+}
+
+static void
+SetIdleTimeout(const tUSBDHIDDevice *psHIDDevice, uint8_t ui8ReportID,
+               uint8_t ui8Timeout4mS)
+{
+    uint32_t ui32Loop;
+    bool bReportNeeded;
+    tHIDReportIdle *psIdle;
+
+    //
+    // Remember that we have not found any report that needs to be sent
+    // immediately.
+    //
+    bReportNeeded = false;
+
+    //
+    // Search through all the input reports looking for ones that fit the
+    // requirements.
+    //
+    for(ui32Loop = 0; ui32Loop < psHIDDevice->ui8NumInputReports; ui32Loop++)
+    {
+        psIdle = &psHIDDevice->psReportIdle[ui32Loop];
+
+        //
+        // If the report ID passed matches the report ID in the idle timer
+        // control structure or we were passed a report ID of zero, which
+        // indicates that all timers are to be set...
+        //
+        if(!ui8ReportID || (ui8ReportID == psIdle->ui8ReportID))
+        {
+            //
+            // Save the new duration for the idle timer.
+            //
+            psIdle->ui8Duration4mS = ui8Timeout4mS;
+
+            //
+            // Are we enabling the idle timer?  If so, fix up the time until it
+            // needs to fire.
+            //
+            if(ui8Timeout4mS)
+            {
+                //
+                // Determine what the timeout is for this report given the time
+                // since the last report of this type was sent.
+                //
+                if(psIdle->ui32TimeSinceReportmS >=
+                   ((uint32_t)ui8Timeout4mS * 4))
+                {
+                    psIdle->ui16TimeTillNextmS = 0;
+                    bReportNeeded = true;
+                }
+                else
+                {
+                    psIdle->ui16TimeTillNextmS =
+                                        (((uint16_t)ui8Timeout4mS * 4) -
+                                         psIdle->ui32TimeSinceReportmS);
+                }
+            }
+        }
+    }
+
+    //
+    // If we get to here and bReportNeeded is true, this means we need to
+    // send back at least one of the input reports as soon as possible.  Try
+    // to do this immediately.
+    //
+    if(bReportNeeded)
+    {
+        ProcessIdleTimers(psHIDDevice, 0);
+    }
+}
+
+//*****************************************************************************
+//
+// Find the idle timeout for a given HID input report.
+//
+// \param psHIDDevice points to the HID device whose report idle timeout is to
+// be found.
+// \param ui8ReportID identifies the report whose timeout is requested.  If 0,
+// the timeout for the first report is returns, regardless of its ID (or
+// whether it has one).
+//
+// This function returns the current idle timeout for a given HID input report.
+// The value returned is expressed in terms of 4mS intervals.  Convert to
+// milliseconds by multiplying by 4.  If the return value is 0, this indicates
+// that an infinite timeout is currently set and the device will not send the
+// report unless a state change occurs.
+//
+// \return Returns the current idle timeout for the given report.
+//
+//*****************************************************************************
+static uint32_t
+GetIdleTimeout(const tUSBDHIDDevice *psHIDDevice, uint8_t ui8ReportID)
+{
+    uint32_t ui32Loop;
+    tHIDReportIdle *psIdle;
+
+    //
+    // Search through all the input reports looking for ones that fit the
+    // requirements.
+    //
+    for(ui32Loop = 0; ui32Loop < psHIDDevice->ui8NumInputReports; ui32Loop++)
+    {
+        psIdle = &psHIDDevice->psReportIdle[ui32Loop];
+
+        //
+        // If the report ID passed matches the report ID in the idle timer
+        // control structure or we were passed a report ID of zero, which
+        // indicates that all timers are to be set...
+        //
+        if(!ui8ReportID || (ui8ReportID == psIdle->ui8ReportID))
+        {
+            //
+            // We found a report matching the required ID or we were not passed
+            // an ID and we are looking at the first report information.
+            //
+            return((uint32_t)psIdle->ui8Duration4mS);
+        }
+    }
+
+    //
+    // If we drop out, the report could not be found so we need to indicate
+    // an error.
+    //
+    return(HID_NOT_FOUND);
+}
+
+//*****************************************************************************
+//
+// Find the n-th HID class descriptor of a given type in the client-provided
+// descriptor table.
+//
+// \param psHIDDevice points to the HID device which is to be searched for the
+// required class descriptor.
+// \param ui8Type is the type of class descriptor being requested.  This will
+// be either USB_HID_DTYPE_REPORT or USB_HID_DTYPE_PHYSICAL.
+// \param ui32Index is the zero-based index of the descriptor that is being
+// requested.
+//
+// This function parses the supplied HID descriptor to find the index into the
+// sClassDescriptor array that corresponds to the requested descriptor.  If
+// a descriptor with the requested index does not exist, HID_NOT_FOUND will be
+// returned unless the request is for a physical descriptor and at least one
+// such descriptor exists.  In this case, the index returned will be for the
+// last physical descriptor (as required by the HID spec 7.1.1).
+//
+// \return Returns the index of the descriptor within the sClassDescriptor
+// of the tHIDDevice structure if found or HID_NOT_FOUND otherwise.
+//
+//*****************************************************************************
+static uint32_t
+FindHIDDescriptor(const tUSBDHIDDevice *psHIDDevice, uint8_t ui8Type,
+                  uint32_t ui32Index, uint32_t *pui32Len)
+{
+    bool bFoundType;
+    uint32_t ui32Loop, ui32Count, ui32LastFound;
+    const tHIDClassDescriptorInfo *psDesc;
+
+    //
+    // Remember that we have not found any descriptor with a matching type yet.
+    //
+    bFoundType = false;
+    ui32Count = 0;
+    ui32LastFound = 0;
+
+    //
+    // Walk through all the class descriptors looking for the one which
+    // matches the requested index and type.
+    //
+    for(ui32Loop = 0; ui32Loop < psHIDDevice->psHIDDescriptor->bNumDescriptors;
+        ui32Loop++)
+    {
+        psDesc = &(psHIDDevice->psHIDDescriptor->sClassDescriptor[ui32Loop]);
+        if(psDesc->bDescriptorType == ui8Type)
+        {
+            //
+            // We found a descriptor of the correct type.  Is this the
+            // correct index?
+            //
+            bFoundType = true;
+
+            //
+            // Is this the descriptor we are looking for?
+            //
+            if(ui32Count == ui32Index)
+            {
+                //
+                // Yes - we found it so return the index and size to the
+                // caller.
+                //
+                *pui32Len = (uint32_t)psDesc->wDescriptorLength;
+                return(ui32Loop);
+            }
+            else
+            {
+                //
+                // Update our count and keep looking.  Remember where we were
+                // when we found this descriptor in case we need to return the
+                // last physical descriptor.
+                //
+                ui32Count++;
+                ui32LastFound = ui32Loop;
+            }
+        }
+    }
+
+    //
+    // If we drop out, we did not find the requested descriptor.  Now handle
+    // the special case of a physical descriptor - if we found any physical
+    // descriptors, return the last one.
+    //
+    if((ui8Type == USB_HID_DTYPE_PHYSICAL) && bFoundType)
+    {
+        //
+        // Get the length of the last descriptor we found.
+        //
+        psDesc =
+            &(psHIDDevice->psHIDDescriptor->sClassDescriptor[ui32LastFound]);
+        *pui32Len = (uint32_t)psDesc->wDescriptorLength;
+
+        //
+        // Return the index to the caller.
+        //
+        return(ui32LastFound);
+    }
+    else
+    {
+        //
+        // We could not find the descriptor so return an appropriate error.
+        //
+        return(HID_NOT_FOUND);
+    }
+}
+
+//*****************************************************************************
+//
+// Schedule transmission of the next packet forming part of an input report.
+//
+// \param psHIDInst points to the HID device instance whose input report is to
+// be sent.
+//
+// This function is called to transmit the next packet of an input report
+// passed to the driver via a call to USBDHIDReportWrite.  If any data remains
+// to be sent, a USB packet is written to the FIFO and scheduled for
+// transmission to the host.  The function ensures that reports are sent as
+// a sequence of full packets followed by either a single int16_t packet or a
+// packet with no data to indicate the end of the transaction.
+//
+//*****************************************************************************
+static int32_t
+ScheduleReportTransmission(tHIDInstance *psHIDInst)
+{
+    uint32_t ui32NumBytes;
+    uint8_t *pui8Data;
+    int32_t i32Retcode;
+
+    //
+    // Set the number of bytes to send this iteration.
+    //
+    ui32NumBytes = (uint32_t)(psHIDInst->ui16InReportSize -
+                              psHIDInst->ui16InReportIndex);
+
+    //
+    // Limit individual transfers to the maximum packet size for the endpoint.
+    //
+    if(ui32NumBytes > USBDHID_MAX_PACKET)
+    {
+        ui32NumBytes = USBDHID_MAX_PACKET;
+    }
+
+    //
+    // Where are we sending this data from?
+    //
+    pui8Data = psHIDInst->pui8InReportData + psHIDInst->ui16InReportIndex;
+
+    //
+    // Put the data in the correct FIFO.
+    //
+    i32Retcode = MAP_USBEndpointDataPut(psHIDInst->ui32USBBase,
+                                        psHIDInst->ui8INEndpoint,
+                                        pui8Data, ui32NumBytes);
+
+    if(i32Retcode != -1)
+    {
+        //
+        // Update the count and index ready for the next time round.
+        //
+        psHIDInst->ui16InReportIndex += ui32NumBytes;
+
+        //
+        // Send out the current data.
+        //
+        i32Retcode = MAP_USBEndpointDataSend(psHIDInst->ui32USBBase,
+                                             psHIDInst->ui8INEndpoint,
+                                             USB_TRANS_IN);
+    }
+
+    //
+    // Tell the caller how we got on.
+    //
+    return(i32Retcode);
+}
+
+//*****************************************************************************
+//
+// Receives notifications related to data received from the host.
+//
+// \param psHIDDevice is the device instance whose endpoint is to be processed.
+// \param ui32Status is the USB interrupt status that caused this function to
+// be called.
+//
+// This function is called from HandleEndpoints for all interrupts signaling
+// the arrival of data on the interrupt OUT endpoint (in other words, whenever
+// the host has sent us a packet of data).  We inform the client that a packet
+// is available and, on return, check to see if the packet has been read.  If
+// not, we schedule another notification to the client for a later time.
+//
+// \return Returns \b true on success or \b false on failure.
+//
+//*****************************************************************************
+static bool
+ProcessDataFromHost(tUSBDHIDDevice *psHIDDevice, uint32_t ui32Status)
+{
+    uint32_t ui32EPStatus, ui32Size;
+    tHIDInstance *psInst;
+
+    //
+    // Get a pointer to our instance data.
+    //
+    psInst = &psHIDDevice->sPrivateData;
+
+    //
+    // Get the endpoint status to see why we were called.
+    //
+    ui32EPStatus = MAP_USBEndpointStatus(USB0_BASE, psInst->ui8OUTEndpoint);
+
+    //
+    // Clear the status bits.
+    //
+    MAP_USBDevEndpointStatusClear(USB0_BASE, psInst->ui8OUTEndpoint,
+                                  ui32EPStatus);
+
+    //
+    // Has a packet been received?
+    //
+    if(ui32EPStatus & USB_DEV_RX_PKT_RDY)
+    {
+        //
+        // Set the flag we use to indicate that a packet read is pending.  This
+        // will be cleared if the packet is read.  If the client does not read
+        // the packet in the context of the USB_EVENT_RX_AVAILABLE callback,
+        // the event will be signaled later during tick processing.
+        //
+        SetDeferredOpFlag(&psInst->ui16DeferredOpFlags, HID_DO_PACKET_RX,
+                          true);
+
+        //
+        // How big is the packet we have just been sent?
+        //
+        ui32Size = MAP_USBEndpointDataAvail(psInst->ui32USBBase,
+                                            psInst->ui8OUTEndpoint);
+
+        //
+        // The receive channel is not blocked so let the caller know
+        // that a packet is waiting.  The parameters are set to indicate
+        // that the packet has not been read from the hardware FIFO yet.
+        //
+        psHIDDevice->pfnRxCallback(psHIDDevice->pvRxCBData,
+                                   USB_EVENT_RX_AVAILABLE, ui32Size,
+                                   (void *)0);
+    }
+    else
+    {
+        //
+        // No packet was received.  Some error must have been reported.  Check
+        // and pass this on to the client if necessary.
+        //
+        if(ui32EPStatus & USB_RX_ERROR_FLAGS)
+        {
+            //
+            // This is an error we report to the client so...
+            //
+            psHIDDevice->pfnRxCallback(psHIDDevice->pvRxCBData,
+                                       USB_EVENT_ERROR,
+                                       (ui32EPStatus & USB_RX_ERROR_FLAGS),
+                                       (void *)0);
+        }
+        return(false);
+    }
+
+    return(true);
+}
+
+//*****************************************************************************
+//
+// Receives notifications related to data sent to the host.
+//
+// \param psHIDDevice is the device instance whose endpoint is to be processed.
+// \param ui32Status is the USB interrupt status that caused this function to
+// be called.
+//
+// This function is called from HandleEndpoints for all interrupts originating
+// from the interrupt IN endpoint (in other words, whenever data has been
+// transmitted to the USB host).  We examine the cause of the interrupt and,
+// if due to completion of a transmission, notify the client.
+//
+// \return Returns \b true on success or \b false on failure.
+//
+//*****************************************************************************
+static bool
+ProcessDataToHost(tUSBDHIDDevice *psHIDDevice, uint32_t ui32Status)
+{
+    tHIDInstance *psInst;
+    uint32_t ui32EPStatus;
+
+    //
+    // Get a pointer to our instance data.
+    //
+    psInst = &psHIDDevice->sPrivateData;
+
+    //
+    // Get the endpoint status to see why we were called.
+    //
+    ui32EPStatus = MAP_USBEndpointStatus(psInst->ui32USBBase,
+                                         psInst->ui8INEndpoint);
+
+    //
+    // Clear the status bits.
+    //
+    MAP_USBDevEndpointStatusClear(psInst->ui32USBBase, psInst->ui8INEndpoint,
+                                  ui32EPStatus);
+
+    //
+    // Our last packet was transmitted successfully.  Is there any more data to
+    // send or have we finished sending the whole report?  We know we finished
+    // if the ui16InReportIndex has reached the ui16InReportSize value.
+    //
+    if(psInst->ui16InReportSize == psInst->ui16InReportIndex)
+    {
+        //
+        // We finished sending the last report so are idle once again.
+        //
+        psInst->iHIDTxState = eHIDStateIdle;
+
+        //
+        // Notify the client that the report transmission completed.
+        //
+        psHIDDevice->pfnTxCallback(psHIDDevice->pvTxCBData,
+                                   USB_EVENT_TX_COMPLETE,
+                                   psInst->ui16InReportSize, (void *)0);
+
+        //
+        // Do we have any reports to send as a result of idle timer timeouts?
+        //
+        if(psInst->ui16DeferredOpFlags & (1 << HID_DO_SEND_IDLE_REPORT))
+        {
+            //
+            // Yes - send reports for any timers that expired recently.
+            //
+            ProcessIdleTimers(psHIDDevice, 0);
+        }
+    }
+    else
+    {
+        //
+        // There must be more data or a zero length packet waiting to be sent
+        // so go ahead and do this.
+        //
+        ScheduleReportTransmission(psInst);
+    }
+
+    return(true);
+}
+
+//*****************************************************************************
+//
+// Called by the USB stack for any activity involving one of our endpoints
+// other than EP0.  This function is a fan out that merely directs the call to
+// the correct handler depending upon the endpoint and transaction direction
+// signaled in ui32Status.
+//
+//*****************************************************************************
+static void
+HandleEndpoints(void *pvHIDInstance, uint32_t ui32Status)
+{
+    tUSBDHIDDevice *psHIDInst;
+    tHIDInstance *psInst;
+
+    ASSERT(pvHIDInstance != 0);
+
+    //
+    // Determine if the serial device is in single or composite mode because
+    // the meaning of ui32Index is different in both cases.
+    //
+    psHIDInst = (tUSBDHIDDevice *)pvHIDInstance;
+    psInst = &psHIDInst->sPrivateData;
+
+    //
+    // Handler for the interrupt OUT data endpoint.
+    //
+    if(ui32Status & (0x10000 << USBEPToIndex(psInst->ui8OUTEndpoint)))
+    {
+        //
+        // Data is being sent to us from the host.
+        //
+        ProcessDataFromHost(pvHIDInstance, ui32Status);
+    }
+
+    //
+    // Handler for the interrupt IN data endpoint.
+    //
+    if(ui32Status & (1 << USBEPToIndex(psInst->ui8INEndpoint)))
+    {
+        ProcessDataToHost(pvHIDInstance, ui32Status);
+    }
+}
+
+//*****************************************************************************
+//
+// Called by the USB stack whenever a configuration change occurs.
+//
+//*****************************************************************************
+static void
+HandleConfigChange(void *pvHIDInstance, uint32_t ui32Info)
+{
+    tHIDInstance *psInst;
+    tUSBDHIDDevice *psHIDDevice;
+
+    ASSERT(pvHIDInstance != 0);
+
+    //
+    // Create the instance pointer.
+    //
+    psHIDDevice = pvHIDInstance;
+
+    //
+    // Get a pointer to our instance data.
+    //
+    psInst = &psHIDDevice->sPrivateData;
+
+    //
+    // Set all our endpoints to idle state.
+    //
+    psInst->iHIDRxState = eHIDStateIdle;
+    psInst->iHIDTxState = eHIDStateIdle;
+
+    //
+    // If we are not currently connected let the client know we are open for
+    // business.
+    //
+    if(!psInst->bConnected)
+    {
+        //
+        // Pass the connected event to the client.
+        //
+        psHIDDevice->pfnRxCallback(psHIDDevice->pvRxCBData,
+                                   USB_EVENT_CONNECTED, 0, (void *)0);
+    }
+
+    //
+    // Clear the idle timers for each input report.
+    //
+    ClearIdleTimers(psHIDDevice);
+
+    //
+    // Remember that we are connected.
+    //
+    psInst->bConnected = true;
+}
+
+//*****************************************************************************
+//
+// Device instance specific handler.
+//
+//*****************************************************************************
+static void
+HandleDevice(void *pvHIDInstance, uint32_t ui32Request, void *pvRequestData)
+{
+    tHIDInstance *psInst;
+    uint8_t *pui8Data;
+    tUSBDHIDDevice *psHIDDevice;
+
+    psHIDDevice = (tUSBDHIDDevice *)pvHIDInstance;
+
+    //
+    // Create the serial instance data.
+    //
+    psInst = &((tUSBDHIDDevice *)pvHIDInstance)->sPrivateData;
+
+    //
+    // Create the int8_t array used by the events supported by the USB CDC
+    // serial class.
+    //
+    pui8Data = (uint8_t *)pvRequestData;
+
+    switch(ui32Request)
+    {
+        //
+        // This was an interface change event.
+        //
+        case USB_EVENT_COMP_IFACE_CHANGE:
+        {
+            psInst->ui8Interface = pui8Data[1];
+            break;
+        }
+
+        //
+        // This was an endpoint change event.
+        //
+        case USB_EVENT_COMP_EP_CHANGE:
+        {
+            //
+            // Determine if this is an IN or OUT endpoint that has changed.
+            //
+            if(pui8Data[0] & USB_EP_DESC_IN)
+            {
+                psInst->ui8INEndpoint = IndexToUSBEP((pui8Data[1] & 0x7f));
+            }
+            else
+            {
+                //
+                // Extract the new endpoint number.
+                //
+                psInst->ui8OUTEndpoint = IndexToUSBEP(pui8Data[1] & 0x7f);
+            }
+            break;
+        }
+        case USB_EVENT_LPM_RESUME:
+        {
+            if(psHIDDevice->pfnRxCallback)
+            {
+                //
+                // Pass the LPM resume event to the client.
+                //
+                psHIDDevice->pfnRxCallback(psHIDDevice->pvRxCBData,
+                                           USB_EVENT_LPM_RESUME, 0, (void *)0);
+            }
+            break;
+        }
+        case USB_EVENT_LPM_SLEEP:
+        {
+            if(psHIDDevice->pfnRxCallback)
+            {
+            //
+            // Pass the LPM sleep event to the client.
+            //
+            psHIDDevice->pfnRxCallback(psHIDDevice->pvRxCBData,
+                                       USB_EVENT_LPM_SLEEP, 0, (void *)0);
+            }
+            break;
+        }
+        case USB_EVENT_LPM_ERROR:
+        {
+            if(psHIDDevice->pfnRxCallback)
+            {
+            //
+            // Pass the LPM error event to the client.
+            //
+            psHIDDevice->pfnRxCallback(psHIDDevice->pvRxCBData,
+                                       USB_EVENT_LPM_ERROR, 0, (void *)0);
+            }
+            break;
+        }
+        default:
+        {
+            break;
+        }
+    }
+}
+
+//*****************************************************************************
+//
+// This function is called by the USB device stack whenever the device is
+// disconnected from the host.
+//
+//*****************************************************************************
+static void
+HandleDisconnect(void *pvHIDInstance)
+{
+    tUSBDHIDDevice *psHIDDevice;
+
+    ASSERT(pvHIDInstance != 0);
+
+    //
+    // Create the instance pointer.
+    //
+    psHIDDevice = (tUSBDHIDDevice *)pvHIDInstance;
+
+    //
+    // If we are not currently connected so let the client know we are open
+    // for business.
+    //
+    if(psHIDDevice->sPrivateData.bConnected)
+    {
+        //
+        // Pass the disconnected event to the client.
+        //
+        psHIDDevice->pfnRxCallback(psHIDDevice->pvRxCBData,
+                                   USB_EVENT_DISCONNECTED, 0, (void *)0);
+    }
+
+    //
+    // Remember that we are no longer connected.
+    //
+    psHIDDevice->sPrivateData.bConnected = false;
+}
+
+//*****************************************************************************
+//
+// This function is called by the USB device stack whenever a request for a
+// non-standard descriptor is received.
+//
+// \param pvHIDInstance is the instance data for this request.
+// \param psUSBRequest points to the request received.
+//
+// This call parses the provided request structure and determines which
+// descriptor is being requested.  Assuming the descriptor can be found, it is
+// scheduled for transmission via endpoint zero.  If the descriptor cannot be
+// found, the endpoint is stalled to indicate an error to the host.
+//
+//*****************************************************************************
+static void
+HandleGetDescriptor(void *pvHIDInstance, tUSBRequest *psUSBRequest)
+{
+    uint32_t ui32Size, ui32Desc;
+    const tUSBDHIDDevice *psHIDDevice;
+
+    ASSERT(pvHIDInstance != 0);
+
+    //
+    // Which device are we dealing with?
+    //
+    psHIDDevice = pvHIDInstance;
+
+    //
+    // Which type of class descriptor are we being asked for?
+    //
+    switch(psUSBRequest->wValue >> 8)
+    {
+        //
+        // This is a request for a HID report or physical descriptor.
+        //
+        case USB_HID_DTYPE_REPORT:
+        case USB_HID_DTYPE_PHYSICAL:
+        {
+            //
+            // Find the index to the descriptor that is being queried.
+            //
+            ui32Size = 0;
+            ui32Desc = FindHIDDescriptor(psHIDDevice,
+                                         psUSBRequest->wValue >> 8,
+                                         psUSBRequest->wValue & 0xFF,
+                                         &ui32Size);
+
+            //
+            // Did we find the descriptor?
+            //
+            if(ui32Desc == HID_NOT_FOUND)
+            {
+                //
+                // No - stall the endpoint and return.
+                //
+                USBDCDStallEP0(0);
+                return;
+            }
+
+            //
+            // If there is more data to send than the host requested then just
+            // send the requested amount of data.
+            //
+            if(ui32Size > psUSBRequest->wLength)
+            {
+                ui32Size = psUSBRequest->wLength;
+            }
+
+            //
+            // Send the data via endpoint 0.
+            //
+            USBDCDSendDataEP0(0,
+                (uint8_t *)psHIDDevice->ppui8ClassDescriptors[ui32Desc],
+                ui32Size);
+
+            break;
+        }
+
+        //
+        // This is a request for the HID descriptor (as found in the
+        // configuration descriptor following the relevant interface).
+        //
+        case USB_HID_DTYPE_HID:
+        {
+            //
+            // How big is the HID descriptor?
+            //
+            ui32Size = (uint32_t)psHIDDevice->psHIDDescriptor->bLength;
+
+            //
+            // If there is more data to send than the host requested then just
+            // send the requested amount of data.
+            //
+            if(ui32Size > psUSBRequest->wLength)
+            {
+                ui32Size = psUSBRequest->wLength;
+            }
+
+            //
+            // Send the data via endpoint 0.
+            //
+            USBDCDSendDataEP0(0, (uint8_t *)psHIDDevice->psHIDDescriptor,
+                              ui32Size);
+            break;
+        }
+
+        //
+        // This was an unknown request so stall.
+        //
+        default:
+        {
+            USBDCDStallEP0(0);
+            break;
+        }
+    }
+}
+
+//*****************************************************************************
+//
+// This function is called by the USB device stack whenever a non-standard
+// request is received.
+//
+// \param pvHIDInstance is the instance data for this HID device.
+// \param psUSBRequest points to the request received.
+//
+// This call parses the provided request structure.  Assuming the request is
+// understood, it is handled and any required response generated.  If the
+// request cannot be handled by this device class, endpoint zero is stalled to
+// indicate an error to the host.
+//
+//*****************************************************************************
+static void
+HandleRequest(void *pvHIDInstance, tUSBRequest *psUSBRequest)
+{
+    tHIDInstance *psInst;
+    uint8_t ui8Protocol;
+    uint32_t ui32Size, ui32Timeout;
+    uint8_t *pui8Report;
+    tUSBDHIDDevice *psHIDDevice;
+
+    ASSERT(pvHIDInstance != 0);
+
+    //
+    // Which device are we dealing with?
+    //
+    psHIDDevice = pvHIDInstance;
+
+    //
+    // Get a pointer to our instance data.
+    //
+    psInst = &psHIDDevice->sPrivateData;
+
+    //
+    // Make sure the request was for this interface.
+    //
+    if(psUSBRequest->wIndex != psInst->ui8Interface)
+    {
+        return;
+    }
+
+    //
+    // Determine the type of request.
+    //
+    switch(psUSBRequest->bRequest)
+    {
+        //
+        // A Set Report request is received from the host when it sends an
+        // Output report via endpoint 0.
+        //
+        case USBREQ_SET_REPORT:
+        {
+            //
+            // Ask the application for a buffer large enough to hold the
+            // report we are to be sent.
+            //
+            psInst->ui16OutReportSize = psUSBRequest->wLength;
+            psInst->pui8OutReportData =
+                (uint8_t *)psHIDDevice->pfnRxCallback(
+                               psHIDDevice->pvRxCBData,
+                               USBD_HID_EVENT_GET_REPORT_BUFFER,
+                               psUSBRequest->wValue,
+                               (void *)(uint32_t)(psUSBRequest->wLength));
+
+            //
+            // Did the client provide us a buffer?
+            //
+            if(!psInst->pui8OutReportData)
+            {
+                //
+                // The application could not provide us a buffer so stall the
+                // request.
+                //
+                USBDCDStallEP0(0);
+            }
+            else
+            {
+                //
+                // The client provided us a buffer to read the report into
+                // so request the data from the host.
+                //
+
+                //
+                // Set the state to indicate we are waiting for data.
+                //
+                psInst->iHIDRxState = eHIDStateWaitData;
+
+                //
+                // Now read the payload of the request.  We handle the actual
+                // operation in the data callback once this data is received.
+                //
+                USBDCDRequestDataEP0(0, psInst->pui8OutReportData,
+                                     (uint32_t)psUSBRequest->wLength);
+
+                //
+                // Need to ACK the data on end point 0 in this case.  Do this
+                // after requesting the data to prevent race conditions that
+                // occur if you acknowledge before setting up to receive the
+                // request data.
+                //
+                MAP_USBDevEndpointDataAck(psInst->ui32USBBase, USB_EP_0, false);
+            }
+
+            break;
+        }
+
+        //
+        // A Get Report request is used by the host to poll a device for its
+        // current state.
+        //
+        case USBREQ_GET_REPORT:
+        {
+            //
+            // Get the latest report from the application.
+            //
+            ui32Size = psHIDDevice->pfnRxCallback(psHIDDevice->pvRxCBData,
+                                            USBD_HID_EVENT_GET_REPORT,
+                                            psUSBRequest->wValue, &pui8Report);
+
+            //
+            // Need to ACK the data on end point 0 in this case.
+            //
+            MAP_USBDevEndpointDataAck(psInst->ui32USBBase, USB_EP_0, true);
+
+            //
+            // ..then send back the requested report.
+            //
+            psInst->bGetRequestPending = true;
+            USBDCDSendDataEP0(0, pui8Report, ui32Size);
+
+            break;
+        }
+
+        //
+        // A set IDLE request has been made.  This indicates to us how often a
+        // given report should be sent back to the host in the absence of any
+        // change in state of the device.
+        //
+        case USBREQ_SET_IDLE:
+        {
+            //
+            // Set the idle timeout for the requested report(s).
+            //
+            SetIdleTimeout(psHIDDevice, psUSBRequest->wValue & 0xFF,
+                           (psUSBRequest->wValue >> 8) & 0xFF);
+
+            //
+            // Need to ACK the data on end point 0 in this case.
+            //
+            MAP_USBDevEndpointDataAck(psInst->ui32USBBase, USB_EP_0, true);
+
+            break;
+        }
+
+        //
+        // A get IDLE request has been made.  This request queries the current
+        // idle timeout for a given report.
+        //
+        case USBREQ_GET_IDLE:
+        {
+            //
+            // Determine the timeout for the requested report.
+            //
+            ui32Timeout = GetIdleTimeout(psHIDDevice, psUSBRequest->wValue);
+
+            if(ui32Timeout != HID_NOT_FOUND)
+            {
+                //
+                // Need to ACK the data on end point 0 in this case.
+                //
+                MAP_USBDevEndpointDataAck(psInst->ui32USBBase, USB_EP_0, true);
+
+                //
+                // Send our response to the host.
+                //
+                USBDCDSendDataEP0(0, (uint8_t *)&ui32Timeout, 1);
+            }
+            else
+            {
+                //
+                // The report ID was not found so stall the endpoint.
+                //
+                USBDCDStallEP0(0);
+            }
+            break;
+        }
+
+        //
+        // Set either boot or report protocol for reports sent from the device.
+        // This is only supported by devices in the boot subclass.
+        //
+        case USBREQ_SET_PROTOCOL:
+        {
+            if(psHIDDevice->ui8Subclass == USB_HID_SCLASS_BOOT)
+            {
+                //
+                // We need to ACK the data on end point 0 in this case.
+                //
+                MAP_USBDevEndpointDataAck(psInst->ui32USBBase, USB_EP_0, true);
+
+                //
+                // We are a boot subclass device so pass this on to the
+                // application.
+                //
+                psHIDDevice->pfnRxCallback(psHIDDevice->pvRxCBData,
+                                           USBD_HID_EVENT_SET_PROTOCOL,
+                                           psUSBRequest->wValue,
+                                           (void *)0);
+            }
+            else
+            {
+                //
+                // This is not a boot subclass device so stall the endpoint to
+                // show that we don't support this request.
+                //
+                USBDCDStallEP0(0);
+            }
+            break;
+        }
+
+        //
+        // Inform the host of the protocol, boot or report, that is currently
+        // in use.  This is only supported by devices in the boot subclass.
+        //
+        case USBREQ_GET_PROTOCOL:
+        {
+            if(psHIDDevice->ui8Subclass == USB_HID_SCLASS_BOOT)
+            {
+                //
+                // We need to ACK the data on end point 0 in this case.
+                //
+                MAP_USBDevEndpointDataAck(psInst->ui32USBBase, USB_EP_0, true);
+
+                //
+                // We are a boot subclass device so pass this on to the
+                // application callback to get the answer.
+                //
+                ui8Protocol = (uint8_t)psHIDDevice->pfnRxCallback(
+                    psHIDDevice->pvRxCBData, USBD_HID_EVENT_GET_PROTOCOL, 0,
+                    (void *)0);
+
+                //
+                // Send our response to the host.
+                //
+                USBDCDSendDataEP0(0, (uint8_t *)&ui8Protocol, 1);
+            }
+            else
+            {
+                //
+                // This is not a boot subclass device so stall the endpoint to
+                // show that we don't support this request.
+                //
+                USBDCDStallEP0(0);
+            }
+            break;
+        }
+
+        //
+        // This request was not recognized so stall.
+        //
+        default:
+        {
+            USBDCDStallEP0(0);
+            break;
+        }
+    }
+}
+
+//*****************************************************************************
+//
+// This function is called by the USB device stack whenever the data requested
+// on endpoint zero is received.
+//
+//*****************************************************************************
+static void
+HandleEP0DataReceived(void *pvHIDInstance, uint32_t ui32DataSize)
+{
+    tHIDInstance *psInst;
+    tUSBDHIDDevice *psHIDDevice;
+
+    ASSERT(pvHIDInstance != 0);
+
+    //
+    // Which device are we dealing with?
+    //
+    psHIDDevice = pvHIDInstance;
+
+    //
+    // If we were not passed any data, just return.
+    //
+    if(ui32DataSize == 0)
+    {
+        return;
+    }
+
+    //
+    // Get our instance data pointer.
+    //
+    psInst = &psHIDDevice->sPrivateData;
+
+    //
+    // Make sure we are actually expecting something.
+    //
+    if(psInst->iHIDRxState != eHIDStateWaitData)
+    {
+        return;
+    }
+
+    //
+    // Change the endpoint state back to idle now that we have been passed
+    // the data we were waiting for.
+    //
+    psInst->iHIDRxState = eHIDStateIdle;
+
+    //
+    // The only things we ever request via endpoint zero are reports sent to
+    // us via a Set_Report request.  Pass the newly received report on to
+    // the client.
+    //
+    psHIDDevice->pfnRxCallback(psHIDDevice->pvRxCBData,
+                               USBD_HID_EVENT_SET_REPORT,
+                               psInst->ui16OutReportSize,
+                               psInst->pui8OutReportData);
+}
+
+//*****************************************************************************
+//
+// This function is called by the USB device stack whenever the data sent on
+// endpoint zero is received and acknowledged by the host.
+//
+//*****************************************************************************
+static void
+HandleEP0DataSent(void *pvHIDInstance, uint32_t ui32Info)
+{
+    tHIDInstance *psInst;
+    tUSBDHIDDevice *psHIDDevice;
+
+    ASSERT(pvHIDInstance != 0);
+
+    //
+    // Which device are we dealing with?
+    //
+    psHIDDevice = pvHIDInstance;
+
+    //
+    // Get our instance data pointer.
+    //
+    psInst = &psHIDDevice->sPrivateData;
+
+    //
+    // If we just sent a report in response to a Get_Report request, send an
+    // event to the application telling it that the transmission completed.
+    //
+    if(psInst->bGetRequestPending)
+    {
+        //
+        // Clear the flag now that we are sending the application callback.
+        //
+        psInst->bGetRequestPending = false;
+
+        psHIDDevice->pfnRxCallback(psHIDDevice->pvRxCBData,
+                                   USBD_HID_EVENT_REPORT_SENT, 0, (void *)0);
+    }
+
+    return;
+}
+
+//*****************************************************************************
+//
+// This function is called by the USB device stack whenever the device is
+// reset.  If we are currently connected, send a disconnect event at this
+// point.
+//
+//*****************************************************************************
+static void
+HandleReset(void *pvHIDInstance)
+{
+    ASSERT(pvHIDInstance != 0);
+
+    //
+    // Merely call the disconnect handler.  This causes a disconnect message to
+    // be sent to the client if we think we are currently connected.
+    //
+    HandleDisconnect(pvHIDInstance);
+}
+
+//*****************************************************************************
+//
+// This function is called by the USB device stack whenever the bus is put into
+// suspend state.
+//
+//*****************************************************************************
+static void
+HandleSuspend(void *pvHIDInstance)
+{
+    const tUSBDHIDDevice *psHIDDevice;
+
+    ASSERT(pvHIDInstance != 0);
+
+    //
+    // Create the instance pointer.
+    //
+    psHIDDevice = (const tUSBDHIDDevice *)pvHIDInstance;
+
+    //
+    // Pass the event on to the client.
+    //
+    psHIDDevice->pfnRxCallback(psHIDDevice->pvRxCBData, USB_EVENT_SUSPEND, 0,
+                               (void *)0);
+}
+
+//*****************************************************************************
+//
+// This function is called by the USB device stack whenever the bus is taken
+// out of suspend state.
+//
+//*****************************************************************************
+static void
+HandleResume(void *pvHIDInstance)
+{
+    const tUSBDHIDDevice *psHIDDevice;
+
+    ASSERT(pvHIDInstance != 0);
+
+    //
+    // Create the instance pointer.
+    //
+    psHIDDevice = (const tUSBDHIDDevice *)pvHIDInstance;
+
+    //
+    // Pass the event on to the client.
+    //
+    psHIDDevice->pfnRxCallback(psHIDDevice->pvRxCBData, USB_EVENT_RESUME, 0,
+                               (void *)0);
+}
+
+//*****************************************************************************
+//
+// This function is called periodically and provides us with a time reference
+// and method of implementing delayed or time-dependent operations.
+//
+// \param pvHIDInstance is the instance data for this request.
+// \param ui32TimemS is the elapsed time in milliseconds since the last call
+// to this function.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+HIDTickHandler(void *pvHIDInstance, uint32_t ui32TimemS)
+{
+    tHIDInstance *psInst;
+    uint32_t ui32Size;
+    tUSBDHIDDevice *psHIDDevice;
+
+    ASSERT(pvHIDInstance != 0);
+
+    //
+    // Create the instance pointer.
+    //
+    psHIDDevice = (tUSBDHIDDevice *)pvHIDInstance;
+
+    //
+    // Get our instance data pointer.
+    //
+    psInst = &psHIDDevice->sPrivateData;
+
+    //
+    // If we are connected, process our idle timers.
+    //
+    if(psInst->bConnected)
+    {
+        ProcessIdleTimers(psHIDDevice, ui32TimemS);
+    }
+
+    //
+    // Do we have a deferred receive waiting
+    //
+    if(psInst->ui16DeferredOpFlags & (1 << HID_DO_PACKET_RX))
+    {
+        //
+        // Yes - how big is the waiting packet?
+        //
+        ui32Size = MAP_USBEndpointDataAvail(USB0_BASE, psInst->ui8OUTEndpoint);
+
+        //
+        // Tell the client that there is a packet waiting for it.
+        //
+        psHIDDevice->pfnRxCallback(psHIDDevice->pvRxCBData,
+                                   USB_EVENT_RX_AVAILABLE, ui32Size,
+                                   (void *)0);
+    }
+
+    return;
+}
+
+//*****************************************************************************
+//
+//! Initializes HID device operation for a given USB controller.
+//!
+//! \param ui32Index is the index of the USB controller which is to be
+//! initialized for HID device operation.
+//! \param psHIDDevice points to a structure containing parameters customizing
+//! the operation of the HID device.
+//!
+//! An application wishing to offer a USB HID interface to a host system
+//! must call this function to initialize the USB controller and attach the
+//! device to the USB bus.  This function performs all required USB
+//! initialization.
+//!
+//! On successful completion, this function will return the \e psHIDDevice
+//! pointer passed to it.  This must be passed on all future calls from the
+//! application to the HID device class driver.
+//!
+//! The USB HID device class API offers the application a report-based transmit
+//! interface for Input reports.  Output reports may be received via the
+//! control endpoint or via a dedicated Interrupt OUT endpoint.  If using the
+//! dedicated endpoint, report data is delivered to the application packet-by-
+//! packet.  If the application uses reports longer than \b USBDHID_MAX_PACKET
+//! bytes and would rather receive full reports, it may use a USB buffer above
+//! the receive channel to allow full reports to be read.
+//!
+//! Transmit Operation:
+//!
+//! Calls to USBDHIDReportWrite() pass complete reports to the driver for
+//! transmission.  These will be transmitted to the host using as many USB
+//! packets as are necessary to complete the transmission.
+//!
+//! Once a full Input report has been acknowledged by the USB host, a
+//! \b USB_EVENT_TX_COMPLETE event is sent to the application transmit callback
+//! to inform it that another report may be transmitted.
+//!
+//! Receive Operation (when using a dedicated interrupt OUT endpoint):
+//!
+//! An incoming USB data packet will result in a call to the application
+//! callback with event \b USB_EVENT_RX_AVAILABLE.  The application must then
+//! call USBDHIDPacketRead(), passing a buffer capable of holding the received
+//! packet.  The size of the packet may be determined by calling function
+//! USBDHIDRxPacketAvailable() prior to reading the packet.
+//!
+//! Receive Operation (when not using a dedicated OUT endpoint):
+//!
+//! If no dedicated OUT endpoint is used, Output and Feature reports are sent
+//! from the host using the control endpoint, endpoint zero.  When such a
+//! report is received, \b USBD_HID_EVENT_GET_REPORT_BUFFER is sent to the
+//! application which must respond with a buffer large enough to hold the
+//! report.  The device class driver will then copy the received report into
+//! the supplied buffer before sending \b USBD_HID_EVENT_SET_REPORT to indicate
+//! that the report is now available.
+//!
+//! \note The application must not make any calls to the low level USB device
+//! interface if interacting with USB via the USB HID device class API.  Doing
+//! so will cause unpredictable (though almost certainly unpleasant) behavior.
+//!
+//! \return Returns NULL on failure or the \e psHIDDevice pointer on success.
+//
+//*****************************************************************************
+void *
+USBDHIDInit(uint32_t ui32Index, tUSBDHIDDevice *psHIDDevice)
+{
+    tDeviceDescriptor *pi16DevDesc;
+
+    //
+    // Check parameter validity.
+    //
+    ASSERT(ui32Index == 0);
+    ASSERT(psHIDDevice);
+    ASSERT(psHIDDevice->ppui8StringDescriptors);
+    ASSERT(psHIDDevice->pfnRxCallback);
+    ASSERT(psHIDDevice->pfnTxCallback);
+    ASSERT(psHIDDevice->ppui8ClassDescriptors);
+    ASSERT(psHIDDevice->psHIDDescriptor);
+    ASSERT((psHIDDevice->ui8NumInputReports == 0) || psHIDDevice->psReportIdle);
+
+    USBDHIDCompositeInit(ui32Index, psHIDDevice, 0);
+
+    //
+    // Fix up the device descriptor with the client-supplied values.
+    //
+    pi16DevDesc = (tDeviceDescriptor *)psHIDDevice->sPrivateData.sDevInfo.pui8DeviceDescriptor;
+    pi16DevDesc->idVendor = psHIDDevice->ui16VID;
+    pi16DevDesc->idProduct = psHIDDevice->ui16PID;
+
+    //
+    // All is well so now pass the descriptors to the lower layer and put
+    // the HID device on the bus.
+    //
+    USBDCDInit(ui32Index, &psHIDDevice->sPrivateData.sDevInfo,
+               (void *)psHIDDevice);
+
+    //
+    // Return the pointer to the instance indicating that everything went well.
+    //
+    return((void *)psHIDDevice);
+}
+
+//*****************************************************************************
+//
+//! Initializes HID device operation for a given USB controller.
+//!
+//! \param ui32Index is the index of the USB controller which is to be
+//! initialized for HID device operation.
+//! \param psHIDDevice points to a structure containing parameters customizing
+//! the operation of the HID device.
+//! \param psCompEntry is the composite device entry to initialize when
+//! creating a composite device.
+//!
+//! USB HID device classes call this function to initialize the lower level
+//! HID interface in the USB controller.  If this HID device device is part of
+//! a composite device, then the \e psCompEntry should point to the composite
+//! device entry to initialize.  This is part of the array that is passed to
+//! the USBDCompositeInit() function.
+//!
+//! \return Returns zero on failure or a non-zero instance value that should be
+//! used with the remaining USB HID APIs.
+//
+//*****************************************************************************
+void *
+USBDHIDCompositeInit(uint32_t ui32Index, tUSBDHIDDevice *psHIDDevice,
+                     tCompositeEntry *psCompEntry)
+{
+    tHIDInstance *psInst;
+    tEndpointDescriptor *psEndpoint;
+
+    //
+    // Check parameter validity.
+    //
+    ASSERT(ui32Index == 0);
+    ASSERT(psHIDDevice);
+    ASSERT(psHIDDevice->ppsConfigDescriptor);
+    ASSERT(psHIDDevice->ppui8StringDescriptors);
+    ASSERT(psHIDDevice->pfnRxCallback);
+    ASSERT(psHIDDevice->pfnTxCallback);
+    ASSERT(psHIDDevice->ppui8ClassDescriptors);
+    ASSERT(psHIDDevice->psHIDDescriptor);
+    ASSERT((psHIDDevice->ui8NumInputReports == 0) || psHIDDevice->psReportIdle);
+
+    //
+    // Initialize the workspace in the passed instance structure.
+    //
+    psInst = &psHIDDevice->sPrivateData;
+
+    //
+    // Initialize the device information structure.
+    //
+    psInst->sDevInfo.psCallbacks = &g_sHIDHandlers;
+    psInst->sDevInfo.pui8DeviceDescriptor = g_pui8HIDDeviceDescriptor;
+    psInst->sDevInfo.ppsConfigDescriptors = psHIDDevice->ppsConfigDescriptor;
+    psInst->sDevInfo.ppui8StringDescriptors =
+                                        psHIDDevice->ppui8StringDescriptors;
+    psInst->sDevInfo.ui32NumStringDescriptors =
+                                        psHIDDevice->ui32NumStringDescriptors;
+
+    //
+    // Default the endpoints zero before looking for them in the configuration
+    // descriptor.
+    //
+    psInst->ui8Interface = 0;
+    psInst->ui8INEndpoint = 0;
+    psInst->ui8OUTEndpoint = 0;
+
+    //
+    // Get the first endpoint descriptor on interface 0.
+    //
+    psEndpoint =
+        USBDCDConfigGetInterfaceEndpoint(psHIDDevice->ppsConfigDescriptor[0],
+                                         psInst->ui8Interface, 0, 0);
+
+    if(psEndpoint)
+    {
+        if(psEndpoint->bEndpointAddress & 0x80)
+        {
+            psInst->ui8INEndpoint = IndexToUSBEP(psEndpoint->bEndpointAddress);
+        }
+        else
+        {
+            psInst->ui8OUTEndpoint = IndexToUSBEP(psEndpoint->bEndpointAddress);
+        }
+    }
+
+    //
+    // Get the second endpoint descriptor on interface 0.
+    //
+    psEndpoint =
+        USBDCDConfigGetInterfaceEndpoint(psHIDDevice->ppsConfigDescriptor[0],
+                                         psInst->ui8Interface, 0, 1);
+    if(psEndpoint)
+    {
+        if(psEndpoint->bEndpointAddress & 0x80)
+        {
+            psInst->ui8INEndpoint = IndexToUSBEP(psEndpoint->bEndpointAddress);
+        }
+        else
+        {
+            psInst->ui8OUTEndpoint = IndexToUSBEP(psEndpoint->bEndpointAddress);
+        }
+    }
+
+    //
+    // Must have at least an IN endpoint.
+    //
+    if(psInst->ui8INEndpoint == 0)
+    {
+        return((void *)0);
+    }
+
+    //
+    // Initialize the composite entry that is used by the composite device
+    // class.
+    //
+    if(psCompEntry != 0)
+    {
+        psCompEntry->psDevInfo = &psInst->sDevInfo;
+        psCompEntry->pvInstance = (void *)psHIDDevice;
+    }
+
+    psInst->ui32USBBase = USB0_BASE;
+    psInst->iHIDRxState = eHIDStateUnconfigured;
+    psInst->iHIDTxState = eHIDStateUnconfigured;
+    psInst->ui16DeferredOpFlags = 0;
+    psInst->bConnected = false;
+    psInst->bGetRequestPending = false;
+    psInst->bSendInProgress = false;
+    psInst->ui16InReportIndex = 0;
+    psInst->ui16InReportSize = 0;
+    psInst->pui8InReportData = (uint8_t *)0;
+    psInst->ui16OutReportSize = 0;
+    psInst->pui8OutReportData = (uint8_t *)0;
+
+    //
+    // Initialize the device info structure for the HID device.
+    //
+    USBDCDDeviceInfoInit(0, &psInst->sDevInfo);
+
+    //
+    // Initialize the input report idle timers if any input reports exist.
+    //
+    ClearIdleTimers(psHIDDevice);
+
+    //
+    // Initialize the USB tick module, this will prevent it from being
+    // initialized later in the call to USBDCDInit();
+    //
+    InternalUSBTickInit();
+
+    //
+    // Register our tick handler (this must be done after USBDCDInit).
+    //
+    InternalUSBRegisterTickHandler(HIDTickHandler, (void *)psHIDDevice);
+
+    //
+    // Return the pointer to the instance indicating that everything went well.
+    //
+    return((void *)psHIDDevice);
+}
+
+//*****************************************************************************
+//
+//! Shuts down the HID device.
+//!
+//! \param pvHIDInstance is the pointer to the device instance structure as
+//! returned by USBDHIDInit().
+//!
+//! This function terminates HID operation for the instance supplied and
+//! removes the device from the USB bus.  This function should not be called
+//! if the HID device is part of a composite device and instead the
+//! USBDCompositeTerm() function should be called for the full composite
+//! device.
+//!
+//! Following this call, the \e pvHIDInstance instance should not me used in
+//! any other calls.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBDHIDTerm(void *pvHIDInstance)
+{
+    tHIDInstance *psInst;
+
+    ASSERT(pvHIDInstance);
+
+    //
+    // Get a pointer to our instance data.
+    //
+    psInst = &((tUSBDHIDDevice *)pvHIDInstance)->sPrivateData;
+
+    //
+    // Terminate the requested instance.
+    //
+    USBDCDTerm(USBBaseToIndex(psInst->ui32USBBase));
+
+    psInst->ui32USBBase = 0;
+}
+
+//*****************************************************************************
+//
+//! Sets the client-specific pointer parameter for the receive channel
+//! callback.
+//!
+//! \param pvHIDInstance is the pointer to the device instance structure as
+//! returned by USBDHIDInit().
+//! \param pvCBData is the pointer that client wishes to be provided on each
+//! event sent to the receive channel callback function.
+//!
+//! The client uses this function to change the callback pointer passed in
+//! the first parameter on all callbacks to the \e pfnRxCallback function
+//! passed on USBDHIDInit().
+//!
+//! If a client wants to make runtime changes in the callback pointer, it must
+//! ensure that the pvHIDInstance structure passed to USBDHIDInit() resides in
+//! RAM.  If this structure is in flash, callback data changes will not be
+//! possible.
+//!
+//! \return Returns the previous callback pointer that was being used for
+//! this instance's receive callback.
+//
+//*****************************************************************************
+void *
+USBDHIDSetRxCBData(void *pvHIDInstance, void *pvCBData)
+{
+    void *pvOldValue;
+
+    ASSERT(pvHIDInstance);
+
+    //
+    // Set the callback data for the receive channel after remembering the
+    // previous value.
+    //
+    pvOldValue = ((tUSBDHIDDevice *)pvHIDInstance)->pvRxCBData;
+    ((tUSBDHIDDevice *)pvHIDInstance)->pvRxCBData = pvCBData;
+
+    //
+    // Return the previous callback data value.
+    //
+    return(pvOldValue);
+}
+
+//*****************************************************************************
+//
+//! Sets the client-specific data pointer for the transmit callback.
+//!
+//! \param pvHIDInstance is the pointer to the device instance structure as
+//! returned by USBDHIDInit().
+//! \param pvCBData is the pointer that client wishes to be provided on each
+//! event sent to the transmit channel callback function.
+//!
+//! The client uses this function to change the callback data pointer passed in
+//! the first parameter on all callbacks to the \e pfnTxCallback function
+//! passed on USBDHIDInit().
+//!
+//! If a client wants to make runtime changes in the callback data, it must
+//! ensure that the pvHIDInstance structure passed to USBDHIDInit() resides in
+//! RAM.  If this structure is in flash, callback data changes will not be
+//! possible.
+//!
+//! \return Returns the previous callback data pointer that was being used for
+//! this instance's transmit callback.
+//
+//*****************************************************************************
+void *
+USBDHIDSetTxCBData(void *pvHIDInstance, void *pvCBData)
+{
+    void *pvOldValue;
+
+    ASSERT(pvHIDInstance);
+
+    //
+    // Set the callback data for the transmit channel after remembering the
+    // previous value.
+    //
+    pvOldValue = ((tUSBDHIDDevice *)pvHIDInstance)->pvTxCBData;
+    ((tUSBDHIDDevice *)pvHIDInstance)->pvTxCBData = pvCBData;
+
+    //
+    // Return the previous callback data value.
+    //
+    return(pvOldValue);
+}
+
+//*****************************************************************************
+//
+//! Transmits a HID device report to the USB host via the HID interrupt IN
+//! endpoint.
+//!
+//! \param pvHIDInstance is the pointer to the device instance structure as
+//! returned by USBDHIDInit().
+//! \param pi8Data points to the first byte of data which is to be transmitted.
+//! \param ui32Length is the number of bytes of data to transmit.
+//! \param bLast is ignored in this implementation.  This parameter is required
+//! to ensure compatibility with other device class drivers and USB buffers.
+//!
+//! This function schedules the supplied data for transmission to the USB
+//! host in a single USB transaction using as many packets as it takes to send
+//! all the data in the report.  If no transmission is currently ongoing,
+//! the first packet of data is immediately copied to the relevant USB endpoint
+//! FIFO for transmission.  Whenever all the report data has been acknowledged
+//! by the host, a \b USB_EVENT_TX_COMPLETE event will be sent to the
+//! application transmit callback indicating that another report can now be
+//! transmitted.
+//!
+//! The caller must ensure that the data pointed to by \e pui8Data remains
+//! accessible and unaltered until the \b USB_EVENT_TX_COMPLETE is received.
+//!
+//! \return Returns the number of bytes actually scheduled for transmission.
+//! At this level, this will either be the number of bytes passed or 0 to
+//! indicate a failure.
+//
+//*****************************************************************************
+uint32_t
+USBDHIDReportWrite(void *pvHIDInstance, uint8_t *pi8Data, uint32_t ui32Length,
+                   bool bLast)
+{
+    tHIDInstance *psInst;
+    int32_t i32Retcode;
+
+    ASSERT(pvHIDInstance);
+
+    //
+    // Get our instance data pointer
+    //
+    psInst = &((tUSBDHIDDevice *)pvHIDInstance)->sPrivateData;
+
+    //
+    // Set a flag indicating that we are currently in the process of sending
+    // a packet.
+    //
+    psInst->bSendInProgress = true;
+
+    //
+    // Can we send the data provided?
+    //
+    if(psInst->iHIDTxState != eHIDStateIdle)
+    {
+        //
+        // We are in the middle of sending another report.  Return 0 to
+        // indicate that we can't send this report until the previous one
+        // finishes.
+        //
+        psInst->bSendInProgress = false;
+        return(0);
+    }
+
+    //
+    // Clear the elapsed time since this report was last sent.
+    //
+    if(ui32Length)
+    {
+        ClearReportTimer(pvHIDInstance, *pi8Data);
+    }
+
+    //
+    // Keep track of the whereabouts of the report so that we can send it in
+    // multiple packets if necessary.
+    //
+    psInst->pui8InReportData = pi8Data;
+    psInst->ui16InReportIndex = 0;
+    psInst->ui16InReportSize = ui32Length;
+
+    //
+    // Schedule transmission of the first packet of the report.
+    //
+    psInst->iHIDTxState = eHIDStateWaitData;
+    i32Retcode = ScheduleReportTransmission(psInst);
+
+    //
+    // Clear the flag we use to indicate that we are in the midst of sending
+    // a packet.
+    //
+    psInst->bSendInProgress = false;
+
+    //
+    // Did an error occur while trying to send the data?
+    //
+    if(i32Retcode != -1)
+    {
+        //
+        // No - tell the caller we sent all the bytes provided.
+        //
+        return(ui32Length);
+    }
+    else
+    {
+        //
+        // Yes - tell the caller we could not send the data.
+        //
+        return(0);
+    }
+}
+
+//*****************************************************************************
+//
+//! Reads a packet of data received from the USB host via the interrupt OUT
+//! endpoint (if in use).
+//!
+//! \param pvHIDInstance is the pointer to the device instance structure as
+//! returned by USBDHIDInit().
+//! \param pi8Data points to a buffer into which the received data will be
+//! written.
+//! \param ui32Length is the size of the buffer pointed to by pi8Data.
+//! \param bLast indicates whether the client will make a further call to
+//! read additional data from the packet.
+//!
+//! This function reads up to \e ui32Length bytes of data received from the USB
+//! host into the supplied application buffer.  If the driver detects that the
+//! entire packet has been read, it is acknowledged to the host.
+//!
+//! The \e bLast parameter is ignored in this implementation since the end of
+//! a packet can be determined without relying upon the client to provide
+//! this information.
+//!
+//! \return Returns the number of bytes of data read.
+//
+//*****************************************************************************
+uint32_t
+USBDHIDPacketRead(void *pvHIDInstance, uint8_t *pi8Data, uint32_t ui32Length,
+                  bool bLast)
+{
+    uint32_t ui32EPStatus, ui32Count, ui32Pkt;
+    tHIDInstance *psInst;
+    int32_t i32Retcode;
+
+    ASSERT(pvHIDInstance);
+
+    //
+    // Get our instance data pointer
+    //
+    psInst = &((tUSBDHIDDevice *)pvHIDInstance)->sPrivateData;
+
+    //
+    // Does the relevant endpoint FIFO have a packet waiting for us?
+    //
+    ui32EPStatus = MAP_USBEndpointStatus(psInst->ui32USBBase,
+                                         psInst->ui8OUTEndpoint);
+    if(ui32EPStatus & USB_DEV_RX_PKT_RDY)
+    {
+        //
+        // How many bytes are available for us to receive?
+        //
+        ui32Pkt = MAP_USBEndpointDataAvail(psInst->ui32USBBase,
+                                           psInst->ui8OUTEndpoint);
+
+        //
+        // Get as much data as we can.
+        //
+        ui32Count = ui32Length;
+        i32Retcode = MAP_USBEndpointDataGet(psInst->ui32USBBase,
+                                            psInst->ui8OUTEndpoint,
+                                            pi8Data, &ui32Count);
+
+        //
+        // Did we read the last of the packet data?
+        //
+        if(ui32Count == ui32Pkt)
+        {
+            //
+            // Clear the endpoint status so that we know no packet is
+            // waiting.
+            //
+            MAP_USBDevEndpointStatusClear(psInst->ui32USBBase,
+                                          psInst->ui8OUTEndpoint,
+                                          ui32EPStatus);
+
+            //
+            // Acknowledge the data, thus freeing the host to send the
+            // next packet.
+            //
+            MAP_USBDevEndpointDataAck(psInst->ui32USBBase,
+                                      psInst->ui8OUTEndpoint, true);
+
+            //
+            // Clear the flag we set to indicate that a packet read is
+            // pending.
+            //
+            SetDeferredOpFlag(&psInst->ui16DeferredOpFlags,
+                              HID_DO_PACKET_RX, false);
+        }
+
+        //
+        // If all went well, tell the caller how many bytes they got.
+        //
+        if(i32Retcode != -1)
+        {
+            return(ui32Count);
+        }
+    }
+
+    //
+    // No packet was available or an error occurred while reading so tell
+    // the caller no bytes were returned.
+    //
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! Returns the number of free bytes in the transmit buffer.
+//!
+//! \param pvHIDInstance is the pointer to the device instance structure as
+//! returned by USBDHIDInit().
+//!
+//! This function indicates to the caller whether or not it is safe to send a
+//! new report using a call to USBDHIDReportWrite().  The value returned will
+//! be the maximum USB packet size (\b USBDHID_MAX_PACKET) if no transmission
+//! is currently outstanding or 0 if a transmission is in progress.  Since the
+//! function USBDHIDReportWrite() can accept full reports longer than a single
+//! USB packet, the caller should be aware that the returned value from this
+//! class driver, unlike others, does not indicate the maximum size of report
+//! that can be written but is merely an indication that another report can be
+//! written.
+//!
+//! \return Returns 0 if an outgoing report is still being transmitted or
+//! \b USBDHID_MAX_PACKET if no transmission is currently in progress.
+//
+//*****************************************************************************
+uint32_t
+USBDHIDTxPacketAvailable(void *pvHIDInstance)
+{
+    tHIDInstance *psInst;
+
+    ASSERT(pvHIDInstance);
+
+    //
+    // Get our instance data pointer.
+    //
+    psInst = &((tUSBDHIDDevice *)pvHIDInstance)->sPrivateData;
+
+    //
+    // Do we have a packet transmission currently ongoing?
+    //
+    if(psInst->iHIDTxState != eHIDStateIdle)
+    {
+        //
+        // We are not ready to receive a new packet so return 0.
+        //
+        return(0);
+    }
+    else
+    {
+        //
+        // We can receive a packet so return the max packet size for the
+        // relevant endpoint.
+        //
+        return(USBDHID_MAX_PACKET);
+    }
+}
+
+//*****************************************************************************
+//
+//! Determines whether a packet is available and, if so, the size of the
+//! buffer required to read it.
+//!
+//! \param pvHIDInstance is the pointer to the device instance structure as
+//! returned by USBDHIDInit().
+//!
+//! This function may be used to determine if a received packet remains to be
+//! read and allows the application to determine the buffer size needed to
+//! read the data.
+//!
+//! \return Returns 0 if no received packet remains unprocessed or the
+//! size of the packet if a packet is waiting to be read.
+//
+//*****************************************************************************
+uint32_t
+USBDHIDRxPacketAvailable(void *pvHIDInstance)
+{
+    uint32_t ui32EPStatus, ui32Size;
+    tHIDInstance *psInst;
+
+    ASSERT(pvHIDInstance);
+
+    //
+    // Get our instance data pointer
+    //
+    psInst = &((tUSBDHIDDevice *)pvHIDInstance)->sPrivateData;
+
+    //
+    // Does the relevant endpoint FIFO have a packet waiting for us?
+    //
+    ui32EPStatus = MAP_USBEndpointStatus(psInst->ui32USBBase,
+                                         psInst->ui8OUTEndpoint);
+    if(ui32EPStatus & USB_DEV_RX_PKT_RDY)
+    {
+        //
+        // Yes - a packet is waiting.  How big is it?
+        //
+        ui32Size = MAP_USBEndpointDataAvail(psInst->ui32USBBase,
+                                            psInst->ui8OUTEndpoint);
+
+        return(ui32Size);
+    }
+    else
+    {
+        //
+        // There is no packet waiting to be received.
+        //
+        return(0);
+    }
+}
+#ifndef DEPRECATED
+
+//*****************************************************************************
+//
+//! Reports the device power status (bus- or self-powered) to the USB library.
+//!
+//! \param pvHIDInstance is the pointer to the HID device instance structure.
+//! \param ui8Power indicates the current power status, either
+//! \b USB_STATUS_SELF_PWR or \b USB_STATUS_BUS_PWR.
+//!
+//! Applications which support switching between bus- or self-powered
+//! operation should call this function whenever the power source changes
+//! to indicate the current power status to the USB library.  This information
+//! is required by the USB library to allow correct responses to be provided
+//! when the host requests status from the device.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBDHIDPowerStatusSet(void *pvHIDInstance, uint8_t ui8Power)
+{
+    ASSERT(pvHIDInstance);
+
+    //
+    // Pass the request through to the lower layer.
+    //
+    USBDCDPowerStatusSet(0, ui8Power);
+}
+#endif
+
+//*****************************************************************************
+//
+//! Requests a remote wake up to resume communication when in suspended state.
+//!
+//! \param pvHIDInstance is the pointer to the HID device instance structure.
+//!
+//! When the bus is suspended, an application which supports remote wake up
+//! (advertised to the host via the configuration descriptor) may call this
+//! function to initiate remote wake up signaling to the host.  If the remote
+//! wake up feature has not been disabled by the host, this will cause the bus
+//! to resume operation within 20mS.  If the host has disabled remote wake up,
+//! \b false will be returned to indicate that the wake up request was not
+//! successful.
+//!
+//! \return Returns \b true if the remote wake up is not disabled and the
+//! signaling was started or \b false if remote wake up is disabled or if
+//! signaling is currently ongoing following a previous call to this function.
+//
+//*****************************************************************************
+bool
+USBDHIDRemoteWakeupRequest(void *pvHIDInstance)
+{
+    ASSERT(pvHIDInstance);
+
+    //
+    // Pass the request through to the lower layer.
+    //
+    return(USBDCDRemoteWakeupRequest(0));
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
diff --git a/bsp/tm4c129x/libraries/usblib/device/usbdhid.h b/bsp/tm4c129x/libraries/usblib/device/usbdhid.h
new file mode 100755
index 0000000..0bc2483
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/device/usbdhid.h
@@ -0,0 +1,1102 @@
+//*****************************************************************************
+//
+// usbdhid.h - Definitions used by HID class devices.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#ifndef __USBDHID_H__
+#define __USBDHID_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+//*****************************************************************************
+//
+//! \addtogroup hid_device_class_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// This is the size of the g_pui8HIDInterface array in bytes.
+//
+//*****************************************************************************
+#define HIDINTERFACE_SIZE       (9)
+
+//*****************************************************************************
+//
+// This is the size of the g_pui8HIDInEndpoint array in bytes.
+//
+//*****************************************************************************
+#define HIDINENDPOINT_SIZE      (7)
+
+//*****************************************************************************
+//
+// This is the size of the g_pui8HIDOutEndpoint array in bytes.
+//
+//*****************************************************************************
+#define HIDOUTENDPOINT_SIZE     (7)
+
+//*****************************************************************************
+//
+// This is the size of the tHIDDescriptor in bytes.
+//
+//*****************************************************************************
+#define HIDDESCRIPTOR_SIZE      (9)
+
+//*****************************************************************************
+//
+//! The size of the memory that should be allocated to create a configuration
+//! descriptor for a single instance of the USB HID Device.
+//! This does not include the configuration descriptor which is automatically
+//! ignored by the composite device class.
+//
+//*****************************************************************************
+#define COMPOSITE_DHID_SIZE     (HIDINTERFACE_SIZE + HIDINENDPOINT_SIZE +     \
+                                 HIDOUTENDPOINT_SIZE + HIDDESCRIPTOR_SIZE)
+
+//*****************************************************************************
+//
+// Macros used to create the static Report Descriptors.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! This is a macro to assist adding Usage Page entries in HID report
+//! descriptors.
+//!
+//! \param ui8Value is the Usage Page value.
+//!
+//! This macro takes a value and prepares it to be placed as a Usage Page entry
+//! into a HID report structure.  These are defined by the USB HID
+//! specification.
+//!
+//! \return Not a function.
+//
+//*****************************************************************************
+#define UsagePage(ui8Value)      0x05, ((ui8Value) & 0xff)
+
+//*****************************************************************************
+//
+//! This is a macro to assist adding Usage Page entries in HID report
+//! descriptors when a vendor-specific value is to be used.
+//!
+//! \param ui16Value is the Usage Page value.
+//!
+//! This macro takes a value and prepares it to be placed as a Usage Page entry
+//! into a HID report structure.  These are defined by the USB HID
+//! specification.  Vendor-specific values must lie in the range 0xFF00 to
+//! 0xFFFF inclusive.
+//!
+//! \return Not a function.
+//
+//*****************************************************************************
+#define UsagePageVendor(ui16Value)     0x06, ((ui16Value) & 0xFF),            \
+                                       (((ui16Value) >> 8) & 0xFF)
+
+//*****************************************************************************
+//
+//! This is a macro to assist adding Usage entries in HID report descriptors.
+//!
+//! \param ui8Value is the Usage value.
+//!
+//! This macro takes a value and prepares it to be placed as a Usage entry into
+//! a HID report structure.  These are defined by the USB HID specification.
+//!
+//! \return Not a function.
+//
+//*****************************************************************************
+#define Usage(ui8Value)          0x09, ((ui8Value) & 0xff)
+
+//*****************************************************************************
+//
+//! This is a macro to assist adding vendor-specific Usage entries in HID
+//! report descriptors.
+//!
+//! \param ui16Value is the vendor-specific Usage value in the range 0xFF00 to
+//! 0xFFFF.
+//!
+//! This macro takes a value and prepares it to be placed as a Usage entry into
+//! a HID report structure.  These are defined by the USB HID specification.
+//!
+//! \return Not a function.
+//
+//*****************************************************************************
+#define UsageVendor(ui16Value)   0x0A, ((ui16Value) & 0xFF),            \
+                                 (((ui16Value) >> 8) & 0xFF)
+
+//*****************************************************************************
+//
+//! This is a macro to assist adding Usage Minimum entries in HID report
+//! descriptors.
+//!
+//! \param ui8Value is the Usage Minimum value.
+//!
+//! This macro takes a value and prepares it to be placed as a Usage Minimum
+//! entry into a HID report structure.  This is the first or minimum value
+//! associated with a usage value.
+//!
+//! \return Not a function.
+//
+//*****************************************************************************
+#define UsageMinimum(ui8Value)   0x19, ((ui8Value) & 0xff)
+
+//*****************************************************************************
+//
+//! This is a macro to assist adding Usage Maximum entries in HID report
+//! descriptors.
+//!
+//! \param ui8Value is the Usage Maximum value.
+//!
+//! This macro takes a value and prepares it to be placed as a Usage Maximum
+//! entry into a HID report structure.  This is the last or maximum value
+//! associated with a usage value.
+//!
+//! \return Not a function.
+//
+//*****************************************************************************
+#define UsageMaximum(ui8Value)   0x29, ((ui8Value) & 0xff)
+
+//*****************************************************************************
+//
+//! This is a macro to assist adding Logical Minimum entries in HID report
+//! descriptors.
+//!
+//! \param i8Value is the Logical Minimum value.
+//!
+//! This macro takes a value and prepares it to be placed as a Logical Minimum
+//! entry into a HID report structure.  This is the actual minimum value for a
+//! range of values associated with a field.
+//!
+//! \return Not a function.
+//
+//*****************************************************************************
+#define LogicalMinimum(i8Value)  0x15, ((i8Value) & 0xff)
+
+//*****************************************************************************
+//
+//! This is a macro to assist adding Logical Maximum entries in HID report
+//! descriptors.
+//!
+//! \param i8Value is the Logical Maximum value.
+//!
+//! This macro takes a value and prepares it to be placed as a Logical Maximum
+//! entry into a HID report structure.  This is the actual maximum value for a
+//! range of values associated with a field.
+//!
+//! \return Not a function.
+//
+//*****************************************************************************
+#define LogicalMaximum(i8Value)  0x25, ((i8Value) & 0xff)
+
+//*****************************************************************************
+//
+//! This is a macro to assist adding Physical Minimum entries in HID report
+//! descriptors.
+//!
+//! \param i16Value is the Physical Minimum value.  It is a signed, 16 bit
+//! number.
+//!
+//! This macro takes a value and prepares it to be placed as a Physical Minimum
+//! entry into a HID report structure.  This is value is used in conversion of
+//! the control logical value, as returned to the host in the relevant report,
+//! to a physical measurement in the appropriate units.
+//!
+//! \return Not a function.
+//
+//*****************************************************************************
+#define PhysicalMinimum(i16Value)                                           \
+                                0x36, ((i16Value) & 0xFF),                    \
+                                (((i16Value) >> 8) & 0xFF)
+
+//*****************************************************************************
+//
+//! This is a macro to assist adding Physical Maximum entries in HID report
+//! descriptors.
+//!
+//! \param i16Value is the Physical Maximum value.  It is a signed, 16 bit
+//! number.
+//!
+//! This macro takes a value and prepares it to be placed as a Physical Maximum
+//! entry into a HID report structure.  This is value is used in conversion of
+//! the control logical value, as returned to the host in the relevant report,
+//! to a physical measurement in the appropriate units.
+//!
+//! \return Not a function.
+//
+//*****************************************************************************
+#define PhysicalMaximum(i16Value)                                           \
+                                0x46, ((i16Value) & 0xFF),                    \
+                                (((i16Value) >> 8) & 0xFF)
+
+//*****************************************************************************
+//
+//! This is a macro to assist adding Collection entries in HID report
+//! descriptors.
+//!
+//! \param ui8Value is the type of Collection.
+//!
+//! This macro takes a value and prepares it to be placed as a Collection
+//! entry into a HID report structure.  This is the type of values that are
+//! being grouped together, for instance input, output or features can be
+//! grouped together as a collection.
+//!
+//! \return Not a function.
+//
+//*****************************************************************************
+#define Collection(ui8Value)     0xa1, ((ui8Value) & 0xff)
+
+//*****************************************************************************
+//
+//! This is a macro to assist adding End Collection entries in HID report
+//! descriptors.
+//!
+//! This macro can be used to place an End Collection entry into a HID report
+//! structure.  This is a tag to indicate that a collection of entries has
+//! ended in the HID report structure.  This terminates a previous Collection()
+//! entry.
+//!
+//! \return Not a function.
+//
+//*****************************************************************************
+#define EndCollection           0xc0
+
+//*****************************************************************************
+//
+//! This is a macro to assist adding Report Count entries in HID report
+//! descriptors.
+//!
+//! \param ui8Value is the number of items in a report item.
+//!
+//! This macro takes a value and prepares it to be placed as a Report Count
+//! entry into a HID report structure.  This is number of entries of Report
+//! Size for a given item.
+//!
+//! \return Not a function.
+//
+//*****************************************************************************
+#define ReportCount(ui8Value)    0x95, ((ui8Value) & 0xff)
+
+//*****************************************************************************
+//
+//! This is a macro to assist adding Report ID entries in HID report
+//! descriptors.
+//!
+//! \param ui8Value is the identifier prefix for the current report.
+//!
+//! This macro takes a value and prepares it to be placed as a Report ID
+//! entry into a HID report structure.  This value is used as a 1 byte prefix
+//! for the report it is contained within.
+//!
+//! \return Not a function.
+//
+//*****************************************************************************
+#define ReportID(ui8Value)       0x85, ((ui8Value) & 0xff)
+
+//*****************************************************************************
+//
+//! This is a macro to assist adding Report Size entries in HID report
+//! descriptors.
+//!
+//! \param ui8Value is the size, in bits, of items in a report item.
+//!
+//! This macro takes a value and prepares it to be placed as a Report Size
+//! entry into a HID report structure.  This is size in bits of the entries of
+//! of a report entry.  The Report Count specifies how many entries of Report
+//! Size are in a given item.  These can be individual bits or bit fields.
+//!
+//! \return Not a function.
+//
+//*****************************************************************************
+#define ReportSize(ui8Value)     0x75, ((ui8Value) & 0xff)
+
+//*****************************************************************************
+//
+//! This is a macro to assist adding Input entries in HID report descriptors.
+//!
+//! \param ui8Value is bit mask to specify the type of a set of input report
+//! items.  Note that if the USB_HID_INPUT_BITF flag is required, the Input2
+//! macro (which uses a 2 byte version of the Input item tag) must be used
+//! instead of this macro.
+//!
+//! This macro takes a value and prepares it to be placed as an Input entry
+//! into a HID report structure.  This specifies the type of an input item in
+//! a report structure.  These refer to a bit mask of flags that indicate the
+//! type of input for a set of items.
+//!
+//! \return Not a function.
+//
+//*****************************************************************************
+#define Input(ui8Value)          0x81, ((ui8Value) & 0xff)
+
+//*****************************************************************************
+//
+//! This is a macro to assist adding Input entries in HID report descriptors.
+//!
+//! \param ui16Value is bit mask to specify the type of a set of input report
+//! items.  Note that this macro uses a version of the Input item tag with a
+//! two byte payload and allows any of the 8 possible data bits for the tag to
+//! be used.  If USB_HID_INPUT_BITF (bit 8) is not required, the Input macro
+//! may be used instead.
+//!
+//! This macro takes a value and prepares it to be placed as an Input entry
+//! into a HID report structure.  This specifies the type of an input item in
+//! a report structure.  These refer to a bit mask of flags that indicate the
+//! type of input for a set of items.
+//!
+//! \return Not a function.
+//
+//*****************************************************************************
+#define Input2(ui16Value)       0x82, ((ui16Value) & 0xff),                   \
+                                (((ui16Value) >> 8) & 0xFF)
+
+//*****************************************************************************
+//
+//! This is a macro to assist adding Feature entries in HID report descriptors.
+//!
+//! \param ui8Value is bit mask to specify the type of a set of feature report
+//! items.  Note that if the \b USB_HID_FEATURE_BITF flag is required, the
+//! Feature2 macro (which uses a 2 byte version of the Feature item tag) must
+//! be used instead of this macro.
+//!
+//! This macro takes a value and prepares it to be placed as a Feature entry
+//! into a HID report structure.  This specifies the type of a feature item in
+//! a report structure.  These refer to a bit mask of flags that indicate the
+//! type of feature for a set of items.
+//!
+//! \return Not a function.
+//
+//*****************************************************************************
+#define Feature(ui8Value)        0xB1, ((ui8Value) & 0xff)
+
+//*****************************************************************************
+//
+//! This is a macro to assist adding Feature entries in HID report descriptors.
+//!
+//! \param ui16Value is bit mask to specify the type of a set of feature report
+//! items.  Note that this macro uses a version of the Feature item tag with a
+//! two byte payload and allows any of the 8 possible data bits for the tag to
+//! be used.  If \b USB_HID_FEATURE_BITF (bit 8) is not required, the Feature
+//! macro may be used instead.
+//!
+//! This macro takes a value and prepares it to be placed as a Feature entry
+//! into a HID report structure.  This specifies the type of a feature item in
+//! a report structure.  These refer to a bit mask of flags that indicate the
+//! type of feature for a set of items.
+//!
+//! \return Not a function.
+//
+//*****************************************************************************
+#define Feature2(ui16Value)     0xB2, ((ui16Value) & 0xff),                   \
+                                (((ui16Value) >> 8) & 0xFF)
+
+//*****************************************************************************
+//
+//! This is a macro to assist adding Output entries in HID report descriptors.
+//!
+//! \param ui8Value is bit mask to specify the type of a set of output report
+//! items.  Note that if the \b USB_HID_OUTPUT_BITF flag is required, the
+//! Output2 macro (which uses a 2 byte version of the Output item tag) must be
+//! used instead of this macro.
+//!
+//! This macro takes a value and prepares it to be placed as an Output entry
+//! into a HID report structure.  This specifies the type of an output item in
+//! a report structure.  These refer to a bit mask of flags that indicate the
+//! type of output for a set of items.
+//!
+//! \return Not a function.
+//
+//*****************************************************************************
+#define Output(ui8Value)        0x91, ((ui8Value) & 0xff)
+
+//*****************************************************************************
+//
+//! This is a macro to assist adding Output entries in HID report descriptors.
+//!
+//! \param ui16Value is bit mask to specify the type of a set of output report
+//! items.  Note that this macro uses a version of the Output item tag with a
+//! two byte payload and allows any of the 8 possible data bits for the tag to
+//! be used.  If \b USB_HID_OUTPUT_BITF is not required, the Output macro
+//! may be used instead.
+//!
+//! This macro takes a value and prepares it to be placed as an Output entry
+//! into a HID report structure.  This specifies the type of an output item in
+//! a report structure.  These refer to a bit mask of flags that indicate the
+//! type of output for a set of items.
+//!
+//! \return Not a function.
+//
+//*****************************************************************************
+#define Output2(ui16Value)      0x92, ((ui16Value) & 0xff),                   \
+                                (((ui16Value) >> 8) & 0xFF)
+
+//*****************************************************************************
+//
+//! This is a macro to assist adding Unit Exponent entries in HID report
+//! descriptors.
+//!
+//! \param i8Value is the required exponent in the range [-8, 7].
+//!
+//! This macro takes a value and prepares it to be placed as a Unit Exponent
+//! entry into a HID report structure.  This is the exponent applied to
+//! PhysicalMinimum and PhysicalMaximum when scaling and converting control
+//! values to "real" units.
+//!
+//! \return Not a function.
+//
+//*****************************************************************************
+#define UnitExponent(i8Value)   0x55, ((i8Value) & 0x0f)
+
+//*****************************************************************************
+//
+//! This is a macro to assist adding Unit entries for uncommon units in HID
+//! report descriptors.
+//!
+//! \param ui32Value is the definition of the unit required as defined in
+//! section 6.2.2.7 of the USB HID device class definition document.
+//!
+//! This macro takes a value and prepares it to be placed as a Unit entry into
+//! a HID report structure.  Note that individual macros are defined for common
+//! units and this macro is intended for use when a complex or uncommon unit
+//! is needed.  It allows entry of a 5 nibble unit definition into the report
+//! descriptor.
+//!
+//! \return Not a function.
+//
+//*****************************************************************************
+#define Unit(ui32Value)         0x67, (ui32Value) & 0x0f),                    \
+                                (((ui32Value) >> 8) & 0xFF),                  \
+                                (((ui32Value) >> 16) & 0xFF),                 \
+                                (((ui32Value) >> 24) & 0xFF)
+
+//*****************************************************************************
+//
+//! This macro inserts a Unit entry for centimeters into a report descriptor.
+//!
+//*****************************************************************************
+#define UnitDistance_cm         0x66, 0x11, 0x00
+
+//*****************************************************************************
+//
+//! This macro inserts a Unit entry for inches into a report descriptor.
+//!
+//*****************************************************************************
+#define UnitDistance_i          0x66, 0x13, 0x00
+
+//*****************************************************************************
+//
+//! This macro inserts a Unit entry for degrees into a report descriptor.
+//!
+//*****************************************************************************
+#define UnitRotation_deg        0x66, 0x14, 0x00
+
+//*****************************************************************************
+//
+//! This macro inserts a Unit entry for radians into a report descriptor.
+//!
+//*****************************************************************************
+#define UnitRotation_rad        0x66, 0x12, 0x00
+
+//*****************************************************************************
+//
+//! This macro inserts a Unit entry for grams into a report descriptor.
+//!
+//*****************************************************************************
+#define UnitMass_g              0x66, 0x01, 0x01
+
+//*****************************************************************************
+//
+//! This macro inserts a Unit entry for seconds into a report descriptor.
+//!
+//*****************************************************************************
+#define UnitTime_s              0x66, 0x01, 0x10
+
+//*****************************************************************************
+//
+//! This macro inserts a Unit entry for temperature in Kelvin into a report
+//! descriptor.
+//!
+//*****************************************************************************
+#define UnitTemp_K              0x67, 0x01, 0x00, 0x01, 0x00
+
+//*****************************************************************************
+//
+//! This macro inserts a Unit entry for temperature in Fahrenheit into a report
+//! descriptor.
+//!
+//*****************************************************************************
+#define UnitTemp_F              0x67, 0x03, 0x00, 0x01, 0x00
+
+//*****************************************************************************
+//
+//! This macro inserts a Unit entry for velocity in cm/s into a report
+//! descriptor.
+//!
+//*****************************************************************************
+#define UnitVelocitySI          0x66, 0x11, 0xF0
+
+//*****************************************************************************
+//
+//! This macro inserts a Unit entry for momentum in (grams * cm)/s into a
+//! report descriptor.
+//!
+//*****************************************************************************
+#define UnitMomentumSI          0x66, 0x11, 0xF1
+
+//*****************************************************************************
+//
+//! This macro inserts a Unit entry for acceleration in cm/s**2 into a
+//! report descriptor.
+//!
+//*****************************************************************************
+#define UnitAccelerationSI      0x66, 0x11, 0xE0
+
+//*****************************************************************************
+//
+//! This macro inserts a Unit entry for force in (cm * grams)/s**2 into a
+//! report descriptor.
+//!
+//*****************************************************************************
+#define UnitForceSI             0x66, 0x11, 0xE1
+
+//*****************************************************************************
+//
+//! This macro inserts a Unit entry for energy in (grams * cm^2)/(s^2) into a
+//! report descriptor.
+//!
+//*****************************************************************************
+#define UnitEnergySI            0x66, 0x21, 0xE1
+
+//*****************************************************************************
+//
+//! This macro inserts a Unit entry for angular acceleration in degrees/(s^2)
+//! into a report descriptor.
+//!
+//*****************************************************************************
+#define UnitAngAccelerationSI   0x66, 0x12, 0xE0
+
+//*****************************************************************************
+//
+//! This macro inserts a Unit entry for voltage into a a report descriptor.
+//!
+//*****************************************************************************
+#define UnitVoltage             0x67, 0x21, 0xD1, 0xF0, 0x00
+
+//*****************************************************************************
+//
+//! This macro inserts a Unit entry for voltage into a a report descriptor.
+//!
+//*****************************************************************************
+#define UnitCurrent_A           0x67, 0x01, 0x00, 0x10, 0x00
+
+//*****************************************************************************
+//
+// PRIVATE
+//
+// The first few sections of this header are private defines that are used by
+// the USB HID code and are here only to help with the application
+// allocating the correct amount of memory for the HID device code.
+//
+//*****************************************************************************
+#define USBDHID_MAX_PACKET      64
+
+//*****************************************************************************
+//
+// PRIVATE
+//
+// This enumeration holds the various states that the device can be in during
+// normal operation.
+//
+//*****************************************************************************
+typedef enum
+{
+    //
+    // Unconfigured.
+    //
+    eHIDStateUnconfigured,
+
+    //
+    // No outstanding transaction remains to be completed.
+    //
+    eHIDStateIdle,
+
+    //
+    // Waiting on completion of a send or receive transaction.
+    //
+    eHIDStateWaitData
+}
+tHIDState;
+
+//*****************************************************************************
+//
+// PRIVATE
+//
+// This structure defines the private instance data and state variables for
+// HID devices.  The memory for this structure is included in the
+// sPrivateData field in the tUSBDHIDDevice structure passed in the
+// USBDHIDInit() function.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    // Base address for the USB controller.
+    //
+    uint32_t ui32USBBase;
+
+    //
+    // The device info to interact with the lower level DCD code.
+    //
+    tDeviceInfo sDevInfo;
+
+    //
+    // The state of the HID receive channel.
+    //
+    volatile tHIDState iHIDRxState;
+
+    //
+    // The state of the HID transmit channel.
+    //
+    volatile tHIDState iHIDTxState;
+
+    //
+    // State of any pending operations that could not be handled immediately
+    // upon receipt.
+    //
+    volatile uint16_t ui16DeferredOpFlags;
+
+    //
+    // Size of the HID IN report.
+    //
+    uint16_t ui16InReportSize;
+
+    //
+    // .
+    //
+    uint16_t ui16InReportIndex;
+
+    //
+    // Size of the HID OUT report.
+    //
+    uint16_t ui16OutReportSize;
+
+    //
+    // Pointer to the current HID IN report data.
+    //
+    uint8_t *pui8InReportData;
+
+    //
+    // Pointer to the current HID OUT report data.
+    //
+    uint8_t *pui8OutReportData;
+
+    //
+    // The connection status of the device.
+    //
+    volatile bool bConnected;
+
+    //
+    // Whether an IN transaction is in process.
+    //
+    volatile bool bSendInProgress;
+
+    //
+    // An HID request transaction is in process(Endpoint 0).
+    //
+    bool bGetRequestPending;
+
+    //
+    // The IN endpoint number, this is modified in composite devices.
+    //
+    uint8_t ui8INEndpoint;
+
+    //
+    // The OUT endpoint number, this is modified in composite devices.
+    //
+    uint8_t ui8OUTEndpoint;
+
+    //
+    // The bulk class interface number, this is modified in composite devices.
+    //
+    uint8_t ui8Interface;
+}
+tHIDInstance;
+
+//*****************************************************************************
+//
+//! The structure used to track idle time for reports.  An array of these
+//! structures is passed to the HID device class driver during USBDHIDInit and
+//! is used to track automatic resending of each report (if not disabled by
+//! the host).
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The idle duration for the report expressed in units of 4mS.  0
+    //! indicates infinite and informs the class driver not to send the report
+    //! unless a state change occurs.
+    //
+    uint8_t ui8Duration4mS;
+
+    //
+    //! The ID of the report which this structure applies to.  This is the
+    //! report ID as specified using a ReportID tag in the report descriptor
+    //! rather than the index of the report in the HID class descriptor array.
+    //! If only a single Input report is supported and, thus, no ReportID tag
+    //! is present, this field should be set to 0.
+    //
+    uint8_t ui8ReportID;
+
+    //
+    //! The number of milliseconds before we need to send a copy of a given
+    //! report back to the host.  This field is updated by the HID driver and
+    //! used to time sending of \b USBD_HID_EVENT_IDLE_TIMEOUT.
+    //
+    uint16_t ui16TimeTillNextmS;
+
+    //
+    //! The number of milliseconds that have passed since the last time this
+    //! report was sent.  The HID class driver needs to track this since
+    //! Set_Idle requests are required to take effect as if issued immediately
+    //! after the last transmission of the report to which they refer.
+    //
+    uint32_t ui32TimeSinceReportmS;
+}
+tHIDReportIdle;
+
+//*****************************************************************************
+//
+//! The structure used by the application to define operating parameters for
+//! the HID device.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The vendor ID that this device is to present in the device descriptor.
+    //
+    uint16_t ui16VID;
+
+    //
+    //! The product ID that this device is to present in the device descriptor.
+    //
+    uint16_t ui16PID;
+
+    //
+    //! The maximum power consumption of the device, expressed in milliamps.
+    //
+    uint16_t ui16MaxPowermA;
+
+    //
+    //! Indicates whether the device is self- or bus-powered and whether or not
+    //! it supports remote wakeup.  Valid values are \b USB_CONF_ATTR_SELF_PWR
+    //! or \b USB_CONF_ATTR_BUS_PWR, optionally ORed with
+    //! \b USB_CONF_ATTR_RWAKE.
+    //
+    uint8_t ui8PwrAttributes;
+
+    //
+    //! The interface subclass to publish to the server for this HID device.
+    //
+    uint8_t ui8Subclass;
+
+    //
+    //! The interface protocol to publish to the server for this HID device.
+    //
+    uint8_t ui8Protocol;
+
+    //
+    //! The number of Input reports that this device supports.  This field
+    //! must equal the number of reports published in the HID class descriptors
+    //! for the device and also the number of entries in the array whose first
+    //! element is pointed to by field \e pi16ReportIdle below.
+    //
+    uint8_t ui8NumInputReports;
+
+    //
+    //! A pointer to the first element in an array of structures used to track
+    //! idle time for each Input report.  When USBDHIDInit() is called, the
+    //! ui8Duration4mS and ui8ReportID fields of each of these array members
+    //! should be initialized to indicate the default idle timeout for each
+    //! input report.  This array must be in RAM since the HID device class
+    //! driver updates values in it in response to requests from the host
+    //! and to track elapsed time.  The number of elements in the array must
+    //! match the number supplied in the ui8NumInputReports field above.
+    //
+    tHIDReportIdle *psReportIdle;
+
+    //! A pointer to the callback function which is called to notify
+    //! the application of general events, events related to report transfers
+    //! on endpoint zero and events related to reception of Output and Feature
+    //! reports via the (optional) interrupt OUT endpoint.
+    //
+    tUSBCallback pfnRxCallback;
+
+    //
+    //! A client-supplied pointer which is sent as the first
+    //! parameter in all calls made to the receive channel callback,
+    //! pfnRxCallback.
+    //
+    void *pvRxCBData;
+
+    //
+    //! A pointer to the callback function which is called to notify
+    //! the application of events related to transmission of Input reports
+    //! via the interrupt IN endpoint.
+    //
+    tUSBCallback pfnTxCallback;
+
+    //
+    //! A client-supplied pointer which is sent as the first
+    //! parameter in all calls made to the transmit channel callback,
+    //! pfnTxCallback.
+    //
+    void *pvTxCBData;
+
+    //
+    //! If set to true, this field indicates that the device should use a
+    //! dedicated interrupt OUT endpoint to receive reports from the host.  In
+    //! this case, reports from the host are passed to the application via the
+    //! receive callback using \b USB_EVENT_RX_AVAILABLE events.  If false,
+    //! reports from the host are received via endpoint zero and passed to the
+    //! application via \b USBD_HID_EVENT_REPORT_SENT events.
+    //
+    bool bUseOutEndpoint;
+
+    //
+    //! The HID descriptor that the device is to publish (following the
+    //! standard interface descriptor and prior to the endpoint descriptors for
+    //! the interface).
+    //
+    const tHIDDescriptor *psHIDDescriptor;
+
+    //
+    //! The HID class descriptors offered by the device are defined in an
+    //! array of byte pointers and this field points to that array.  The
+    //! order and number of elements in the array must match the associated
+    //! information provided in the HID descriptor in field by
+    //! \e pi16HIDDescriptor.
+    //
+    const uint8_t * const *ppui8ClassDescriptors;
+
+    //
+    //! A pointer to the string descriptor array for this device.  This array
+    //! must contain the following string descriptor pointers in this order.
+    //! Language descriptor, Manufacturer name string (language 1), Product
+    //! name string (language 1), Serial number string (language 1),HID
+    //! Interface description string (language 1), Configuration description
+    //! string (language 1), (optionally) First HID device-specific string
+    //! (language 1), (optionally) Second HID device-specific string (language
+    //! 1), etc.
+    //!
+    //! If supporting more than 1 language, the descriptor block (except for
+    //! string descriptor 0) must be repeated for each language defined in the
+    //! language descriptor.
+    //!
+    //! The number of HID device-specific strings is dependent upon the content
+    //! of the report descriptor passed to the interface and is, thus,
+    //! application controlled.
+    //
+    const uint8_t * const *ppui8StringDescriptors;
+
+    //
+    //! The number of descriptors provided in the \e ppStringDescriptors
+    //! array.  This must be 1 + ((5 + (num HID strings)) * (num languages)).
+    //
+    uint32_t ui32NumStringDescriptors;
+
+    //
+    // ! The configuration descriptor for this HID device.
+    //
+    const tConfigHeader * const *ppsConfigDescriptor;
+
+    //
+    //! The private instance data for this device instance.  This
+    //! memory must remain accessible for as long as the HID device is in
+    //! use and must not be modified by any code outside the HID class driver.
+    //
+    tHIDInstance sPrivateData;
+}
+tUSBDHIDDevice;
+
+//*****************************************************************************
+//
+// HID-specific device class driver events
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! This event indicates that the host is requesting a particular report be
+//! returned via endpoint 0, the control endpoint.  The ui32MsgValue parameter
+//! contains the requested report type in the high byte and report ID in the
+//! low byte (as passed in the wValue field of the USB request structure).
+//! The pvMsgData parameter contains a pointer which must be written with the
+//! address of the first byte of the requested report.  The callback must
+//! return the size in bytes of the report pointed to by *pvMsgData.  The
+//! memory returned in response to this event must remain unaltered until
+//! \b USBD_HID_EVENT_REPORT_SENT is sent.
+//
+//*****************************************************************************
+#define USBD_HID_EVENT_GET_REPORT                                             \
+                                (USBD_HID_EVENT_BASE + 0)
+
+//*****************************************************************************
+//
+//! This event indicates that a report previously requested via a
+//! \b USBD_HID_EVENT_GET_REPORT has been successfully transmitted to the host.
+//! The application may now free or reuse the report memory passed on the
+//! previous event.  Although this would seem to be an event that would be
+//! passed to the transmit channel callback, it is actually passed to the
+//! receive channel callback.  This ensures that all events related to the
+//! request and transmission of reports via endpoint zero can be handled in
+//! a single function.
+//
+//*****************************************************************************
+#define USBD_HID_EVENT_REPORT_SENT                                            \
+                                (USBD_HID_EVENT_BASE + 1)
+
+//*****************************************************************************
+//
+//! This event indicates that the host has sent a Set_Report request to
+//! the device and requests that the device provide a buffer into which the
+//! report can be written.  The ui32MsgValue parameter contains the received
+//! report type in the high byte and report ID in the low byte (as passed in
+//! the wValue field of the USB request structure).  The pvMsgData parameter
+//! contains the length of buffer requested.  Note that this is the actual
+//! length value cast to a "void *" type and not a pointer in this case.
+//! The callback must return a pointer to a suitable buffer (cast to the
+//! standard "uint32_t" return type for the callback).
+//
+//*****************************************************************************
+#define USBD_HID_EVENT_GET_REPORT_BUFFER                                      \
+                                (USBD_HID_EVENT_BASE + 2)
+
+//*****************************************************************************
+//
+//! This event indicates that the host has sent the device a report via
+//! endpoint 0, the control endpoint.  The ui32MsgValue field indicates the
+//! size of the report and pvMsgData points to the first byte of the report.
+//! The report buffer was previously returned in response to an
+//! earlier \b USBD_HID_EVENT_GET_REPORT_BUFFER callback.  The HID device class
+//! driver does not access the memory pointed to by pvMsgData after this
+//! callback is made so the application is free to reuse or free it at this
+//! point.
+//
+//*****************************************************************************
+#define USBD_HID_EVENT_SET_REPORT                                             \
+                                (USBD_HID_EVENT_BASE + 3)
+
+//*****************************************************************************
+//
+//! This event is sent in response to a Get_Protocol request from the host.
+//! The callback should provide the current protocol via the return code,
+//! \b USB_HID_PROTOCOL_BOOT or \b USB_HID_PROTOCOL_REPORT.
+//
+//*****************************************************************************
+#define USBD_HID_EVENT_GET_PROTOCOL                                           \
+                                (USBD_HID_EVENT_BASE + 4)
+
+//*****************************************************************************
+//
+//! This event is sent in response to a Set_Protocol request from the host.
+//! The ui32MsgData value contains the requested protocol,
+//! \b USB_HID_PROTOCOL_BOOT or \b USB_HID_PROTOCOL_REPORT.
+//
+//*****************************************************************************
+#define USBD_HID_EVENT_SET_PROTOCOL                                           \
+                                (USBD_HID_EVENT_BASE + 5)
+
+//*****************************************************************************
+//
+//! This event indicates to an application that a report idle timeout has
+//! occurred and requests a pointer to the report that must be sent back to
+//! the host.  The ui32MsgData value contains the requested report ID and
+//! pvMsgData contains a pointer that must be written with a pointer to the
+//! report data that is to be sent.  The callback must return the number of
+//! bytes in the report pointed to by *pvMsgData.
+//
+//*****************************************************************************
+#define USBD_HID_EVENT_IDLE_TIMEOUT                                           \
+                                (USBD_HID_EVENT_BASE + 6)
+
+//*****************************************************************************
+//
+// API Function Prototypes
+//
+//*****************************************************************************
+extern void *USBDHIDInit(uint32_t ui32Index, tUSBDHIDDevice *psHIDDevice);
+extern void *USBDHIDCompositeInit(uint32_t ui32Index,
+                                  tUSBDHIDDevice *psDevice,
+                                  tCompositeEntry *psCompEntry);
+extern void USBDHIDTerm(void *pvHIDInstance);
+extern void *USBDHIDSetRxCBData(void *pvHIDInstance, void *pvCBData);
+extern void *USBDHIDSetTxCBData(void *pvHIDInstance, void *pvCBData);
+extern uint32_t USBDHIDReportWrite(void *pvHIDInstance, uint8_t *pi8Data,
+                                   uint32_t ui32Length, bool bLast);
+extern uint32_t USBDHIDPacketRead(void *pvHIDInstance, uint8_t *pi8Data,
+                                  uint32_t ui32Length, bool bLast);
+extern uint32_t USBDHIDTxPacketAvailable(void *pvHIDInstance);
+extern uint32_t USBDHIDRxPacketAvailable(void *pvHIDInstance);
+extern bool USBDHIDRemoteWakeupRequest(void *pvHIDInstance);
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// The following APIs are deprecated.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+
+//
+// Use USBDCDFeatureSet() or USBHCDFeatureSet() with \b USBLIB_FEATURE_POWER
+// configuration option.
+//
+extern void USBDHIDPowerStatusSet(void *pvHIDInstance, uint8_t ui8Power);
+#endif
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __USBDHID_H__
diff --git a/bsp/tm4c129x/libraries/usblib/device/usbdhidgamepad.c b/bsp/tm4c129x/libraries/usblib/device/usbdhidgamepad.c
new file mode 100755
index 0000000..b36c033
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/device/usbdhidgamepad.c
@@ -0,0 +1,845 @@
+//*****************************************************************************
+//
+// usbdhidgame.c - USB HID Gamepad device class driver
+//
+// Copyright (c) 2013-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "inc/hw_types.h"
+#include "driverlib/debug.h"
+#include "driverlib/usb.h"
+#include "usblib/usblib.h"
+#include "usblib/usblibpriv.h"
+#include "usblib/device/usbdevice.h"
+#include "usblib/usbhid.h"
+#include "usblib/device/usbdhid.h"
+#include "usblib/device/usbdhidgamepad.h"
+
+//*****************************************************************************
+//
+//! \addtogroup hid_gamepad_device_class_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// HID device configuration descriptor.
+//
+// It is vital that the configuration descriptor bConfigurationValue field
+// (byte 6) is 1 for the first configuration and increments by 1 for each
+// additional configuration defined here.  This relationship is assumed in the
+// device stack for simplicity even though the USB 2.0 specification imposes
+// no such restriction on the bConfigurationValue values.
+//
+//*****************************************************************************
+static uint8_t g_pui8GameDescriptor[] =
+{
+    //
+    // Configuration descriptor header.
+    //
+    9,                          // Size of the configuration descriptor.
+    USB_DTYPE_CONFIGURATION,    // Type of this descriptor.
+    USBShort(24),               // The total size of this full structure.
+    1,                          // The number of interfaces in this
+                                // configuration.
+    1,                          // The unique value for this configuration.
+    5,                          // The string identifier that describes this
+                                // configuration.
+    USB_CONF_ATTR_SELF_PWR,     // Self Powered.
+    0,                          // The maximum power in 2mA increments.
+};
+
+//*****************************************************************************
+//
+// This is the HID interface descriptor for the gamepad device.
+//
+//*****************************************************************************
+static uint8_t g_pui8HIDInterface[HIDINTERFACE_SIZE] =
+{
+    //
+    // HID Device Class Interface Descriptor.
+    //
+    9,                          // Size of the interface descriptor.
+    USB_DTYPE_INTERFACE,        // Type of this descriptor.
+    0,                          // The index for this interface.
+    0,                          // The alternate setting for this interface.
+    1,                          // The number of endpoints used by this
+                                // interface.
+    USB_CLASS_HID,              // The interface class
+    0,                          // The interface sub-class.
+    0,                          // The interface protocol for the sub-class
+                                // specified above.
+    4,                          // The string index for this interface.
+};
+
+//*****************************************************************************
+//
+// This is the HID IN endpoint descriptor for the gamepad device.
+//
+//*****************************************************************************
+static const uint8_t g_pui8HIDInEndpoint[HIDINENDPOINT_SIZE] =
+{
+    //
+    // Interrupt IN endpoint descriptor
+    //
+    7,                          // The size of the endpoint descriptor.
+    USB_DTYPE_ENDPOINT,         // Descriptor type is an endpoint.
+    USB_EP_DESC_IN | USBEPToIndex(USB_EP_1),
+    USB_EP_ATTR_INT,            // Endpoint is an interrupt endpoint.
+    USBShort(USBFIFOSizeToBytes(USB_FIFO_SZ_64)),
+                                // The maximum packet size.
+    1,                          // The polling interval for this endpoint.
+};
+
+//*****************************************************************************
+//
+// The following is the HID report structure definition that is passed back
+// to the host.
+//
+//*****************************************************************************
+static const uint8_t g_pui8GameReportDescriptor[] =
+{
+    UsagePage(USB_HID_GENERIC_DESKTOP),
+    Usage(USB_HID_JOYSTICK),
+    Collection(USB_HID_APPLICATION),
+        //
+        // The axis for the controller.
+        //
+        UsagePage(USB_HID_GENERIC_DESKTOP),
+        Usage (USB_HID_POINTER),
+        Collection (USB_HID_PHYSICAL),
+
+            //
+            // The X, Y and Z values which are specified as 8-bit absolute
+            // position values.
+            //
+            Usage (USB_HID_X),
+            Usage (USB_HID_Y),
+            Usage (USB_HID_Z),
+
+            //
+            // 3 8-bit absolute values.
+            //
+            ReportSize(8),
+            ReportCount(3),
+            Input(USB_HID_INPUT_DATA | USB_HID_INPUT_VARIABLE |
+                  USB_HID_INPUT_ABS),
+
+            //
+            // The 8 buttons.
+            //
+            UsagePage(USB_HID_BUTTONS),
+            UsageMinimum(1),
+            UsageMaximum(8),
+            LogicalMinimum(0),
+            LogicalMaximum(1),
+            PhysicalMinimum(0),
+            PhysicalMaximum(1),
+
+            //
+            // 8 - 1 bit values for the buttons.
+            //
+            ReportSize(1),
+            ReportCount(8),
+            Input(USB_HID_INPUT_DATA | USB_HID_INPUT_VARIABLE |
+                  USB_HID_INPUT_ABS),
+
+        EndCollection,
+    EndCollection
+};
+
+//*****************************************************************************
+//
+// The HID descriptor for the gamepad device.
+//
+//*****************************************************************************
+static tHIDDescriptor g_sGameHIDDescriptor =
+{
+    9,                              // bLength
+    USB_HID_DTYPE_HID,              // bDescriptorType
+    0x111,                          // bcdHID (version 1.11 compliant)
+    0,                              // bCountryCode (not localized)
+    1,                              // bNumDescriptors
+    {
+        {
+            USB_HID_DTYPE_REPORT,   // Report descriptor
+            sizeof(g_pui8GameReportDescriptor)
+                                    // Size of report descriptor
+        }
+    }
+};
+
+//*****************************************************************************
+//
+// The HID configuration descriptor is defined as four sections.
+// These sections are:
+//
+// 1.  The 9 byte configuration descriptor.
+// 2.  The interface descriptor.
+// 3.  The HID report and physical descriptors, provided by the application
+//     or the default can be used.
+// 4.  The mandatory interrupt IN endpoint descriptor.
+//
+//*****************************************************************************
+static const tConfigSection g_sHIDConfigSection =
+{
+    sizeof(g_pui8GameDescriptor),
+    g_pui8GameDescriptor
+};
+
+static const tConfigSection g_sHIDInterfaceSection =
+{
+    sizeof(g_pui8HIDInterface),
+    g_pui8HIDInterface
+};
+
+static const tConfigSection g_sHIDInEndpointSection =
+{
+    sizeof(g_pui8HIDInEndpoint),
+    g_pui8HIDInEndpoint
+};
+
+//*****************************************************************************
+//
+// Place holder for the user's HID descriptor block.
+//
+//*****************************************************************************
+static tConfigSection g_sHIDDescriptorSection =
+{
+   sizeof(g_sGameHIDDescriptor),
+   (const uint8_t *)&g_sGameHIDDescriptor
+};
+
+//*****************************************************************************
+//
+// This array lists all the sections that must be concatenated to make a
+// single, complete HID configuration descriptor.
+//
+//*****************************************************************************
+static const tConfigSection *g_psHIDSections[] =
+{
+    &g_sHIDConfigSection,
+    &g_sHIDInterfaceSection,
+    &g_sHIDDescriptorSection,
+    &g_sHIDInEndpointSection,
+};
+
+#define NUM_HID_SECTIONS        ((sizeof(g_psHIDSections) /                   \
+                                  sizeof(tConfigSection *)))
+
+//*****************************************************************************
+//
+// The header for the single configuration supported.  This is the root of
+// the data structure that defines all the bits and pieces that are pulled
+// together to generate the configuration descriptor.  Note that this must be
+// in RAM since we need to include or exclude the final section based on
+// client supplied initialization parameters.
+//
+//*****************************************************************************
+static tConfigHeader g_sHIDConfigHeader =
+{
+    NUM_HID_SECTIONS,
+    g_psHIDSections
+};
+
+//*****************************************************************************
+//
+// Configuration Descriptor.
+//
+//*****************************************************************************
+static const tConfigHeader * const g_ppsHIDConfigDescriptors[] =
+{
+    &g_sHIDConfigHeader
+};
+
+//*****************************************************************************
+//
+// The HID class descriptor table.  For the gamepad class there is only a
+// single report descriptor.
+//
+//*****************************************************************************
+static const uint8_t *g_ppui8GameClassDescriptors[] =
+{
+    g_pui8GameReportDescriptor
+};
+
+//*****************************************************************************
+//
+// HID gamepad transmit channel event handler function.
+//
+// \param pvGameDevice is the event callback pointer provided during
+// USBDHIDInit().  This is a pointer to the HID gamepad device structure
+// of the type tUSBDHIDGamepadDevice.
+// \param ui32Event identifies the event we are being called back for.
+// \param ui32MsgData is an event-specific value.
+// \param pvMsgData is an event-specific pointer.
+//
+// This function is called by the lower level HID device class driver to inform
+// the application of particular asynchronous events related to report events
+// related to using the interrupt IN endpoint.
+//
+// \return Returns a value which is event-specific.
+//
+//*****************************************************************************
+static uint32_t
+HIDGamepadTxHandler(void *pvGameDevice, uint32_t ui32Event,
+                    uint32_t ui32MsgData, void *pvMsgData)
+{
+    tUSBDGamepadInstance *psInst;
+    tUSBDHIDGamepadDevice *psGamepad;
+
+    //
+    // Make sure we did not get a NULL pointer.
+    //
+    ASSERT(pvGameDevice);
+
+    //
+    // Get a pointer to our instance data
+    //
+    psGamepad = (tUSBDHIDGamepadDevice *)pvGameDevice;
+    psInst = &psGamepad->sPrivateData;
+
+    //
+    // Which event were we sent?
+    //
+    switch (ui32Event)
+    {
+        //
+        // A report transmitted via the interrupt IN endpoint was acknowledged
+        // by the host.
+        //
+        case USB_EVENT_TX_COMPLETE:
+        {
+            //
+            // The last transmission is complete so return to the idle state.
+            //
+            psInst->iState = eHIDGamepadStateIdle;
+
+            //
+            // Pass the event on to the application.
+            //
+            psGamepad->pfnCallback(psGamepad->pvCBData, USB_EVENT_TX_COMPLETE,
+                                   ui32MsgData, (void *)0);
+
+            break;
+        }
+
+        //
+        // Ignore all other events related to transmission of reports via
+        // the interrupt IN endpoint.
+        //
+        default:
+        {
+            break;
+        }
+    }
+
+    return(0);
+}
+
+//*****************************************************************************
+//
+// Main HID device class event receive handler function.
+//
+// \param pvGameDevice is the event callback pointer provided during
+// USBDHIDInit().  This is a pointer to the HID gamepad device structure
+// of the type tUSBDHIDGamepadDevice.
+// \param ui32Event identifies the event we are being called back for.
+// \param ui32MsgData is an event-specific value.
+// \param pvMsgData is an event-specific pointer.
+//
+// This function is called by the lower level HID device class driver to inform
+// the application of particular asynchronous events related to operation of
+// the gamepad HID device.
+//
+// \note This function also receive all generic events as well such as
+// \b USB_EVENT_CONNECTED and USB_EVENT_DISCONNECTED.
+//
+// \return Returns a value which is event-specific.
+//
+//*****************************************************************************
+static uint32_t
+HIDGamepadRxHandler(void *pvGamepad, uint32_t ui32Event, uint32_t ui32MsgData,
+                    void *pvMsgData)
+{
+    tUSBDGamepadInstance *psInst;
+    tUSBDHIDGamepadDevice *psGamepad;
+    uint32_t ui32Ret;
+
+    //
+    // Make sure we did not get a NULL pointer.
+    //
+    ASSERT(pvGamepad);
+
+    //
+    // Return zero by default.
+    //
+    ui32Ret = 0;
+
+    //
+    // Get a pointer to our instance data
+    //
+    psGamepad = (tUSBDHIDGamepadDevice *)pvGamepad;
+    psInst = &psGamepad->sPrivateData;
+
+    //
+    // Which event were we sent?
+    //
+    switch(ui32Event)
+    {
+        //
+        // The host has connected to us and configured the device.
+        //
+        case USB_EVENT_CONNECTED:
+        {
+            //
+            // Now in the idle state.
+            //
+            psInst->iState = eHIDGamepadStateIdle;
+
+            //
+            // Pass the information on to the application.
+            //
+            psGamepad->pfnCallback(psGamepad->pvCBData, USB_EVENT_CONNECTED, 0,
+                                   (void *)0);
+
+            break;
+        }
+
+        //
+        // The host has disconnected from us.
+        //
+        case USB_EVENT_DISCONNECTED:
+        {
+            psInst->iState = eHIDGamepadStateNotConnected;
+
+            //
+            // Pass the information on to the application.
+            //
+            ui32Ret = psGamepad->pfnCallback(psGamepad->pvCBData,
+                                             USB_EVENT_DISCONNECTED, 0,
+                                             (void *)0);
+
+            break;
+        }
+
+        //
+        // This handles the Set Idle command.
+        //
+        case USBD_HID_EVENT_IDLE_TIMEOUT:
+        {
+            //
+            // Give the pointer to the idle report structure.
+            //
+            *(void **)pvMsgData = (void *)&psInst->sReportIdle;
+
+            ui32Ret = sizeof(psInst->sReportIdle);
+
+            break;
+        }
+
+        //
+        // The host is polling for a particular report and the HID driver
+        // is asking for the latest version to transmit.
+        //
+        case USBD_HID_EVENT_GET_REPORT:
+        {
+            //
+            // If this is an IN request then pass the request on to the
+            // application.  All other requests are ignored.
+            //
+            if(ui32MsgData == USB_HID_REPORT_IN)
+            {
+                ui32Ret = psGamepad->pfnCallback(psGamepad->pvCBData,
+                                                 USBD_HID_EVENT_GET_REPORT, 0,
+                                                 pvMsgData);
+            }
+
+            break;
+        }
+
+        //
+        // The device class driver has completed sending a report to the
+        // host in response to a Get_Report request.
+        //
+        case USBD_HID_EVENT_REPORT_SENT:
+        {
+            //
+            // We have nothing to do here.
+            //
+            break;
+        }
+
+        //
+        // Pass these events to the client unchanged.
+        //
+        case USB_EVENT_ERROR:
+        case USB_EVENT_SUSPEND:
+        case USB_EVENT_RESUME:
+        case USB_EVENT_LPM_RESUME:
+        case USB_EVENT_LPM_SLEEP:
+        case USB_EVENT_LPM_ERROR:
+        {
+            ui32Ret = psGamepad->pfnCallback(psGamepad->pvCBData, ui32Event,
+                                             ui32MsgData, pvMsgData);
+
+            break;
+        }
+
+        //
+        // This event is sent in response to a host Set_Report request which
+        // is not supported for gamepads.
+        //
+        case USBD_HID_EVENT_GET_REPORT_BUFFER:
+
+        //
+        // We ignore all other events.
+        //
+        default:
+        {
+            break;
+        }
+    }
+    return(ui32Ret);
+}
+
+//*****************************************************************************
+//
+//! Initializes HID gamepad device operation for a given USB controller.
+//!
+//! \param ui32Index is the index of the USB controller that is to be
+//! initialized for HID gamepad device operation.
+//! \param psGamepad points to a structure containing parameters
+//! customizing the operation of the HID gamepad device.
+//!
+//! An application that enables a USB HID gamepad interface to a USB host
+//! must call this function to initialize the USB controller and attach the
+//! gamepad device to the USB bus.  This function performs all required USB
+//! initialization, and the device is ready for operation on the function
+//! return.
+//!
+//! On successful completion, this function returns the modified \e psGamepad
+//! pointer passed to it or returns a NULL pointer if there was a problem.
+//! This pointer must be passed on all future calls to the HID gamepad device
+//! driver.
+//!
+//! When a host connects and configures the device, the application callback
+//! receives \b USB_EVENT_CONNECTED, after which calls can be made to
+//! USBDHIDGamepadSendReport() to report changes to the gamepad interface to
+//! the USB host when it requests them.
+//!
+//! \note The application must not make any calls to the lower level USB device
+//! interfaces if interacting with USB via the USB HID gamepad device class
+//! API.
+//!
+//! \return Returns NULL on failure or the \e psGamepad pointer on success.
+//
+//*****************************************************************************
+tUSBDHIDGamepadDevice *
+USBDHIDGamepadInit(uint32_t ui32Index, tUSBDHIDGamepadDevice *psGamepad)
+{
+    void *pvRetcode;
+    tUSBDHIDDevice *psHIDDevice;
+    tConfigDescriptor *pConfigDesc;
+
+    //
+    // Check basic parameter validity.
+    //
+    ASSERT(psGamepad);
+    ASSERT(psGamepad->ppui8StringDescriptors);
+    ASSERT(psGamepad->pfnCallback);
+
+    //
+    // Get a pointer to the HID device data.
+    //
+    psHIDDevice = &psGamepad->sPrivateData.sHIDDevice;
+
+    //
+    // Call the common initialization routine.
+    //
+    pvRetcode = USBDHIDGamepadCompositeInit(ui32Index, psGamepad, 0);
+
+    pConfigDesc = (tConfigDescriptor *)g_pui8GameDescriptor;
+    pConfigDesc->bmAttributes = psGamepad->ui8PwrAttributes;
+    pConfigDesc->bMaxPower =  (uint8_t)(psGamepad->ui16MaxPowermA / 2);
+
+    //
+    // If we initialized the HID layer successfully, pass our device pointer
+    // back as the return code, otherwise return NULL to indicate an error.
+    //
+    if(pvRetcode)
+    {
+        //
+        // Initialize the lower layer HID driver and pass it the various
+        // structures and descriptors necessary to declare that we are a
+        // gamepad.
+        //
+        pvRetcode = USBDHIDInit(ui32Index, psHIDDevice);
+
+        return(psGamepad);
+    }
+    else
+    {
+        return((tUSBDHIDGamepadDevice *)0);
+    }
+}
+
+//*****************************************************************************
+//
+//! Initializes HID gamepad device operation for a given USB controller.
+//!
+//! \param ui32Index is the index of the USB controller that is to be
+//! initialized for HID gamepad device operation.
+//! \param psGamepad points to a structure containing parameters
+//! customizing the operation of the HID gamepad device.
+//! \param psCompEntry is the composite device entry to initialize when
+//! creating a composite device.
+//!
+//! This call is very similar to USBDHIDGamepadInit() except that it is used
+//! for initializing an instance of the HID gamepad device for use in a
+//! composite device.  If this HID gamepad is part of a composite device, then
+//! the \e psCompEntry should point to the composite device entry to
+//! initialize.  This entry is part of the array that is passed to the
+//! USBDCompositeInit() function to start up and complete configuration of a
+//! composite USB device.
+//!
+//! \return Returns NULL on failure or the \e psGamepad value that should be
+//! used with the remaining USB HID gamepad APIs.
+//
+//*****************************************************************************
+tUSBDHIDGamepadDevice *
+USBDHIDGamepadCompositeInit(uint32_t ui32Index,
+                            tUSBDHIDGamepadDevice *psGamepad,
+                            tCompositeEntry *psCompEntry)
+{
+    tUSBDGamepadInstance *psInst;
+    tUSBDHIDDevice *psHIDDevice;
+
+    //
+    // Check parameter validity.
+    //
+    ASSERT(psGamepad);
+    ASSERT(psGamepad->ppui8StringDescriptors);
+    ASSERT(psGamepad->pfnCallback);
+
+    //
+    // Get a pointer to our instance data
+    //
+    psInst = &psGamepad->sPrivateData;
+
+    //
+    // Initialize the various fields in our instance structure.
+    //
+    psInst->iState = eHIDGamepadStateNotConnected;
+
+    //
+    // Get a pointer to the HID device data.
+    //
+    psHIDDevice = &psInst->sHIDDevice;
+
+    //
+    // Initialize the HID device class instance structure based on input from
+    // the caller.
+    //
+    psHIDDevice->ui16PID = psGamepad->ui16PID;
+    psHIDDevice->ui16VID = psGamepad->ui16VID;
+    psHIDDevice->ui16MaxPowermA = psGamepad->ui16MaxPowermA;
+    psHIDDevice->ui8PwrAttributes = psGamepad->ui8PwrAttributes;
+    psHIDDevice->ui8Subclass = 0;
+    psHIDDevice->ui8Protocol = 0;
+    psHIDDevice->ui8NumInputReports = 1;
+    psHIDDevice->psReportIdle = &psInst->sReportIdle;
+    psInst->sReportIdle.ui8Duration4mS = 125;
+    psInst->sReportIdle.ui8ReportID = 0;
+    psInst->sReportIdle.ui32TimeSinceReportmS = 0;
+    psInst->sReportIdle.ui16TimeTillNextmS = 0;
+    psHIDDevice->pfnTxCallback = HIDGamepadTxHandler;
+    psHIDDevice->pvRxCBData = (void *)psGamepad;
+    psHIDDevice->pfnRxCallback = HIDGamepadRxHandler;
+    psHIDDevice->pvTxCBData = (void *)psGamepad;
+    psHIDDevice->bUseOutEndpoint = false,
+    psHIDDevice->psHIDDescriptor = &g_sGameHIDDescriptor;
+    psHIDDevice->ppui8ClassDescriptors = g_ppui8GameClassDescriptors;
+    psHIDDevice->ppui8StringDescriptors = psGamepad->ppui8StringDescriptors;
+    psHIDDevice->ui32NumStringDescriptors =
+                                          psGamepad->ui32NumStringDescriptors;
+    psHIDDevice->ppsConfigDescriptor = g_ppsHIDConfigDescriptors;
+
+    //
+    // If there was an override for the report descriptor then use it.
+    //
+    if(psGamepad->pui8ReportDescriptor)
+    {
+        //
+        // Save the report descriptor in the list of report descriptors.
+        //
+        g_ppui8GameClassDescriptors[0] = psGamepad->pui8ReportDescriptor;
+
+        //
+        // Override the report descriptor size.
+        //
+        g_sGameHIDDescriptor.sClassDescriptor[0].wDescriptorLength =
+                                                    psGamepad->ui32ReportSize;
+    }
+
+    //
+    // Initialize the lower layer HID driver and pass it the various structures
+    // and descriptors necessary to declare that we are a gamepad.
+    //
+    return(USBDHIDCompositeInit(ui32Index, psHIDDevice, psCompEntry));
+}
+
+//*****************************************************************************
+//
+//! Schedules a report to be sent once the host requests more data.
+//!
+//! \param psHIDGamepad is the structure pointer that is returned from the
+//! USBDHIDGamepadCompositeInit() or USBDHIDGamepadInit() functions.
+//! \param pvReport is the data to send to the host.
+//! \param ui32Size is the number of bytes in the \e pvReport buffer.
+//!
+//! This call is made by an application to schedule data to be sent to the
+//! host when the host requests an update from the device.  The application
+//! must then wait for a \b USB_EVENT_TX_COMPLETE event in the function
+//! provided in the \e pfnCallback pointer in the tUSBDHIDGamepadDevice
+//! structure before being able to send more data with this function.  The
+//! pointer passed in the \e pvReport can be updated once this call returns as
+//! the data has been copied from the buffer.  The function returns
+//! \b USBDGAMEPAD_SUCCESS if the transmission was successfully scheduled or
+//! \b USBDGAMEPAD_TX_ERROR if the report could not be sent at this time.
+//! If the call is made before the device is connected or ready to communicate
+//! with the host, then the function can return \b USBDGAMEPAD_NOT_CONFIGURED.
+//!
+//! \return The function returns one of the \b USBDGAMEPAD_* values.
+//
+//*****************************************************************************
+uint32_t
+USBDHIDGamepadSendReport(tUSBDHIDGamepadDevice *psHIDGamepad, void *pvReport,
+                         uint32_t ui32Size)
+{
+    uint32_t ui32Retcode, ui32Count;
+    tUSBDGamepadInstance *psInst;
+    tUSBDHIDDevice *psHIDDevice;
+
+    //
+    // Get a pointer to the HID device data.
+    //
+    psHIDDevice = &psHIDGamepad->sPrivateData.sHIDDevice;
+
+    //
+    // Get a pointer to our instance data
+    //
+    psInst = &psHIDGamepad->sPrivateData;
+
+    //
+    // If we are not configured, return an error here before trying to send
+    // anything.
+    //
+    if(psInst->iState == eHIDGamepadStateNotConnected)
+    {
+        return(USBDGAMEPAD_NOT_CONFIGURED);
+    }
+
+    //
+    // Only send a report if the transmitter is currently free.
+    //
+    if(USBDHIDTxPacketAvailable((void *)psHIDDevice))
+    {
+        //
+        // Send the report to the host.
+        //
+        psInst->iState = eHIDGamepadStateSending;
+        ui32Count = USBDHIDReportWrite((void *)psHIDDevice, pvReport, ui32Size,
+                                       true);
+
+        //
+        // Did we schedule a packet for transmission correctly?
+        //
+        if(ui32Count == 0)
+        {
+            //
+            // No - report the error to the caller.
+            //
+            ui32Retcode = USBDGAMEPAD_TX_ERROR;
+        }
+        else
+        {
+            ui32Retcode = USBDGAMEPAD_SUCCESS;
+        }
+    }
+    else
+    {
+        ui32Retcode = USBDGAMEPAD_TX_ERROR;
+    }
+
+    //
+    // Return the relevant error code to the caller.
+    //
+    return(ui32Retcode);
+}
+
+//*****************************************************************************
+//
+//! Shuts down the HID gamepad device.
+//!
+//! \param psGamepad is the pointer to the device instance structure
+//! as returned by USBDHIDGamepadInit() or USBDHIDGamepadCompositeInit().
+//!
+//! This function terminates HID gamepad operation for the instance supplied
+//! and removes the device from the USB bus.  Following this call, the
+//! \e psGamepad instance may not me used in any other call to the HID
+//! gamepad device other than to reinitialize by calling USBDHIDGamepadInit()
+//! or USBDHIDGamepadCompositeInit().
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBDHIDGamepadTerm(tUSBDHIDGamepadDevice *psGamepad)
+{
+    tUSBDHIDDevice *psHIDDevice;
+
+    ASSERT(psGamepad);
+
+    //
+    // Get a pointer to the HID device data.
+    //
+    psHIDDevice = &psGamepad->sPrivateData.sHIDDevice;
+
+    //
+    // Mark the device as no longer connected.
+    //
+    psGamepad->sPrivateData.iState = eHIDGamepadStateNotConnected;
+
+    //
+    // Terminate the low level HID driver.
+    //
+    USBDHIDTerm(psHIDDevice);
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
diff --git a/bsp/tm4c129x/libraries/usblib/device/usbdhidgamepad.h b/bsp/tm4c129x/libraries/usblib/device/usbdhidgamepad.h
new file mode 100755
index 0000000..d54953f
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/device/usbdhidgamepad.h
@@ -0,0 +1,274 @@
+//*****************************************************************************
+//
+// usbdhidgame.h - The header information for using the USB libraries game pad
+// device class.
+//
+// Copyright (c) 2013-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#ifndef __USBDHIDGAME_H__
+#define __USBDHIDGAME_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+//*****************************************************************************
+//
+//! \addtogroup hid_gamepad_device_class_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// PRIVATE
+//
+// This enumeration holds the various states that the game pad can be in during
+// normal operation.  This should not be used by applications and is only
+// here for memory allocation purposes.
+//
+//*****************************************************************************
+typedef enum
+{
+    //
+    // Not yet configured.
+    //
+    eHIDGamepadStateNotConnected,
+
+    //
+    // Nothing to transmit and not waiting on data to be sent.
+    //
+    eHIDGamepadStateIdle,
+
+    //
+    // Waiting on data to be sent.
+    //
+    eHIDGamepadStateSending
+}
+tGamepadState;
+
+//*****************************************************************************
+//
+// PRIVATE
+//
+// This is the structure for an instance of a USB game pad device. This should
+// not be used by applications and is only here for memory allocation purposes.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    // This is needed for the lower level HID driver.
+    //
+    tUSBDHIDDevice sHIDDevice;
+
+    //
+    // The current state of the game pad device.
+    //
+    tGamepadState iState;
+
+    //
+    // The idle timeout control structure for our input report.  This is
+    // required by the lower level HID driver.
+    //
+    tHIDReportIdle sReportIdle;
+} tUSBDGamepadInstance;
+
+//*****************************************************************************
+//
+//! This structure is used by the application to define operating parameters
+//! for the HID game device.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The vendor ID that this device is to present in the device descriptor.
+    //
+    const uint16_t ui16VID;
+
+    //
+    //! The product ID that this device is to present in the device descriptor.
+    //
+    const uint16_t ui16PID;
+
+    //
+    //! The maximum power consumption of the device, expressed in milliamps.
+    //
+    const uint16_t ui16MaxPowermA;
+
+    //
+    //! Indicates whether the device is self- or bus-powered and whether or not
+    //! it supports remote wake up.  Valid values are \b USB_CONF_ATTR_SELF_PWR
+    //! or \b USB_CONF_ATTR_BUS_PWR, optionally ORed with
+    //! \b USB_CONF_ATTR_RWAKE.
+    //
+    const uint8_t ui8PwrAttributes;
+
+    //
+    //! A pointer to the callback function that is called to notify
+    //! the application of general events.  This pointer must point to a valid
+    //! function.
+    //
+    const tUSBCallback pfnCallback;
+
+    //
+    //! A client-supplied pointer that is sent as the first parameter in all
+    //! calls made to the pfnCallback gamedevice callback function.
+    //
+    void *pvCBData;
+
+    //
+    //! A pointer to the string descriptor array for this device.  This array
+    //! must contain the following string descriptor pointers in this order:
+    //! Language descriptor, Manufacturer name string (language 1), Product
+    //! name string (language 1), Serial number string (language 1),HID
+    //! Interface description string (language 1), Configuration description
+    //! string (language 1).
+    //!
+    //! If supporting more than 1 language, the descriptor block (except for
+    //! string descriptor 0) must be repeated for each language defined in the
+    //! language descriptor.
+    //
+    const uint8_t * const *ppui8StringDescriptors;
+
+    //
+    //! The number of descriptors provided in the \e ppStringDescriptors
+    //! array, which must be (1 + (5 * (number of languages))).
+    //
+    const uint32_t ui32NumStringDescriptors;
+
+    //
+    //! Optional report descriptor if the application wants to use a custom
+    //! descriptor.
+    //
+    const uint8_t *pui8ReportDescriptor;
+
+    //
+    //! The size of the optional report descriptor define in
+    //! pui8ReportDescriptor.
+    //
+    const uint32_t ui32ReportSize;
+
+    //
+    //! The private instance data for this device.  This memory must
+    //! remain accessible for as long as the game device is in use and
+    //! must not be modified by any code outside the HID game device driver.
+    //
+    tUSBDGamepadInstance sPrivateData;
+}
+tUSBDHIDGamepadDevice;
+
+//*****************************************************************************
+//
+//! The USBDHIDGamepadSendReport() call successfully scheduled the report.
+//
+//*****************************************************************************
+#define USBDGAMEPAD_SUCCESS     0
+
+//*****************************************************************************
+//
+//! The USBDHIDGamepadSendReport() function could not send the report at this
+//! time.
+//
+//*****************************************************************************
+#define USBDGAMEPAD_TX_ERROR    1
+
+//*****************************************************************************
+//
+//! The device is not currently configured and cannot perform any operations.
+//
+//*****************************************************************************
+#define USBDGAMEPAD_NOT_CONFIGURED \
+                                2
+
+//*****************************************************************************
+//
+//! This structure is the default packed report structure that is sent to the
+//! host.  The application can provide its own structure if the default report
+//! descriptor is overridden by the application.  This structure or an
+//! application-defined structure is passed to the USBDHIDGamepadSendReport
+//! function to send gamepad updates to the host.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! Signed 8-bit value (-128 to 127).
+    //
+    int8_t i8XPos;
+
+    //
+    //! Signed 8-bit value (-128 to 127).
+    //
+    int8_t i8YPos;
+
+    //
+    //! Signed 8-bit value (-128 to 127).
+    //
+    int8_t i8ZPos;
+
+    //
+    //! 8-bit button mapping with button 1 in the LSB.
+    //
+    uint8_t ui8Buttons;
+}
+PACKED tGamepadReport;
+
+//*****************************************************************************
+//
+// API Function Prototypes
+//
+//*****************************************************************************
+extern tUSBDHIDGamepadDevice *USBDHIDGamepadInit(uint32_t ui32Index,
+                                        tUSBDHIDGamepadDevice *psHIDGamepad);
+extern tUSBDHIDGamepadDevice *USBDHIDGamepadCompositeInit(uint32_t ui32Index,
+                                         tUSBDHIDGamepadDevice *psHIDGamepad,
+                                         tCompositeEntry *psCompEntry);
+extern void USBDHIDGamepadTerm(tUSBDHIDGamepadDevice *psCompEntry);
+
+extern uint32_t USBDHIDGamepadSendReport(tUSBDHIDGamepadDevice *psHIDGamepad,
+                                         void *pvReport, uint32_t ui32Size);
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/bsp/tm4c129x/libraries/usblib/device/usbdhidkeyb.c b/bsp/tm4c129x/libraries/usblib/device/usbdhidkeyb.c
new file mode 100755
index 0000000..ebf4d8e
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/device/usbdhidkeyb.c
@@ -0,0 +1,1321 @@
+//*****************************************************************************
+//
+// usbdhidkeyb.c - USB HID Keyboard device class driver.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "inc/hw_types.h"
+#include "driverlib/debug.h"
+#include "driverlib/usb.h"
+#include "usblib/usblib.h"
+#include "usblib/usblibpriv.h"
+#include "usblib/device/usbdevice.h"
+#include "usblib/usbhid.h"
+#include "usblib/device/usbdhid.h"
+#include "usblib/device/usbdhidkeyb.h"
+
+//*****************************************************************************
+//
+//! \addtogroup hid_keyboard_device_class_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// HID device configuration descriptor.
+//
+// It is vital that the configuration descriptor bConfigurationValue field
+// (byte 6) is 1 for the first configuration and increments by 1 for each
+// additional configuration defined here.  This relationship is assumed in the
+// device stack for simplicity even though the USB 2.0 specification imposes
+// no such restriction on the bConfigurationValue values.
+//
+// Note that this structure is deliberately located in RAM since we need to
+// be able to patch some values in it based on client requirements.
+//
+//*****************************************************************************
+static uint8_t g_pui8KeybDescriptor[] =
+{
+    //
+    // Configuration descriptor header.
+    //
+    9,                          // Size of the configuration descriptor.
+    USB_DTYPE_CONFIGURATION,    // Type of this descriptor.
+    USBShort(34),               // The total size of this full structure.
+    1,                          // The number of interfaces in this
+                                // configuration.
+    1,                          // The unique value for this configuration.
+    5,                          // The string identifier that describes this
+                                // configuration.
+    USB_CONF_ATTR_SELF_PWR,     // Bus Powered, Self Powered, remote wake up.
+    250,                        // The maximum power in 2mA increments.
+};
+
+//*****************************************************************************
+//
+// The remainder of the configuration descriptor is stored in flash since we
+// don't need to modify anything in it at runtime.
+//
+//*****************************************************************************
+static uint8_t g_pui8HIDInterface[HIDINTERFACE_SIZE] =
+{
+    //
+    // HID Device Class Interface Descriptor.
+    //
+    9,                          // Size of the interface descriptor.
+    USB_DTYPE_INTERFACE,        // Type of this descriptor.
+    0,                          // The index for this interface.
+    0,                          // The alternate setting for this interface.
+    1,                          // The number of endpoints used by this
+                                // interface.
+    USB_CLASS_HID,              // The interface class
+    USB_HID_SCLASS_BOOT,        // The interface sub-class.
+    USB_HID_PROTOCOL_KEYB,      // The interface protocol for the sub-class
+                                // specified above.
+    4,                          // The string index for this interface.
+};
+
+static const uint8_t g_pui8HIDInEndpoint[HIDINENDPOINT_SIZE] =
+{
+    //
+    // Interrupt IN endpoint descriptor
+    //
+    7,                          // The size of the endpoint descriptor.
+    USB_DTYPE_ENDPOINT,         // Descriptor type is an endpoint.
+    USB_EP_DESC_IN | USBEPToIndex(USB_EP_1),
+    USB_EP_ATTR_INT,            // Endpoint is an interrupt endpoint.
+    USBShort(USBFIFOSizeToBytes(USB_FIFO_SZ_64)),
+                                // The maximum packet size.
+    16,                         // The polling interval for this endpoint.
+};
+
+static const uint8_t g_pui8HIDOutEndpoint[HIDOUTENDPOINT_SIZE] =
+{
+    //
+    // Interrupt OUT endpoint descriptor
+    //
+    7,                          // The size of the endpoint descriptor.
+    USB_DTYPE_ENDPOINT,         // Descriptor type is an endpoint.
+    USB_EP_DESC_OUT | USBEPToIndex(USB_EP_2),
+    USB_EP_ATTR_INT,            // Endpoint is an interrupt endpoint.
+    USBShort(USBFIFOSizeToBytes(USB_FIFO_SZ_64)),
+                                // The maximum packet size.
+    16,                         // The polling interval for this endpoint.
+};
+
+//*****************************************************************************
+//
+// The following is the HID report structure definition that is passed back
+// to the host.
+//
+//*****************************************************************************
+static const uint8_t g_pui8KeybReportDescriptor[] =
+{
+    UsagePage(USB_HID_GENERIC_DESKTOP),
+    Usage(USB_HID_KEYBOARD),
+    Collection(USB_HID_APPLICATION),
+
+        //
+        // Modifier keys.
+        // 8 - 1 bit values indicating the modifier keys (ctrl, shift...)
+        //
+        ReportSize(1),
+        ReportCount(8),
+        UsagePage(USB_HID_USAGE_KEYCODES),
+        UsageMinimum(224),
+        UsageMaximum(231),
+        LogicalMinimum(0),
+        LogicalMaximum(1),
+        Input(USB_HID_INPUT_DATA | USB_HID_INPUT_VARIABLE | USB_HID_INPUT_ABS),
+
+        //
+        // One byte of rsvd data required by HID spec.
+        //
+        ReportCount(1),
+        ReportSize(8),
+        Input(USB_HID_INPUT_CONSTANT),
+
+        //
+        // Keyboard LEDs.
+        // 5 - 1 bit values.
+        //
+        ReportCount(5),
+        ReportSize(1),
+        UsagePage(USB_HID_USAGE_LEDS),
+        UsageMinimum(1),
+        UsageMaximum(5),
+        Output(USB_HID_OUTPUT_DATA | USB_HID_OUTPUT_VARIABLE |
+               USB_HID_OUTPUT_ABS),
+        //
+        // 1 - 3 bit value to pad out to a full byte.
+        //
+        ReportCount(1),
+        ReportSize(3),
+        Output(USB_HID_OUTPUT_CONSTANT), //LED report padding
+
+        //
+        // The Key buffer.
+        // 6 - 8 bit values to store the current key state.
+        //
+        ReportCount(6),
+        ReportSize(8),
+        LogicalMinimum(0),
+        LogicalMaximum(101),
+        UsagePage(USB_HID_USAGE_KEYCODES),
+        UsageMinimum (0),
+        UsageMaximum (101),
+        Input(USB_HID_INPUT_DATA | USB_HID_INPUT_ARRAY),
+    EndCollection
+};
+
+//*****************************************************************************
+//
+// The HID descriptor for the keyboard device.
+//
+//*****************************************************************************
+static const tHIDDescriptor g_sKeybHIDDescriptor =
+{
+    9,                              // bLength
+    USB_HID_DTYPE_HID,              // bDescriptorType
+    0x111,                          // bcdHID (version 1.11 compliant)
+    0,                              // bCountryCode (not localized)
+    1,                              // bNumDescriptors
+    {
+        {
+            USB_HID_DTYPE_REPORT,   // Report descriptor
+            sizeof(g_pui8KeybReportDescriptor)
+                                    // Size of report descriptor
+        }
+    }
+};
+
+//*****************************************************************************
+//
+// The HID configuration descriptor is defined as four or five sections
+// depending upon the client's configuration choice.  These sections are:
+//
+// 1.  The 9 byte configuration descriptor (RAM).
+// 2.  The interface descriptor (RAM).
+// 3.  The HID report and physical descriptors (provided by the client)
+//     (FLASH).
+// 4.  The mandatory interrupt IN endpoint descriptor (FLASH).
+// 5.  The optional interrupt OUT endpoint descriptor (FLASH).
+//
+//*****************************************************************************
+static const tConfigSection g_sHIDConfigSection =
+{
+    sizeof(g_pui8KeybDescriptor),
+    g_pui8KeybDescriptor
+};
+
+static const tConfigSection g_sHIDInterfaceSection =
+{
+    sizeof(g_pui8HIDInterface),
+    g_pui8HIDInterface
+};
+
+static const tConfigSection g_sHIDInEndpointSection =
+{
+    sizeof(g_pui8HIDInEndpoint),
+    g_pui8HIDInEndpoint
+};
+
+static const tConfigSection g_sHIDOutEndpointSection =
+{
+    sizeof(g_pui8HIDOutEndpoint),
+    g_pui8HIDOutEndpoint
+};
+
+//*****************************************************************************
+//
+// Place holder for the user's HID descriptor block.
+//
+//*****************************************************************************
+static tConfigSection g_sHIDDescriptorSection =
+{
+   sizeof(g_sKeybHIDDescriptor),
+   (const uint8_t *)&g_sKeybHIDDescriptor
+};
+
+//*****************************************************************************
+//
+// This array lists all the sections that must be concatenated to make a
+// single, complete HID configuration descriptor.
+//
+//*****************************************************************************
+static const tConfigSection *g_psHIDSections[] =
+{
+    &g_sHIDConfigSection,
+    &g_sHIDInterfaceSection,
+    &g_sHIDDescriptorSection,
+    &g_sHIDInEndpointSection,
+    &g_sHIDOutEndpointSection
+};
+
+#define NUM_HID_SECTIONS        ((sizeof(g_psHIDSections) /                   \
+                                  sizeof(g_psHIDSections[0])) - 1)
+
+//*****************************************************************************
+//
+// The header for the single configuration we support.  This is the root of
+// the data structure that defines all the bits and pieces that are pulled
+// together to generate the configuration descriptor.  Note that this must be
+// in RAM since we need to include or exclude the final section based on
+// client supplied initialization parameters.
+//
+//*****************************************************************************
+static tConfigHeader g_sHIDConfigHeader =
+{
+    NUM_HID_SECTIONS,
+    g_psHIDSections
+};
+
+//*****************************************************************************
+//
+// Configuration Descriptor.
+//
+//*****************************************************************************
+static const tConfigHeader * const g_ppsHIDConfigDescriptors[] =
+{
+    &g_sHIDConfigHeader
+};
+
+//*****************************************************************************
+//
+// The HID class descriptor table.  For the keyboard class, we have only a
+// single report descriptor.
+//
+//*****************************************************************************
+static const uint8_t * const g_pui8KeybClassDescriptors[] =
+{
+    g_pui8KeybReportDescriptor
+};
+
+//*****************************************************************************
+//
+// Forward references for keyboard device callback functions.
+//
+//*****************************************************************************
+static uint32_t HIDKeyboardRxHandler(void *pvKeyboardDevice, uint32_t ui32Event,
+                                     uint32_t ui32MsgData, void *pvMsgData);
+static uint32_t HIDKeyboardTxHandler(void *pvKeyboardDevice, uint32_t ui32Event,
+                                     uint32_t ui32MsgData, void *pvMsgData);
+
+//*****************************************************************************
+//
+// Main HID device class event handler function.
+//
+// \param pvKeyboardDevice is the event callback pointer provided during
+//  USBDHIDInit().This is a pointer to our HID device structure
+// (&g_sHIDKeybDevice).
+// \param ui32Event identifies the event we are being called back for.
+// \param ui32MsgData is an event-specific value.
+// \param pvMsgData is an event-specific pointer.
+//
+// This function is called by the HID device class driver to inform the
+// application of particular asynchronous events related to operation of the
+// keyboard HID device.
+//
+// \return Returns a value which is event-specific.
+//
+//*****************************************************************************
+static uint32_t
+HIDKeyboardRxHandler(void *pvKeyboardDevice, uint32_t ui32Event,
+                     uint32_t ui32MsgData, void *pvMsgData)
+{
+    tHIDKeyboardInstance *psInst;
+    tUSBDHIDKeyboardDevice *psKeyboardDevice;
+
+    //
+    // Make sure we did not get a NULL pointer.
+    //
+    ASSERT(pvKeyboardDevice);
+
+    //
+    // Get a pointer to our instance data
+    //
+    psKeyboardDevice = (tUSBDHIDKeyboardDevice *)pvKeyboardDevice;
+    psInst = &psKeyboardDevice->sPrivateData;
+
+    //
+    // Which event were we sent?
+    //
+    switch (ui32Event)
+    {
+        //
+        // The host has connected to us and configured the device.
+        //
+        case USB_EVENT_CONNECTED:
+        {
+            psInst->ui8USBConfigured = true;
+
+            //
+            // Pass the information on to the client.
+            //
+            psKeyboardDevice->pfnCallback(psKeyboardDevice->pvCBData,
+                                          USB_EVENT_CONNECTED, 0, (void *)0);
+
+            break;
+        }
+
+        //
+        // The host has disconnected from us.
+        //
+        case USB_EVENT_DISCONNECTED:
+        {
+            psInst->ui8USBConfigured = false;
+
+            //
+            // Pass the information on to the client.
+            //
+            psKeyboardDevice->pfnCallback(psKeyboardDevice->pvCBData,
+                                          USB_EVENT_DISCONNECTED, 0,
+                                          (void *)0);
+
+            break;
+        }
+
+        //
+        // The host is polling us for a particular report and the HID driver
+        // is asking for the latest version to transmit.
+        //
+        case USBD_HID_EVENT_IDLE_TIMEOUT:
+        case USBD_HID_EVENT_GET_REPORT:
+        {
+            //
+            // We only support a single input report so we don't need to check
+            // the ui32MsgValue parameter in this case.  Set the report pointer
+            // in *pvMsgData and return the length of the report in bytes.
+            //
+            *(uint8_t **)pvMsgData = psInst->pui8Report;
+            return(KEYB_IN_REPORT_SIZE);
+        }
+
+        //
+        // The device class driver has completed sending a report to the
+        // host in response to a Get_Report request.
+        //
+        case USBD_HID_EVENT_REPORT_SENT:
+        {
+            //
+            // We have nothing to do here.
+            //
+            break;
+        }
+
+        //
+        // This event is sent in response to a host Set_Report request.  We
+        // must return a pointer to a buffer large enough to receive the
+        // report into.
+        //
+        case USBD_HID_EVENT_GET_REPORT_BUFFER:
+        {
+            //
+            // Are we being asked for a report that is shorter than the storage
+            // we have set aside for this?  The only output report we define is
+            // 8 bits long so we really expect to see a length of 1 passed.
+            //
+            if((uint32_t)pvMsgData == KEYB_OUT_REPORT_SIZE )
+            {
+                //
+                // Yes - return our pointer.
+                //
+                return((uint32_t)psInst->pui8DataBuffer);
+            }
+            else
+            {
+                //
+                // We are being passed a report that is longer than the
+                // only report we expect so return NULL.  This causes the
+                // device class driver to stall the request.
+                //
+                return(0);
+            }
+        }
+
+        //
+        // This event indicates that the host has sent us an Output or
+        // Feature report and that the report is now in the buffer we provided
+        // on the previous USBD_HID_EVENT_GET_REPORT_BUFFER callback.
+        //
+        case USBD_HID_EVENT_SET_REPORT:
+        {
+            //
+            // Inform the application if the keyboard LEDs have changed.
+            //
+            if(psInst->ui8LEDStates != psInst->pui8DataBuffer[0])
+            {
+                //
+                // Note the new LED states.
+                //
+                psInst->ui8LEDStates = psInst->pui8DataBuffer[0];
+
+                //
+                // Pass the information on to the client.
+                //
+                psKeyboardDevice->pfnCallback(
+                                            psKeyboardDevice->pvCBData,
+                                            USBD_HID_KEYB_EVENT_SET_LEDS,
+                                            psInst->pui8DataBuffer[0],
+                                            (void *)0);
+            }
+            break;
+        }
+
+        //
+        // The host is asking us to set either boot or report protocol (not
+        // that it makes any difference to this particular mouse).
+        //
+        case USBD_HID_EVENT_SET_PROTOCOL:
+        {
+            psInst->ui8Protocol = ui32MsgData;
+            break;
+        }
+
+        //
+        // The host is asking us to tell it which protocol we are currently
+        // using, boot or request.
+        //
+        case USBD_HID_EVENT_GET_PROTOCOL:
+        {
+            return(psInst->ui8Protocol);
+        }
+
+        //
+        // Pass ERROR, SUSPEND and RESUME to the client unchanged.
+        //
+        case USB_EVENT_ERROR:
+        case USB_EVENT_SUSPEND:
+        case USB_EVENT_RESUME:
+        case USB_EVENT_LPM_RESUME:
+        case USB_EVENT_LPM_SLEEP:
+        case USB_EVENT_LPM_ERROR:
+        {
+            return(psKeyboardDevice->pfnCallback(
+                                         psKeyboardDevice->pvCBData,
+                                         ui32Event, ui32MsgData, pvMsgData));
+        }
+
+        //
+        // We ignore all other events.
+        //
+        default:
+        {
+            break;
+        }
+    }
+    return(0);
+}
+
+//*****************************************************************************
+//
+// HID device class transmit channel event handler function.
+//
+// \param pvKeyboardDevice is the event callback pointer provided during
+// USBDHIDInit().  This is a pointer to our HID device structure
+// (&g_sHIDKeybDevice).
+// \param ui32Event identifies the event we are being called back for.
+// \param ui32MsgData is an event-specific value.
+// \param pvMsgData is an event-specific pointer.
+//
+// This function is called by the HID device class driver to inform the
+// application of particular asynchronous events related to report
+// transmissions made using the interrupt IN endpoint.
+//
+// \return Returns a value which is event-specific.
+//
+//*****************************************************************************
+static uint32_t
+HIDKeyboardTxHandler(void *pvKeyboardDevice, uint32_t ui32Event,
+                     uint32_t ui32MsgData, void *pvMsgData)
+{
+    tHIDKeyboardInstance *psInst;
+    tUSBDHIDKeyboardDevice *psHIDKbDevice;
+    tUSBDHIDDevice *psHIDDevice;
+    uint32_t ui32Count;
+
+    //
+    // Make sure we did not get a NULL pointer.
+    //
+    ASSERT(pvKeyboardDevice);
+
+    //
+    // Get a pointer to our instance data
+    //
+    psHIDKbDevice = (tUSBDHIDKeyboardDevice *)pvKeyboardDevice;
+    psInst = &psHIDKbDevice->sPrivateData;
+    psHIDDevice = &psInst->sHIDDevice;
+
+    //
+    // Which event were we sent?
+    //
+    switch (ui32Event)
+    {
+        //
+        // A report transmitted via the interrupt IN endpoint was acknowledged
+        // by the host.
+        //
+        case USB_EVENT_TX_COMPLETE:
+        {
+            //
+            // Do we have any pending changes needing transmitted?
+            //
+            if(psInst->bChangeMade)
+            {
+                //
+                // Yes - go ahead and send another report immediately.
+                //
+                ui32Count = USBDHIDReportWrite((void *)psHIDDevice,
+                                             psInst->pui8Report,
+                                             KEYB_IN_REPORT_SIZE, true);
+
+                //
+                // If we scheduled the report for transmission, clear the
+                // change flag.
+                //
+                if(ui32Count != 0)
+                {
+                    psInst->bChangeMade = false;
+                }
+            }
+            else
+            {
+                //
+                // Our last transmission is complete and we have nothing more
+                // to send.
+                //
+                psInst->eKeyboardState = HID_KEYBOARD_STATE_IDLE;
+            }
+
+            //
+            // Pass the event on to the client.
+            //
+            psHIDKbDevice->pfnCallback(psHIDKbDevice->pvCBData,
+                                       USB_EVENT_TX_COMPLETE, ui32MsgData,
+                                       (void *)0);
+
+            break;
+        }
+
+        //
+        // We ignore all other events related to transmission of reports via
+        // the interrupt IN endpoint.
+        //
+        default:
+        {
+            break;
+        }
+    }
+
+    return(0);
+}
+
+//*****************************************************************************
+//
+// Add the supplied usage code to the list of keys currently in the pressed
+// state.
+//
+// \param ui8UsageCode is the HID usage code of the newly pressed key.
+//
+// This function adds the supplied usage code to the global list of keys which
+// are currently pressed (assuming it is not already noted as pressed and that
+// there is space in the list to hold the new information).  The return code
+// indicates success if the list did not overflow and failure if the list
+// already contains as many pressed keys as can be reported.
+//
+// \return Returns \b true if the usage code was successfully added to the
+// list or \b false if there was insufficient space to hold the new key
+// press (in which case the caller should report a roll over error to the
+// host).
+//
+//*****************************************************************************
+static bool
+AddKeyToPressedList(tHIDKeyboardInstance *psInst, uint8_t ui8UsageCode)
+{
+    uint32_t ui32Loop;
+    bool bRetcode;
+
+    //
+    // Assume all is well until we determine otherwise.
+    //
+    bRetcode = true;
+
+    //
+    // Look through the list of existing pressed keys to see if the new one
+    // is already there.
+    //
+    for(ui32Loop = 0; ui32Loop < (uint32_t)psInst->ui8KeyCount; ui32Loop++)
+    {
+        //
+        // Is this key already included in the list of keys in the pressed
+        // state?
+        //
+        if(ui8UsageCode == psInst->pui8KeysPressed[ui32Loop])
+        {
+            //
+            // Yes - drop out.
+            //
+            break;
+        }
+    }
+
+    //
+    // If we exited the loop at the end of the existing key presses, this
+    // key does not exist already so add it if space exists.
+    //
+    if(ui32Loop >= psInst->ui8KeyCount)
+    {
+        if(psInst->ui8KeyCount < KEYB_MAX_CHARS_PER_REPORT)
+        {
+            //
+            // We have room so store the new key press in the list.
+            //
+            psInst->pui8KeysPressed[psInst->ui8KeyCount] = ui8UsageCode;
+            psInst->ui8KeyCount++;
+            bRetcode = true;
+        }
+        else
+        {
+            //
+            // We have no room for the new key - declare a rollover error.
+            //
+            bRetcode = false;
+        }
+    }
+
+    return(bRetcode);
+}
+
+//*****************************************************************************
+//
+// Remove the supplied usage code from the list of keys currently in the
+// pressed state.
+//
+// \param ui8UsageCode is the HID usage code of the newly released key.
+//
+// This function removes the supplied usage code from the global list of keys
+// which are currently pressed.  The return code indicates whether the key was
+// found in the list.  On exit, the list has been cleaned up to ensure
+// that all key presses are contiguous starting at the first entry.
+//
+// \return Returns \b true if the usage code was found and removed from the
+// list or \b false if the code was not found.  The caller need not pass a new
+// report to the host if \b false is returned since the key list has not
+// changed.
+//
+//*****************************************************************************
+static bool
+RemoveKeyFromPressedList(tHIDKeyboardInstance *psInst,
+                         uint8_t ui8UsageCode)
+{
+    uint32_t ui32Loop;
+    uint32_t ui32Pos;
+
+    //
+    // Keep the compiler happy by setting ui32Pos to something.
+    //
+    ui32Pos = 0;
+
+    //
+    // Find the usage code in the current list.
+    //
+    for(ui32Loop = 0; ui32Loop < KEYB_MAX_CHARS_PER_REPORT; ui32Loop++)
+    {
+        if(psInst->pui8KeysPressed[ui32Loop] == ui8UsageCode)
+        {
+            ui32Pos = ui32Loop;
+            break;
+        }
+    }
+
+    //
+    // If we dropped out at the end of the loop, we could not find the code so
+    // just return false.
+    //
+    if(ui32Loop == KEYB_MAX_CHARS_PER_REPORT)
+    {
+        return(false);
+    }
+
+    //
+    // Now shuffle all the values to the right of the usage code we found
+    // down one position to fill the gap left by removing it.
+    //
+    for(ui32Loop = (ui32Pos + 1); ui32Loop < KEYB_MAX_CHARS_PER_REPORT;
+        ui32Loop++)
+    {
+        psInst->pui8KeysPressed[ui32Loop - 1] =
+                                        psInst->pui8KeysPressed[ui32Loop];
+    }
+
+    //
+    // Clear the last entry in the array and adjust the number of keys in the
+    // array.
+    //
+    psInst->pui8KeysPressed[KEYB_MAX_CHARS_PER_REPORT - 1] =
+                                                    HID_KEYB_USAGE_RESERVED;
+    psInst->ui8KeyCount--;
+
+    //
+    // Tell the caller we were successful.
+    //
+    return(true);
+}
+
+//*****************************************************************************
+//
+//! Initializes HID keyboard device operation for a given USB controller.
+//!
+//! \param ui32Index is the index of the USB controller which is to be
+//! initialized for HID keyboard device operation.
+//! \param psHIDKbDevice points to a structure containing parameters
+//! customizing the operation of the HID keyboard device.
+//!
+//! An application wishing to offer a USB HID keyboard interface to a USB host
+//! must call this function to initialize the USB controller and attach the
+//! keyboard device to the USB bus.  This function performs all required USB
+//! initialization.
+//!
+//! On successful completion, this function returns the \e psHIDKbDevice
+//! pointer passed to it.  This must be passed on all future calls to the HID
+//! keyboard device driver.
+//!
+//! When a host connects and configures the device, the application callback
+//! receives \b USB_EVENT_CONNECTED after which calls can be made to
+//! USBDHIDKeyboardKeyStateChange() to report key presses and releases to the
+//! USB host.
+//!
+//! \note The application must not make any calls to the lower level USB device
+//! interfaces if interacting with USB via the USB HID keyboard device class
+//! API.  Doing so causes unpredictable (though almost certainly
+//! unpleasant) behavior.
+//!
+//! \return Returns NULL on failure or the \e psHIDKbDevice pointer on success.
+//
+//*****************************************************************************
+void *
+USBDHIDKeyboardInit(uint32_t ui32Index, tUSBDHIDKeyboardDevice *psHIDKbDevice)
+{
+    void *pvRetcode;
+    tUSBDHIDDevice *psHIDDevice;
+    tConfigDescriptor *pConfigDesc;
+
+    //
+    // Check parameter validity.
+    //
+    ASSERT(psHIDKbDevice);
+    ASSERT(psHIDKbDevice->ppui8StringDescriptors);
+    ASSERT(psHIDKbDevice->pfnCallback);
+
+    //
+    // Get a pointer to the HID device data.
+    //
+    psHIDDevice = &psHIDKbDevice->sPrivateData.sHIDDevice;
+
+    //
+    // Call the common initialization routine.
+    //
+    pvRetcode = USBDHIDKeyboardCompositeInit(ui32Index, psHIDKbDevice, 0);
+
+    pConfigDesc = (tConfigDescriptor *)g_pui8KeybDescriptor;
+    pConfigDesc->bmAttributes = psHIDKbDevice->ui8PwrAttributes;
+    pConfigDesc->bMaxPower =  (uint8_t)(psHIDKbDevice->ui16MaxPowermA / 2);
+
+    //
+    // If we initialized the HID layer successfully, pass our device pointer
+    // back as the return code, otherwise return NULL to indicate an error.
+    //
+    if(pvRetcode)
+    {
+        //
+        // Initialize the lower layer HID driver and pass it the various
+        // structures and descriptors necessary to declare that we are a
+        // keyboard.
+        //
+        pvRetcode = USBDHIDInit(ui32Index, psHIDDevice);
+
+        return((void *)psHIDKbDevice);
+    }
+    else
+    {
+        return((void *)0);
+    }
+}
+
+//*****************************************************************************
+//
+//! Initializes HID keyboard device operation for a given USB controller.
+//!
+//! \param ui32Index is the index of the USB controller which is to be
+//! initialized for HID keyboard device operation.
+//! \param psHIDKbDevice points to a structure containing parameters
+//! customizing the operation of the HID keyboard device.
+//! \param psCompEntry is the composite device entry to initialize when
+//! creating a composite device.
+//!
+//! This call is very similar to USBDHIDKeyboardInit() except that it is used
+//! for initializing an instance of the HID keyboard device for use in a
+//! composite device.  If this HID keyboard is part of a composite device, then
+//! the \e psCompEntry should point to the composite device entry to
+//! initialize. This is part of the array that is passed to the
+//! USBDCompositeInit() function.
+//!
+//! \return Returns zero on failure or a non-zero instance value that should be
+//! used with the remaining USB HID Keyboard APIs.
+//
+//*****************************************************************************
+void *
+USBDHIDKeyboardCompositeInit(uint32_t ui32Index,
+                             tUSBDHIDKeyboardDevice *psHIDKbDevice,
+                             tCompositeEntry *psCompEntry)
+{
+    tHIDKeyboardInstance *psInst;
+    uint32_t ui32Loop;
+    tUSBDHIDDevice *psHIDDevice;
+
+    //
+    // Check parameter validity.
+    //
+    ASSERT(psHIDKbDevice);
+    ASSERT(psHIDKbDevice->ppui8StringDescriptors);
+    ASSERT(psHIDKbDevice->pfnCallback);
+
+    //
+    // Get a pointer to our instance data
+    //
+    psInst = &psHIDKbDevice->sPrivateData;
+
+    //
+    // Initialize the various fields in our instance structure.
+    //
+    psInst->ui8USBConfigured = 0;
+    psInst->ui8Protocol = USB_HID_PROTOCOL_REPORT;
+    psInst->sReportIdle.ui8Duration4mS = 125;
+    psInst->sReportIdle.ui8ReportID = 0;
+    psInst->sReportIdle.ui32TimeSinceReportmS = 0;
+    psInst->sReportIdle.ui16TimeTillNextmS = 0;
+    psInst->ui8LEDStates = 0;
+    psInst->ui8KeyCount = 0;
+    for(ui32Loop = 0; ui32Loop < KEYB_MAX_CHARS_PER_REPORT; ui32Loop++)
+    {
+        psInst->pui8KeysPressed[ui32Loop] = HID_KEYB_USAGE_RESERVED;
+    }
+
+    psInst->eKeyboardState = HID_KEYBOARD_STATE_UNCONFIGURED;
+
+    //
+    // Get a pointer to the HID device data.
+    //
+    psHIDDevice = &psInst->sHIDDevice;
+
+    //
+    // Initialize the HID device class instance structure based on input from
+    // the caller.
+    //
+    psHIDDevice->ui16PID = psHIDKbDevice->ui16PID;
+    psHIDDevice->ui16VID = psHIDKbDevice->ui16VID;
+    psHIDDevice->ui16MaxPowermA = psHIDKbDevice->ui16MaxPowermA;
+    psHIDDevice->ui8PwrAttributes = psHIDKbDevice->ui8PwrAttributes;
+    psHIDDevice->ui8Subclass = USB_HID_SCLASS_BOOT;
+    psHIDDevice->ui8Protocol = USB_HID_PROTOCOL_KEYB;
+    psHIDDevice->ui8NumInputReports = 1;
+    psHIDDevice->psReportIdle = 0;
+    psHIDDevice->pfnRxCallback = HIDKeyboardRxHandler;
+    psHIDDevice->pvRxCBData = (void *)psHIDKbDevice;
+    psHIDDevice->pfnTxCallback = HIDKeyboardTxHandler;
+    psHIDDevice->pvTxCBData = (void *)psHIDKbDevice;
+    psHIDDevice->bUseOutEndpoint = false,
+
+    psHIDDevice->psHIDDescriptor = &g_sKeybHIDDescriptor;
+    psHIDDevice->ppui8ClassDescriptors = g_pui8KeybClassDescriptors;
+    psHIDDevice->ppui8StringDescriptors =
+                                        psHIDKbDevice->ppui8StringDescriptors;
+    psHIDDevice->ui32NumStringDescriptors =
+                                        psHIDKbDevice->ui32NumStringDescriptors;
+    psHIDDevice->ppsConfigDescriptor = g_ppsHIDConfigDescriptors;
+
+    psHIDDevice->psReportIdle = &psInst->sReportIdle;
+
+    //
+    // Initialize the lower layer HID driver and pass it the various structures
+    // and descriptors necessary to declare that we are a keyboard.
+    //
+    return(USBDHIDCompositeInit(ui32Index, psHIDDevice, psCompEntry));
+}
+
+//*****************************************************************************
+//
+//! Shuts down the HID keyboard device.
+//!
+//! \param pvKeyboardDevice is the pointer to the device instance structure
+//! as returned by USBDHIDKeyboardInit().
+//!
+//! This function terminates HID keyboard operation for the instance supplied
+//! and removes the device from the USB bus.  Following this call, the
+//! \e pvKeyboardDevice instance may not me used in any other call to the HID
+//! keyboard device other than USBDHIDKeyboardInit().
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBDHIDKeyboardTerm(void *pvKeyboardDevice)
+{
+    tUSBDHIDKeyboardDevice *psHIDKbDevice;
+    tUSBDHIDDevice *psHIDDevice;
+
+    ASSERT(pvKeyboardDevice);
+
+    //
+    // Get a pointer to the device.
+    //
+    psHIDKbDevice = (tUSBDHIDKeyboardDevice *)pvKeyboardDevice;
+
+    //
+    // Get a pointer to the HID device data.
+    //
+    psHIDDevice = &psHIDKbDevice->sPrivateData.sHIDDevice;
+
+    //
+    // Mark the device as no longer configured.
+    //
+    psHIDKbDevice->sPrivateData.ui8USBConfigured = 0;
+
+    //
+    // Terminate the low level HID driver.
+    //
+    USBDHIDTerm(psHIDDevice);
+}
+
+//*****************************************************************************
+//
+//! Sets the client-specific pointer parameter for the keyboard callback.
+//!
+//! \param pvKeyboardDevice is the pointer to the device instance structure
+//! as returned by USBDHIDKeyboardInit().
+//! \param pvCBData is the pointer that client wishes to be provided on each
+//! event sent to the keyboard callback function.
+//!
+//! The client uses this function to change the callback pointer passed in
+//! the first parameter on all callbacks to the \e pfnCallback function
+//! passed on USBDHIDKeyboardInit().
+//!
+//! If a client wants to make runtime changes in the callback pointer, it must
+//! ensure that the \e pvKeyboardDevice structure passed to
+//! USBDHIDKeyboardInit() resides in RAM.  If this structure is in flash,
+//! callback data changes is not possible.
+//!
+//! \return Returns the previous callback pointer that was set for this
+//! instance.
+//
+//*****************************************************************************
+void *
+USBDHIDKeyboardSetCBData(void *pvKeyboardDevice, void *pvCBData)
+{
+    void *pvOldCBData;
+    tUSBDHIDKeyboardDevice *psKeyboard;
+
+    //
+    // Check for a NULL pointer in the device parameter.
+    //
+    ASSERT(pvKeyboardDevice);
+
+    //
+    // Get a pointer to our keyboard device.
+    //
+    psKeyboard = (tUSBDHIDKeyboardDevice *)pvKeyboardDevice;
+
+    //
+    // Save the old callback pointer and replace it with the new value.
+    //
+    pvOldCBData = psKeyboard->pvCBData;
+    psKeyboard->pvCBData = pvCBData;
+
+    //
+    // Pass the old callback pointer back to the caller.
+    //
+    return(pvOldCBData);
+}
+
+//*****************************************************************************
+//
+//! Reports a key state change to the USB host.
+//!
+//! \param pvKeyboardDevice is the pointer to the device instance structure
+//! as returned by USBDHIDKeyboardInit().
+//! \param ui8Modifiers contains the states of each of the keyboard modifiers
+//! (left/right shift, ctrl, alt or GUI keys).  Valid values are logical OR
+//! combinations of the labels \b HID_KEYB_LEFT_CTRL, \b HID_KEYB_LEFT_SHIFT,
+//! \b HID_KEYB_LEFT_ALT, \b HID_KEYB_LEFT_GUI, \b HID_KEYB_RIGHT_CTRL, \b
+//! HID_KEYB_RIGHT_SHIFT, \b HID_KEYB_RIGHT_ALT and \b HID_KEYB_RIGHT_GUI.
+//! Presence of one of these bit flags indicates that the relevant modifier
+//! key is pressed and absence indicates that it is released.
+//! \param ui8UsageCode is the usage code of the key whose state has changed.
+//! If only modifier keys have changed, \b HID_KEYB_USAGE_RESERVED should be
+//! passed in this parameter.
+//! \param bPress is \b true if the key has been pressed or \b false if it has
+//! been released.  If only modifier keys have changed state, this parameter is
+//! ignored.
+//!
+//! This function adds or removes a key usage code from the list of keys
+//! currently pressed and schedules a report transmission to the host to
+//! inform it of the new keyboard state.  If the maximum number of simultaneous
+//! key presses are already recorded, the report to the host contains the
+//! rollover error code, \b HID_KEYB_USAGE_ROLLOVER instead of key usage codes
+//! and the caller receives return code \b KEYB_ERR_TOO_MANY_KEYS.
+//!
+//! \return Returns \b KEYB_SUCCESS if the key usage code was added to or
+//! removed from the current list successfully.  \b KEYB_ERR_TOO_MANY_KEYS is
+//! returned if an attempt is made to press a 7th key (the BIOS keyboard
+//! protocol can report no more than 6 simultaneously pressed keys).  If called
+//! before the USB host has configured the device, \b KEYB_ERR_NOT_CONFIGURED
+//! is returned and, if an error is reported while attempting to transmit the
+//! report, \b KEYB_ERR_TX_ERROR is returned.  If an attempt is made to remove
+//! a key from the pressed list (by setting parameter \e bPressed to \b false)
+//! but the key usage code is not found, \b KEYB_ERR_NOT_FOUND is returned.
+//
+//*****************************************************************************
+uint32_t
+USBDHIDKeyboardKeyStateChange(void *pvKeyboardDevice, uint8_t ui8Modifiers,
+                              uint8_t ui8UsageCode, bool bPress)
+{
+    bool bRetcode;
+    uint32_t ui32Loop, ui32Count;
+    tHIDKeyboardInstance *psInst;
+    tUSBDHIDKeyboardDevice *psHIDKbDevice;
+    tUSBDHIDDevice *psHIDDevice;
+
+    psHIDKbDevice = (tUSBDHIDKeyboardDevice *)pvKeyboardDevice;
+
+    //
+    // Get a pointer to the HID device data.
+    //
+    psHIDDevice = &psHIDKbDevice->sPrivateData.sHIDDevice;
+
+    //
+    // Assume all is well until we determine otherwise.
+    //
+    bRetcode = true;
+
+    //
+    // Get a pointer to our instance data
+    //
+    psInst = &psHIDKbDevice->sPrivateData;
+
+    //
+    // Update the global keyboard report with the information passed.
+    //
+    psInst->pui8Report[0] = ui8Modifiers;
+    psInst->pui8Report[1] = 0;
+
+    //
+    // Were we passed a usage code for a new key press or release or was
+    // this call just telling us about a modifier change?
+    //
+    if(ui8UsageCode != HID_KEYB_USAGE_RESERVED)
+    {
+        //
+        // Has a key been pressed or released?
+        //
+        if(bPress)
+        {
+            //
+            // A key has been pressed - add it to the list if there is space an
+            // and the key is not already in the list.
+            //
+            bRetcode = AddKeyToPressedList(psInst, ui8UsageCode);
+        }
+        else
+        {
+            //
+            // A key has been released - remove it from the list.
+            //
+            bRetcode = RemoveKeyFromPressedList(psInst, ui8UsageCode);
+
+            //
+            // The return code here indicates whether the key was found.  If it
+            // wasn't, the list has not changes so merely exit at this point
+            // without sending anything to the host.
+            //
+            if(!bRetcode)
+            {
+                return(KEYB_ERR_NOT_FOUND);
+            }
+        }
+
+        //
+        // Build the report from the current list of keys.  If we added a key
+        // and got a bad return code indicating a roll over error, we need to
+        // send a roll over report
+        //
+        for(ui32Loop = 0; ui32Loop < KEYB_MAX_CHARS_PER_REPORT; ui32Loop++)
+        {
+            psInst->pui8Report[2 + ui32Loop] = (bRetcode ?
+                psInst->pui8KeysPressed[ui32Loop] : HID_KEYB_USAGE_ROLLOVER);
+        }
+    }
+
+    //
+    // If we are not configured, return an error here before trying to send
+    // anything.
+    //
+    if(!psInst->ui8USBConfigured)
+    {
+        return(KEYB_ERR_NOT_CONFIGURED);
+    }
+
+    //
+    // Only send a report if the transmitter is currently free.
+    //
+    if(USBDHIDTxPacketAvailable((void *)psHIDDevice))
+    {
+        //
+        // Send the report to the host.
+        //
+        psInst->eKeyboardState = HID_KEYBOARD_STATE_SEND;
+        ui32Count = USBDHIDReportWrite((void *)psHIDDevice,
+                                       psInst->pui8Report, KEYB_IN_REPORT_SIZE,
+                                       true);
+
+        //
+        // Did we schedule a packet for transmission correctly?
+        //
+        if(!ui32Count)
+        {
+            //
+            // No - report the error to the caller.
+            //
+            return(KEYB_ERR_TX_ERROR);
+        }
+    }
+    else
+    {
+        //
+        // We can't send the report immediately so mark the instance so that
+        // it is sent next time the transmitter is free.
+        //
+        psInst->bChangeMade = true;
+    }
+
+    //
+    // If we get this far, the key information was sent successfully.  Are
+    // too many keys currently pressed, though?
+    //
+    return(bRetcode ? KEYB_SUCCESS : KEYB_ERR_TOO_MANY_KEYS);
+}
+#ifndef DEPRECATED
+
+//*****************************************************************************
+//
+//! Reports the device power status (bus or self powered) to the USB library.
+//!
+//! \param pvKeyboardDevice is the pointer to the keyboard device instance
+//! structure.
+//! \param ui8Power indicates the current power status, either
+//! \b USB_STATUS_SELF_PWR or \b USB_STATUS_BUS_PWR.
+//!
+//! Applications which support switching between bus or self powered
+//! operation should call this function whenever the power source changes
+//! to indicate the current power status to the USB library.  This information
+//! is required by the USB library to allow correct responses to be provided
+//! when the host requests status from the device.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBDHIDKeyboardPowerStatusSet(void *pvKeyboardDevice, uint8_t ui8Power)
+{
+    tUSBDHIDKeyboardDevice *psHIDKbDevice;
+    tUSBDHIDDevice *psHIDDevice;
+
+    ASSERT(pvKeyboardDevice);
+
+    //
+    // Get the keyboard device pointer.
+    //
+    psHIDKbDevice = (tUSBDHIDKeyboardDevice *)pvKeyboardDevice;
+
+    //
+    // Get a pointer to the HID device data.
+
+    psHIDDevice = &psHIDKbDevice->sPrivateData.sHIDDevice;
+
+    //
+    // Pass the request through to the lower layer.
+    //
+    USBDHIDPowerStatusSet((void *)psHIDDevice, ui8Power);
+}
+#endif
+
+//*****************************************************************************
+//
+//! Requests a remote wake up to resume communication when in suspended state.
+//!
+//! \param pvKeyboardDevice is the pointer to the keyboard device instance
+//! structure.
+//!
+//! When the bus is suspended, an application which supports remote wake up
+//! (advertised to the host via the configuration descriptor) may call this
+//! function to initiate remote wake up signaling to the host.  If the remote
+//! wake up feature has not been disabled by the host, this causes the bus
+//! to resume operation within 20mS.  If the host has disabled remote wake up,
+//! \b false is returned to indicate that the wake up request was not
+//! successful.
+//!
+//! \return Returns \b true if the remote wake up is not disabled and the
+//! signaling was started or \b false if remote wake up is disabled or if
+//! signaling is currently ongoing following a previous call to this function.
+//
+//*****************************************************************************
+bool
+USBDHIDKeyboardRemoteWakeupRequest(void *pvKeyboardDevice)
+{
+    tUSBDHIDKeyboardDevice *psHIDKbDevice;
+    tUSBDHIDDevice *psHIDDevice;
+
+    ASSERT(pvKeyboardDevice);
+
+    //
+    // Get the keyboard device pointer.
+    //
+    psHIDKbDevice = (tUSBDHIDKeyboardDevice *)pvKeyboardDevice;
+
+    //
+    // Get a pointer to the HID device data.
+    //
+    psHIDDevice = &psHIDKbDevice->sPrivateData.sHIDDevice;
+
+    //
+    // Pass the request through to the lower layer.
+    //
+    return(USBDHIDRemoteWakeupRequest((void *)psHIDDevice));
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
diff --git a/bsp/tm4c129x/libraries/usblib/device/usbdhidkeyb.h b/bsp/tm4c129x/libraries/usblib/device/usbdhidkeyb.h
new file mode 100755
index 0000000..1af56c4
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/device/usbdhidkeyb.h
@@ -0,0 +1,365 @@
+//*****************************************************************************
+//
+// usbdhidkeyb.h - Definitions used by HID keyboard class devices.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#ifndef __USBDHIDKEYB_H__
+#define __USBDHIDKEYB_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+//*****************************************************************************
+//
+//! \addtogroup hid_keyboard_device_class_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! The maximum number of simultaneously-pressed, non-modifier keys that the
+//! HID BIOS keyboard protocol can send at once.  Attempts to send more pressed
+//! keys than this results in a rollover error being reported to the host
+//! and KEYB_ERR_TOO_MANY_KEYS being returned from
+//! USBDHIDKeyboardKeyStateChange().
+//
+//*****************************************************************************
+#define KEYB_MAX_CHARS_PER_REPORT \
+                                6
+
+//*****************************************************************************
+//
+// PRIVATE
+//
+// The first few sections of this header are private defines that are used by
+// the USB HID keyboard code and are here only to help with the application
+// allocating the correct amount of memory for the USB HID Keyboard device
+// code.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// PRIVATE
+//
+// This enumeration holds the various states that the keyboard can be in during
+// normal operation.
+//
+//*****************************************************************************
+typedef enum
+{
+    //
+    // Unconfigured.
+    //
+    HID_KEYBOARD_STATE_UNCONFIGURED,
+
+    //
+    // No keys to send and not waiting on data.
+    //
+    HID_KEYBOARD_STATE_IDLE,
+
+    //
+    // Waiting on report data from the host.
+    //
+    HID_KEYBOARD_STATE_WAIT_DATA,
+
+    //
+    // Waiting on data to be sent out.
+    //
+    HID_KEYBOARD_STATE_SEND
+}
+tKeyboardState;
+
+//*****************************************************************************
+//
+// PRIVATE
+//
+// The size of the keyboard input and output reports.
+//
+//*****************************************************************************
+#define KEYB_IN_REPORT_SIZE 8
+#define KEYB_OUT_REPORT_SIZE 1
+
+//*****************************************************************************
+//
+// PRIVATE
+//
+// This structure defines the private instance data structure for the USB HID
+// keyboard device.  This structure forms the RAM workspace used by each
+// instance of the keyboard.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    // The USB configuration number set by the host or 0 of the device is
+    // currently unconfigured.
+    //
+    uint8_t ui8USBConfigured;
+
+    //
+    // The protocol requested by the host, USB_HID_PROTOCOL_BOOT or
+    // USB_HID_PROTOCOL_REPORT.
+    //
+    uint8_t ui8Protocol;
+
+    //
+    // The current states that the keyboard LEDs are to be set to.
+    //
+    volatile uint8_t ui8LEDStates;
+
+    //
+    // The total number of keys currently pressed.  This indicates the number
+    // of key press entries in the pui8KeysPressed array.
+    //
+    uint8_t ui8KeyCount;
+
+    //
+    // The current state of the keyboard interrupt IN endpoint.
+    //
+    volatile tKeyboardState eKeyboardState;
+
+    //
+    // A flag to indicate that the application pressed or released a key
+    // but that we couldn't send the report immediately.
+    //
+    volatile bool bChangeMade;
+
+    //
+    // A buffer used to receive output reports from the host.
+    //
+    uint8_t pui8DataBuffer[KEYB_OUT_REPORT_SIZE];
+
+    //
+    // A buffer used to hold the last input report sent to the host.
+    //
+    uint8_t pui8Report[KEYB_IN_REPORT_SIZE];
+
+    //
+    // A buffer containing the usage codes of all non-modifier keys currently
+    // in the pressed state.
+    //
+    uint8_t pui8KeysPressed[KEYB_MAX_CHARS_PER_REPORT];
+
+    //
+    // The idle timeout control structure for our input report.  This is
+    // required by the lower level HID driver.
+    //
+    tHIDReportIdle sReportIdle;
+
+    //
+    // This is needed for the lower level HID driver.
+    //
+    tUSBDHIDDevice sHIDDevice;
+}
+tHIDKeyboardInstance;
+
+//*****************************************************************************
+//
+//! This structure is used by the application to define operating parameters
+//! for the HID keyboard device.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The vendor ID that this device is to present in the device descriptor.
+    //
+    const uint16_t ui16VID;
+
+    //
+    //! The product ID that this device is to present in the device descriptor.
+    //
+    const uint16_t ui16PID;
+
+    //
+    //! The maximum power consumption of the device, expressed in milliamps.
+    //
+    const uint16_t ui16MaxPowermA;
+
+    //
+    //! Indicates whether the device is self- or bus-powered and whether or not
+    //! it supports remote wakeup.  Valid values are \b USB_CONF_ATTR_SELF_PWR
+    //! or \b USB_CONF_ATTR_BUS_PWR, optionally ORed with
+    //! \b USB_CONF_ATTR_RWAKE.
+    //
+    const uint8_t ui8PwrAttributes;
+
+    //! A pointer to the callback function which is called to notify
+    //! the application of general events and those related to reception of
+    //! Output and Feature reports via the (optional) interrupt OUT endpoint.
+    //
+    const tUSBCallback pfnCallback;
+
+    //
+    //! A client-supplied pointer which is sent as the first
+    //! parameter in all calls made to the keyboard callback,
+    //! pfnCallback.
+    //
+    void *pvCBData;
+
+    //
+    //! A pointer to the string descriptor array for this device.  This array
+    //! must contain the following string descriptor pointers in this order.
+    //! Language descriptor, Manufacturer name string (language 1), Product
+    //! name string (language 1), Serial number string (language 1),HID
+    //! Interface description string (language 1), Configuration description
+    //! string (language 1).
+    //!
+    //! If supporting more than 1 language, the descriptor block (except for
+    //! string descriptor 0) must be repeated for each language defined in the
+    //! language descriptor.
+    //
+    const uint8_t * const *ppui8StringDescriptors;
+
+    //
+    //! The number of descriptors provided in the ppStringDescriptors
+    //! array.  This must be (1 + (5 * (num languages))).
+    //
+    const uint32_t ui32NumStringDescriptors;
+
+    //
+    //! The private instance data for this device.  This memory must
+    //! remain accessible for as long as the keyboard device is in use and
+    //! must not be modified by any code outside the HID keyboard driver.
+    //
+    tHIDKeyboardInstance sPrivateData;
+}
+tUSBDHIDKeyboardDevice;
+
+//*****************************************************************************
+//
+// Keyboard-specific device class driver events
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! This event indicates that the keyboard LED states are to be set.  The
+//! ui32MsgValue parameter contains the requested state for each of the LEDs
+//! defined as a collection of ORed bits where a 1 indicates that the LED is
+//! to be turned on and a 0 indicates that it should be turned off.  The
+//! individual LED bits are defined using labels \b HID_KEYB_NUM_LOCK,
+//! \b HID_KEYB_CAPS_LOCK, \b HID_KEYB_SCROLL_LOCK, \b HID_KEYB_COMPOSE and
+//! \b HID_KEYB_KANA.
+//
+//*****************************************************************************
+#define USBD_HID_KEYB_EVENT_SET_LEDS                                          \
+                                USBD_HID_KEYB_EVENT_BASE
+
+//*****************************************************************************
+//
+//! This return code from USBDHIDKeyboardKeyStateChange() indicates success.
+//
+//*****************************************************************************
+#define KEYB_SUCCESS            0
+
+//*****************************************************************************
+//
+//! This return code from USBDHIDKeyboardKeyStateChange() indicates that an
+//! attempt has been made to record more than 6 simultaneously pressed,
+//! non-modifier keys.  The USB HID BIOS keyboard protocol allows no more than
+//! 6 pressed keys to be reported at one time.  Until at least one key is
+//! released, the device reports a roll over error to the host each time it
+//! is asked for the keyboard input report.
+//
+//*****************************************************************************
+#define KEYB_ERR_TOO_MANY_KEYS  1
+
+//*****************************************************************************
+//
+//! This return code from USBDHIDKeyboardKeyStateChange() indicates that an
+//! error was reported while attempting to send a report to the host.  A client
+//! should assume that the host has disconnected if this return code is seen.
+//
+//*****************************************************************************
+#define KEYB_ERR_TX_ERROR       2
+
+//*****************************************************************************
+//
+//! USBDHIDKeyboardKeyStateChange() returns this value if it is called with the
+//! bPress parameter set to false but with a ui8UsageCode parameter which does
+//! does not indicate a key that is currently recorded as being pressed.  This
+//! may occur if an attempt was previously made to report more than 6 pressed
+//! keys and the earlier pressed keys are released before the later ones.  This
+//! condition is benign and should not be used to indicate a host disconnection
+//! or serious error.
+//
+//*****************************************************************************
+#define KEYB_ERR_NOT_FOUND      3
+
+//*****************************************************************************
+//
+//! USBDHIDKeyboardKeyStateChange() returns this value if it is called before
+//! the USB host has connected and configured the device.  Any key usage code
+//! passed is stored and passed to the host once configuration completes.
+//
+//*****************************************************************************
+#define KEYB_ERR_NOT_CONFIGURED 4
+
+//*****************************************************************************
+//
+// API Function Prototypes
+//
+//*****************************************************************************
+extern void *USBDHIDKeyboardInit(uint32_t ui32Index,
+                                 tUSBDHIDKeyboardDevice *psHIDKbDevice);
+extern void *USBDHIDKeyboardCompositeInit(uint32_t ui32Index,
+                                        tUSBDHIDKeyboardDevice *psHIDKbDevice,
+                                        tCompositeEntry *psCompEntry);
+extern void USBDHIDKeyboardTerm(void *pvKeyboardInstance);
+extern void *USBDHIDKeyboardSetCBData(void *pvKeyboardInstance,
+                                      void *pvCBData);
+extern uint32_t USBDHIDKeyboardKeyStateChange(void *pvKeyboardInstance,
+                                              uint8_t ui8Modifiers,
+                                              uint8_t ui8UsageCode,
+                                              bool bPressed);
+extern void USBDHIDKeyboardPowerStatusSet(void *pvKeyboardInstance,
+                                          uint8_t ui8Power);
+extern bool USBDHIDKeyboardRemoteWakeupRequest(void *pvKeyboardInstance);
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __USBDHIDKEYB_H__
diff --git a/bsp/tm4c129x/libraries/usblib/device/usbdhidmouse.c b/bsp/tm4c129x/libraries/usblib/device/usbdhidmouse.c
new file mode 100755
index 0000000..25ea393
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/device/usbdhidmouse.c
@@ -0,0 +1,1008 @@
+//*****************************************************************************
+//
+// usbdhidmouse.c - USB HID Mouse device class driver.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "inc/hw_types.h"
+#include "driverlib/debug.h"
+#include "driverlib/usb.h"
+#include "usblib/usblib.h"
+#include "usblib/usblibpriv.h"
+#include "usblib/device/usbdevice.h"
+#include "usblib/usbhid.h"
+#include "usblib/device/usbdhid.h"
+#include "usblib/device/usbdhidmouse.h"
+
+//*****************************************************************************
+//
+//! \addtogroup hid_mouse_device_class_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// HID device configuration descriptor.
+//
+// It is vital that the configuration descriptor bConfigurationValue field
+// (byte 6) is 1 for the first configuration and increments by 1 for each
+// additional configuration defined here.  This relationship is assumed in the
+// device stack for simplicity even though the USB 2.0 specification imposes
+// no such restriction on the bConfigurationValue values.
+//
+// Note that this structure is deliberately located in RAM since we need to
+// be able to patch some values in it based on client requirements.
+//
+//*****************************************************************************
+uint8_t g_pui8MouseDescriptor[] =
+{
+    //
+    // Configuration descriptor header.
+    //
+    9,                          // Size of the configuration descriptor.
+    USB_DTYPE_CONFIGURATION,    // Type of this descriptor.
+    USBShort(34),               // The total size of this full structure.
+    1,                          // The number of interfaces in this
+                                // configuration.
+    1,                          // The unique value for this configuration.
+    5,                          // The string identifier that describes this
+                                // configuration.
+    USB_CONF_ATTR_SELF_PWR,     // Bus Powered, Self Powered, remote wake up.
+    250,                        // The maximum power in 2mA increments.
+};
+
+//*****************************************************************************
+//
+// The remainder of the configuration descriptor is stored in flash since we
+// don't need to modify anything in it at runtime.
+//
+//*****************************************************************************
+uint8_t g_pui8HIDInterface[HIDINTERFACE_SIZE] =
+{
+    //
+    // HID Device Class Interface Descriptor.
+    //
+    9,                          // Size of the interface descriptor.
+    USB_DTYPE_INTERFACE,        // Type of this descriptor.
+    0,                          // The index for this interface.
+    0,                          // The alternate setting for this interface.
+    1,                          // The number of endpoints used by this
+                                // interface.
+    USB_CLASS_HID,              // The interface class
+    USB_HID_SCLASS_BOOT,        // The interface sub-class.
+    USB_HID_PROTOCOL_MOUSE,     // The interface protocol for the sub-class
+                                // specified above.
+    4,                          // The string index for this interface.
+};
+
+const uint8_t g_pui8HIDInEndpoint[HIDINENDPOINT_SIZE] =
+{
+    //
+    // Interrupt IN endpoint descriptor
+    //
+    7,                          // The size of the endpoint descriptor.
+    USB_DTYPE_ENDPOINT,         // Descriptor type is an endpoint.
+    USB_EP_DESC_IN | USBEPToIndex(USB_EP_1),
+    USB_EP_ATTR_INT,            // Endpoint is an interrupt endpoint.
+    USBShort(USBFIFOSizeToBytes(USB_FIFO_SZ_64)),
+                                // The maximum packet size.
+    16,                         // The polling interval for this endpoint.
+};
+
+//*****************************************************************************
+//
+// The report descriptor for the mouse class device.
+//
+//*****************************************************************************
+static const uint8_t g_pui8MouseReportDescriptor[] =
+{
+    UsagePage(USB_HID_GENERIC_DESKTOP),
+    Usage(USB_HID_MOUSE),
+    Collection(USB_HID_APPLICATION),
+        Usage(USB_HID_POINTER),
+        Collection(USB_HID_PHYSICAL),
+
+            //
+            // The buttons.
+            //
+            UsagePage(USB_HID_BUTTONS),
+            UsageMinimum(1),
+            UsageMaximum(3),
+            LogicalMinimum(0),
+            LogicalMaximum(1),
+
+            //
+            // 3 - 1 bit values for the buttons.
+            //
+            ReportSize(1),
+            ReportCount(3),
+            Input(USB_HID_INPUT_DATA | USB_HID_INPUT_VARIABLE |
+                  USB_HID_INPUT_ABS),
+
+            //
+            // 1 - 5 bit unused constant value to fill the 8 bits.
+            //
+            ReportSize(5),
+            ReportCount(1),
+            Input(USB_HID_INPUT_CONSTANT | USB_HID_INPUT_ARRAY |
+                  USB_HID_INPUT_ABS),
+
+            //
+            // The X and Y axis.
+            //
+            UsagePage(USB_HID_GENERIC_DESKTOP),
+            Usage(USB_HID_X),
+            Usage(USB_HID_Y),
+            LogicalMinimum(-127),
+            LogicalMaximum(127),
+
+            //
+            // 2 - 8 bit Values for x and y.
+            //
+            ReportSize(8),
+            ReportCount(2),
+            Input(USB_HID_INPUT_DATA | USB_HID_INPUT_VARIABLE |
+                  USB_HID_INPUT_RELATIVE),
+
+        EndCollection,
+    EndCollection,
+};
+
+//*****************************************************************************
+//
+// The HID descriptor for the mouse device.
+//
+//*****************************************************************************
+static const tHIDDescriptor g_sMouseHIDDescriptor =
+{
+    9,                              // bLength
+    USB_HID_DTYPE_HID,              // bDescriptorType
+    0x111,                          // bcdHID (version 1.11 compliant)
+    0,                              // bCountryCode (not localized)
+    1,                              // bNumDescriptors
+    {
+        {
+            USB_HID_DTYPE_REPORT,   // Report descriptor
+            sizeof(g_pui8MouseReportDescriptor)
+                                    // Size of report descriptor
+        }
+    }
+};
+
+//*****************************************************************************
+//
+// The HID configuration descriptor is defined as four or five sections
+// depending upon the client's configuration choice.  These sections are:
+//
+// 1.  The 9 byte configuration descriptor (RAM).
+// 2.  The interface descriptor (RAM).
+// 3.  The HID report and physical descriptors (provided by the client)
+//     (FLASH).
+// 4.  The mandatory interrupt IN endpoint descriptor (FLASH).
+// 5.  The optional interrupt OUT endpoint descriptor (FLASH).
+//
+//*****************************************************************************
+const tConfigSection g_sHIDConfigSection =
+{
+    sizeof(g_pui8MouseDescriptor),
+    g_pui8MouseDescriptor
+};
+
+const tConfigSection g_sHIDInterfaceSection =
+{
+    sizeof(g_pui8HIDInterface),
+    g_pui8HIDInterface
+};
+
+const tConfigSection g_sHIDInEndpointSection =
+{
+    sizeof(g_pui8HIDInEndpoint),
+    g_pui8HIDInEndpoint
+};
+
+//*****************************************************************************
+//
+// Place holder for the user's HID descriptor block.
+//
+//*****************************************************************************
+tConfigSection g_sHIDDescriptorSection =
+{
+   sizeof(g_sMouseHIDDescriptor),
+   (const uint8_t *)&g_sMouseHIDDescriptor
+};
+
+//*****************************************************************************
+//
+// This array lists all the sections that must be concatenated to make a
+// single, complete HID configuration descriptor.
+//
+//*****************************************************************************
+const tConfigSection *g_psHIDSections[] =
+{
+    &g_sHIDConfigSection,
+    &g_sHIDInterfaceSection,
+    &g_sHIDDescriptorSection,
+    &g_sHIDInEndpointSection,
+};
+
+#define NUM_HID_SECTIONS        (sizeof(g_psHIDSections) /                    \
+                                 sizeof(g_psHIDSections[0]))
+
+//*****************************************************************************
+//
+// The header for the single configuration we support.  This is the root of
+// the data structure that defines all the bits and pieces that are pulled
+// together to generate the configuration descriptor.  Note that this must be
+// in RAM since we need to include or exclude the final section based on
+// client supplied initialization parameters.
+//
+//*****************************************************************************
+tConfigHeader g_sHIDConfigHeader =
+{
+    NUM_HID_SECTIONS,
+    g_psHIDSections
+};
+
+//*****************************************************************************
+//
+// Configuration Descriptor.
+//
+//*****************************************************************************
+const tConfigHeader * const g_ppsHIDConfigDescriptors[] =
+{
+    &g_sHIDConfigHeader
+};
+
+//*****************************************************************************
+//
+// The HID class descriptor table.  For the mouse class, we have only a single
+// report descriptor.
+//
+//*****************************************************************************
+static const uint8_t * const g_pui8MouseClassDescriptors[] =
+{
+    g_pui8MouseReportDescriptor
+};
+
+//*****************************************************************************
+//
+// Forward references for mouse device callback functions.
+//
+//*****************************************************************************
+static uint32_t HIDMouseRxHandler(void *pvMouseDevice, uint32_t ui32Event,
+                                  uint32_t ui32MsgData, void *pvMsgData);
+static uint32_t HIDMouseTxHandler(void *pvMouseDevice, uint32_t ui32Event,
+                                  uint32_t ui32MsgData, void *pvMsgData);
+
+//*****************************************************************************
+//
+// The HID mouse report offsets for this mouse application.
+//
+//*****************************************************************************
+#define HID_REPORT_BUTTONS      0
+#define HID_REPORT_X            1
+#define HID_REPORT_Y            2
+
+//*****************************************************************************
+//
+// Main HID device class event handler function.
+//
+// \param pvMouseDevice is the event callback pointer provided during
+// USBDHIDInit().  This is a pointer to our HID device structure
+// (&g_sHIDMouseDevice).
+// \param ui32Event identifies the event we are being called back for.
+// \param ui32MsgData is an event-specific value.
+// \param pvMsgData is an event-specific pointer.
+//
+// This function is called by the HID device class driver to inform the
+// application of particular asynchronous events related to operation of the
+// mouse HID device.
+//
+// \return Returns a value which is event-specific.
+//
+//*****************************************************************************
+static uint32_t
+HIDMouseRxHandler(void *pvMouseDevice, uint32_t ui32Event,
+                  uint32_t ui32MsgData, void *pvMsgData)
+{
+    tHIDMouseInstance *psInst;
+    tUSBDHIDMouseDevice *psMouseDevice;
+
+    //
+    // Make sure we did not get a NULL pointer.
+    //
+    ASSERT(pvMouseDevice);
+
+    //
+    // Get a pointer to our instance data
+    //
+    psMouseDevice = (tUSBDHIDMouseDevice *)pvMouseDevice;
+    psInst = &psMouseDevice->sPrivateData;
+
+    //
+    // Which event were we sent?
+    //
+    switch(ui32Event)
+    {
+        //
+        // The host has connected to us and configured the device.
+        //
+        case USB_EVENT_CONNECTED:
+        {
+            psInst->ui8USBConfigured = true;
+
+            //
+            // Pass the information on to the client.
+            //
+            psMouseDevice->pfnCallback(psMouseDevice->pvCBData,
+                                       USB_EVENT_CONNECTED, 0, (void *)0);
+
+            break;
+        }
+
+        //
+        // The host has disconnected from us.
+        //
+        case USB_EVENT_DISCONNECTED:
+        {
+            psInst->ui8USBConfigured = false;
+
+            //
+            // Pass the information on to the client.
+            //
+            psMouseDevice->pfnCallback(psMouseDevice->pvCBData,
+                                       USB_EVENT_DISCONNECTED, 0, (void *)0);
+
+            break;
+        }
+
+        //
+        // The host is polling us for a particular report and the HID driver
+        // is asking for the latest version to transmit.
+        //
+        case USBD_HID_EVENT_IDLE_TIMEOUT:
+        case USBD_HID_EVENT_GET_REPORT:
+        {
+            //
+            // We only support a single input report so we don't need to check
+            // the ui32MsgValue parameter in this case.  Set the report pointer
+            // in *pvMsgData and return the length of the report in bytes.
+            //
+            *(uint8_t **)pvMsgData = psInst->pui8Report;
+            return(8);
+        }
+
+        //
+        // The device class driver has completed sending a report to the
+        // host in response to a Get_Report request.
+        //
+        case USBD_HID_EVENT_REPORT_SENT:
+        {
+            //
+            // We have nothing to do here.
+            //
+            break;
+        }
+
+        //
+        // This event is sent in response to a host Set_Report request.  The
+        // mouse device has no output reports so we return a NULL pointer and
+        // zero length to cause this request to be stalled.
+        //
+        case USBD_HID_EVENT_GET_REPORT_BUFFER:
+        {
+            //
+            // We are being asked for a report that does not exist for
+            // this device.  Return 0 to indicate that we are not providing
+            // a buffer.
+            //
+            return(0);
+        }
+
+        //
+        // The host is asking us to set either boot or report protocol (not
+        // that it makes any difference to this particular mouse).
+        //
+        case USBD_HID_EVENT_SET_PROTOCOL:
+        {
+            psInst->ui8Protocol = ui32MsgData;
+            break;
+        }
+
+        //
+        // The host is asking us to tell it which protocol we are currently
+        // using, boot or request.
+        //
+        case USBD_HID_EVENT_GET_PROTOCOL:
+        {
+            return(psInst->ui8Protocol);
+        }
+
+        //
+        // Pass ERROR, SUSPEND and RESUME to the client unchanged.
+        //
+        case USB_EVENT_ERROR:
+        case USB_EVENT_SUSPEND:
+        case USB_EVENT_RESUME:
+        case USB_EVENT_LPM_RESUME:
+        case USB_EVENT_LPM_SLEEP:
+        case USB_EVENT_LPM_ERROR:
+        {
+            return(psMouseDevice->pfnCallback(psMouseDevice->pvCBData,
+                                              ui32Event, ui32MsgData,
+                                              pvMsgData));
+        }
+
+        //
+        // We ignore all other events.
+        //
+        default:
+        {
+            break;
+        }
+    }
+    return(0);
+}
+
+//*****************************************************************************
+//
+// HID device class transmit channel event handler function.
+//
+// \param pvMouseDevice is the event callback pointer provided during
+// USBDHIDInit(). This is a pointer to our HID device structure
+// (&g_sHIDMouseDevice).
+// \param ui32Event identifies the event we are being called back for.
+// \param ui32MsgData is an event-specific value.
+// \param pvMsgData is an event-specific pointer.
+//
+// This function is called by the HID device class driver to inform the
+// application of particular asynchronous events related to report
+// transmissions made using the interrupt IN endpoint.
+//
+// \return Returns a value which is event-specific.
+//
+//*****************************************************************************
+static uint32_t
+HIDMouseTxHandler(void *pvMouseDevice, uint32_t ui32Event,
+                  uint32_t ui32MsgData, void *pvMsgData)
+{
+    tHIDMouseInstance *psInst;
+    tUSBDHIDMouseDevice *psMouseDevice;
+
+    //
+    // Make sure we did not get a NULL pointer.
+    //
+    ASSERT(pvMouseDevice);
+
+    //
+    // Get a pointer to our instance data
+    //
+    psMouseDevice = (tUSBDHIDMouseDevice *)pvMouseDevice;
+    psInst = &psMouseDevice->sPrivateData;
+
+    //
+    // Which event were we sent?
+    //
+    switch (ui32Event)
+    {
+        //
+        // A report transmitted via the interrupt IN endpoint was acknowledged
+        // by the host.
+        //
+        case USB_EVENT_TX_COMPLETE:
+        {
+            //
+            // Our last transmission is complete.
+            //
+            psInst->iMouseState = eHIDMouseStateIdle;
+
+            //
+            // Pass the event on to the client.
+            //
+            psMouseDevice->pfnCallback(psMouseDevice->pvCBData,
+                                       USB_EVENT_TX_COMPLETE, ui32MsgData,
+                                       (void *)0);
+
+            break;
+        }
+
+        //
+        // We ignore all other events related to transmission of reports via
+        // the interrupt IN endpoint.
+        //
+        default:
+        {
+            break;
+        }
+    }
+
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! Initializes HID mouse device operation for a given USB controller.
+//!
+//! \param ui32Index is the index of the USB controller which is to be
+//! initialized for HID mouse device operation.
+//! \param psMouseDevice points to a structure containing parameters
+//! customizing the operation of the HID mouse device.
+//!
+//! An application wishing to offer a USB HID mouse interface to a USB host
+//! must call this function to initialize the USB controller and attach the
+//! mouse device to the USB bus.  This function performs all required USB
+//! initialization.
+//!
+//! On successful completion, this function returns the \e psMouseDevice
+//! pointer passed to it.  This must be passed on all future calls to the HID
+//! mouse device driver.
+//!
+//! When a host connects and configures the device, the application callback
+//! receives \b USB_EVENT_CONNECTED after which calls can be made to
+//! USBDHIDMouseStateChange() to report pointer movement and button presses
+//! to the host.
+//!
+//! \note The application must not make any calls to the lower level USB device
+//! interfaces if interacting with USB via the USB HID mouse device API.
+//! Doing so causes unpredictable (though almost certainly unpleasant)
+//! behavior.
+//!
+//! \return Returns NULL on failure or the psMouseDevice pointer on success.
+//
+//*****************************************************************************
+void *
+USBDHIDMouseInit(uint32_t ui32Index, tUSBDHIDMouseDevice *psMouseDevice)
+{
+    void *pvRetcode;
+    tUSBDHIDDevice *psHIDDevice;
+    tConfigDescriptor *pConfigDesc;
+
+    //
+    // Check parameter validity.
+    //
+    ASSERT(psMouseDevice);
+    ASSERT(psMouseDevice->ppui8StringDescriptors);
+    ASSERT(psMouseDevice->pfnCallback);
+
+    //
+    // Get a pointer to the HID device data.
+    //
+    psHIDDevice = &psMouseDevice->sPrivateData.sHIDDevice;
+
+    pConfigDesc = (tConfigDescriptor *)g_pui8MouseDescriptor;
+    pConfigDesc->bmAttributes = psMouseDevice->ui8PwrAttributes;
+    pConfigDesc->bMaxPower =  (uint8_t)(psMouseDevice->ui16MaxPowermA / 2);
+
+    //
+    // Call the common initialization routine.
+    //
+    pvRetcode = USBDHIDMouseCompositeInit(ui32Index, psMouseDevice, 0);
+
+    //
+    // If we initialized the HID layer successfully, pass our device pointer
+    // back as the return code, otherwise return NULL to indicate an error.
+    //
+    if(pvRetcode)
+    {
+        //
+        // Initialize the lower layer HID driver and pass it the various
+        // structures and descriptors necessary to declare that we are a
+        // keyboard.
+        //
+        pvRetcode = USBDHIDInit(ui32Index, psHIDDevice);
+
+        return((void *)psMouseDevice);
+    }
+    else
+    {
+        return((void *)0);
+    }
+}
+
+//*****************************************************************************
+//
+//! Initializes HID mouse device operation for a given USB controller.
+//!
+//! \param ui32Index is the index of the USB controller which is to be
+//! initialized for HID mouse device operation.
+//! \param psMouseDevice points to a structure containing parameters
+//! customizing the operation of the HID mouse device.
+//! \param psCompEntry is the composite device entry to initialize when
+//! creating a composite device.
+//!
+//! This call is very similar to USBDHIDMouseInit() except that it is used for
+//! initializing an instance of the HID mouse device for use in a composite
+//! device.  If this HID mouse is part of a composite device, then the
+//! \e psCompEntry should point to the composite device entry to initialize.
+//! This is part of the array that is passed to the USBDCompositeInit()
+//! function.
+//!
+//! \return Returns zero on failure or a non-zero instance value that should be
+//! used with the remaining USB HID Mouse APIs.
+//
+//*****************************************************************************
+void *
+USBDHIDMouseCompositeInit(uint32_t ui32Index,
+                          tUSBDHIDMouseDevice *psMouseDevice,
+                          tCompositeEntry *psCompEntry)
+{
+    tHIDMouseInstance *psInst;
+    tUSBDHIDDevice *psHIDDevice;
+
+
+    //
+    // Check parameter validity.
+    //
+    ASSERT(psMouseDevice);
+    ASSERT(psMouseDevice->ppui8StringDescriptors);
+    ASSERT(psMouseDevice->pfnCallback);
+
+    //
+    // Get a pointer to our instance data
+    //
+    psInst = &psMouseDevice->sPrivateData;
+
+    //
+    // Get a pointer to the HID device data.
+    //
+    psHIDDevice = &psMouseDevice->sPrivateData.sHIDDevice;
+
+    //
+    // Initialize the various fields in our instance structure.
+    //
+    psInst->ui8USBConfigured = 0;
+    psInst->ui8Protocol = USB_HID_PROTOCOL_REPORT;
+    psInst->sReportIdle.ui8Duration4mS = 0;
+    psInst->sReportIdle.ui8ReportID = 0;
+    psInst->sReportIdle.ui32TimeSinceReportmS = 0;
+    psInst->sReportIdle.ui16TimeTillNextmS = 0;
+    psInst->iMouseState = eHIDMouseStateUnconfigured;
+
+    //
+    // Initialize the HID device class instance structure based on input from
+    // the caller.
+    //
+    psHIDDevice->ui16PID = psMouseDevice->ui16PID;
+    psHIDDevice->ui16VID = psMouseDevice->ui16VID;
+    psHIDDevice->ui16MaxPowermA = psMouseDevice->ui16MaxPowermA;
+    psHIDDevice->ui8PwrAttributes = psMouseDevice->ui8PwrAttributes;
+    psHIDDevice->ui8Subclass = USB_HID_SCLASS_BOOT;
+    psHIDDevice->ui8Protocol = USB_HID_PROTOCOL_MOUSE;
+    psHIDDevice->ui8NumInputReports = 1;
+    psHIDDevice->psReportIdle = &psInst->sReportIdle;
+    psHIDDevice->pfnRxCallback = HIDMouseRxHandler;
+    psHIDDevice->pvRxCBData = (void *)psMouseDevice;
+    psHIDDevice->pfnTxCallback = HIDMouseTxHandler;
+    psHIDDevice->pvTxCBData = (void *)psMouseDevice;
+    psHIDDevice->bUseOutEndpoint = false;
+    psHIDDevice->psHIDDescriptor = &g_sMouseHIDDescriptor;
+    psHIDDevice->ppui8ClassDescriptors = g_pui8MouseClassDescriptors;
+    psHIDDevice->ppui8StringDescriptors =
+                                    psMouseDevice->ppui8StringDescriptors;
+    psHIDDevice->ui32NumStringDescriptors =
+                                    psMouseDevice->ui32NumStringDescriptors;
+    psHIDDevice->ppsConfigDescriptor = g_ppsHIDConfigDescriptors;
+
+    //
+    // Initialize the lower layer HID driver and pass it the various structures
+    // and descriptors necessary to declare that we are a keyboard.
+    //
+    return(USBDHIDCompositeInit(ui32Index, psHIDDevice, psCompEntry));
+}
+
+//*****************************************************************************
+//
+//! Shuts down the HID mouse device.
+//!
+//! \param pvMouseDevice is the pointer to the device instance structure.
+//!
+//! This function terminates HID mouse operation for the instance supplied
+//! and removes the device from the USB bus.  Following this call, the
+//! \e pvMouseDevice instance may not me used in any other call to the HID
+//! mouse device other than USBDHIDMouseInit().
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBDHIDMouseTerm(void *pvMouseDevice)
+{
+    tUSBDHIDMouseDevice *psMouseDevice;
+    tUSBDHIDDevice *psHIDDevice;
+
+    ASSERT(pvMouseDevice);
+
+    //
+    // Get a pointer to the device.
+    //
+    psMouseDevice = (tUSBDHIDMouseDevice *)pvMouseDevice;
+
+    //
+    // Get a pointer to the HID device data.
+    //
+    psHIDDevice = &psMouseDevice->sPrivateData.sHIDDevice;
+
+    //
+    // Mark our device as no longer configured.
+    //
+    psMouseDevice->sPrivateData.ui8USBConfigured = 0;
+
+    //
+    // Terminate the low level HID driver.
+    //
+    USBDHIDTerm(psHIDDevice);
+}
+
+//*****************************************************************************
+//
+//! Sets the client-specific pointer parameter for the mouse callback.
+//!
+//! \param pvMouseDevice is the pointer to the mouse device instance structure.
+//! \param pvCBData is the pointer that client wishes to be provided on
+//! each event sent to the mouse callback function.
+//!
+//! The client uses this function to change the callback pointer passed in
+//! the first parameter on all callbacks to the \e pfnCallback function
+//! passed on USBDHIDMouseInit().
+//!
+//! If a client wants to make runtime changes in the callback pointer, it must
+//! ensure that the pvMouseDevice structure passed to USBDHIDMouseInit()
+//! resides in RAM.  If this structure is in flash, callback data changes are
+//! not possible.
+//!
+//! \return Returns the previous callback pointer that was set for this
+//! instance.
+//
+//*****************************************************************************
+void *
+USBDHIDMouseSetCBData(void *pvMouseDevice, void *pvCBData)
+{
+    void *pvOldCBData;
+    tUSBDHIDMouseDevice *psMouse;
+
+    //
+    // Check for a NULL pointer in the device parameter.
+    //
+    ASSERT(pvMouseDevice);
+
+    //
+    // Get a pointer to our mouse device.
+    //
+    psMouse = (tUSBDHIDMouseDevice *)pvMouseDevice;
+
+    //
+    // Save the old callback pointer and replace it with the new value.
+    //
+    pvOldCBData = psMouse->pvCBData;
+    psMouse->pvCBData = pvCBData;
+
+    //
+    // Pass the old callback pointer back to the caller.
+    //
+    return(pvOldCBData);
+}
+
+//*****************************************************************************
+//
+//! Reports a mouse state change, pointer movement or button press, to the USB
+//! host.
+//!
+//! \param pvMouseDevice is the pointer to the mouse device instance structure.
+//! \param i8DeltaX is the relative horizontal pointer movement that the
+//! application wishes to report.  Valid values are in the range [-127, 127]
+//! with positive values indicating movement to the right.
+//! \param i8DeltaY is the relative vertical pointer movement that the
+//! application wishes to report.  Valid values are in the range [-127, 127]
+//! with positive values indicating downward movement.
+//! \param ui8Buttons is a bit mask indicating which (if any) of the three
+//! mouse buttons is pressed.  Valid values are logical OR combinations of
+//! \b MOUSE_REPORT_BUTTON_1, \b MOUSE_REPORT_BUTTON_2 and
+//! \b MOUSE_REPORT_BUTTON_3.
+//!
+//! This function is called to report changes in the mouse state to the USB
+//! host.  These changes can be movement of the pointer, reported relative to
+//! its previous position, or changes in the states of up to 3 buttons that
+//! the mouse may support.  The return code indicates whether or not the
+//! mouse report could be sent to the host.  In cases where a previous
+//! report is still being transmitted, \b MOUSE_ERR_TX_ERROR is returned
+//! and the state change is ignored.
+//!
+//! \return Returns \b MOUSE_SUCCESS on success, \b MOUSE_ERR_TX_ERROR if an
+//! error occurred while attempting to schedule transmission of the mouse
+//! report to the host (typically due to a previous report which has not yet
+//! completed transmission or due to disconnection of the host) or \b
+//! MOUSE_ERR_NOT_CONFIGURED if called before a host has connected to and
+//! configured the device.
+//
+//*****************************************************************************
+uint32_t
+USBDHIDMouseStateChange(void *pvMouseDevice, int8_t i8DeltaX, int8_t i8DeltaY,
+                        uint8_t ui8Buttons)
+{
+    uint32_t ui32Retcode, ui32Count;
+    tHIDMouseInstance *psInst;
+    tUSBDHIDMouseDevice *psMouseDevice;
+    tUSBDHIDDevice *psHIDDevice;
+
+    //
+    // Get a pointer to the device.
+    //
+    psMouseDevice = (tUSBDHIDMouseDevice *)pvMouseDevice;
+
+    //
+    // Get a pointer to the HID device data.
+    //
+    psHIDDevice = &psMouseDevice->sPrivateData.sHIDDevice;
+
+    //
+    // Get a pointer to our instance data
+    //
+    psInst = &psMouseDevice->sPrivateData;
+
+    //
+    // Update the global mouse report with the information passed.
+    //
+    psInst->pui8Report[HID_REPORT_BUTTONS] = ui8Buttons;
+    psInst->pui8Report[HID_REPORT_X] = (uint8_t)i8DeltaX;
+    psInst->pui8Report[HID_REPORT_Y] = (uint8_t)i8DeltaY;
+
+    //
+    // If we are not configured, return an error here before trying to send
+    // anything.
+    //
+    if(!psInst->ui8USBConfigured)
+    {
+        return(MOUSE_ERR_NOT_CONFIGURED);
+    }
+
+    //
+    // Only send a report if the transmitter is currently free.
+    //
+    if(USBDHIDTxPacketAvailable((void *)psHIDDevice))
+    {
+        //
+        // Send the report to the host.
+        //
+        psInst->iMouseState = eHIDMouseStateSend;
+        ui32Count = USBDHIDReportWrite((void *)psHIDDevice,
+                                       psInst->pui8Report, MOUSE_REPORT_SIZE,
+                                       true);
+
+        //
+        // Did we schedule a packet for transmission correctly?
+        //
+        if(!ui32Count)
+        {
+            //
+            // No - report the error to the caller.
+            //
+            ui32Retcode = MOUSE_ERR_TX_ERROR;
+        }
+        else
+        {
+            ui32Retcode = MOUSE_SUCCESS;
+        }
+    }
+    else
+    {
+        ui32Retcode = MOUSE_ERR_TX_ERROR;
+    }
+    //
+    // Return the relevant error code to the caller.
+    //
+    return(ui32Retcode);
+}
+#ifndef DEPRECATED
+
+//*****************************************************************************
+//
+//! Reports the device power status (bus- or self-powered) to the USB library.
+//!
+//! \param pvMouseDevice is the pointer to the mouse device instance structure.
+//! \param ui8Power indicates the current power status, either \b
+//! USB_STATUS_SELF_PWR or \b USB_STATUS_BUS_PWR.
+//!
+//! Applications which support switching between bus- or self-powered
+//! operation should call this function whenever the power source changes
+//! to indicate the current power status to the USB library.  This information
+//! is required by the USB library to allow correct responses to be provided
+//! when the host requests status from the device.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBDHIDMousePowerStatusSet(void *pvMouseDevice, uint8_t ui8Power)
+{
+    tUSBDHIDMouseDevice *psMouseDevice;
+    tUSBDHIDDevice *psHIDDevice;
+
+    ASSERT(pvMouseDevice);
+
+    //
+    // Get the keyboard device pointer.
+    //
+    psMouseDevice = (tUSBDHIDMouseDevice *)pvMouseDevice;
+
+    //
+    // Get a pointer to the HID device data.
+    //
+    psHIDDevice = &psMouseDevice->sPrivateData.sHIDDevice;
+
+    //
+    // Pass the request through to the lower layer.
+    //
+    USBDHIDPowerStatusSet((void *)psHIDDevice, ui8Power);
+}
+#endif
+
+//*****************************************************************************
+//
+//! Requests a remote wake up to resume communication when in suspended state.
+//!
+//! \param pvMouseDevice is the pointer to the mouse device instance structure.
+//!
+//! When the bus is suspended, an application which supports remote wake up
+//! (advertised to the host via the configuration descriptor) may call this
+//! function to initiate remote wake up signaling to the host.  If the remote
+//! wake up feature has not been disabled by the host, this causes the bus
+//! to resume operation within 20mS.  If the host has disabled remote wake up,
+//! \b false is returned to indicate that the wake up request was not
+//! successful.
+//!
+//! \return Returns \b true if the remote wake up is not disabled and the
+//! signaling was started or \b false if remote wake up is disabled or if
+//! signaling is currently ongoing following a previous call to this function.
+//
+//*****************************************************************************
+bool
+USBDHIDMouseRemoteWakeupRequest(void *pvMouseDevice)
+{
+    tUSBDHIDMouseDevice *psMouseDevice;
+    tUSBDHIDDevice *psHIDDevice;
+
+    ASSERT(pvMouseDevice);
+
+    //
+    // Get the keyboard device pointer.
+    //
+    psMouseDevice = (tUSBDHIDMouseDevice *)pvMouseDevice;
+
+    //
+    // Get a pointer to the HID device data.
+    //
+    psHIDDevice = &psMouseDevice->sPrivateData.sHIDDevice;
+
+    //
+    // Pass the request through to the lower layer.
+    //
+    return(USBDHIDRemoteWakeupRequest((void *)&psHIDDevice));
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
diff --git a/bsp/tm4c129x/libraries/usblib/device/usbdhidmouse.h b/bsp/tm4c129x/libraries/usblib/device/usbdhidmouse.h
new file mode 100755
index 0000000..1d229d9
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/device/usbdhidmouse.h
@@ -0,0 +1,299 @@
+//*****************************************************************************
+//
+// usbdhidmouse.h - Public header file for the USB HID Mouse device class
+//                  driver
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#ifndef __USBDHIDMOUSE_H__
+#define __USBDHIDMOUSE_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+//*****************************************************************************
+//
+//! \addtogroup hid_mouse_device_class_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// PRIVATE
+//
+// The first few sections of this header are private defines that are used by
+// the USB HID mouse code and are here only to help with the application
+// allocating the correct amount of memory for the HID mouse device code.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// PRIVATE
+//
+// The size of the mouse input report sent to the host.
+//
+//*****************************************************************************
+#define MOUSE_REPORT_SIZE       3
+
+//*****************************************************************************
+//
+// PRIVATE
+//
+// This enumeration holds the various states that the mouse can be in during
+// normal operation.
+//
+//*****************************************************************************
+typedef enum
+{
+    //
+    // Unconfigured.
+    //
+    eHIDMouseStateUnconfigured,
+
+    //
+    // No keys to send and not waiting on data.
+    //
+    eHIDMouseStateIdle,
+
+    //
+    // Waiting on report data from the host.
+    //
+    eHIDMouseStateWaitData,
+
+    //
+    // Waiting on data to be sent out.
+    //
+    eHIDMouseStateSend
+}
+tMouseState;
+
+//*****************************************************************************
+//
+// PRIVATE
+//
+// This structure provides the private instance data structure for the USB
+// HID Mouse device.  This structure forms the RAM workspace used by each
+// instance of the mouse.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    // The USB configuration number set by the host or 0 of the device is
+    // currently unconfigured.
+    //
+    uint8_t ui8USBConfigured;
+
+    //
+    // The protocol requested by the host, USB_HID_PROTOCOL_BOOT or
+    // USB_HID_PROTOCOL_REPORT.
+    //
+    uint8_t ui8Protocol;
+
+    //
+    // A buffer used to hold the last input report sent to the host.
+    //
+    uint8_t pui8Report[MOUSE_REPORT_SIZE];
+
+    //
+    // The current state of the mouse interrupt IN endpoint.
+    //
+    volatile tMouseState iMouseState;
+
+    //
+    // The idle timeout control structure for our input report.  This is
+    // required by the lower level HID driver.
+    //
+    tHIDReportIdle sReportIdle;
+
+    //
+    // This is needed for the lower level HID driver.
+    //
+    tUSBDHIDDevice sHIDDevice;
+}
+tHIDMouseInstance;
+
+//*****************************************************************************
+//
+//! This structure is used by the application to define operating parameters
+//! for the HID mouse device.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The vendor ID that this device is to present in the device descriptor.
+    //
+    const uint16_t ui16VID;
+
+    //
+    //! The product ID that this device is to present in the device descriptor.
+    //
+    const uint16_t ui16PID;
+
+    //
+    //! The maximum power consumption of the device, expressed in milliamps.
+    //
+    const uint16_t ui16MaxPowermA;
+
+    //
+    //! Indicates whether the device is self- or bus-powered and whether or not
+    //! it supports remote wakeup.  Valid values are USB_CONF_ATTR_SELF_PWR or
+    //! USB_CONF_ATTR_BUS_PWR, optionally ORed with USB_CONF_ATTR_RWAKE.
+    //
+    const uint8_t ui8PwrAttributes;
+
+    //
+    //! A pointer to the callback function which is called to notify
+    //! the application of events relating to the operation of the mouse.
+    //
+    const tUSBCallback pfnCallback;
+
+    //
+    //! A client-supplied pointer which is sent as the first
+    //! parameter in all calls made to the mouse callback, pfnCallback.
+    //
+    void *pvCBData;
+
+    //
+    //! A pointer to the string descriptor array for this device.  This array
+    //! must contain the following string descriptor pointers in this order.
+    //! Language descriptor, Manufacturer name string (language 1), Product
+    //! name string (language 1), Serial number string (language 1),HID
+    //! Interface description string (language 1), Configuration description
+    //! string (language 1).
+    //!
+    //! If supporting more than 1 language, the descriptor block (except for
+    //! string descriptor 0) must be repeated for each language defined in the
+    //! language descriptor.
+    //
+    const uint8_t * const *ppui8StringDescriptors;
+
+    //
+    //! The number of descriptors provided in the ppStringDescriptors
+    //! array.  This must be (1 + (5 * (num languages))).
+    //
+    const uint32_t ui32NumStringDescriptors;
+
+    //
+    //! The private instance data for this device.  This memory must
+    //! remain accessible for as long as the mouse device is in use and must
+    //! not be modified by any code outside the HID mouse driver.
+    //
+    tHIDMouseInstance sPrivateData;
+}
+tUSBDHIDMouseDevice;
+
+//*****************************************************************************
+//
+//! This return code from USBDHIDMouseStateChange() indicates success.
+//
+//*****************************************************************************
+#define MOUSE_SUCCESS           0
+
+//*****************************************************************************
+//
+//! This return code from USBDHIDMouseStateChange() indicates that an error was
+//! reported while attempting to send a report to the host.  A client should
+//! assume that the host has disconnected if this return code is seen.
+//
+//*****************************************************************************
+#define MOUSE_ERR_TX_ERROR      2
+
+//*****************************************************************************
+//
+//! USBDHIDMouseStateChange() returns this value if it is called before the
+//! USB host has connected and configured the device.  All mouse state
+//! information passed on the call is been ignored.
+//
+//*****************************************************************************
+#define MOUSE_ERR_NOT_CONFIGURED \
+                                4
+
+//*****************************************************************************
+//
+//! Setting this bit in the ui8Buttons parameter to USBDHIDMouseStateChange()
+//! indicates to the USB host that button 1 on the mouse is pressed.
+//
+//*****************************************************************************
+#define MOUSE_REPORT_BUTTON_1   0x01
+
+//*****************************************************************************
+//
+//! Setting this bit in the ui8Buttons parameter to USBDHIDMouseStateChange()
+//! indicates to the USB host that button 2 on the mouse is pressed.
+//
+//*****************************************************************************
+#define MOUSE_REPORT_BUTTON_2   0x02
+
+//*****************************************************************************
+//
+//! Setting this bit in the ui8Buttons parameter to USBDHIDMouseStateChange()
+//! indicates to the USB host that button 3 on the mouse is pressed.
+//
+//*****************************************************************************
+#define MOUSE_REPORT_BUTTON_3   0x04
+
+//*****************************************************************************
+//
+// API Function Prototypes
+//
+//*****************************************************************************
+extern void *USBDHIDMouseInit(uint32_t ui32Index,
+                              tUSBDHIDMouseDevice *psMouseDevice);
+extern void *USBDHIDMouseCompositeInit(uint32_t ui32Index,
+                                     tUSBDHIDMouseDevice *psMouseDevice,
+                                     tCompositeEntry *psCompEntry);
+extern void USBDHIDMouseTerm(void *pvMouseDevice);
+extern void *USBDHIDMouseSetCBData(void *pvMouseDevice, void *pvCBData);
+extern uint32_t USBDHIDMouseStateChange(void *pvMouseDevice, int8_t i8DeltaX,
+                                        int8_t i8DeltaY, uint8_t ui8Buttons);
+extern void USBDHIDMousePowerStatusSet(void *pvMouseDevice,
+                                       uint8_t ui8Power);
+extern bool USBDHIDMouseRemoteWakeupRequest(void *pvMouseDevice);
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __USBDHIDMOUSE_H__
diff --git a/bsp/tm4c129x/libraries/usblib/device/usbdmsc.c b/bsp/tm4c129x/libraries/usblib/device/usbdmsc.c
new file mode 100755
index 0000000..ac7a639
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/device/usbdmsc.c
@@ -0,0 +1,2441 @@
+//*****************************************************************************
+//
+// usbdmsc.c - USB mass storage device class driver.
+//
+// Copyright (c) 2009-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "inc/hw_memmap.h"
+#include "inc/hw_types.h"
+#include "driverlib/debug.h"
+#include "driverlib/rom.h"
+#include "driverlib/rom_map.h"
+#include "driverlib/sysctl.h"
+#include "driverlib/usb.h"
+#include "usblib/usblib.h"
+#include "usblib/usblibpriv.h"
+#include "usblib/usbmsc.h"
+#include "usblib/device/usbdevice.h"
+#include "usblib/device/usbdmsc.h"
+
+//*****************************************************************************
+//
+//! \addtogroup msc_device_class_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// These are the internal flags used with the ui32Flags member variable.
+//
+//*****************************************************************************
+#define USBD_FLAG_DMA_IN        0x00000001
+#define USBD_FLAG_DMA_OUT       0x00000002
+#define USBD_FLAG_ALLOW_REMOVAL 0x00000004
+
+//*****************************************************************************
+//
+// The subset of endpoint status flags that we consider to be reception
+// errors.  These are passed to the client via USB_EVENT_ERROR if seen.
+//
+//*****************************************************************************
+#define USB_RX_ERROR_FLAGS      (USBERR_DEV_RX_DATA_ERROR |                   \
+                                 USBERR_DEV_RX_OVERRUN |                      \
+                                 USBERR_DEV_RX_FIFO_FULL)
+
+//*****************************************************************************
+//
+// These are fields that are used by the USB descriptors for the Mass Storage
+// Class.
+//
+//*****************************************************************************
+#define USB_MSC_SUBCLASS_SCSI   0x6
+#define USB_MSC_PROTO_BULKONLY  0x50
+
+//*****************************************************************************
+//
+// Endpoints to use for each of the required endpoints in the driver.
+//
+//*****************************************************************************
+#define DATA_IN_ENDPOINT        USB_EP_1
+#define DATA_OUT_ENDPOINT       USB_EP_1
+
+//*****************************************************************************
+//
+// Maximum packet size for the bulk endpoints is 64 bytes.
+//
+//*****************************************************************************
+#define DATA_IN_EP_MAX_SIZE     64
+#define DATA_OUT_EP_MAX_SIZE    64
+
+//*****************************************************************************
+//
+// These defines control the size of USB transfers for commands.
+//
+//*****************************************************************************
+#define COMMAND_BUFFER_SIZE     64
+
+//*****************************************************************************
+//
+// The block size of a device. It defaults to DEVICE_BLOCK_SIZE
+//
+//*****************************************************************************
+static uint32_t g_pui32BlockSize = DEVICE_BLOCK_SIZE;
+
+//*****************************************************************************
+//
+// The local buffer used to read in commands and process them.
+//
+//*****************************************************************************
+static uint8_t g_pui8Command[COMMAND_BUFFER_SIZE];
+
+//*****************************************************************************
+//
+// The current transfer state is held in these variables.
+//
+//*****************************************************************************
+static tMSCCSW g_sSCSICSW;
+
+//*****************************************************************************
+//
+// The current state for the SCSI commands that are being handled and are
+// stored in the tMSCInstance.ui8SCSIState structure member.
+//
+//*****************************************************************************
+
+//
+// No command in process.
+//
+#define STATE_SCSI_IDLE             0x00
+
+//
+// Sending and reading logical blocks.
+//
+#define STATE_SCSI_SEND_BLOCKS      0x01
+
+//
+// Receiving and writing logical blocks.
+//
+#define STATE_SCSI_RECEIVE_BLOCKS   0x02
+
+//
+// Send the status once the previous transfer is complete.
+//
+#define STATE_SCSI_SEND_STATUS      0x03
+
+//
+// Status was prepared to be sent and now waiting for it to have gone out.
+//
+#define STATE_SCSI_SENT_STATUS      0x04
+
+//*****************************************************************************
+//
+// Device Descriptor.  This is stored in RAM to allow several fields to be
+// changed at runtime based on the client's requirements.
+//
+//*****************************************************************************
+static uint8_t g_pui8MSCDeviceDescriptor[] =
+{
+    18,                             // Size of this structure.
+    USB_DTYPE_DEVICE,               // Type of this structure.
+    USBShort(0x110),                // USB version 1.1 (if we say 2.0, hosts
+                                    // assume
+                                    // high-speed - see USB 2.0 spec 9.2.6.6)
+    0,                              // USB Device Class (spec 5.1.1)
+    0,                              // USB Device Sub-class (spec 5.1.1)
+    0,                              // USB Device protocol (spec 5.1.1)
+    64,                             // Maximum packet size for default pipe.
+    USBShort(0),                    // Vendor ID (filled in during
+                                    // USBDCDCInit).
+    USBShort(0),                    // Product ID (filled in during
+                                    // USBDCDCInit).
+    USBShort(0x100),                // Device Version BCD.
+    1,                              // Manufacturer string identifier.
+    2,                              // Product string identifier.
+    3,                              // Product serial number.
+    1                               // Number of configurations.
+};
+
+//*****************************************************************************
+//
+// Mass storage device configuration descriptor.
+//
+// It is vital that the configuration descriptor bConfigurationValue field
+// (byte 6) is 1 for the first configuration and increments by 1 for each
+// additional configuration defined here.  This relationship is assumed in the
+// device stack for simplicity even though the USB 2.0 specification imposes
+// no such restriction on the bConfigurationValue values.
+//
+// Note that this structure is deliberately located in RAM since we need to
+// be able to patch some values in it based on client requirements.
+//
+//*****************************************************************************
+static uint8_t g_pui8MSCDescriptor[] =
+{
+    //
+    // Configuration descriptor header.
+    //
+    9,                              // Size of the configuration descriptor.
+    USB_DTYPE_CONFIGURATION,        // Type of this descriptor.
+    USBShort(32),                   // The total size of this full structure.
+    1,                              // The number of interfaces in this
+                                    // configuration.
+    1,                              // The unique value for this configuration.
+    0,                              // The string identifier that describes
+                                    // this configuration.
+    USB_CONF_ATTR_SELF_PWR,         // Bus Powered, Self Powered, remote wake
+                                    // up.
+    250,                            // The maximum power in 2mA increments.
+};
+
+//*****************************************************************************
+//
+// The remainder of the configuration descriptor is stored in flash since we
+// don't need to modify anything in it at runtime.
+//
+//*****************************************************************************
+const uint8_t g_pui8MSCInterface[MSCINTERFACE_SIZE] =
+{
+    //
+    // Vendor-specific Interface Descriptor.
+    //
+    9,                              // Size of the interface descriptor.
+    USB_DTYPE_INTERFACE,            // Type of this descriptor.
+    0,                              // The index for this interface.
+    0,                              // The alternate setting for this
+                                    // interface.
+    2,                              // The number of endpoints used by this
+                                    // interface.
+    USB_CLASS_MASS_STORAGE,         // The interface class
+    USB_MSC_SUBCLASS_SCSI,          // The interface sub-class.
+    USB_MSC_PROTO_BULKONLY,         // The interface protocol for the sub-class
+                                    // specified above.
+    0,                              // The string index for this interface.
+
+    //
+    // Endpoint Descriptor
+    //
+    7,                              // The size of the endpoint descriptor.
+    USB_DTYPE_ENDPOINT,             // Descriptor type is an endpoint.
+    USB_EP_DESC_IN | USBEPToIndex(DATA_IN_ENDPOINT),
+    USB_EP_ATTR_BULK,               // Endpoint is a bulk endpoint.
+    USBShort(DATA_IN_EP_MAX_SIZE),  // The maximum packet size.
+    0,                              // The polling interval for this endpoint.
+
+    //
+    // Endpoint Descriptor
+    //
+    7,                              // The size of the endpoint descriptor.
+    USB_DTYPE_ENDPOINT,             // Descriptor type is an endpoint.
+    USB_EP_DESC_OUT | USBEPToIndex(DATA_OUT_ENDPOINT),
+    USB_EP_ATTR_BULK,               // Endpoint is a bulk endpoint.
+    USBShort(DATA_OUT_EP_MAX_SIZE), // The maximum packet size.
+    0,                              // The polling interval for this endpoint.
+};
+
+//*****************************************************************************
+//
+// The mass storage configuration descriptor is defined as two sections,
+// one containing just the 9 byte USB configuration descriptor and the other
+// containing everything else that is sent to the host along with it.
+//
+//*****************************************************************************
+const tConfigSection g_sMSCConfigSection =
+{
+    sizeof(g_pui8MSCDescriptor),
+    g_pui8MSCDescriptor
+};
+
+const tConfigSection g_sMSCInterfaceSection =
+{
+    sizeof(g_pui8MSCInterface),
+    g_pui8MSCInterface
+};
+
+//*****************************************************************************
+//
+// This array lists all the sections that must be concatenated to make a
+// single, complete bulk device configuration descriptor.
+//
+//*****************************************************************************
+const tConfigSection *g_psMSCSections[] =
+{
+    &g_sMSCConfigSection,
+    &g_sMSCInterfaceSection
+};
+
+#define NUM_MSC_SECTIONS        (sizeof(g_psMSCSections) /                    \
+                                 sizeof(g_psMSCSections[0]))
+
+//*****************************************************************************
+//
+// The header for the single configuration we support.  This is the root of
+// the data structure that defines all the bits and pieces that are pulled
+// together to generate the configuration descriptor.
+//
+//*****************************************************************************
+const tConfigHeader g_sMSCConfigHeader =
+{
+    NUM_MSC_SECTIONS,
+    g_psMSCSections
+};
+
+//*****************************************************************************
+//
+// Configuration Descriptor.
+//
+//*****************************************************************************
+const tConfigHeader * const g_ppsMSCConfigDescriptors[] =
+{
+    &g_sMSCConfigHeader
+};
+
+//*****************************************************************************
+//
+// Various internal handlers needed by this class.
+//
+//*****************************************************************************
+static void HandleDisconnect(void *pvMSCDevice);
+static void ConfigChangeHandler(void *pvMSCDevice, uint32_t ui32Value);
+static void HandleEndpoints(void *pvMSCDevice, uint32_t ui32Status);
+static void HandleRequests(void *pvMSCDevice, tUSBRequest *psUSBRequest);
+static void USBDSCSISendStatus(tUSBDMSCDevice *psMSCDevice);
+uint32_t USBDSCSICommand(tUSBDMSCDevice *psMSCDevice, tMSCCBW *psSCSICBW);
+static void HandleDevice(void *pvMSCDevice, uint32_t ui32Request,
+                         void *pvRequestData);
+
+//*****************************************************************************
+//
+// The device information structure for the USB MSC device.
+//
+//*****************************************************************************
+const tCustomHandlers g_sMSCHandlers =
+{
+    //
+    // GetDescriptor
+    //
+    0,
+
+    //
+    // RequestHandler
+    //
+    HandleRequests,
+
+    //
+    // InterfaceChange
+    //
+    0,
+
+    //
+    // ConfigChange
+    //
+    ConfigChangeHandler,
+
+    //
+    // DataReceived
+    //
+    0,
+
+    //
+    // DataSentCallback
+    //
+    0,
+
+    //
+    // ResetHandler
+    //
+    0,
+
+    //
+    // SuspendHandler
+    //
+    0,
+
+    //
+    // ResumeHandler
+    //
+    0,
+
+    //
+    // DisconnectHandler
+    //
+    HandleDisconnect,
+
+    //
+    // EndpointHandler
+    //
+    HandleEndpoints,
+
+    //
+    // Device handler
+    //
+    HandleDevice
+};
+
+//*****************************************************************************
+//
+//! This function is used by an application if it can detect insertion or
+//! removal of the media.
+//!
+//! \param pvMSCDevice is the mass storage device instance that had a media
+//! change.
+//! \param iMediaStatus is the updated status for the media.
+//!
+//! This function should be called by an application when it detects a change
+//! in the status of the media in use by the USB mass storage class.  The
+//! \e iMediaStatus parameter will indicate the new status of the media and
+//! can also indicate that the application has no knowledge of the media state.
+//!
+//! There are currently the three following values for the \e iMediaStatus
+//! parameter:
+//! - \b eUSBDMSCMediaPresent indicates that the media is present or has been
+//! added.
+//! - \b eUSBDMSCMediaNotPresent indicates that the media is not present or was
+//! removed.
+//! - \b eUSBDMSCMediaUnknown indicates that the application has no knowledge
+//! of the media state and the USB mass storage class.
+//!
+//! It will be left up to the application to call this function whenever it
+//! detects a change or simply call it once with \b eUSBDMSCMediaUnknown and
+//! allow the mass storage class to infer the state from the remaining device
+//! APIs.
+//!
+//! \note It is recommended that the application use this function to inform
+//! the mass storage class of media state changes as it will lead to a more
+//! responsive system.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBDMSCMediaChange(void *pvMSCDevice, tUSBDMSCMediaStatus iMediaStatus)
+{
+    tUSBDMSCDevice *psMSCDevice;
+
+    //
+    // Create a device instance pointer.
+    //
+    psMSCDevice = pvMSCDevice;
+
+    //
+    // Save the current media status.
+    //
+    psMSCDevice->sPrivateData.iMediaStatus = iMediaStatus;
+}
+
+//*****************************************************************************
+//
+// This function is called to handle the interrupts on the Bulk endpoints for
+// the mass storage class.
+//
+//*****************************************************************************
+static void
+HandleEndpoints(void *pvMSCDevice, uint32_t ui32Status)
+{
+    tUSBDMSCDevice *psMSCDevice;
+    tMSCInstance *psInst;
+    tMSCCBW *psSCSICBW;
+    uint32_t ui32EPStatus, ui32Size;
+
+    ASSERT(pvMSCDevice != 0);
+
+    //
+    // Determine if the serial device is in single or composite mode because
+    // the meaning of ui32Index is different in both cases.
+    //
+    psMSCDevice = pvMSCDevice;
+
+    //
+    // Initialize the workspace in the passed instance structure.
+    //
+    psInst = &psMSCDevice->sPrivateData;
+
+    //
+    // Get the endpoints status.
+    //
+    ui32EPStatus = MAP_USBEndpointStatus(USB0_BASE, psInst->ui8OUTEndpoint);
+
+    //
+    // Handler for the bulk IN data endpoint.
+    //
+    if((ui32Status & (1 << USBEPToIndex(psInst->ui8INEndpoint))) ||
+       ((psInst->ui32Flags & USBD_FLAG_DMA_IN) &&
+       (USBLibDMAChannelStatus(psInst->psDMAInstance, psInst->ui8INDMA) &
+        USBLIBSTATUS_DMA_COMPLETE)))
+    {
+        switch(psInst->ui8SCSIState)
+        {
+            //
+            // Handle the case where we are sending out data due to a read
+            // command.
+            //
+            case STATE_SCSI_SEND_BLOCKS:
+            {
+                //
+                // Decrement the number of bytes left to send.
+                //
+                psInst->ui32BytesToTransfer -= g_pui32BlockSize;
+
+                //
+                // If we are done then move on to the status phase.
+                //
+                if(psInst->ui32BytesToTransfer == 0)
+                {
+                    //
+                    // Set the status so that it can be sent when this
+                    // response has has be successfully sent.
+                    //
+                    g_sSCSICSW.bCSWStatus = 0;
+                    g_sSCSICSW.dCSWDataResidue = 0;
+
+                    //
+                    // DMA has completed for the IN endpoint.
+                    //
+                    psInst->ui32Flags &= ~USBD_FLAG_DMA_IN;
+
+                    //
+                    // Disable uDMA on the endpoint
+                    //
+                    MAP_USBEndpointDMADisable(USB0_BASE, psInst->ui8INEndpoint,
+                                              USB_EP_DEV_IN);
+
+                    if(psMSCDevice->pfnEventCallback)
+                    {
+                        psMSCDevice->pfnEventCallback(0, USBD_MSC_EVENT_IDLE,
+                                                      0, 0);
+                    }
+
+                    //
+                    // Make sure that the transfer has actually finished.  If
+                    // it has not there will be another interrupt to send
+                    // out the status.
+                    //
+                    if(USBEndpointStatus(USB0_BASE,psInst->ui8INEndpoint) &
+                       USB_DEV_TX_TXPKTRDY)
+                    {
+                        //
+                        // Send back the status once this transfer is complete.
+                        //
+                        psInst->ui8SCSIState = STATE_SCSI_SEND_STATUS;
+                    }
+                    else
+                    {
+                        //
+                        // Indicate success and no extra data coming.
+                        //
+                        USBDSCSISendStatus(psMSCDevice);
+                    }
+
+                    //
+                    // The transfer is complete so don't read anymore data.
+                    //
+                    break;
+                }
+
+                //
+                // Move on to the next Logical Block.
+                //
+                psInst->ui32CurrentLBA++;
+
+                //
+                // Read the new data and send it out.
+                //
+                if(psMSCDevice->sMediaFunctions.pfnBlockRead(psInst->pvMedia,
+                                              (uint8_t *)psInst->pui32Buffer,
+                                              psInst->ui32CurrentLBA, 1) == 0)
+                {
+                }
+
+                //
+                // Configure and enable DMA for the IN transfer.
+                //
+                USBLibDMATransfer(psInst->psDMAInstance,
+                                  psInst->ui8INDMA, psInst->pui32Buffer,
+                                  g_pui32BlockSize);
+
+                //
+                // Start the DMA transfer.
+                //
+                USBLibDMAChannelEnable(psInst->psDMAInstance,
+                                       psInst->ui8INDMA);
+
+                break;
+            }
+
+            //
+            // Handle sending status.
+            //
+            case STATE_SCSI_SEND_STATUS:
+            {
+                //
+                // Indicate success and no extra data coming.
+                //
+                USBDSCSISendStatus(psMSCDevice);
+
+                break;
+            }
+
+            //
+            // Handle completing sending status.
+            //
+            case STATE_SCSI_SENT_STATUS:
+            {
+                psInst->ui8SCSIState = STATE_SCSI_IDLE;
+
+                break;
+            }
+
+            //
+            // These cases should not occur as the being in the IDLE state due
+            // to an IN interrupt is invalid.
+            //
+            case STATE_SCSI_IDLE:
+            default:
+            {
+                break;
+            }
+        }
+    }
+
+    //
+    // Handler for the bulk OUT data endpoint.
+    //
+    if((ui32Status & (0x10000 << USBEPToIndex(psInst->ui8OUTEndpoint))) ||
+        ((psInst->ui32Flags & USBD_FLAG_DMA_OUT) &&
+       (USBLibDMAChannelStatus(psInst->psDMAInstance, psInst->ui8OUTDMA) &
+        USBLIBSTATUS_DMA_COMPLETE)))
+    {
+        //
+        // Get the endpoint status to see why we were called.
+        //
+        ui32EPStatus = MAP_USBEndpointStatus(USB0_BASE,
+                                             psInst->ui8OUTEndpoint);
+
+        switch(psInst->ui8SCSIState)
+        {
+            //
+            // Receiving and writing bytes to the storage device.
+            //
+            case STATE_SCSI_RECEIVE_BLOCKS:
+            {
+                //
+                // Update the current status for the buffer.
+                //
+                psInst->ui32BytesToTransfer -= g_pui32BlockSize;
+
+                //
+                // Write the new data.
+                //
+                psMSCDevice->sMediaFunctions.pfnBlockWrite(psInst->pvMedia,
+                                                (uint8_t *)psInst->pui32Buffer,
+                                                psInst->ui32CurrentLBA, 1);
+
+                //
+                // Move on to the next Logical Block.
+                //
+                psInst->ui32CurrentLBA++;
+
+                //
+                // Check if all bytes have been received.
+                //
+                if(psInst->ui32BytesToTransfer == 0)
+                {
+                    //
+                    // Set the status so that it can be sent when this response
+                    // has be successfully sent.
+                    //
+                    g_sSCSICSW.bCSWStatus = 0;
+                    g_sSCSICSW.dCSWDataResidue = 0;
+
+                    //
+                    // DMA has completed for the OUT endpoint.
+                    //
+                    psInst->ui32Flags &= ~USBD_FLAG_DMA_OUT;
+
+                    //
+                    // Indicate success and no extra data coming.
+                    //
+                    USBDSCSISendStatus(psMSCDevice);
+
+                    //
+                    // Disable uDMA on the endpoint
+                    //
+                    MAP_USBEndpointDMADisable(USB0_BASE,
+                                              psInst->ui8OUTEndpoint,
+                                              USB_EP_DEV_OUT);
+
+                    //
+                    // If there is an event callback then call it to notify
+                    // that last operation has completed.
+                    //
+                    if(psMSCDevice->pfnEventCallback)
+                    {
+                        psMSCDevice->pfnEventCallback(0, USBD_MSC_EVENT_IDLE,
+                                                      0, 0);
+                    }
+                }
+                else
+                {
+                    //
+                    // Configure and enable DMA for the OUT transfer.
+                    //
+                    USBLibDMATransfer(psInst->psDMAInstance,
+                                      psInst->ui8OUTDMA, psInst->pui32Buffer,
+                                      g_pui32BlockSize);
+                }
+
+                break;
+            }
+
+            //
+            // If there is an OUT transfer in idle state then it was a new
+            // command.
+            //
+            case STATE_SCSI_IDLE:
+            {
+                //
+                // Attempt to handle the new command.
+                //
+
+                //
+                // Receive the command.
+                //
+                ui32Size = COMMAND_BUFFER_SIZE;
+                MAP_USBEndpointDataGet(psInst->ui32USBBase,
+                                       psInst->ui8OUTEndpoint,
+                                       g_pui8Command, &ui32Size);
+                psSCSICBW = (tMSCCBW *)g_pui8Command;
+
+                //
+                // Acknowledge the OUT data packet.
+                //
+                MAP_USBDevEndpointDataAck(psInst->ui32USBBase,
+                                          psInst->ui8OUTEndpoint, false);
+
+                //
+                // If this is a valid CBW then handle it.
+                //
+                if(psSCSICBW->dCBWSignature == CBW_SIGNATURE)
+                {
+                    g_sSCSICSW.dCSWSignature = CSW_SIGNATURE;
+                    g_sSCSICSW.dCSWTag = psSCSICBW->dCBWTag;
+                    g_sSCSICSW.dCSWDataResidue = 0;
+                    g_sSCSICSW.bCSWStatus = 0;
+
+                    USBDSCSICommand(psMSCDevice, psSCSICBW);
+                }
+                else
+                {
+                    //
+                    // Just return to the idle state since we are now out of
+                    // sync with the host.  This should not happen, but this
+                    // should allow the device to synchronize with the host
+                    // controller.
+                    //
+                    psInst->ui8SCSIState = STATE_SCSI_IDLE;
+                }
+
+                break;
+            }
+            default:
+            {
+                break;
+            }
+        }
+
+        //
+        // Clear the status bits.
+        //
+        MAP_USBDevEndpointStatusClear(USB0_BASE, psInst->ui8OUTEndpoint,
+                                      ui32EPStatus);
+    }
+}
+
+//*****************************************************************************
+//
+// Device instance specific handler.
+//
+//*****************************************************************************
+static void
+HandleDevice(void *pvMSCDevice, uint32_t ui32Request, void *pvRequestData)
+{
+    tMSCInstance *psInst;
+    uint8_t *pui8Data;
+    tUSBDMSCDevice *psMSCDevice;
+
+    psMSCDevice = (tUSBDMSCDevice *)pvMSCDevice;
+
+    //
+    // Get the instance data pointers.
+    //
+    psInst = &((tUSBDMSCDevice *)pvMSCDevice)->sPrivateData;
+
+    //
+    // Create the 8-bit array used by the events supported by the USB MSC
+    // class.
+    //
+    pui8Data = (uint8_t *)pvRequestData;
+
+    switch(ui32Request)
+    {
+        //
+        // This was an interface change event.
+        //
+        case USB_EVENT_COMP_IFACE_CHANGE:
+        {
+            psInst->ui8Interface = pui8Data[1];
+            break;
+        }
+
+        //
+        // This was an endpoint change event.
+        //
+        case USB_EVENT_COMP_EP_CHANGE:
+        {
+            //
+            // Determine if this is an IN or OUT endpoint that has changed.
+            //
+            if(pui8Data[0] & USB_EP_DESC_IN)
+            {
+                psInst->ui8INEndpoint = IndexToUSBEP((pui8Data[1] & 0x7f));
+
+                //
+                // If the DMA channel has already been allocated then clear
+                // that channel and prepare to possibly use a new one.
+                //
+                if(psInst->ui8INDMA != 0)
+                {
+                    USBLibDMAChannelRelease(psInst->psDMAInstance,
+                                            psInst->ui8INDMA);
+                }
+
+                //
+                // Allocate a DMA channel to the endpoint.
+                //
+                psInst->ui8INDMA =
+                    USBLibDMAChannelAllocate(psInst->psDMAInstance,
+                                             psInst->ui8INEndpoint, 0,
+                                             USB_DMA_EP_TX |
+                                             USB_DMA_EP_DEVICE);
+
+                //
+                // Set the DMA individual transfer size.
+                //
+                USBLibDMAUnitSizeSet(psInst->psDMAInstance, psInst->ui8INDMA,
+                                     32);
+
+                //
+                // Set the DMA arbitration size.
+                //
+                USBLibDMAArbSizeSet(psInst->psDMAInstance, psInst->ui8INDMA,
+                                    16);
+            }
+            else
+            {
+                //
+                // If the DMA channel has already been allocated then clear
+                // that channel and prepare to possibly use a new one.
+                //
+                if(psInst->ui8OUTDMA != 0)
+                {
+                    USBLibDMAChannelRelease(psInst->psDMAInstance,
+                                            psInst->ui8OUTDMA);
+                }
+
+                //
+                // Allocate a DMA channel to the endpoint.
+                //
+                psInst->ui8OUTDMA =
+                    USBLibDMAChannelAllocate(psInst->psDMAInstance,
+                                             psInst->ui8OUTEndpoint, 0,
+                                             USB_DMA_EP_RX |
+                                             USB_DMA_EP_DEVICE);
+
+                //
+                // Set the DMA individual transfer size.
+                //
+                USBLibDMAUnitSizeSet(psInst->psDMAInstance, psInst->ui8OUTDMA,
+                                     32);
+
+                //
+                // Set the DMA arbitration size.
+                //
+                USBLibDMAArbSizeSet(psInst->psDMAInstance, psInst->ui8OUTDMA,
+                                    16);
+            }
+            break;
+        }
+        case USB_EVENT_LPM_RESUME:
+        {
+            if(psMSCDevice->pfnEventCallback)
+            {
+                //
+                // Pass the LPM resume event to the client.
+                //
+                psMSCDevice->pfnEventCallback(0, USB_EVENT_LPM_RESUME, 0,
+                                              (void *)0);
+            }
+            break;
+        }
+        case USB_EVENT_LPM_SLEEP:
+        {
+            if(psMSCDevice->pfnEventCallback)
+            {
+                //
+                // Pass the LPM sleep event to the client.
+                //
+                psMSCDevice->pfnEventCallback(0, USB_EVENT_LPM_RESUME, 0,
+                                              (void *)0);
+            }
+            break;
+        }
+        case USB_EVENT_LPM_ERROR:
+        {
+            if(psMSCDevice->pfnEventCallback)
+            {
+                //
+                // Pass the LPM error event to the client.
+                //
+                psMSCDevice->pfnEventCallback(0, USB_EVENT_LPM_RESUME, 0,
+                                              (void *)0);
+            }
+            break;
+        }
+        default:
+        {
+            break;
+        }
+    }
+}
+
+//*****************************************************************************
+//
+// This function is called by the USB device stack whenever the device is
+// disconnected from the host.
+//
+//*****************************************************************************
+static void
+HandleDisconnect(void *pvMSCDevice)
+{
+    tUSBDMSCDevice *psMSCDevice;
+
+    ASSERT(pvMSCDevice != 0);
+
+    //
+    // Create the instance pointer.
+    //
+    psMSCDevice = (tUSBDMSCDevice *)pvMSCDevice;
+
+    //
+    // Close the drive requested.
+    //
+    if(psMSCDevice->sPrivateData.pvMedia != 0)
+    {
+        psMSCDevice->sPrivateData.pvMedia = 0;
+        psMSCDevice->sMediaFunctions.pfnClose(0);
+    }
+
+    //
+    // If we have a control callback, let the client know we are open for
+    // business.
+    //
+    if(psMSCDevice->pfnEventCallback)
+    {
+        //
+        // Pass the connected event to the client.
+        //
+        psMSCDevice->pfnEventCallback(pvMSCDevice, USB_EVENT_DISCONNECTED, 0,
+                                      0);
+    }
+}
+
+//*****************************************************************************
+//
+// This function is called by the USB device stack whenever the device
+// configuration changes.
+//
+//*****************************************************************************
+static void
+ConfigChangeHandler(void *pvMSCDevice, uint32_t ui32Value)
+{
+    tUSBDMSCDevice *psMSCDevice;
+
+    ASSERT(pvMSCDevice != 0);
+
+    //
+    // Create the instance pointer.
+    //
+    psMSCDevice = (tUSBDMSCDevice *)pvMSCDevice;
+
+    //
+    // If the DMA channel has already been allocated then clear
+    // that channel and prepare to possibly use a new one.
+    //
+    if(psMSCDevice->sPrivateData.ui8OUTDMA != 0)
+    {
+        USBLibDMAChannelRelease(psMSCDevice->sPrivateData.psDMAInstance,
+                                psMSCDevice->sPrivateData.ui8OUTDMA);
+    }
+
+    //
+    // Configure the DMA for the OUT endpoint.
+    //
+    psMSCDevice->sPrivateData.ui8OUTDMA =
+        USBLibDMAChannelAllocate(psMSCDevice->sPrivateData.psDMAInstance,
+                                 psMSCDevice->sPrivateData.ui8OUTEndpoint, 64,
+                                 USB_DMA_EP_RX | USB_DMA_EP_DEVICE);
+
+    USBLibDMAUnitSizeSet(psMSCDevice->sPrivateData.psDMAInstance,
+                         psMSCDevice->sPrivateData.ui8OUTDMA, 32);
+
+    USBLibDMAArbSizeSet(psMSCDevice->sPrivateData.psDMAInstance,
+                        psMSCDevice->sPrivateData.ui8OUTDMA, 16);
+
+    //
+    // If the DMA channel has already been allocated then clear
+    // that channel and prepare to possibly use a new one.
+    //
+    if(psMSCDevice->sPrivateData.ui8INDMA != 0)
+    {
+        USBLibDMAChannelRelease(psMSCDevice->sPrivateData.psDMAInstance,
+                                psMSCDevice->sPrivateData.ui8INDMA);
+    }
+
+    //
+    // Configure the DMA for the IN endpoint.
+    //
+    psMSCDevice->sPrivateData.ui8INDMA =
+        USBLibDMAChannelAllocate(psMSCDevice->sPrivateData.psDMAInstance,
+                                 psMSCDevice->sPrivateData.ui8INEndpoint, 64,
+                                 USB_DMA_EP_TX | USB_DMA_EP_DEVICE);
+
+    USBLibDMAUnitSizeSet(psMSCDevice->sPrivateData.psDMAInstance,
+                         psMSCDevice->sPrivateData.ui8INDMA, 32);
+
+    USBLibDMAArbSizeSet(psMSCDevice->sPrivateData.psDMAInstance,
+                        psMSCDevice->sPrivateData.ui8INDMA, 16);
+
+    //
+    // If we have a control callback, let the client know we are open for
+    // business.
+    //
+    if(psMSCDevice->pfnEventCallback)
+    {
+        //
+        // Pass the connected event to the client.
+        //
+        psMSCDevice->pfnEventCallback(pvMSCDevice, USB_EVENT_CONNECTED, 0, 0);
+    }
+}
+
+//*****************************************************************************
+//
+//! This function should be called once for the mass storage class device to
+//! initialized basic operation and prepare for enumeration.
+//!
+//! \param ui32Index is the index of the USB controller to initialize for
+//! mass storage class device operation.
+//! \param psMSCDevice points to a structure containing parameters customizing
+//! the operation of the mass storage device.
+//!
+//! In order for an application to initialize the USB device mass storage
+//! class, it must first call this function with the a valid mass storage
+//! device class structure in the \e psMSCDevice parameter.  This allows this
+//! function to initialize the USB controller and device code to be prepared to
+//! enumerate and function as a USB mass storage device.
+//!
+//! This function returns a void pointer that must be passed in to all other
+//! APIs used by the mass storage class.
+//!
+//! See the documentation on the tUSBDMSCDevice structure for more information
+//! on how to properly fill the structure members.
+//!
+//! \return Returns 0 on failure or a non-zero void pointer on success.
+//
+//*****************************************************************************
+void *
+USBDMSCInit(uint32_t ui32Index, tUSBDMSCDevice *psMSCDevice)
+{
+    tDeviceDescriptor *psDevDesc;
+    tConfigDescriptor *pConfDesc;
+
+    //
+    // Check parameter validity.
+    //
+    ASSERT(ui32Index == 0);
+    ASSERT(psMSCDevice);
+    ASSERT(psMSCDevice->ppui8StringDescriptors);
+
+    USBDMSCCompositeInit(ui32Index, psMSCDevice, 0);
+
+    //
+    // Fix up the device descriptor with the client-supplied values.
+    //
+    psDevDesc = (tDeviceDescriptor *)g_pui8MSCDeviceDescriptor;
+    psDevDesc->idVendor = psMSCDevice->ui16VID;
+    psDevDesc->idProduct = psMSCDevice->ui16PID;
+
+    //
+    // Fix up the configuration descriptor with client-supplied values.
+    //
+    pConfDesc = (tConfigDescriptor *)g_pui8MSCDescriptor;
+    pConfDesc->bmAttributes = psMSCDevice->ui8PwrAttributes;
+    pConfDesc->bMaxPower = (uint8_t)(psMSCDevice->ui16MaxPowermA / 2);
+
+    //
+    // All is well so now pass the descriptors to the lower layer and put
+    // the bulk device on the bus.
+    //
+    USBDCDInit(ui32Index, &psMSCDevice->sPrivateData.sDevInfo,
+               (void *)psMSCDevice);
+
+    //
+    // Return the pointer to the instance indicating that everything went well.
+    //
+    return((void *)psMSCDevice);
+}
+
+//*****************************************************************************
+//
+//! This function should be called once for the mass storage class device to
+//! initialized basic operation and prepare for enumeration.
+//!
+//! \param ui32Index is the index of the USB controller to initialize for
+//! mass storage class device operation.
+//! \param psMSCDevice points to a structure containing parameters customizing
+//! the operation of the mass storage device.
+//! \param psCompEntry is the composite device entry to initialize when
+//! creating a composite device.
+//!
+//! In order for an application to initialize the USB device mass storage
+//! class, it must first call this function with the a valid mass storage
+//! device class structure in the \e psMSCDevice parameter.  This allows this
+//! function to initialize the USB controller and device code to be prepared to
+//! enumerate and function as a USB mass storage device.  If this mass storage
+//! device is part of a composite device, then the \e psCompEntry should
+//! point to the composite device entry to initialize.  This is part of the
+//! array that is passed to the USBDCompositeInit() function.
+//!
+//! This function returns a void pointer that must be passed in to all other
+//! APIs used by the mass storage class.
+//!
+//! See the documentation on the tUSBDMSCDevice structure for more information
+//! on how to properly fill the structure members.
+//!
+//! \return Returns zero on failure or a non-zero instance value that should be
+//! used with the remaining USB mass storage APIs.
+//
+//*****************************************************************************
+void *
+USBDMSCCompositeInit(uint32_t ui32Index, tUSBDMSCDevice *psMSCDevice,
+                     tCompositeEntry *psCompEntry)
+{
+    tMSCInstance *psInst;
+
+    //
+    // Check parameter validity.
+    //
+    ASSERT(ui32Index == 0);
+    ASSERT(psMSCDevice);
+    ASSERT(psMSCDevice->ppui8StringDescriptors);
+    ASSERT(psCompEntry != 0);
+
+    //
+    // Initialize the workspace in the passed instance structure.
+    //
+    psInst = &psMSCDevice->sPrivateData;
+    psInst->ui32USBBase = USB0_BASE;
+    psInst->bConnected = false;
+    psInst->iMediaStatus = eUSBDMSCMediaUnknown;
+
+    //
+    // Initialize the composite entry that is used by the composite device
+    // class.
+    //
+    if(psCompEntry != 0)
+    {
+        psCompEntry->psDevInfo = &psInst->sDevInfo;
+        psCompEntry->pvInstance = (void *)psMSCDevice;
+    }
+
+    //
+    // Initialize the device information structure.
+    //
+    psInst->sDevInfo.psCallbacks = &g_sMSCHandlers;
+    psInst->sDevInfo.pui8DeviceDescriptor = g_pui8MSCDeviceDescriptor;
+    psInst->sDevInfo.ppsConfigDescriptors = g_ppsMSCConfigDescriptors;
+    psInst->sDevInfo.ppui8StringDescriptors = 0;
+    psInst->sDevInfo.ui32NumStringDescriptors = 0;
+
+    //
+    // Initialize the device info structure for the mass storage device.
+    //
+    USBDCDDeviceInfoInit(0, &psInst->sDevInfo);
+
+    //
+    // Set the initial interface and endpoints.
+    //
+    psInst->ui8Interface = 0;
+    psInst->ui8OUTEndpoint = DATA_OUT_ENDPOINT;
+    psInst->ui8INEndpoint = DATA_IN_ENDPOINT;
+
+    //
+    // Set the initial SCSI state to idle.
+    //
+    psInst->ui8SCSIState = STATE_SCSI_IDLE;
+
+    //
+    // Plug in the client's string stable to the device information
+    // structure.
+    //
+    psInst->sDevInfo.ppui8StringDescriptors =
+                                        psMSCDevice->ppui8StringDescriptors;
+    psInst->sDevInfo.ui32NumStringDescriptors =
+                                        psMSCDevice->ui32NumStringDescriptors;
+
+    //
+    // Open the drive requested.
+    //
+    psInst->pvMedia = psMSCDevice->sMediaFunctions.pfnOpen(0);
+
+    if(psInst->pvMedia == 0)
+    {
+        //
+        // There is no media currently present.
+        //
+        psInst->ui8SenseKey = SCSI_RS_KEY_NOT_READY;
+        psInst->ui16AddSenseCode = SCSI_RS_MED_NOT_PRSNT;
+    }
+    else
+    {
+        //
+        // Media is now ready for use.
+        //
+        psInst->ui8SenseKey = SCSI_RS_KEY_UNIT_ATTN;
+        psInst->ui16AddSenseCode = SCSI_RS_MED_NOTRDY2RDY;
+    }
+
+    //
+    // Enable Clocking to the USB controller.
+    //
+    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_USB0);
+
+    //
+    // Turn on USB Phy clock.
+    //
+    MAP_SysCtlUSBPLLEnable();
+
+    //
+    // Get the DMA instance pointer.
+    //
+    psInst->psDMAInstance = USBLibDMAInit(0);
+
+    //
+    // Return the pointer to the instance indicating that everything went well.
+    //
+    return((void *)psMSCDevice);
+}
+
+//*****************************************************************************
+//
+//! Shuts down the mass storage device.
+//!
+//! \param pvMSCDevice is the pointer to the device instance structure as
+//! returned by USBDMSCInit() or USBDMSCCompositeInit().
+//!
+//! This function terminates mass storage operation for the instance supplied
+//! and removes the device from the USB bus.  Following this call, the
+//! \e pvMSCDevice instance may not me used in any other call to the mass
+//! storage device other than USBDMSCInit() or USBDMSCCompositeInit().
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBDMSCTerm(void *pvMSCDevice)
+{
+    tUSBDMSCDevice *psMSCDevice;
+
+    ASSERT(pvMSCDevice != 0);
+
+    //
+    // Cleanly exit device mode.
+    //
+    USBDCDTerm(0);
+
+    //
+    // Create a device instance pointer.
+    //
+    psMSCDevice = pvMSCDevice;
+
+    //
+    // If the media was opened the close it out.
+    //
+    if(psMSCDevice->sPrivateData.pvMedia != 0)
+    {
+        psMSCDevice->sPrivateData.pvMedia = 0;
+        psMSCDevice->sMediaFunctions.pfnClose(0);
+    }
+}
+
+//*****************************************************************************
+//
+// This function is called by the USB device stack whenever a non-standard
+// request is received.
+//
+// \param pvMSCDevice is instance data for this request.
+// \param pUSBRequest points to the request received.
+//
+// This call parses the provided request structure to determine the command.
+// The only mass storage command supported over endpoint 0 is the Get Max LUN
+// command.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+HandleRequests(void *pvMSCDevice, tUSBRequest *pUSBRequest)
+{
+    //
+    // This class only support a single LUN.
+    //
+    static const uint8_t ui8MaxLun = 0;
+
+    ASSERT(pvMSCDevice != 0);
+
+    //
+    // Determine the type of request.
+    //
+    switch(pUSBRequest->bRequest)
+    {
+        //
+        // A Set Report request is received from the host when it sends an
+        // Output report via endpoint 0.
+        //
+        case USBREQ_GET_MAX_LUN:
+        {
+            //
+            // Need to ACK the data on end point 0 with last data since there
+            // is no more data expected.
+            //
+            USBDevEndpointDataAck(USB0_BASE, USB_EP_0, true);
+
+            //
+            // Send our response to the host.
+            //
+            USBDCDSendDataEP0(0, (uint8_t *)&ui8MaxLun, 1);
+
+            break;
+        }
+        case USBREQ_BULK_ONLY_RESET:
+        {
+            //
+            // Need to ACK the data on end point 0 with last data since there
+            // is no more data expected.
+            //
+            USBDevEndpointDataAck(USB0_BASE, USB_EP_0, true);
+
+            //
+            // Send a null packet to the host.
+            //
+            USBDCDSendDataEP0(0, (uint8_t *)&ui8MaxLun, 0);
+
+            break;
+        }
+
+        //
+        // This request was not recognized so stall.
+        //
+        default:
+        {
+            USBDCDStallEP0(0);
+            break;
+        }
+    }
+}
+
+//*****************************************************************************
+//
+// This function is used to handle the SCSI Inquiry command when it is received
+// from the host.
+//
+//*****************************************************************************
+static void
+USBDSCSIInquiry(tUSBDMSCDevice *psMSCDevice)
+{
+    int32_t i32Idx;
+    tMSCInstance *psInst;
+    uint32_t *pui32Data;
+
+    //
+    // Create a local 32-bit pointer to the command.
+    //
+    pui32Data = (uint32_t *)g_pui8Command;
+
+    //
+    // Create the serial instance data.
+    //
+    psInst = &psMSCDevice->sPrivateData;
+
+    //
+    // Direct Access device, Removable storage and SCSI 1 responses.
+    //
+    pui32Data[0] = SCSI_INQ_PDT_SBC | (SCSI_INQ_RMB << 8);
+
+    //
+    // Additional Length is fixed at 31 bytes.
+    //
+    pui32Data[1] = 31;
+
+    //
+    // Copy the Vendor string.
+    //
+    for(i32Idx = 0; i32Idx < 8; i32Idx++)
+    {
+        g_pui8Command[i32Idx + 8] = psMSCDevice->pui8Vendor[i32Idx];
+    }
+
+    //
+    // Copy the Product string.
+    //
+    for(i32Idx = 0; i32Idx < 16; i32Idx++)
+    {
+        g_pui8Command[i32Idx + 16] = psMSCDevice->pui8Product[i32Idx];
+    }
+
+    //
+    // Copy the Version string.
+    //
+    for(i32Idx = 0; i32Idx < 4; i32Idx++)
+    {
+        g_pui8Command[i32Idx + 32] = psMSCDevice->pui8Version[i32Idx];
+    }
+
+    //
+    // Send the SCSI Inquiry Response.
+    //
+    MAP_USBEndpointDataPut(USB0_BASE, psInst->ui8INEndpoint, g_pui8Command,
+                           36);
+
+    //
+    // Send the data to the host.
+    //
+    MAP_USBEndpointDataSend(USB0_BASE, psInst->ui8INEndpoint, USB_TRANS_IN);
+
+    //
+    // Set the status so that it can be sent when this response has
+    // has be successfully sent.
+    //
+    g_sSCSICSW.bCSWStatus = 0;
+    g_sSCSICSW.dCSWDataResidue = 0;
+
+    psInst->ui8SCSIState = STATE_SCSI_SEND_STATUS;
+}
+
+//*****************************************************************************
+//
+// This function is used to handle the SCSI Read Capacities command when it is
+// received from the host.
+//
+//*****************************************************************************
+static void
+USBDSCSIReadCapacities(tUSBDMSCDevice *psMSCDevice)
+{
+    uint32_t ui32Blocks;
+    tMSCInstance *psInst;
+    uint32_t *pui32Data;
+
+    //
+    // Create a local 32-bit pointer to the command.
+    //
+    pui32Data = (uint32_t *)g_pui8Command;
+
+    //
+    // Get our instance data pointer.
+    //
+    psInst = &psMSCDevice->sPrivateData;
+
+    if(psInst->pvMedia != 0)
+    {
+        if(psMSCDevice->sMediaFunctions.pfnBlockSize)
+        {
+            //
+            // Query the block size for the device
+            //
+            g_pui32BlockSize =
+                     psMSCDevice->sMediaFunctions.pfnBlockSize(psInst->pvMedia);
+        }
+        ui32Blocks =
+                    psMSCDevice->sMediaFunctions.pfnNumBlocks(psInst->pvMedia);
+
+        pui32Data[0] = 0x08000000;
+
+        //
+        // Fill in the number of blocks, the bytes endianness must be changed.
+        //
+        g_pui8Command[4] = ui32Blocks >> 24;
+        g_pui8Command[5] = 0xff & (ui32Blocks >> 16);
+        g_pui8Command[6] = 0xff & (ui32Blocks >> 8);
+        g_pui8Command[7] = 0xff & (ui32Blocks);
+
+        //
+        // Current media capacity
+        //
+        g_pui8Command[8] = 0x2;
+
+        //
+        // Fill in the block size, which is g_pui32BlockSize.
+        //
+        g_pui8Command[9] = 0xff & (g_pui32BlockSize >> 16);
+        g_pui8Command[10] = 0xff & (g_pui32BlockSize >> 8);
+        g_pui8Command[11] = 0xff & g_pui32BlockSize;
+
+        //
+        // Send out the 12 bytes that are in this response.
+        //
+        MAP_USBEndpointDataPut(USB0_BASE, psInst->ui8INEndpoint, g_pui8Command,
+                               12);
+        MAP_USBEndpointDataSend(USB0_BASE, psInst->ui8INEndpoint,
+                                USB_TRANS_IN);
+
+        //
+        // Set the status so that it can be sent when this response has
+        // has be successfully sent.
+        //
+        g_sSCSICSW.bCSWStatus = 0;
+        g_sSCSICSW.dCSWDataResidue = 0;
+    }
+    else
+    {
+        //
+        // Set the status so that it can be sent when this response has
+        // has be successfully sent.
+        //
+        g_sSCSICSW.bCSWStatus = 1;
+        g_sSCSICSW.dCSWDataResidue = 0;
+
+        //
+        // Stall the IN endpoint
+        //
+        MAP_USBDevEndpointStall(USB0_BASE, psInst->ui8INEndpoint,
+                                USB_EP_DEV_IN);
+
+        //
+        // Mark the sense code as valid and indicate that these is no media
+        // present.
+        //
+        psInst->ui8ErrorCode = SCSI_RS_VALID | SCSI_RS_CUR_ERRORS;
+        psInst->ui8SenseKey = SCSI_RS_KEY_NOT_READY;
+        psInst->ui16AddSenseCode = SCSI_RS_MED_NOT_PRSNT;
+    }
+
+    psInst->ui8SCSIState = STATE_SCSI_SEND_STATUS;
+}
+
+//*****************************************************************************
+//
+// This function is used to handle the SCSI Read Capacity command when it is
+// received from the host.
+//
+//*****************************************************************************
+static void
+USBDSCSIReadCapacity(tUSBDMSCDevice *psMSCDevice)
+{
+    uint32_t ui32Blocks;
+    tMSCInstance *psInst;
+
+    //
+    // Get our instance data pointer.
+    //
+    psInst = &psMSCDevice->sPrivateData;
+
+    if(psMSCDevice->sMediaFunctions.pfnBlockSize)
+    {
+        //
+        // Query the block size for the device
+        //
+        g_pui32BlockSize =
+                 psMSCDevice->sMediaFunctions.pfnBlockSize(psInst->pvMedia);
+    }
+
+    ui32Blocks = psMSCDevice->sMediaFunctions.pfnNumBlocks(psInst->pvMedia);
+
+    //
+    // Only decrement if any blocks were found.
+    //
+    if(ui32Blocks != 0)
+    {
+        //
+        // One less than the maximum number is the last addressable
+        // block.
+        //
+        ui32Blocks--;
+    }
+
+    if(psInst->pvMedia != 0)
+    {
+        //
+        // Fill in the number of blocks, the bytes endianness must be changed.
+        //
+        g_pui8Command[0] = 0xff & (ui32Blocks >> 24);
+        g_pui8Command[1] = 0xff & (ui32Blocks >> 16);
+        g_pui8Command[2] = 0xff & (ui32Blocks >> 8);
+        g_pui8Command[3] = 0xff & (ui32Blocks);
+
+        g_pui8Command[4] = 0;
+
+        //
+        // Fill in the block size, which is g_pui32BlockSize.
+        //
+        g_pui8Command[5] = 0xff & (g_pui32BlockSize >> 16);
+        g_pui8Command[6] = 0xff & (g_pui32BlockSize >> 8);
+        g_pui8Command[7] = 0xff & g_pui32BlockSize;
+
+        //
+        // Send the SCSI Inquiry Response.
+        //
+        MAP_USBEndpointDataPut(USB0_BASE, psInst->ui8INEndpoint, g_pui8Command,
+                               8);
+        MAP_USBEndpointDataSend(USB0_BASE, psInst->ui8INEndpoint,
+                                USB_TRANS_IN);
+
+        //
+        // Set the status so that it can be sent when this response has
+        // has be successfully sent.
+        //
+        g_sSCSICSW.bCSWStatus = 0;
+        g_sSCSICSW.dCSWDataResidue = 0;
+    }
+    else
+    {
+        //
+        // Set the status so that it can be sent when this response has
+        // has be successfully sent.
+        //
+        g_sSCSICSW.bCSWStatus = 1;
+        g_sSCSICSW.dCSWDataResidue = 0;
+
+        //
+        // Stall the IN endpoint
+        //
+        MAP_USBDevEndpointStall(USB0_BASE, psInst->ui8INEndpoint,
+                                USB_EP_DEV_IN);
+
+        //
+        // Mark the sense code as valid and indicate that these is no media
+        // present.
+        //
+        psInst->ui8ErrorCode = SCSI_RS_VALID | SCSI_RS_CUR_ERRORS;
+        psInst->ui8SenseKey = SCSI_RS_KEY_NOT_READY;
+        psInst->ui16AddSenseCode = SCSI_RS_MED_NOT_PRSNT;
+    }
+
+    psInst->ui8SCSIState = STATE_SCSI_SEND_STATUS;
+}
+
+//*****************************************************************************
+//
+// This function is used to handle the SCSI Request Sense command when it is
+// received from the host.
+//
+//*****************************************************************************
+static void
+USBDSCSIRequestSense(tUSBDMSCDevice *psMSCDevice)
+{
+    tMSCInstance *psInst;
+    int32_t i32Idx;
+
+    //
+    // Zero out the response data.
+    //
+    for(i32Idx = 0; i32Idx < 18; i32Idx++)
+    {
+        g_pui8Command[i32Idx] = 0;
+    }
+
+    //
+    // Get our instance data pointer.
+    //
+    psInst = &psMSCDevice->sPrivateData;
+
+    //
+    // The request sense response.
+    //
+    g_pui8Command[0] = psInst->ui8ErrorCode;
+    g_pui8Command[2] = psInst->ui8SenseKey;
+
+    //
+    // There are 10 more bytes of data.
+    //
+    g_pui8Command[7] = 10;
+
+    //
+    // Transition from not ready to ready.
+    //
+    g_pui8Command[12] = (uint8_t)psInst->ui16AddSenseCode;
+    g_pui8Command[13] = (uint8_t)(psInst->ui16AddSenseCode >> 8);
+
+    //
+    // Send the SCSI Inquiry Response.
+    //
+    MAP_USBEndpointDataPut(USB0_BASE, psInst->ui8INEndpoint, g_pui8Command,
+                           18);
+    MAP_USBEndpointDataSend(USB0_BASE, psInst->ui8INEndpoint, USB_TRANS_IN);
+
+    //
+    // Reset the valid flag on errors.
+    //
+    psInst->ui8ErrorCode = SCSI_RS_CUR_ERRORS;
+
+    //
+    // Set the status so that it can be sent when this response has
+    // has be successfully sent.
+    //
+    g_sSCSICSW.bCSWStatus = 0;
+    g_sSCSICSW.dCSWDataResidue = 0;
+
+    //
+    // Move on to the status phase.
+    //
+    psInst->ui8SCSIState = STATE_SCSI_SEND_STATUS;
+}
+
+//*****************************************************************************
+//
+// This function is used to handle the SCSI Read 10 command when it is
+// received from the host.
+//
+//*****************************************************************************
+static void
+USBDSCSIRead10(tUSBDMSCDevice *psMSCDevice, tMSCCBW *psSCSICBW)
+{
+    uint16_t ui16NumBlocks;
+    tMSCInstance *psInst;
+
+    //
+    // Default the number of blocks.
+    //
+    ui16NumBlocks = 0;
+
+    //
+    // Get our instance data pointer.
+    //
+    psInst = &psMSCDevice->sPrivateData;
+
+    if(psInst->pvMedia != 0)
+    {
+        //
+        // Get the logical block from the CBW structure. This switching
+        // is required to convert from big to little endian.
+        //
+        psInst->ui32CurrentLBA = (psSCSICBW->CBWCB[2] << 24) |
+                                 (psSCSICBW->CBWCB[3] << 16) |
+                                 (psSCSICBW->CBWCB[4] << 8) |
+                                 (psSCSICBW->CBWCB[5] << 0);
+
+        //
+        // More bytes to read.
+        //
+        ui16NumBlocks = (psSCSICBW->CBWCB[7] << 8) | psSCSICBW->CBWCB[8];
+
+        //
+        // Read the next logical block from the storage device.
+        //
+        if(psMSCDevice->sMediaFunctions.pfnBlockRead(psInst->pvMedia,
+               (uint8_t *)psInst->pui32Buffer, psInst->ui32CurrentLBA, 1) == 0)
+        {
+            psInst->pvMedia = 0;
+            psMSCDevice->sMediaFunctions.pfnClose(0);
+        }
+    }
+
+    //
+    // If there is media present then start transferring the data.
+    //
+    if(psInst->pvMedia != 0)
+    {
+        //
+        // Configure and DMA for the IN transfer.
+        //
+        USBLibDMATransfer(psInst->psDMAInstance, psInst->ui8INDMA,
+                          psInst->pui32Buffer, g_pui32BlockSize);
+
+        //
+        // Remember that a DMA is in progress.
+        //
+        psInst->ui32Flags |= USBD_FLAG_DMA_IN;
+
+        //
+        // Schedule the remaining bytes to send.
+        //
+        psInst->ui32BytesToTransfer = (g_pui32BlockSize * ui16NumBlocks);
+
+        //
+        // Move on and start sending blocks.
+        //
+        psInst->ui8SCSIState = STATE_SCSI_SEND_BLOCKS;
+
+        if(psMSCDevice->pfnEventCallback)
+        {
+            psMSCDevice->pfnEventCallback(0, USBD_MSC_EVENT_READING, 0, 0);
+        }
+    }
+    else
+    {
+        //
+        // Set the status so that it can be sent when this response has
+        // has be successfully sent.
+        //
+        g_sSCSICSW.bCSWStatus = 1;
+        g_sSCSICSW.dCSWDataResidue = 0;
+
+        //
+        // Stall the IN endpoint
+        //
+        MAP_USBDevEndpointStall(USB0_BASE, psInst->ui8INEndpoint,
+                                USB_EP_DEV_IN);
+
+        //
+        // Mark the sense code as valid and indicate that these is no media
+        // present.
+        //
+        psInst->ui8ErrorCode = SCSI_RS_VALID | SCSI_RS_CUR_ERRORS;
+        psInst->ui8SenseKey = SCSI_RS_KEY_NOT_READY;
+        psInst->ui16AddSenseCode = SCSI_RS_MED_NOT_PRSNT;
+
+        psInst->ui8SCSIState = STATE_SCSI_SEND_STATUS;
+    }
+}
+
+//*****************************************************************************
+//
+// This function is used to handle the SCSI Read 10 command when it is
+// received from the host.
+//
+//*****************************************************************************
+static void
+USBDSCSIWrite10(tUSBDMSCDevice *psMSCDevice, tMSCCBW *psSCSICBW)
+{
+    uint16_t ui16NumBlocks;
+    tMSCInstance *psInst;
+
+    //
+    // Get instance data pointers.
+    //
+    psInst = &psMSCDevice->sPrivateData;
+
+    //
+    // If there is media present then start transferring the data.
+    //
+    if(psInst->pvMedia != 0)
+    {
+        //
+        // Get the logical block from the CBW structure. This switching
+        // is required to convert from big to little endian.
+        //
+        psInst->ui32CurrentLBA = (psSCSICBW->CBWCB[2] << 24) |
+                                 (psSCSICBW->CBWCB[3] << 16) |
+                                 (psSCSICBW->CBWCB[4] << 8) |
+                                 (psSCSICBW->CBWCB[5] << 0);
+
+        //
+        // More bytes to read.
+        //
+        ui16NumBlocks = (psSCSICBW->CBWCB[7] << 8) | psSCSICBW->CBWCB[8];
+
+        psInst->ui32BytesToTransfer = g_pui32BlockSize * ui16NumBlocks;
+
+        //
+        // Start sending logical blocks, these are always multiples of
+        // g_pui32BlockSize bytes.
+        //
+        psInst->ui8SCSIState = STATE_SCSI_RECEIVE_BLOCKS;
+
+        //
+        // Configure and enable DMA for the OUT transfer.
+        //
+        USBLibDMATransfer(psInst->psDMAInstance, psInst->ui8OUTDMA,
+                          psInst->pui32Buffer, g_pui32BlockSize);
+
+        //
+        // Remember that a DMA is in progress.
+        //
+        psInst->ui32Flags |= USBD_FLAG_DMA_OUT;
+
+        //
+        // Notify the application of the write event.
+        //
+        if(psMSCDevice->pfnEventCallback)
+        {
+            psMSCDevice->pfnEventCallback(0, USBD_MSC_EVENT_WRITING, 0, 0);
+        }
+    }
+    else
+    {
+        //
+        // Set the status so that it can be sent when this response has
+        // has be successfully sent.
+        //
+        g_sSCSICSW.bCSWStatus = 1;
+        g_sSCSICSW.dCSWDataResidue = 0;
+
+        //
+        // Stall the IN endpoint
+        //
+        MAP_USBDevEndpointStall(USB0_BASE, psInst->ui8OUTEndpoint,
+                                USB_EP_DEV_OUT);
+
+        //
+        // Mark the sense code as valid and indicate that these is no media
+        // present.
+        //
+        psInst->ui8ErrorCode = SCSI_RS_VALID | SCSI_RS_CUR_ERRORS;
+        psInst->ui8SenseKey = SCSI_RS_KEY_NOT_READY;
+        psInst->ui16AddSenseCode = SCSI_RS_MED_NOT_PRSNT;
+
+        psInst->ui8SCSIState = STATE_SCSI_SEND_STATUS;
+    }
+}
+
+//*****************************************************************************
+//
+// This function is used to handle the SCSI Mode Sense 6 command when it is
+// received from the host.
+//
+//*****************************************************************************
+static void
+USBDSCSIModeSense6(tUSBDMSCDevice *psMSCDevice, tMSCCBW *psSCSICBW)
+{
+    tMSCInstance *psInst;
+
+    //
+    // Get our instance data pointer.
+    //
+    psInst = &psMSCDevice->sPrivateData;
+
+    //
+    // If there is media present send the response.
+    //
+    if(psInst->pvMedia != 0)
+    {
+        //
+        // Three extra bytes in this response.
+        //
+        g_pui8Command[0] = 3;
+        g_pui8Command[1] = 0;
+        g_pui8Command[2] = 0;
+        g_pui8Command[3] = 0;
+
+        //
+        // Manually send the response back to the host.
+        //
+        MAP_USBEndpointDataPut(USB0_BASE, psInst->ui8INEndpoint, g_pui8Command,
+                               4);
+        MAP_USBEndpointDataSend(USB0_BASE, psInst->ui8INEndpoint,
+                                USB_TRANS_IN);
+
+        //
+        // Set the status so that it can be sent when this response has
+        // has be successfully sent.
+        //
+        g_sSCSICSW.bCSWStatus = 0;
+        g_sSCSICSW.dCSWDataResidue = psSCSICBW->dCBWDataTransferLength - 4;
+    }
+    else
+    {
+        //
+        // Set the status so that it can be sent when this response has
+        // has be successfully sent.
+        //
+        g_sSCSICSW.bCSWStatus = 1;
+        g_sSCSICSW.dCSWDataResidue = 0;
+
+        //
+        // Stall the IN endpoint
+        //
+        MAP_USBDevEndpointStall(USB0_BASE, psInst->ui8INEndpoint,
+                                USB_EP_DEV_IN);
+
+        //
+        // Mark the sense code as valid and indicate that these is no media
+        // present.
+        //
+        psInst->ui8ErrorCode = SCSI_RS_VALID | SCSI_RS_CUR_ERRORS;
+        psInst->ui8SenseKey = SCSI_RS_KEY_NOT_READY;
+        psInst->ui16AddSenseCode = SCSI_RS_MED_NOT_PRSNT;
+    }
+
+    psInst->ui8SCSIState = STATE_SCSI_SEND_STATUS;
+}
+
+//*****************************************************************************
+//
+// This function is used to send out the response data based on the current
+// status of the mass storage class.
+//
+//*****************************************************************************
+static void
+USBDSCSISendStatus(tUSBDMSCDevice *psMSCDevice)
+{
+    tMSCInstance *psInst;
+
+    //
+    // Get our instance data pointer.
+    //
+    psInst = &psMSCDevice->sPrivateData;
+
+    //
+    // Respond with the requested status.
+    //
+    MAP_USBEndpointDataPut(USB0_BASE, psInst->ui8INEndpoint,
+                           (uint8_t *)&g_sSCSICSW, 13);
+    MAP_USBEndpointDataSend(USB0_BASE, psInst->ui8INEndpoint, USB_TRANS_IN);
+
+    //
+    // Move the state to status sent so that the next interrupt will move the
+    // statue to idle.
+    //
+    psInst->ui8SCSIState = STATE_SCSI_SENT_STATUS;
+}
+
+//*****************************************************************************
+//
+// This function is used to handle the Prevent/Allow Medium Removal command when it is
+// received from the host.
+//
+//*****************************************************************************
+static void
+USBDSCSIPreventAllowMediumRemoval(tUSBDMSCDevice *psMSCDevice, tMSCCBW *psSCSICBW)
+{
+    tMSCInstance *psInst;
+
+    //
+    // Get our instance data pointer.
+    //
+    psInst = &psMSCDevice->sPrivateData;
+
+    //
+    // If there is media present send the response.
+    //
+    if(psInst->pvMedia != 0)
+    {
+        //
+        // See if this was an allow or prevent removal request.
+        //
+        if((psSCSICBW->CBWCB[4] & SCSI_PE_MEDRMV_M) == SCSI_PE_MEDRMV_ALLOW)
+        {
+            psInst->ui32Flags |= USBD_FLAG_ALLOW_REMOVAL;
+        }
+        else
+        {
+            psInst->ui32Flags &= ~USBD_FLAG_ALLOW_REMOVAL;
+        }
+
+        //
+        // Set the status so that it can be sent when this response has
+        // has be successfully sent.
+        //
+        g_sSCSICSW.bCSWStatus = 0;
+        g_sSCSICSW.dCSWDataResidue = 0;
+    }
+    else
+    {
+        //
+        // Set the status so that it can be sent when this response has
+        // has be successfully sent.
+        //
+        g_sSCSICSW.bCSWStatus = 1;
+        g_sSCSICSW.dCSWDataResidue = 0;
+
+        //
+        // Stall the IN endpoint
+        //
+        MAP_USBDevEndpointStall(USB0_BASE, psInst->ui8INEndpoint,
+                                USB_EP_DEV_IN);
+
+        //
+        // Mark the sense code as valid and indicate that these is no media
+        // present.
+        //
+        psInst->ui8ErrorCode = SCSI_RS_VALID | SCSI_RS_CUR_ERRORS;
+        psInst->ui8SenseKey = SCSI_RS_KEY_NOT_READY;
+        psInst->ui16AddSenseCode = SCSI_RS_MED_NOT_PRSNT;
+    }
+
+    psInst->ui8SCSIState = STATE_SCSI_SEND_STATUS;
+}
+
+//*****************************************************************************
+//
+// This function is used to handle the SCSI Start/Stop Unit command when it is
+// received from the host.
+//
+//*****************************************************************************
+static void
+USBDSCSIStartStopUnit(tUSBDMSCDevice *psMSCDevice, tMSCCBW *psSCSICBW)
+{
+    tMSCInstance *psInst;
+
+    //
+    // Get our instance data pointer.
+    //
+    psInst = &psMSCDevice->sPrivateData;
+
+    //
+    // If there is media present send the response.
+    //
+    if(psInst->pvMedia != 0)
+    {
+        switch(psSCSICBW->CBWCB[4] & (SCSI_SS_UNIT_START | SCSI_SS_UNIT_LOEJ))
+        {
+            case 0:
+            {
+                //
+                // Media state is now stopped but not ejected.
+                //
+                psInst->iMediaStatus = eUSBDMSCMediaStopped;
+
+                g_sSCSICSW.bCSWStatus = 0;
+
+                break;
+            }
+            case SCSI_SS_UNIT_START:
+            {
+                //
+                // Return to Media present.
+                //
+                psInst->iMediaStatus = eUSBDMSCMediaPresent;
+
+                g_sSCSICSW.bCSWStatus = 0;
+
+                break;
+            }
+            case SCSI_SS_UNIT_LOEJ:
+            {
+                //
+                // Only allow eject if the Prevent/Allow Medium Removal has
+                // been sent and enabled medium removal.
+                //
+                if(psInst->ui32Flags & USBD_FLAG_ALLOW_REMOVAL)
+                {
+                    psInst->iMediaStatus = eUSBDMSCMediaNotPresent;
+                    psMSCDevice->sMediaFunctions.pfnClose(0);
+                    psMSCDevice->sPrivateData.pvMedia = 0;
+                    g_sSCSICSW.bCSWStatus = 0;
+                }
+                else
+                {
+                    g_sSCSICSW.bCSWStatus = 1;
+                }
+
+                break;
+            }
+            case SCSI_SS_UNIT_START | SCSI_SS_UNIT_LOEJ:
+            {
+                //
+                // Since there was no media, check for media here.
+                //
+                psInst->pvMedia = psMSCDevice->sMediaFunctions.pfnOpen(0);
+
+                //
+                // If it is still not present then fail this command.
+                //
+                if(psInst->pvMedia != 0)
+                {
+                    g_sSCSICSW.bCSWStatus = 0;
+                }
+                else
+                {
+                    g_sSCSICSW.bCSWStatus = 1;
+                }
+                break;
+            }
+            default:
+            {
+                break;
+            }
+        }
+
+        //
+        // There is no further data to send.
+        //
+        g_sSCSICSW.dCSWDataResidue = 0;
+    }
+    else
+    {
+        //
+        // Set the status so that it can be sent when this response has
+        // has be successfully sent.
+        //
+        g_sSCSICSW.bCSWStatus = 1;
+        g_sSCSICSW.dCSWDataResidue = 0;
+
+        //
+        // Stall the IN endpoint
+        //
+        MAP_USBDevEndpointStall(USB0_BASE, psInst->ui8INEndpoint,
+                                USB_EP_DEV_IN);
+
+        //
+        // Mark the sense code as valid and indicate that these is no media
+        // present.
+        //
+        psInst->ui8ErrorCode = SCSI_RS_VALID | SCSI_RS_CUR_ERRORS;
+        psInst->ui8SenseKey = SCSI_RS_KEY_NOT_READY;
+        psInst->ui16AddSenseCode = SCSI_RS_MED_NOT_PRSNT;
+    }
+
+    psInst->ui8SCSIState = STATE_SCSI_SEND_STATUS;
+}
+
+//*****************************************************************************
+//
+// This function is used to handle all SCSI commands.
+//
+//*****************************************************************************
+uint32_t
+USBDSCSICommand(tUSBDMSCDevice *psMSCDevice, tMSCCBW *psSCSICBW)
+{
+    uint32_t ui32RetCode, ui32TransferLength;
+    tMSCInstance *psInst;
+
+    //
+    // Get our instance data pointer.
+    //
+    psInst = &psMSCDevice->sPrivateData;
+
+    //
+    // Initialize the return code.
+    //
+    ui32RetCode = 1;
+
+    //
+    // Save the transfer length because it may be overwritten by some calls.
+    //
+    ui32TransferLength = psSCSICBW->dCBWDataTransferLength;
+
+    switch(psSCSICBW->CBWCB[0])
+    {
+        //
+        // Respond to the SCSI Inquiry command.
+        //
+        case SCSI_INQUIRY_CMD:
+        {
+            USBDSCSIInquiry(psMSCDevice);
+
+            break;
+        }
+
+        //
+        // Respond to the test unit ready command.
+        //
+        case SCSI_TEST_UNIT_READY:
+        {
+            g_sSCSICSW.dCSWDataResidue = 0;
+
+            if(psInst->pvMedia != 0)
+            {
+                //
+                // Set the status to success for now, this could be different
+                // if there is no media present.
+                //
+                g_sSCSICSW.bCSWStatus = 0;
+            }
+            else if(psInst->iMediaStatus == eUSBDMSCMediaNotPresent)
+            {
+                //
+                // Set the status to success for now, this could be different
+                // if there is no media present.
+                //
+                g_sSCSICSW.bCSWStatus = 1;
+                psInst->ui8ErrorCode = SCSI_RS_VALID | SCSI_RS_CUR_ERRORS;
+                psInst->ui8SenseKey = SCSI_RS_KEY_NOT_READY;
+                psInst->ui16AddSenseCode = SCSI_RS_MED_NOT_PRSNT;
+            }
+            else
+            {
+                //
+                // Since there was no media, check for media here.
+                //
+                psInst->pvMedia = psMSCDevice->sMediaFunctions.pfnOpen(0);
+
+                //
+                // If it is still not present then fail this command.
+                //
+                if(psInst->pvMedia != 0)
+                {
+                    g_sSCSICSW.bCSWStatus = 0;
+                }
+                else
+                {
+                    g_sSCSICSW.bCSWStatus = 1;
+                }
+            }
+            break;
+        }
+
+        //
+        // Handle the Read Capacities command.
+        //
+        case SCSI_READ_CAPACITIES:
+        {
+            USBDSCSIReadCapacities(psMSCDevice);
+
+            break;
+        }
+
+        //
+        // Handle the Read Capacity command.
+        //
+        case SCSI_READ_CAPACITY:
+        {
+            USBDSCSIReadCapacity(psMSCDevice);
+
+            break;
+        }
+
+        //
+        // Handle the Request Sense command.
+        //
+        case SCSI_REQUEST_SENSE:
+        {
+            USBDSCSIRequestSense(psMSCDevice);
+
+            break;
+        }
+
+        //
+        // Handle the Read 10 command.
+        //
+        case SCSI_READ_10:
+        {
+            USBDSCSIRead10(psMSCDevice, psSCSICBW);
+
+            break;
+        }
+
+        //
+        // Handle the Write 10 command.
+        //
+        case SCSI_WRITE_10:
+        {
+            USBDSCSIWrite10(psMSCDevice, psSCSICBW);
+
+            break;
+        }
+
+        //
+        // Handle the Mode Sense 6 command.
+        //
+        case SCSI_MODE_SENSE_6:
+        {
+            USBDSCSIModeSense6(psMSCDevice, psSCSICBW);
+
+            break;
+        }
+
+        //
+        // Handle the Prevent/Allow Medium Removal command.
+        //
+        case SCSI_MEDIUM_REMOVAL:
+        {
+            USBDSCSIPreventAllowMediumRemoval(psMSCDevice, psSCSICBW);
+
+            break;
+        }
+
+        //
+        // Handle the Prevent/Allow Medium Removal command.
+        //
+        case SCSI_START_STOP_UNIT:
+        {
+            USBDSCSIStartStopUnit(psMSCDevice, psSCSICBW);
+            break;
+        }
+
+        default:
+        {
+            //
+            // Set the status so that it can be sent when this response has
+            // has be successfully sent.
+            //
+            g_sSCSICSW.bCSWStatus = 1;
+            g_sSCSICSW.dCSWDataResidue = psSCSICBW->dCBWDataTransferLength;
+
+            //
+            // If there is data then there is more work to do.
+            //
+            if(psSCSICBW->dCBWDataTransferLength != 0)
+            {
+                if(psSCSICBW->bmCBWFlags & CBWFLAGS_DIR_IN)
+                {
+                    //
+                    // Stall the IN endpoint
+                    //
+                    MAP_USBDevEndpointStall(USB0_BASE, psInst->ui8INEndpoint,
+                                            USB_EP_DEV_IN);
+                }
+                else
+                {
+                    //
+                    // Stall the OUT endpoint
+                    //
+                    MAP_USBDevEndpointStall(USB0_BASE, psInst->ui8OUTEndpoint,
+                                            USB_EP_DEV_OUT);
+
+                }
+
+                //
+                // Go back to the idle state and wait for the host to clear
+                // the stall later.
+                //
+                psInst->ui8SCSIState = STATE_SCSI_IDLE;
+            }
+
+            //
+            // Set the sense codes.
+            //
+            psInst->ui8ErrorCode = SCSI_RS_VALID | SCSI_RS_CUR_ERRORS;
+            psInst->ui8SenseKey = SCSI_RS_KEY_ILGL_RQST;
+            psInst->ui16AddSenseCode = SCSI_RS_PV_INVALID;
+
+            break;
+        }
+    }
+
+    //
+    // If there is no data then send out the current status.
+    //
+    if(ui32TransferLength == 0)
+    {
+        USBDSCSISendStatus(psMSCDevice);
+    }
+    return(ui32RetCode);
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
diff --git a/bsp/tm4c129x/libraries/usblib/device/usbdmsc.h b/bsp/tm4c129x/libraries/usblib/device/usbdmsc.h
new file mode 100755
index 0000000..9f5241f
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/device/usbdmsc.h
@@ -0,0 +1,420 @@
+//*****************************************************************************
+//
+// usbdmsc.h - USB mass storage device class driver.
+//
+// Copyright (c) 2009-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#ifndef __USBDMSC_H__
+#define __USBDMSC_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+//*****************************************************************************
+//
+//! \addtogroup msc_device_class_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! Media Access functions.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! This function is used to initialize and open the physical drive number
+    //! associated with the parameter \e ui32Drive.  The function returns
+    //! zero if the drive could not be opened for some reason.  In the case of
+    //! removable device like an SD card this function must return zero if
+    //! the SD card is not present.
+    //! The function returns a pointer to data that should be passed to other
+    //! APIs or returns 0 if no drive was found.
+    //
+    void *(*pfnOpen)(uint32_t ui32Drive);
+
+    //*************************************************************************
+    //
+    //! This function closes the drive number in use by the mass storage class
+    //! device.  The \e pvDrive is the pointer that was returned from a call to
+    //! \e pfnOpen. This function is used to close the physical drive
+    //! number associated with the parameter \e pvDrive.  This function
+    //! returns 0 if the drive was closed successfully and any other value
+    //! indicates a failure.
+    //
+    //*************************************************************************
+    void (*pfnClose)(void *pvDrive);
+
+    //*************************************************************************
+    //
+    //! This function reads a block of data from a device opened by the
+    //! \e pfnOpen call.  The \e pvDrive parameter is the pointer that was
+    //! returned from the original call to \e pfnOpen.  The \e pui8Data
+    //! parameter is the buffer that data will be written into.  The data area
+    //! pointed to by \e pui8Data must be at least \e ui32NumBlocks * Block
+    //! Size bytes to prevent overwriting data. The \e ui32Sector is the block
+    //! address to read and \e ui32NumBlocks is the number of blocks to read.
+    //! This function returns the number of bytes that were read from the
+    //! and placed into the \e pui8Data buffer..
+    //
+    //*************************************************************************
+    uint32_t (*pfnBlockRead)(void *pvDrive, uint8_t *pui8Data,
+                                uint32_t ui32Sector, uint32_t ui32NumBlocks);
+
+    //*************************************************************************
+    //
+    //! This function is use to write blocks to a physical device from the
+    //! buffer pointed to by the \e pui8Data buffer. The \e pvDrive parameter
+    //! is the pointer that was returned from the original call to \e pfnOpen.
+    //! The \e pui8Data is the pointer to the data to write to the storage
+    //! device and \e ui32NumBlocks is the number of blocks to write.  The
+    //! \e ui32Sector parameter is the sector number used to write the block.
+    //! If the number of blocks is greater than one then the block address
+    //! increments and writes to the next block until
+    //! \e ui32NumBlocks * Block Size bytes are written.  This function returns
+    //! the number of bytes that were written to the device.
+    //
+    //*************************************************************************
+    uint32_t (*pfnBlockWrite)(void *pvDrive, uint8_t *pui8Data,
+                              uint32_t ui32Sector, uint32_t ui32NumBlocks);
+
+    //*************************************************************************
+    //
+    //! This function returns the total number of blocks on a physical device
+    //! based on the \e pvDrive parameter.  The \e pvDrive parameter
+    //! is the pointer that was returned from the original call to \e pfnOpen.
+    //
+    //*************************************************************************
+    uint32_t (*pfnNumBlocks)(void *pvDrive);
+
+    //*************************************************************************
+    //
+    //! This function returns the block size for a physical device based on the
+    //! \e pvDrive parameter.  The \e pvDrive parameter is the pointer
+    //! that was returned from the original call to \e pfnOpen.
+    //
+    //*************************************************************************
+    uint32_t (*pfnBlockSize)(void *pvDrive);
+
+}
+tMSCDMedia;
+
+//*****************************************************************************
+//
+// These defines control the default sizes of USB transfers for data and
+// commands.
+//
+//*****************************************************************************
+#define DEVICE_BLOCK_SIZE       512
+
+//*****************************************************************************
+//
+// USBDMSCMediaChange() tUSBDMSCMediaStatus values.
+//
+//*****************************************************************************
+typedef enum
+{
+    eUSBDMSCMediaPresent,
+    eUSBDMSCMediaNotPresent,
+    eUSBDMSCMediaStopped,
+    eUSBDMSCMediaUnknown
+}
+tUSBDMSCMediaStatus;
+
+//*****************************************************************************
+//
+// PRIVATE
+//
+// This structure defines the private instance data and state variables for the
+// mass storage class.  The memory for this structure is in the the
+// sPrivateData field in the tUSBDMSCDevice structure passed on
+// USBDMSCInit() and should not be modified by any code outside of the mass
+// storage device code.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    // Base address for the USB controller.
+    //
+    uint32_t ui32USBBase;
+
+    //
+    // The device info to interact with the lower level DCD code.
+    //
+    tDeviceInfo sDevInfo;
+
+    //
+    // These three values are used to return the current sense data for an
+    // instance of the mass storage class.
+    //
+    uint8_t ui8ErrorCode;
+    uint8_t ui8SenseKey;
+    uint16_t ui16AddSenseCode;
+
+    //
+    // The pointer to the instance returned from the Open call to the media.
+    //
+    void *pvMedia;
+
+    //
+    // The connection status of the device.
+    //
+    volatile bool bConnected;
+
+    //
+    // Holds the flag settings for this instance.
+    //
+    uint32_t ui32Flags;
+
+    //
+    // Holds the current media status.
+    //
+    tUSBDMSCMediaStatus iMediaStatus;
+
+    //
+    // MSC block buffer.
+    //
+    uint32_t pui32Buffer[0x1000>>2];
+
+    //
+    // Current number of bytes to transfer.
+    //
+    uint32_t ui32BytesToTransfer;
+
+    //
+    // The LBA for the current transfer.
+    //
+    uint32_t ui32CurrentLBA;
+
+    //
+    // The IN endpoint number, this is modified in composite devices.
+    //
+    uint8_t ui8INEndpoint;
+
+    //
+    // The IN DMA channel.
+    //
+    uint8_t ui8INDMA;
+
+    //
+    // The OUT endpoint number, this is modified in composite devices.
+    //
+    uint8_t ui8OUTEndpoint;
+
+    //
+    // The OUT DMA channel.
+    //
+    uint8_t ui8OUTDMA;
+
+    //
+    // The bulk class interface number, this is modified in composite devices.
+    //
+    uint8_t ui8Interface;
+
+    //
+    // Active SCSI state.
+    //
+    uint8_t ui8SCSIState;
+
+    //
+    // A copy of the DMA instance data used with calls to USBLibDMA functions.
+    //
+    tUSBDMAInstance *psDMAInstance;
+}
+tMSCInstance;
+
+//*****************************************************************************
+//
+// This is the size of the g_pui8MSCInterface array in bytes.
+//
+//*****************************************************************************
+#define MSCINTERFACE_SIZE       (23)
+
+//*****************************************************************************
+//
+//! The size of the memory that should be allocated to create a configuration
+//! descriptor for a single instance of the USB Audio Device.
+//! This does not include the configuration descriptor which is automatically
+//! ignored by the composite device class.
+//
+//
+//*****************************************************************************
+#define COMPOSITE_DMSC_SIZE     (MSCINTERFACE_SIZE)
+
+//*****************************************************************************
+//
+//! The structure used by the application to define operating parameters for
+//! the mass storage device.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The vendor ID that this device is to present in the device descriptor.
+    //
+    const uint16_t ui16VID;
+
+    //
+    //! The product ID that this device is to present in the device descriptor.
+    //
+    const uint16_t ui16PID;
+
+    //
+    //! 8 byte vendor string.
+    //
+    const uint8_t pui8Vendor[8];
+
+    //
+    //! 16 byte vendor string.
+    //
+    const uint8_t pui8Product[16];
+
+    //
+    //! 4 byte vendor string.
+    //
+    const uint8_t pui8Version[4];
+
+    //
+    //! The maximum power consumption of the device, expressed in milliamps.
+    //
+    const uint16_t ui16MaxPowermA;
+
+    //
+    //! Indicates whether the device is self or bus-powered and whether or not
+    //! it supports remote wakeup.  Valid values are \b USB_CONF_ATTR_SELF_PWR
+    //! or \b USB_CONF_ATTR_BUS_PWR, optionally ORed with
+    //! \b USB_CONF_ATTR_RWAKE.
+    //
+    const uint8_t ui8PwrAttributes;
+
+    //
+    //! A pointer to the string descriptor array for this device.  This array
+    //! must contain the following string descriptor pointers in this order.
+    //! Language descriptor, Manufacturer name string (language 1), Product
+    //! name string (language 1), Serial number string (language 1), MSC
+    //! Interface description string (language 1), Configuration description
+    //! string (language 1).
+    //!
+    //! If supporting more than 1 language, the descriptor block (except for
+    //! string descriptor 0) must be repeated for each language defined in the
+    //! language descriptor.
+    //!
+    //
+    const uint8_t * const *ppui8StringDescriptors;
+
+    //
+    //! The number of descriptors provided in the \e ppStringDescriptors
+    //! array.  This must be 1 + ((5 + (num HID strings)) * (num languages)).
+    //
+    const uint32_t ui32NumStringDescriptors;
+
+    //
+    //! This structure holds the access functions for the media used by this
+    //! instance of the mass storage class device.  All of the functions in
+    //! this structure are required to be filled out with valid functions.
+    //
+    const tMSCDMedia sMediaFunctions;
+
+    //
+    //! This is the callback function for various events that occur during
+    //! mass storage class operation.
+    //
+    const tUSBCallback pfnEventCallback;
+
+    //
+    //! The private instance data for this device.  This memory
+    //! must remain accessible for as long as the MSC device is in use and
+    //! must not be modified by any code outside the MSC class driver.
+    //
+    tMSCInstance sPrivateData;
+}
+tUSBDMSCDevice;
+
+//*****************************************************************************
+//
+// MSC-specific device class driver events
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! This event indicates that the host has completed other operations and is
+//! no longer accessing the device.
+//
+//*****************************************************************************
+#define USBD_MSC_EVENT_IDLE     (USBD_MSC_EVENT_BASE + 0)
+
+//*****************************************************************************
+//
+//! This event indicates that the host is reading the storage media.
+//
+//*****************************************************************************
+#define USBD_MSC_EVENT_READING  (USBD_MSC_EVENT_BASE + 1)
+
+//*****************************************************************************
+//
+//! This event indicates that the host is writing to the storage media.
+//
+//*****************************************************************************
+#define USBD_MSC_EVENT_WRITING  (USBD_MSC_EVENT_BASE + 2)
+
+//*****************************************************************************
+//
+// API Function Prototypes
+//
+//*****************************************************************************
+extern void *USBDMSCInit(uint32_t ui32Index,
+                         tUSBDMSCDevice *psMSCDevice);
+extern void *USBDMSCCompositeInit(uint32_t ui32Index,
+                                  tUSBDMSCDevice *psMSCDevice,
+                                  tCompositeEntry *psCompEntry);
+extern void USBDMSCTerm(void *pvInstance);
+extern void USBDMSCMediaChange(void *pvInstance,
+                               tUSBDMSCMediaStatus eMediaStatus);
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/bsp/tm4c129x/libraries/usblib/host/usbhaudio.c b/bsp/tm4c129x/libraries/usblib/host/usbhaudio.c
new file mode 100755
index 0000000..3daf10f
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/host/usbhaudio.c
@@ -0,0 +1,1557 @@
+//*****************************************************************************
+//
+// usbhaudio.c - USB host audio driver.
+//
+// Copyright (c) 2010-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "inc/hw_types.h"
+#include "driverlib/usb.h"
+#include "usblib/usblib.h"
+#include "usblib/usblibpriv.h"
+#include "usblib/usbaudio.h"
+#include "usblib/host/usbhost.h"
+#include "usblib/host/usbhostpriv.h"
+#include "usblib/host/usbhaudio.h"
+
+//*****************************************************************************
+//
+//! \addtogroup usblib_host_class
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// These defines are used with the USBHostAudioFormatSet()
+// USBHostAudioFormatGet() to parse out interface number and alternate
+// setting number for an interface.
+//
+//*****************************************************************************
+#define INTERFACE_NUM_M         0x000000FF
+#define INTERFACE_ALTSETTING_M  0x0000FF00
+#define INTERFACE_ALTSETTING_S  8
+
+//*****************************************************************************
+//
+// Used to indicate an invalid interface descriptor number.
+//
+//*****************************************************************************
+#define INVALID_INTERFACE       0xffffffff
+
+//*****************************************************************************
+//
+// Forward declarations for the driver open and close calls.
+//
+//*****************************************************************************
+static void *USBAudioOpen(tUSBHostDevice *psDevice);
+static void USBAudioClose(void *pvInstance);
+
+//*****************************************************************************
+//
+// This is the structure for an instance of a USB host audio driver.
+//
+//*****************************************************************************
+struct tUSBHostAudioInstance
+{
+    //
+    // Save the device instance.
+    //
+    tUSBHostDevice *psDevice;
+
+    //
+    // Used to save the call back.
+    //
+    tUSBHostAudioCallback pfnCallback;
+
+    //
+    // This is the control interface.
+    //
+    uint8_t ui8IControl;
+
+    //
+    // This is the output streaming interface.
+    //
+    uint8_t ui8OutInterface;
+
+    //
+    // This is the currently selected active output interface used with
+    // ui8OutInterface interface.
+    //
+    uint8_t ui8OutAltSetting;
+
+    //
+    // This is the streaming interface.
+    //
+    uint8_t ui8InInterface;
+
+    //
+    // This is the currently selected active input interface used with
+    // ui8InInterface interface.
+    //
+    uint8_t ui8InAltSetting;
+
+    //
+    // The Isochronous endpoint addresses.
+    //
+    uint8_t ui8IsochInAddress;
+    uint8_t ui8IsochOutAddress;
+
+    tACInputTerminal *psInTerminal;
+    tACOutputTerminal *psOutTerminal;
+
+    //
+    // Holds the identifier for the Feature Unit for controlling volume.
+    //
+    uint8_t ui8VolumeID;
+
+    tACFeatureUnit *psFeatureUnit;
+
+    //
+    // Holds what types of controls are enabled on the device.
+    //
+    uint16_t pui16Controls[3];
+
+    //
+    // Isochronous IN pipe.
+    //
+    uint32_t ui32IsochInPipe;
+    uint16_t ui16PipeSizeIn;
+    tUSBHostAudioCallback pfnInCallback;
+    void *pvInBuffer;
+
+    //
+    // Isochronous OUT pipe.
+    //
+    uint32_t ui32IsochOutPipe;
+    uint16_t ui16PipeSizeOut;
+    tUSBHostAudioCallback pfnOutCallback;
+    void *pvOutBuffer;
+
+    //
+    // State flags for this audio instance.
+    //
+    uint32_t ui32Flags;
+};
+
+//*****************************************************************************
+//
+// The internal flags for an audio interface.
+//
+//*****************************************************************************
+#define AUDIO_FLAG_OUT_ACTIVE   1   // Audio output is active.
+#define AUDIO_FLAG_IN_ACTIVE    2   // Audio input is active.
+
+//*****************************************************************************
+//
+// The USB Host audio instance.
+//
+//*****************************************************************************
+static tUSBHostAudioInstance g_sAudioDevice =
+{
+    0
+};
+
+//*****************************************************************************
+//
+//! This constant global structure defines the Audio Class Driver that is
+//! provided with the USB library.
+//
+//*****************************************************************************
+const tUSBHostClassDriver g_sUSBHostAudioClassDriver =
+{
+    USB_CLASS_AUDIO,
+    USBAudioOpen,
+    USBAudioClose,
+    0
+};
+
+//*****************************************************************************
+//
+// This is the internal function that handles callbacks from the USB IN pipe.
+//
+//*****************************************************************************
+static void
+PipeCallbackIN(uint32_t ui32Pipe, uint32_t ui32Event)
+{
+    //
+    // Only handle the data available callback and pass it on to the
+    // application.
+    //
+    if(ui32Event == USB_EVENT_RX_AVAILABLE)
+    {
+        if(g_sAudioDevice.pfnInCallback)
+        {
+            g_sAudioDevice.pfnInCallback(&g_sAudioDevice,
+                                         USB_EVENT_RX_AVAILABLE,
+                                         USBHCDPipeTransferSizeGet(ui32Pipe),
+                                         g_sAudioDevice.pvInBuffer);
+        }
+    }
+}
+
+//*****************************************************************************
+//
+// This is the internal function that handles callbacks from the USB OUT pipe.
+//
+//*****************************************************************************
+static void
+PipeCallbackOUT(uint32_t ui32Pipe, uint32_t ui32Event)
+{
+    //
+    // Only handle the transmit complete callback and pass it on to the
+    // application.
+    //
+    if(ui32Event == USB_EVENT_TX_COMPLETE)
+    {
+        if(g_sAudioDevice.pfnOutCallback)
+        {
+            g_sAudioDevice.pfnOutCallback(&g_sAudioDevice,
+                                          USB_EVENT_TX_COMPLETE, 0,
+                                          g_sAudioDevice.pvOutBuffer);
+        }
+    }
+}
+
+//*****************************************************************************
+//
+// Finds a given terminal and type in an audio configuration descriptor.
+//
+//*****************************************************************************
+static tDescriptorHeader *
+AudioTerminalGet(tConfigDescriptor *psConfigDesc, uint32_t ui32Terminal,
+                 uint32_t ui32TerminalType)
+{
+    tACOutputTerminal *psOutput;
+    tDescriptorHeader *psHeader;
+    int32_t i32BytesRemaining;
+
+    psHeader = (tDescriptorHeader *)psConfigDesc;
+    i32BytesRemaining = psConfigDesc->wTotalLength;
+
+    while(i32BytesRemaining > 0)
+    {
+        //
+        // Output and input terminals are the same past the bDescriptorSubtype
+        // and wTerminalType that are being searched for.
+        //
+        psOutput = (tACOutputTerminal *)psHeader;
+
+        //
+        // Only CS_INTERFACE descriptors can be a terminal.
+        //
+        if((psHeader->bDescriptorType == USB_DTYPE_CS_INTERFACE) &&
+           (ui32Terminal == psOutput->bDescriptorSubtype))
+        {
+            if((psOutput->bDescriptorSubtype == USB_AI_OUTPUT_TERMINAL) ||
+               (psOutput->bDescriptorSubtype == USB_AI_INPUT_TERMINAL))
+
+            {
+                //
+                // If this was the terminal type that was requested, the
+                // return it.
+                //
+                if(psOutput->wTerminalType == ui32TerminalType)
+                {
+                    return(psHeader);
+                }
+            }
+            else if(psOutput->bDescriptorSubtype == USB_AI_FEATURE_UNIT)
+            {
+                return(psHeader);
+            }
+        }
+
+        //
+        // Decrease the bytes remaining by the size of this descriptor.
+        //
+        i32BytesRemaining -=  psHeader->bLength;
+
+        //
+        // Move the pointer to the next header.
+        //
+        psHeader = (tDescriptorHeader *)((uint32_t)psHeader +
+                                         psHeader->bLength);
+    }
+    return((tDescriptorHeader *)0);
+}
+
+//*****************************************************************************
+//
+// This function returns the interface number for the control interface
+// in the structure passed in the psConfigDesc.
+//
+// \param psConfigDescriptor is a pointer to the memory containing a valid
+//        configuration descriptor for a device.
+//
+// This function searches a configuration descriptor for a control interface
+// descriptor.  The function only search for the first descriptor and then
+// returns when it finds one.
+//
+// \return The first control interface descriptor number for an audio device
+//         or INVALID_INTERFACE if no control interface descriptor was found.
+//
+//*****************************************************************************
+static uint32_t
+AudioControlGet(tConfigDescriptor *psConfigDesc)
+{
+    tDescriptorHeader *psHeader;
+    tInterfaceDescriptor *psInterface;
+    uint32_t ui32Interface;
+    int32_t i32Bytes;
+
+    psHeader = (tDescriptorHeader *)psConfigDesc;
+    i32Bytes = psConfigDesc->wTotalLength;
+
+    //
+    // Initialize the interface number to an invalid value.
+    //
+    ui32Interface = INVALID_INTERFACE;
+
+    //
+    // Search the whole configuration descriptor.
+    //
+    while(i32Bytes > 0)
+    {
+        //
+        // Find an interface descriptor and see if it is a control interface.
+        //
+        if(psHeader->bDescriptorType == USB_DTYPE_INTERFACE)
+        {
+            psInterface = (tInterfaceDescriptor *)psHeader;
+
+            //
+            // If this is the control interface then return the value to the
+            // caller.
+            //
+            if(psInterface->bInterfaceSubClass == USB_ASC_AUDIO_CONTROL)
+            {
+                ui32Interface = psInterface->bInterfaceNumber;
+
+                break;
+            }
+        }
+
+        //
+        // Decrease the bytes remaining by the size of this descriptor.
+        //
+        i32Bytes -= psHeader->bLength;
+
+        //
+        // Move the pointer to the next header.
+        //
+        psHeader = (tDescriptorHeader*)((uint32_t)psHeader +
+                                        psHeader->bLength);
+    }
+    return(ui32Interface);
+}
+
+//*****************************************************************************
+//
+// If it exists, finds the correct audio interface for a given audio format.
+//
+//*****************************************************************************
+static uint32_t
+AudioGetInterface(tUSBHostAudioInstance *psAudioDevice, uint16_t ui16Format,
+                  uint32_t ui32SampleRate, uint32_t ui32Bytes,
+                  uint32_t ui32Channels, uint32_t ui32Flags)
+{
+    tDescriptorHeader *psHeader;
+    tInterfaceDescriptor *psInterface;
+    tEndpointDescriptor *pINEndpoint, *pOUTEndpoint;
+    tACHeader *pACHeader;
+    tACGeneral *pGeneral;
+    tASFormat *pFormat;
+    tEndpointDescriptor *pEndpoint;
+    uint8_t *pui8Value;
+    uint32_t ui32Value;
+    int32_t i32Bytes, i32Idx;
+
+    //
+    // Initialize the Interface pointer to null.
+    //
+    psInterface = 0;
+    pINEndpoint = 0;
+    pOUTEndpoint = 0;
+
+    //
+    // Start at the top of the configuration descriptor.
+    //
+    psHeader = (tDescriptorHeader *)psAudioDevice->psDevice->psConfigDescriptor;
+
+    i32Bytes = psAudioDevice->psDevice->psConfigDescriptor->wTotalLength;
+
+    while(i32Bytes > 0)
+    {
+        if(psHeader->bDescriptorType == USB_DTYPE_INTERFACE)
+        {
+            //
+            // If a new interface was found and the last one satisfied all
+            // requirements then a valid interface was found so break out.
+            //
+            if(psInterface)
+            {
+                break;
+            }
+
+            //
+            // Get the new interface pointer.
+            //
+            psInterface = (tInterfaceDescriptor *)psHeader;
+
+            //
+            // Reset the endpoints on finding a new interface descriptor.
+            //
+            pINEndpoint = 0;
+            pOUTEndpoint = 0;
+
+            //
+            // If this is not a valid audio streaming interface then reset
+            // the interface pointer to null.
+            //
+            if((psInterface->bNumEndpoints == 0) ||
+               (psInterface->bInterfaceClass != USB_CLASS_AUDIO) ||
+               (psInterface->bInterfaceSubClass != USB_ASC_AUDIO_STREAMING))
+            {
+                psInterface = 0;
+            }
+        }
+        if((psInterface) &&
+           (psHeader->bDescriptorType == USB_DTYPE_CS_INTERFACE))
+        {
+            pACHeader = (tACHeader *)psHeader;
+
+            //
+            // If this is a General descriptor the check if the format matches.
+            //
+            if(pACHeader->bDescriptorSubtype == USB_AS_GENERAL)
+            {
+                //
+                // Just save the pointer to the format descriptor.
+                //
+                pGeneral = (tACGeneral *)psHeader;
+
+                //
+                // If this interface has the wrong format then set it to null
+                // so that the rest of this interface is ignored.
+                //
+                if(pGeneral->wFormatTag != ui16Format)
+                {
+                    psInterface = 0;
+                }
+            }
+            else if(pACHeader->bDescriptorSubtype == USB_AS_FORMAT_TYPE)
+            {
+                pFormat = (tASFormat *)psHeader;
+
+                //
+                // If the number of bytes per sample and number of channels do
+                // not match then reset the interface pointer so that the rest
+                // of this interface is ignored.
+                //
+                if((pFormat->bNrChannels != ui32Channels) ||
+                   (pFormat->bSubFrameSize != ui32Bytes))
+                {
+                    psInterface = 0;
+                }
+                else
+                {
+                    pui8Value = &pFormat->tSamFreq;
+
+                    //
+                    // Attempt to find the sample rate in the sample rate
+                    // table for this interface.
+                    //
+                    for(i32Idx = 0; i32Idx < pFormat->bSamFreqType; i32Idx++)
+                    {
+                        ui32Value = (*((uint32_t *)&pui8Value[i32Idx * 3]) &
+                                    0xffffff);
+
+                        if(ui32Value == ui32SampleRate)
+                        {
+                            break;
+                        }
+                    }
+
+                    //
+                    // If the sample rate was not found then set the interface
+                    // pointer to null so that the rest of this interface is
+                    // ignored.
+                    //
+                    if(i32Idx == pFormat->bSamFreqType)
+                    {
+                        psInterface = 0;
+                    }
+                }
+            }
+        }
+        else if((psInterface) &&
+                (psHeader->bDescriptorType == USB_DTYPE_ENDPOINT))
+        {
+            pEndpoint = (tEndpointDescriptor *)psHeader;
+
+            //
+            // See what direction is being requested.
+            //
+            if(ui32Flags & USBH_AUDIO_FORMAT_IN)
+            {
+                //
+                // If this is an input endpoint and is just a feed back input
+                // then ignore it.
+                //
+                if(pEndpoint->bEndpointAddress & USB_EP_DESC_IN)
+                {
+                    if((pEndpoint->bmAttributes & USB_EP_ATTR_USAGE_M)
+                        == USB_EP_ATTR_USAGE_FEEDBACK)
+                    {
+                        psInterface = 0;
+                    }
+                    else
+                    {
+                        //
+                        // Save this endpoint as a possible valid endpoint
+                        //
+                        pINEndpoint = pEndpoint;
+                    }
+                }
+            }
+            else
+            {
+                //
+                // If this is an output endpoint and is just a feed back input
+                // then ignore it.
+                //
+                if((pEndpoint->bEndpointAddress & USB_EP_DESC_IN) == 0)
+                {
+                    if((pEndpoint->bmAttributes & USB_EP_ATTR_USAGE_M)
+                        == USB_EP_ATTR_USAGE_FEEDBACK)
+                    {
+                        psInterface = 0;
+                    }
+                    else
+                    {
+                        //
+                        // Save this endpoint as a possible valid endpoint;
+                        //
+                        pOUTEndpoint = pEndpoint;
+                    }
+                }
+            }
+        }
+
+        //
+        // Decrease the bytes remaining by the size of this descriptor.
+        //
+        i32Bytes -= psHeader->bLength;
+
+        //
+        // Move the pointer to the next header.
+        //
+        psHeader = (tDescriptorHeader*)((uint32_t)psHeader +
+                                        psHeader->bLength);
+    }
+
+    //
+    // If there is still a valid interface then return the values.
+    //
+    if(psInterface)
+    {
+        //
+        // Check a valid IN endpoint descriptor.
+        //
+        if(pINEndpoint)
+        {
+            //
+            // Save the endpoint address.
+            //
+            g_sAudioDevice.ui8IsochInAddress = pINEndpoint->bEndpointAddress &
+                                               USB_EP_DESC_NUM_M;
+
+            //
+            // If there is no current pipe then just allocate a new one with
+            // the settings for this interface.
+            //
+            if(g_sAudioDevice.ui32IsochInPipe == 0)
+            {
+                //
+                // Allocate the USB Pipe for this Isochronous IN end point.
+                //
+                g_sAudioDevice.ui32IsochInPipe =
+                    USBHCDPipeAllocSize(0, USBHCD_PIPE_ISOC_IN_DMA,
+                                        g_sAudioDevice.psDevice,
+                                        pINEndpoint->wMaxPacketSize,
+                                        PipeCallbackIN);
+            }
+            else if(g_sAudioDevice.ui16PipeSizeIn < pINEndpoint->wMaxPacketSize)
+            {
+                //
+                // Free the old endpoint and allocate a new one.
+                //
+                USBHCDPipeFree(g_sAudioDevice.ui32IsochInPipe);
+
+                //
+                // Allocate the USB Pipe for this Isochronous IN end point.
+                //
+                g_sAudioDevice.ui32IsochInPipe =
+                    USBHCDPipeAllocSize(0, USBHCD_PIPE_ISOC_IN_DMA,
+                                        g_sAudioDevice.psDevice,
+                                        pINEndpoint->wMaxPacketSize,
+                                        PipeCallbackIN);
+
+                //
+                // Save the new size of the maximum packet size for this
+                // USB pipe.
+                //
+                g_sAudioDevice.ui16PipeSizeIn = pINEndpoint->wMaxPacketSize;
+            }
+
+            //
+            // Configure the USB pipe as a Isochronous IN end point.
+            //
+            USBHCDPipeConfig(g_sAudioDevice.ui32IsochInPipe,
+                             pINEndpoint->wMaxPacketSize,
+                             0,
+                             g_sAudioDevice.ui8IsochInAddress);
+        }
+
+        //
+        // Check a valid OUT endpoint descriptor.
+        //
+        if(pOUTEndpoint)
+        {
+            //
+            // Save the endpoint address.
+            //
+            g_sAudioDevice.ui8IsochOutAddress =
+                            pOUTEndpoint->bEndpointAddress & USB_EP_DESC_NUM_M;
+
+            //
+            // If there is no current pipe then just allocate a new one with
+            // the settings for this interface.
+            //
+            if(g_sAudioDevice.ui32IsochOutPipe == 0)
+            {
+                //
+                // Allocate the USB Pipe for this Isochronous OUT end point.
+                //
+                g_sAudioDevice.ui32IsochOutPipe =
+                    USBHCDPipeAllocSize(0, USBHCD_PIPE_ISOC_OUT_DMA,
+                                        g_sAudioDevice.psDevice,
+                                        pOUTEndpoint->wMaxPacketSize,
+                                        PipeCallbackOUT);
+            }
+            else if(g_sAudioDevice.ui16PipeSizeOut <
+                    pOUTEndpoint->wMaxPacketSize)
+            {
+                //
+                // Free the old endpoint and allocate a new one.
+                //
+                USBHCDPipeFree(g_sAudioDevice.ui32IsochOutPipe);
+
+                //
+                // Allocate the USB Pipe for this Isochronous OUT end point.
+                //
+                g_sAudioDevice.ui32IsochOutPipe =
+                    USBHCDPipeAllocSize(0, USBHCD_PIPE_ISOC_OUT_DMA,
+                                        g_sAudioDevice.psDevice,
+                                        pOUTEndpoint->wMaxPacketSize,
+                                        PipeCallbackOUT);
+
+                //
+                // Save the new size of the maximum packet size for this
+                // USB pipe.
+                //
+                g_sAudioDevice.ui16PipeSizeOut = pOUTEndpoint->wMaxPacketSize;
+            }
+
+            //
+            // Configure the USB pipe as a Isochronous OUT end point.
+            //
+            USBHCDPipeConfig(g_sAudioDevice.ui32IsochOutPipe,
+                             pOUTEndpoint->wMaxPacketSize, 0,
+                             g_sAudioDevice.ui8IsochOutAddress);
+        }
+
+        return(psInterface->bInterfaceNumber |
+               (psInterface->bAlternateSetting << INTERFACE_ALTSETTING_S));
+    }
+    return(INVALID_INTERFACE);
+}
+
+//*****************************************************************************
+//
+// This function is used to open an instance of the USB host audio driver.
+//
+// \param psDevice is a pointer to the device information structure.
+//
+// This function attempts to open an instance of the USB host audio driver
+// based on the information contained in the psDevice structure.  This call
+// fails if there are not sufficient resources to open the device.  The
+// function returns a value that should be passed back into USBHostAudioClose()
+// when the driver is no longer needed.
+//
+// \return The function returns a pointer to a USB host audio driver
+// instance.
+//
+//*****************************************************************************
+static void *
+USBAudioOpen(tUSBHostDevice *psDevice)
+{
+    uint32_t ui32Temp;
+    tConfigDescriptor *psConfigDesc;
+
+    //
+    // Don't allow the device to be opened without closing first.
+    //
+    if(g_sAudioDevice.psDevice)
+    {
+        return(0);
+    }
+
+    //
+    // Save the Host device pointer.
+    //
+    g_sAudioDevice.psDevice = psDevice;
+
+    //
+    // Save a shorter name for the configuration descriptor.
+    //
+    psConfigDesc = psDevice->psConfigDescriptor;
+
+    //
+    // Find the input terminal.
+    //
+    g_sAudioDevice.psInTerminal =
+        (tACInputTerminal *)AudioTerminalGet(psConfigDesc,
+                                             USB_AI_INPUT_TERMINAL,
+                                             USB_TTYPE_STREAMING);
+
+    //
+    // Find the output terminal.
+    //
+    g_sAudioDevice.psOutTerminal =
+        (tACOutputTerminal *)AudioTerminalGet(psConfigDesc,
+                                              USB_AI_OUTPUT_TERMINAL,
+                                              USB_TTYPE_STREAMING);
+
+    //
+    // Find the feature unit.
+    g_sAudioDevice.psFeatureUnit =
+        (tACFeatureUnit *)AudioTerminalGet(psConfigDesc,
+                                             USB_AI_FEATURE_UNIT, 0);
+
+    //
+    // Need some kind of terminal to send or receive audio from.
+    //
+    if((g_sAudioDevice.psOutTerminal == 0) &&
+       (g_sAudioDevice.psInTerminal == 0))
+    {
+        return(0);
+    }
+
+    //
+    // Find the Audio control interface.
+    //
+    ui32Temp = AudioControlGet(psConfigDesc);
+
+    if(ui32Temp == INVALID_INTERFACE)
+    {
+        return(0);
+    }
+
+    //
+    // Save the control interface index and increment the number
+    // of interfaces that have been found.
+    //
+    g_sAudioDevice.ui8IControl = (uint8_t)ui32Temp;
+
+    //
+    // If the call back exists, call it with an Open event.
+    //
+    if(g_sAudioDevice.pfnCallback != 0)
+    {
+        g_sAudioDevice.pfnCallback(&g_sAudioDevice,
+                                   USBH_AUDIO_EVENT_OPEN, 0, 0);
+    }
+
+    //
+    // If a feature unit was found, save the ID
+    //
+    if(g_sAudioDevice.psFeatureUnit != 0)
+    {
+        g_sAudioDevice.ui8VolumeID = g_sAudioDevice.psFeatureUnit->bUnitID;
+    }
+
+    //
+    // Allocate the USB Pipe for this Isochronous IN end point.
+    //
+    g_sAudioDevice.ui32IsochInPipe =
+        USBHCDPipeAllocSize(0, USBHCD_PIPE_ISOC_IN_DMA,
+                            g_sAudioDevice.psDevice, 256, PipeCallbackIN);
+    g_sAudioDevice.ui16PipeSizeIn = 256;
+
+    //
+    // Allocate the USB Pipe for this Isochronous OUT end point.
+    //
+    g_sAudioDevice.ui32IsochOutPipe =
+        USBHCDPipeAllocSize(0, USBHCD_PIPE_ISOC_OUT_DMA,
+                            g_sAudioDevice.psDevice, 256, PipeCallbackOUT);
+    g_sAudioDevice.ui16PipeSizeOut = 256;
+
+    //
+    // Clear the flags.
+    //
+    g_sAudioDevice.ui32Flags = 0;
+
+    //
+    // Return the only instance of this device.
+    //
+    return(&g_sAudioDevice);
+}
+
+//*****************************************************************************
+//
+// This function is used to release an instance of the USB host audio driver.
+//
+// \param pvAudioDevice is an instance pointer that needs to be released.
+//
+// This function frees up any resources in use by the USB host audio
+// driver instance that is passed in.  The \e pvAudioDevice pointer should be a
+// valid value that was returned from a call to USBHostAudioOpen().
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+USBAudioClose(void *pvAudioDevice)
+{
+    tUSBHostAudioInstance *psAudioDevice;
+
+    psAudioDevice = (tUSBHostAudioInstance *)pvAudioDevice;
+
+    //
+    // Do nothing if there is not a driver open.
+    //
+    if(psAudioDevice->psDevice == 0)
+    {
+        return;
+    }
+
+    //
+    // Reset the device pointer.
+    //
+    psAudioDevice->psDevice = 0;
+
+    //
+    // Free the Isochronous IN pipe.
+    //
+    if(psAudioDevice->ui32IsochInPipe != 0)
+    {
+        USBHCDPipeFree(psAudioDevice->ui32IsochInPipe);
+    }
+
+    //
+    // Free the Isochronous OUT pipe.
+    //
+    if(psAudioDevice->ui32IsochOutPipe != 0)
+    {
+        USBHCDPipeFree(psAudioDevice->ui32IsochOutPipe);
+    }
+
+    //
+    // If the call back exists then call it.
+    //
+    if(psAudioDevice->pfnCallback != 0)
+    {
+        psAudioDevice->pfnCallback(psAudioDevice, USBH_AUDIO_EVENT_CLOSE, 0,
+                                   0);
+    }
+}
+
+//*****************************************************************************
+//
+//! This function should be called before any devices are present to enable
+//! the host audio class driver.
+//!
+//! \param ui32Index is the audio device to open (currently only 0 is
+//! supported).
+//! \param pfnCallback is the driver call back for host audio events.
+//!
+//! This function is called to open an instance of a host audio device and
+//! should provide a valid callback function for host audio events in the
+//! \e pfnCallback parameter.  This function must be called before the USB
+//! host code can successfully enumerate an audio device.
+//!
+//! \return This function returns the driver instance to use for the other
+//! host audio functions.  If there is no instance available at the time of
+//! this call, this function returns zero.
+//
+//*****************************************************************************
+tUSBHostAudioInstance *
+USBHostAudioOpen(uint32_t ui32Index, tUSBHostAudioCallback pfnCallback)
+{
+    //
+    // Only one audio device is supported at this time and on one instance
+    // is supported so if there is already a call back then fail.
+    //
+    if((ui32Index != 0) || (g_sAudioDevice.pfnCallback))
+    {
+        return(0);
+    }
+
+    //
+    // Save the call back.
+    //
+    g_sAudioDevice.pfnCallback = pfnCallback;
+
+    //
+    // Return the requested device instance.
+    //
+    return(&g_sAudioDevice);
+}
+
+//*****************************************************************************
+//
+//! This function should be called to release an audio device instance.
+//!
+//! \param psAudioInstance is the device instance that is to be released.
+//!
+//! This function is called when a host audio device needs to be released.
+//! This could be in preparation for shutdown or a switch to USB device mode,
+//! for example.  Following this call, the audio device is available and can
+//! be opened again using a call to USBHostAudioOpen().  After calling this
+//! function, the host audio driver will no longer provide any callbacks or
+//! accept calls to other audio driver APIs.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBHostAudioClose(tUSBHostAudioInstance *psAudioInstance)
+{
+    //
+    // Close the audio device.
+    //
+    USBAudioClose(psAudioInstance);
+
+    //
+    // Clear the call back indicating that the device is now closed.
+    //
+    psAudioInstance->pfnCallback = 0;
+}
+
+//*****************************************************************************
+//
+// This function is used to request settings from a given audio interface.
+//
+// \param psAudioDevice is the audio device instance to access.
+// \param ui32Interface is the interface to access.
+// \param ui32Channel is the channel number to access.
+// \param ui32Request is the audio device request.
+//
+// This function is used to get volume control parameters from a given
+// interface and on a given channel.  The \e ui32Interface is the interface to
+// make the request specified by \e ui32Channel and \e ui32Request.  The
+// \e ui32Request parameter must be one of the USB_AC_GET_* values.
+//
+// \return This function returns the requested value.
+//
+//*****************************************************************************
+static uint32_t
+VolumeSettingGet(tUSBHostAudioInstance *psAudioDevice, uint32_t ui32Interface,
+                 uint32_t ui32Channel, uint32_t ui32Request)
+{
+    uint32_t ui32Value;
+    tUSBRequest sSetupPacket;
+
+    ui32Value = 0;
+
+    //
+    // This is a Class specific Interface IN request.
+    //
+    sSetupPacket.bmRequestType = USB_RTYPE_DIR_IN | USB_RTYPE_CLASS |
+                                 USB_RTYPE_INTERFACE;
+
+    //
+    // Request a Device Descriptor.
+    //
+    sSetupPacket.bRequest = (ui32Request & 0xff);
+
+    //
+    // Request for a string descriptor.
+    //
+    sSetupPacket.wValue = VOLUME_CONTROL | (ui32Channel & 0xff);
+
+    //
+    // Set the language ID.
+    //
+    sSetupPacket.wIndex = (psAudioDevice->ui8VolumeID << 8) |
+                          (ui32Interface & 0xff);
+
+    //
+    // Only request the space available.
+    //
+    sSetupPacket.wLength = 2;
+
+    //
+    // Put the setup packet in the buffer.
+    //
+    USBHCDControlTransfer(0, &sSetupPacket, psAudioDevice->psDevice,
+                (uint8_t *)&ui32Value, 4,
+                psAudioDevice->psDevice->sDeviceDescriptor.bMaxPacketSize0);
+
+    return(ui32Value);
+}
+
+//*****************************************************************************
+//
+//! This function is used to get the current volume setting for a given
+//! audio device.
+//!
+//! \param psAudioInstance is an instance of the USB audio device.
+//! \param ui32Interface is the interface number to use to query the current
+//! volume setting.
+//! \param ui32Channel is the 0 based channel number to query.
+//!
+//! The function is used to retrieve the current volume setting for an audio
+//! device on the channel specified by \e ui32Channel.  The \e ui32Interface is
+//! ignored for now and should be set to 0 to access the default audio control
+//! interface.  The \e ui32Channel value starts with 0 which is the master
+//! audio volume control interface.  The remaining \e ui32Channel values
+//! provide access to various other audio channels, with 1 and 2 being left and
+//! right audio channels.
+//!
+//! \note On devices that do not support volume control interfaces, this
+//! call returns 0, indicating a 0db setting.
+//!
+//! \return Returns the current volume setting for the requested interface.
+//
+//*****************************************************************************
+uint32_t
+USBHostAudioVolumeGet(tUSBHostAudioInstance *psAudioInstance,
+                      uint32_t ui32Interface, uint32_t ui32Channel)
+{
+    return(VolumeSettingGet(psAudioInstance, ui32Interface, ui32Channel,
+                            USB_AC_GET_CUR));
+}
+
+//*****************************************************************************
+//
+//! This function is used to get the maximum volume setting for a given
+//! audio device.
+//!
+//! \param psAudioInstance is an instance of the USB audio device.
+//! \param ui32Interface is the interface number to use to query the maximum
+//! volume control value.
+//! \param ui32Channel is the 0 based channel number to query.
+//!
+//! The function is used to retrieve the maximum volume setting for an audio
+//! device on the channel specified by \e ui32Channel.  The \e ui32Interface is
+//! ignored for now and should be set to 0 to access the default audio control
+//! interface.  The \e ui32Channel value starts with 0 which is the master
+//! audio volume control interface.  The remaining \e ui32Channel values
+//! provide access to various other audio channels, with 1 and 2 being left and
+//! right audio channels.
+//!
+//! \note On devices that do not support volume control interfaces, this
+//! call returns 0, indicating a 0db setting.
+//!
+//! \return Returns the maximum volume setting for the requested interface.
+//
+//*****************************************************************************
+uint32_t
+USBHostAudioVolumeMaxGet(tUSBHostAudioInstance *psAudioInstance,
+                         uint32_t ui32Interface, uint32_t ui32Channel)
+{
+    return(VolumeSettingGet(psAudioInstance, ui32Interface, ui32Channel,
+                            USB_AC_GET_MAX));
+}
+
+//*****************************************************************************
+//
+//! This function is used to get the minimum volume setting for a given
+//! audio device.
+//!
+//! \param psAudioInstance is an instance of the USB audio device.
+//! \param ui32Interface is the interface number to use to query the minimum
+//! volume control value.
+//! \param ui32Channel is the 0 based channel number to query.
+//!
+//! The function is used to retrieve the minimum volume setting for an audio
+//! device on the channel specified by \e ui32Channel.  The \e ui32Interface is
+//! ignored for now and should be set to 0 to access the default audio control
+//! interface.  The \e ui32Channel value starts with 0 which is the master
+//! audio volume control interface.  The remaining \e ui32Channel values
+//! provide access to various other audio channels, with 1 and 2 being left and
+//! right audio channels.
+//!
+//! \note On devices that do not support volume control interfaces, this
+//! call returns 0, indicating a 0db setting.
+//!
+//! \return Returns the minimum volume setting for the requested interface.
+//
+//*****************************************************************************
+uint32_t
+USBHostAudioVolumeMinGet(tUSBHostAudioInstance *psAudioInstance,
+                         uint32_t ui32Interface, uint32_t ui32Channel)
+{
+    return(VolumeSettingGet(psAudioInstance, ui32Interface, ui32Channel,
+                            USB_AC_GET_MIN));
+}
+
+//*****************************************************************************
+//
+//! This function is used to get the volume control resolution for a given
+//! audio device.
+//!
+//! \param psAudioInstance is an instance of the USB audio device.
+//! \param ui32Interface is the interface number to use to query the resolution
+//! for the volume control.
+//! \param ui32Channel is the 0 based channel number to query.
+//!
+//! The function is used to retrieve the volume control resolution for an audio
+//! device on the channel specified by \e ui32Channel.  The \e ui32Interface is
+//! ignored for now and should be set to 0 to access the default audio control
+//! interface.  The \e ui32Channel value starts with 0 which is the master
+//! audio volume control interface.  The remaining \e ui32Channel values
+//! provide access to various other audio channels, with 1 and 2 being left and
+//! right audio channels.
+//!
+//! \note On devices that do not support volume control interfaces, this
+//! call returns 0, indicating a 0db setting.
+//!
+//! \return Returns the volume control resolution for the requested interface.
+//
+//*****************************************************************************
+uint32_t
+USBHostAudioVolumeResGet(tUSBHostAudioInstance *psAudioInstance,
+                         uint32_t ui32Interface, uint32_t ui32Channel)
+{
+    return(VolumeSettingGet(psAudioInstance, ui32Interface, ui32Channel,
+                            USB_AC_GET_RES));
+}
+
+//*****************************************************************************
+//
+//! This function is used to set the current volume setting for a given
+//! audio device.
+//!
+//! \param psAudioInstance is an instance of the USB audio device.
+//! \param ui32Interface is the interface number to use to set the current
+//! volume setting.
+//! \param ui32Channel is the 0 based channel number to query.
+//! \param ui32Value is the value to write to the USB audio device.
+//!
+//! The function is used to set the current volume setting for an audio
+//! device on the channel specified by \e ui32Channel.  The \e ui32Interface is
+//! ignored for now and should be set to 0 to access the default audio control
+//! interface.  The \e ui32Channel value starts with 0 which is the master
+//! audio volume control interface.  The remaining \e ui32Channel values
+//! provide access to various other audio channels, with 1 and 2 being left and
+//! right audio channels.
+//!
+//! \note On devices that do not support volume control interfaces, this
+//! call returns 0, indicating a 0db setting.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBHostAudioVolumeSet(tUSBHostAudioInstance *psAudioInstance,
+                      uint32_t ui32Interface, uint32_t ui32Channel,
+                      uint32_t ui32Value)
+{
+    tUSBRequest sSetupPacket;
+
+    //
+    // This is a Class specific Interface OUT request.
+    //
+    sSetupPacket.bmRequestType = USB_RTYPE_DIR_OUT | USB_RTYPE_CLASS |
+                                 USB_RTYPE_INTERFACE;
+
+    //
+    // Request is to set the current value.
+    //
+    sSetupPacket.bRequest = USB_AC_SET_CUR;
+
+    //
+    // Request the volume control.
+    //
+    sSetupPacket.wValue = VOLUME_CONTROL | (ui32Channel & 0xff);
+
+    //
+    // Set Volume control ID and interface to 0.
+    //
+    sSetupPacket.wIndex = psAudioInstance->ui8VolumeID << 8;
+
+    //
+    // Only request the space available.
+    //
+    sSetupPacket.wLength = 2;
+
+    //
+    // Put the setup packet in the buffer.
+    //
+    USBHCDControlTransfer(0, &sSetupPacket, psAudioInstance->psDevice,
+            (uint8_t *)&ui32Value, 2,
+            psAudioInstance->psDevice->sDeviceDescriptor.bMaxPacketSize0);
+}
+
+//*****************************************************************************
+//
+//! This function is called to determine if an audio format is supported by the
+//! connected USB Audio device.
+//!
+//! \param psAudioInstance is the device instance for this call.
+//! \param ui32SampleRate is the sample rate of the audio stream.
+//! \param ui32Bits is the number of bits per sample in the audio stream.
+//! \param ui32Channels is the number of channels in the audio stream.
+//! \param ui32Flags is a set of flags to determine what type of interface to
+//!        retrieve.
+//!
+//! This function is called when an application needs to determine which audio
+//! formats are supported by a USB audio device that has been connected.  The
+//! \e psAudioInstance value that is used with this call is the value that was
+//! returned from the USBHostAudioOpen() function.  This call checks the
+//! USB audio device to determine if it can support the values provided in the
+//! \e ui32SampleRate, \e ui32Bits, and \e ui32Channels values.  The
+//! \e ui32Flags currently only supports either the \b USBH_AUDIO_FORMAT_IN or
+//! \b USBH_AUDIO_FORMAT_OUT values that indicates if a request is for an
+//! audio input and an audio output.  If the format is supported this
+//! function returns zero, and this function returns a non-zero value if the
+//! format is not supported.  This function does not set the current output or
+//! input format.
+//!
+//! \return A value of zero indicates the supplied format is supported and
+//! a non-zero value indicates that the format is not supported.
+//
+//*****************************************************************************
+uint32_t
+USBHostAudioFormatGet(tUSBHostAudioInstance *psAudioInstance,
+                      uint32_t ui32SampleRate, uint32_t ui32Bits,
+                      uint32_t ui32Channels, uint32_t ui32Flags)
+{
+    //
+    // Look for the requested format.
+    //
+    if(AudioGetInterface(psAudioInstance, USB_ADF_PCM, ui32SampleRate,
+                         ui32Bits >> 3, ui32Channels, ui32Flags) !=
+       INVALID_INTERFACE)
+    {
+        return(0);
+    }
+    return(1);
+}
+
+//*****************************************************************************
+//
+//! This function is called to set the current sample rate on an audio
+//! interface.
+//!
+//! \param psAudioInstance specifies the device instance for this call.
+//! \param ui32SampleRate is the sample rate in Hz.
+//! \param ui32Bits is the number of bits per sample.
+//! \param ui32Channels is then number of audio channels.
+//! \param ui32Flags is a set of flags that determine the access type.
+//!
+//! This function is called when to set the current audio output or input
+//! format for a USB audio device.  The \e psAudioInstance value that is used
+//! with this call is the value that was returned from the USBHostAudioOpen()
+//! function.  The application can use this call to insure that the audio
+//! format is supported and set the format at the same time.  If the
+//! application is just checking for supported rates, then it should call the
+//! USBHostAudioFormatGet().
+//!
+//! \note This function must be called before attempting to send or receive
+//! audio with the USBHostAudioPlay() or USBHostAudioRecord() functions.
+//!
+//! \return A non-zero value indicates the supplied format is not supported and
+//! a zero value indicates that the format was supported and has been
+//! configured.
+//
+//*****************************************************************************
+uint32_t
+USBHostAudioFormatSet(tUSBHostAudioInstance *psAudioInstance,
+                      uint32_t ui32SampleRate, uint32_t ui32Bits,
+                      uint32_t ui32Channels, uint32_t ui32Flags)
+{
+    uint32_t ui32Interface;
+
+    //
+    // Look for the requested format.
+    //
+    ui32Interface = AudioGetInterface(psAudioInstance, USB_ADF_PCM,
+                                      ui32SampleRate, ui32Bits >> 3,
+                                      ui32Channels, ui32Flags);
+
+    if(ui32Interface == INVALID_INTERFACE)
+    {
+        return(1);
+    }
+
+    //
+    // Determine if this is an input or output request.
+    //
+    if(ui32Flags & USBH_AUDIO_FORMAT_IN)
+    {
+        //
+        // Get the active interface number and alternate setting for this
+        // format.
+        //
+        psAudioInstance->ui8InInterface =
+            (uint8_t)(ui32Interface & INTERFACE_NUM_M);
+        psAudioInstance->ui8InAltSetting =
+            (uint8_t)((ui32Interface & INTERFACE_ALTSETTING_M) >>
+            INTERFACE_ALTSETTING_S);
+    }
+    else
+    {
+        //
+        // Get the active interface number and alternate setting for this
+        // format.
+        //
+        psAudioInstance->ui8OutInterface =
+            (uint8_t)(ui32Interface & INTERFACE_NUM_M);
+        psAudioInstance->ui8OutAltSetting =
+            (uint8_t)((ui32Interface & INTERFACE_ALTSETTING_M) >>
+            INTERFACE_ALTSETTING_S);
+    }
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! This function is called to send an audio buffer to the USB audio device.
+//!
+//! \param psAudioInstance specifies the device instance for this call.
+//! \param pvBuffer is the audio buffer to send.
+//! \param ui32Size is the size of the buffer in bytes.
+//! \param pfnCallback is a pointer to a callback function that is called
+//! when the buffer can be used again.
+//!
+//! This function is called when an application needs to schedule a new buffer
+//! for output to the USB audio device.  Since this call schedules the transfer
+//! and returns immediately, the application should provide a \e pfnCallback
+//! function to be notified when the buffer can be used again by the
+//! application.  The \e pfnCallback function provided is called with the
+//! \e pvBuffer parameter set to the \e pvBuffer provided by this call, the
+//! \e ui32Param can be ignored and the \e ui32Event parameter is
+//! \b USB_EVENT_TX_COMPLETE.
+//!
+//! \return This function returns the number of bytes that were scheduled
+//! to be sent.  If this function returns zero then there was no USB audio
+//! device present or the request could not be satisfied at this time.
+//
+//*****************************************************************************
+int32_t
+USBHostAudioPlay(tUSBHostAudioInstance *psAudioInstance, void *pvBuffer,
+                 uint32_t ui32Size, tUSBHostAudioCallback pfnCallback)
+{
+    uint32_t ui32Bytes;
+
+    //
+    // Make sure that there is a device present.
+    //
+    if(psAudioInstance->psDevice == 0)
+    {
+        return(0);
+    }
+
+    //
+    // If the audio output interface is not active then select the current
+    // active audio interface.
+    //
+    if(HWREGBITW(&psAudioInstance->ui32Flags, AUDIO_FLAG_OUT_ACTIVE) == 0)
+    {
+        //
+        // Indicate the active audio interface has been selected.
+        //
+        HWREGBITW(&psAudioInstance->ui32Flags, AUDIO_FLAG_OUT_ACTIVE) = 1;
+
+        //
+        // Configure the USB audio device to use the selected audio interface.
+        //
+        USBHCDSetInterface(0, (uint32_t)psAudioInstance->psDevice,
+                           psAudioInstance->ui8OutInterface,
+                           psAudioInstance->ui8OutAltSetting);
+    }
+
+    //
+    // Save the callback function and the buffer pointer.
+    //
+    psAudioInstance->pfnOutCallback = pfnCallback;
+    psAudioInstance->pvOutBuffer = (void *)pvBuffer;
+
+    //
+    // Schedule the data to be written out to the FIFO.
+    //
+    ui32Bytes = USBHCDPipeSchedule(psAudioInstance->ui32IsochOutPipe, pvBuffer,
+                                   ui32Size);
+
+    //
+    // Return the number of bytes scheduled to be sent.
+    //
+    return(ui32Bytes);
+}
+
+//*****************************************************************************
+//
+//! This function is called to provide an audio buffer to the USB audio device
+//! for audio input.
+//!
+//! \param psAudioInstance specifies the device instance for this call.
+//! \param pvBuffer is the audio buffer to send.
+//! \param ui32Size is the size of the buffer in bytes.
+//! \param pfnCallback is a pointer to a callback function that is called
+//! when the buffer has been filled.
+//!
+//! This function is called when an application needs to schedule a new buffer
+//! for input from the USB audio device.  Since this call schedules the
+//! transfer and returns immediately, the application should provide a
+//! \e pfnCallback function to be notified when the buffer has been filled with
+//! audio data.  When the \e pfnCallback function is called, the \e pvBuffer
+//! parameter is set to \e pvBuffer provided in this call, the \e ui32Param is
+//! the number of valid bytes in the pvBuffer and the \e ui32Event is set to
+//! \b USB_EVENT_RX_AVAILABLE.
+//!
+//! \return This function returns the number of bytes that were scheduled
+//! to be sent.  If this function returns zero then there was no USB audio
+//! device present or the device does not support audio input.
+//
+//*****************************************************************************
+int32_t
+USBHostAudioRecord(tUSBHostAudioInstance *psAudioInstance, void *pvBuffer,
+                   uint32_t ui32Size, tUSBHostAudioCallback pfnCallback)
+{
+    uint32_t ui32Bytes;
+
+    //
+    // Make sure that there is a device present.
+    //
+    if(psAudioInstance->psDevice == 0)
+    {
+        return(0);
+    }
+
+    //
+    // If the audio input interface is not active then select the current
+    // active audio interface.
+    //
+    if(HWREGBITW(&psAudioInstance->ui32Flags, AUDIO_FLAG_IN_ACTIVE) == 0)
+    {
+        //
+        // Indicate the active audio interface has been selected.
+        //
+        HWREGBITW(&psAudioInstance->ui32Flags, AUDIO_FLAG_IN_ACTIVE) = 1;
+
+        //
+        // Configure the USB audio device to use the selected audio interface.
+        //
+        USBHCDSetInterface(0, (uint32_t)psAudioInstance->psDevice,
+                        psAudioInstance->ui8InInterface,
+                        psAudioInstance->ui8InAltSetting);
+    }
+
+    //
+    // Save the callback function and the buffer pointer.
+    //
+    psAudioInstance->pfnInCallback = pfnCallback;
+    psAudioInstance->pvInBuffer = (void *)pvBuffer;
+
+    //
+    // Schedule the data to be read from the FIFO.
+    //
+    ui32Bytes = USBHCDPipeSchedule(psAudioInstance->ui32IsochInPipe, pvBuffer,
+                                   ui32Size);
+
+    //
+    // Return the number of bytes scheduled to be sent.
+    //
+    return(ui32Bytes);
+}
+
+//*****************************************************************************
+//
+//! This function forwards an LPM request for a device to enter L1 sleep state.
+//!
+//! \param psAudioInstance is the audio device instance that was returned
+//! from the call to USBHostAudioOpen().
+//!
+//! This function forwards a request from an application to the audio device
+//! class to request that a device enter the LPM L1 sleep state.  The
+//! caller must check the return value to see if the request can be
+//! attempted at this time.  If another LPM transaction is busy on this or
+//! another device, then this function returns \b USBHCD_LPM_PENDING.  If
+//! the LPM request was scheduled to be sent the function returns
+//! \b USBHCD_LPM_AVAIL.  The caller should check the USBHCDLPMStatus()
+//! function to determine if the request completed successfully or if there
+//! was an error.
+//!
+//! \return This function returns the following values:
+//! - \b USBHCD_LPM_AVAIL - The transition to L1 state is scheduled to be sent.
+//! - \b USBHCD_LPM_PENDING - There is already an LPM request pending.
+//
+//*****************************************************************************
+uint32_t
+USBHostAudioLPMSleep(tUSBHostAudioInstance *psAudioInstance)
+{
+    //
+    // Call the host controller function to send the sleep command.
+    //
+    return(USBHCDLPMSleep(psAudioInstance->psDevice));
+}
+
+//*****************************************************************************
+//
+//! This function returns the current status of an LPM request.
+//!
+//! \param psAudioInstance is the audio device instance that was returned
+//! from the call to USBHostAudioOpen().
+//!
+//! This function returns the current status of LPM requests for a given
+//! device.  This is called to determine if a previous request completed
+//! successfully or if there was an error.
+//!
+//! \return This function returns the following values:
+//! - \b USBHCD_LPM_AVAIL - There are no pending LPM requests on this specific
+//!   device or the last request completed successfully.
+//! - \b USBHCD_LPM_ERROR - The last LPM request for this device did not
+//!   complete successfully.
+//! - \b USBHCD_LPM_PENDING - The last LPM request has not completed.
+//
+//*****************************************************************************
+uint32_t
+USBHostAudioLPMStatus(tUSBHostAudioInstance *psAudioInstance)
+{
+    //
+    // Call the host controller function to get the current LPM status.
+    //
+    return(USBHCDLPMStatus(psAudioInstance->psDevice));
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
+
diff --git a/bsp/tm4c129x/libraries/usblib/host/usbhaudio.h b/bsp/tm4c129x/libraries/usblib/host/usbhaudio.h
new file mode 100755
index 0000000..cf34718
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/host/usbhaudio.h
@@ -0,0 +1,163 @@
+//*****************************************************************************
+//
+// usbhaudio.h - USB host audio class driver.
+//
+// Copyright (c) 2010-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#ifndef __USBHAUDIO_H__
+#define __USBHAUDIO_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+//*****************************************************************************
+//
+//! \addtogroup usblib_host_class
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// USB host audio specific events
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! This USB host audio event indicates that the device is connected and
+//! ready to send or receive buffers.  The \e pvBuffer and \e ui32Param
+//! values are not used in this event.
+//
+//*****************************************************************************
+#define USBH_AUDIO_EVENT_OPEN   (USBH_AUDIO_EVENT_BASE + 0)
+
+//*****************************************************************************
+//
+//! This USB host audio event indicates that the previously connected device
+//! has been disconnected. The \e pvBuffer and \e ui32Param values are not used
+//! in this event.
+//
+//*****************************************************************************
+#define USBH_AUDIO_EVENT_CLOSE  (USBH_AUDIO_EVENT_BASE + 1)
+
+//*****************************************************************************
+//
+// This definition is used with the USBHostAudioFormatGet() and
+// USBHostAudioFormatSet() API's to determine if the audio input is being
+// accesses(USBH_AUDIO_FORMAT_IN set) or audio output(USBH_AUDIO_FORMAT clear).
+//
+//*****************************************************************************
+#define USBH_AUDIO_FORMAT_IN    0x00000001
+#define USBH_AUDIO_FORMAT_OUT   0x00000000
+
+typedef struct
+{
+    uint8_t ui8Channels;
+    uint8_t ui8Bits;
+    uint32_t ui32SampleRate;
+}
+tUSBAudioFormat;
+
+typedef struct tUSBHostAudioInstance tUSBHostAudioInstance;
+
+//*****************************************************************************
+//
+// The prototype for the host USB Audio driver callback function.
+//
+//*****************************************************************************
+typedef void (*tUSBHostAudioCallback)(tUSBHostAudioInstance *psAudioInstance,
+                                      uint32_t ui32Event,
+                                      uint32_t ui32MsgParam,
+                                      void *pvMsgData);
+
+//*****************************************************************************
+//
+// API Function Prototypes
+//
+//*****************************************************************************
+extern tUSBHostAudioInstance * USBHostAudioOpen(uint32_t ui32Index,
+                                           tUSBHostAudioCallback pfnCallback);
+extern void USBHostAudioClose(tUSBHostAudioInstance *psAudioInstance);
+extern int32_t USBHostAudioPlay(tUSBHostAudioInstance *psAudioInstance,
+                                void *pvBuffer, uint32_t ui32Size,
+                                tUSBHostAudioCallback pfnCallback);
+
+extern uint32_t USBHostAudioFormatGet(tUSBHostAudioInstance *psAudioInstance,
+                                      uint32_t ui32SampleRate,
+                                      uint32_t ui32Bits, uint32_t ui32Channels,
+                                      uint32_t ui32Flags);
+extern uint32_t USBHostAudioFormatSet(tUSBHostAudioInstance *psAudioInstance,
+                                      uint32_t ui32SampleRate,
+                                      uint32_t ui32Bits, uint32_t ui32Channels,
+                                      uint32_t ui32Flags);
+
+extern int32_t USBHostAudioRecord(tUSBHostAudioInstance *psAudioInstance,
+                                  void *pvBuffer, uint32_t ui32Size,
+                                  tUSBHostAudioCallback pfnAudioCallback);
+
+extern uint32_t USBHostAudioVolumeGet(tUSBHostAudioInstance *psAudioInstance,
+                                      uint32_t ui32Interface,
+                                      uint32_t ui32Channel);
+
+extern void USBHostAudioVolumeSet(tUSBHostAudioInstance *psAudioInstance,
+                                  uint32_t ui32Interface, uint32_t ui32Channel,
+                                  uint32_t ui32Value);
+
+extern uint32_t USBHostAudioVolumeMaxGet(tUSBHostAudioInstance *psAudioInstance,
+                                         uint32_t ui32Interface,
+                                         uint32_t ui32Channel);
+
+extern uint32_t USBHostAudioVolumeMinGet(tUSBHostAudioInstance *psAudioInstance,
+                                         uint32_t ui32Interface,
+                                         uint32_t ui32Channel);
+
+extern uint32_t USBHostAudioVolumeResGet(tUSBHostAudioInstance *psAudioInstance,
+                                           uint32_t ui32Interface,
+                                           uint32_t ui32Channel);
+extern uint32_t USBHostAudioLPMSleep(tUSBHostAudioInstance *psAudioInstance);
+extern uint32_t USBHostAudioLPMStatus(tUSBHostAudioInstance *psAudioInstance);
+
+//*****************************************************************************
+//
+//! @}
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/bsp/tm4c129x/libraries/usblib/host/usbhhid.c b/bsp/tm4c129x/libraries/usblib/host/usbhhid.c
new file mode 100755
index 0000000..7d86ffd
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/host/usbhhid.c
@@ -0,0 +1,746 @@
+//*****************************************************************************
+//
+// usbhhid.c - This file contains the host HID driver.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "inc/hw_types.h"
+#include "driverlib/usb.h"
+#include "usblib/usblib.h"
+#include "usblib/usblibpriv.h"
+#include "usblib/usbhid.h"
+#include "usblib/host/usbhost.h"
+#include "usblib/host/usbhostpriv.h"
+#include "usblib/host/usbhhid.h"
+
+static void * HIDDriverOpen(tUSBHostDevice *psDevice);
+static void HIDDriverClose(void *pvInstance);
+
+//*****************************************************************************
+//
+//! \addtogroup usblib_host_class
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// If the user has not explicitly stated the maximum number of HID devices to
+// support, we assume that we need to support up to the maximum number of USB
+// devices that the build is configured for.
+//
+//*****************************************************************************
+#ifndef MAX_HID_DEVICES
+#define MAX_HID_DEVICES MAX_USB_DEVICES
+#endif
+
+//*****************************************************************************
+//
+// This is the structure that holds all of the data for a given instance of
+// a HID device.
+//
+//*****************************************************************************
+struct tHIDInstance
+{
+    //
+    // Save the device instance.
+    //
+    tUSBHostDevice *psDevice;
+
+    //
+    // Used to save the callback.
+    //
+    tUSBCallback pfnCallback;
+
+    //
+    // Callback data provided by caller.
+    //
+    void *pvCBData;
+
+    //
+    // Used to remember what type of device was registered.
+    //
+    tHIDSubClassProtocol iDeviceType;
+
+    //
+    // Interrupt IN pipe.
+    //
+    uint32_t ui32IntInPipe;
+};
+
+//*****************************************************************************
+//
+// The instance data storage for attached hid devices.
+//
+//*****************************************************************************
+static tHIDInstance g_psHIDDevice[MAX_HID_DEVICES];
+
+//*****************************************************************************
+//
+//! This constant global structure defines the HID Class Driver that is
+//! provided with the USB library.
+//
+//*****************************************************************************
+const tUSBHostClassDriver g_sUSBHIDClassDriver =
+{
+    USB_CLASS_HID,
+    HIDDriverOpen,
+    HIDDriverClose,
+    0
+};
+
+//*****************************************************************************
+//
+//! This function is used to open an instance of a HID device.
+//!
+//! \param iDeviceType is the type of device that should be loaded for this
+//! instance of the HID device.
+//! \param pfnCallback is the function that will be called whenever changes
+//! are detected for this device.
+//! \param pvCBData is the data that will be returned in when the
+//! \e pfnCallback function is called.
+//!
+//! This function creates an instance of an specific type of HID device.  The
+//! \e iDeviceType parameter is one subclass/protocol values of the types
+//! specified in enumerated types tHIDSubClassProtocol.  Only devices that
+//! enumerate with this type will be called back via the \e pfnCallback
+//! function.  The \e pfnCallback parameter is the callback function for any
+//! events that occur for this device type.  The \e pfnCallback function must
+//! point to a valid function of type \e tUSBCallback for this call to complete
+//! successfully.  To release this device instance the caller of USBHHIDOpen()
+//! should call USBHHIDClose() and pass in the value returned from the
+//! USBHHIDOpen() call.
+//!
+//! \return This function returns and instance value that should be used with
+//! any other APIs that require an instance value.  If a value of 0 is returned
+//! then the device instance could not be created.
+//
+//*****************************************************************************
+tHIDInstance *
+USBHHIDOpen(tHIDSubClassProtocol iDeviceType, tUSBCallback pfnCallback,
+            void *pvCBData)
+{
+    uint32_t ui32Loop;
+
+    //
+    // Find a free device instance structure.
+    //
+    for(ui32Loop = 0; ui32Loop < MAX_HID_DEVICES; ui32Loop++)
+    {
+        if(g_psHIDDevice[ui32Loop].iDeviceType == eUSBHHIDClassNone)
+        {
+            //
+            // Save the instance data for this device.
+            //
+            g_psHIDDevice[ui32Loop].pfnCallback = pfnCallback;
+            g_psHIDDevice[ui32Loop].iDeviceType = iDeviceType;
+            g_psHIDDevice[ui32Loop].pvCBData = pvCBData;
+
+            //
+            // Return the device instance pointer.
+            //
+            return(&g_psHIDDevice[ui32Loop]);
+        }
+    }
+
+    //
+    // If we get here, there are no space device slots so return NULL to
+    // indicate a problem.
+    //
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! This function is used to release an instance of a HID device.
+//!
+//! \param psHIDInstance is the instance value for a HID device to release.
+//!
+//! This function releases an instance of a HID device that was created by a
+//! call to USBHHIDOpen().  This call is required to allow other HID devices
+//! to be enumerated after another HID device has been disconnected.  The
+//! \e psHIDInstance parameter should hold the value that was returned from
+//! the previous call to USBHHIDOpen().
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBHHIDClose(tHIDInstance *psHIDInstance)
+{
+    //
+    // Disable any more notifications from the HID layer.
+    //
+    psHIDInstance->pfnCallback = 0;
+
+    //
+    // Mark this device slot as free.
+    //
+    psHIDInstance->iDeviceType = eUSBHHIDClassNone;
+}
+
+//*****************************************************************************
+//
+// This function handles callbacks for the interrupt IN endpoint.
+//
+//*****************************************************************************
+static void
+HIDIntINCallback(uint32_t ui32Pipe, uint32_t ui32Event)
+{
+    int32_t i32Dev;
+
+    switch (ui32Event)
+    {
+        //
+        // Handles a request to schedule a new request on the interrupt IN
+        // pipe.
+        //
+        case USB_EVENT_SCHEDULER:
+        {
+            USBHCDPipeSchedule(ui32Pipe, 0, 1);
+            break;
+        }
+        //
+        // Called when new data is available on the interrupt IN pipe.
+        //
+        case USB_EVENT_RX_AVAILABLE:
+        {
+            //
+            // Determine which device this notification is intended for.
+            //
+            for(i32Dev = 0; i32Dev < MAX_HID_DEVICES; i32Dev++)
+            {
+                //
+                // Does this device own the pipe we have been passed?
+                //
+                if(g_psHIDDevice[i32Dev].ui32IntInPipe == ui32Pipe)
+                {
+                    //
+                    // Yes - send the report data to the USB host HID device
+                    // class driver.
+                    //
+                    g_psHIDDevice[i32Dev].pfnCallback(
+                                    g_psHIDDevice[i32Dev].pvCBData,
+                                    USB_EVENT_RX_AVAILABLE, ui32Pipe, 0);
+                }
+            }
+
+            break;
+        }
+    }
+}
+
+//*****************************************************************************
+//
+//! This function is used to open an instance of the HID driver.
+//!
+//! \param psDevice is a pointer to the device information structure.
+//!
+//! This function will attempt to open an instance of the HID driver based on
+//! the information contained in the psDevice structure.  This call can fail if
+//! there are not sufficient resources to open the device.  The function will
+//! return a value that should be passed back into USBHIDClose() when the
+//! driver is no longer needed.
+//!
+//! \return The function will return a pointer to a HID driver instance.
+//
+//*****************************************************************************
+static void *
+HIDDriverOpen(tUSBHostDevice *psDevice)
+{
+    int32_t i32Idx, i32Dev;
+    tEndpointDescriptor *psEndpointDescriptor;
+    tInterfaceDescriptor *psInterface;
+
+    //
+    // Get the interface descriptor.
+    //
+    psInterface = USBDescGetInterface(psDevice->psConfigDescriptor, 0, 0);
+
+    //
+    // Search the currently open instances for one that supports the protocol
+    // of this device.
+    //
+    for(i32Dev = 0; i32Dev < MAX_HID_DEVICES; i32Dev++)
+    {
+        if(g_psHIDDevice[i32Dev].iDeviceType ==
+           psInterface->bInterfaceProtocol)
+        {
+            //
+            // Save the device pointer.
+            //
+            g_psHIDDevice[i32Dev].psDevice = psDevice;
+
+            for(i32Idx = 0; i32Idx < 3; i32Idx++)
+            {
+                //
+                // Get the first endpoint descriptor.
+                //
+                psEndpointDescriptor = USBDescGetInterfaceEndpoint(psInterface,
+                                                                   i32Idx,
+                                                                   256);
+
+                //
+                // If no more endpoints then break out.
+                //
+                if(psEndpointDescriptor == 0)
+                {
+                    break;
+                }
+
+                //
+                // Interrupt
+                //
+                if((psEndpointDescriptor->bmAttributes & USB_EP_ATTR_TYPE_M) ==
+                   USB_EP_ATTR_INT)
+                {
+                    //
+                    // Interrupt IN.
+                    //
+                    if(psEndpointDescriptor->bEndpointAddress & USB_EP_DESC_IN)
+                    {
+                        g_psHIDDevice[i32Dev].ui32IntInPipe =
+                                USBHCDPipeAlloc(0, USBHCD_PIPE_INTR_IN,
+                                                psDevice, HIDIntINCallback);
+                        USBHCDPipeConfig(g_psHIDDevice[i32Dev].ui32IntInPipe,
+                                    psEndpointDescriptor->wMaxPacketSize,
+                                    psEndpointDescriptor->bInterval,
+                                    (psEndpointDescriptor->bEndpointAddress &
+                                     USB_EP_DESC_NUM_M));
+                    }
+                }
+            }
+
+            //
+            // If there is a callback function call it to inform the application that
+            // the device has been enumerated.
+            //
+            if(g_psHIDDevice[i32Dev].pfnCallback != 0)
+            {
+                g_psHIDDevice[i32Dev].pfnCallback(
+                                    g_psHIDDevice[i32Dev].pvCBData,
+                                    USB_EVENT_CONNECTED,
+                                    (uint32_t)&g_psHIDDevice[i32Dev], 0);
+            }
+
+            //
+            // Save the device pointer.
+            //
+            g_psHIDDevice[i32Dev].psDevice = psDevice;
+
+            return (&g_psHIDDevice[i32Dev]);
+        }
+    }
+
+    //
+    // If we get here, no user has registered an interest in this particular
+    // HID device so we return an error.
+    //
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! This function is used to release an instance of the HID driver.
+//!
+//! \param pvInstance is an instance pointer that needs to be released.
+//!
+//! This function will free up any resources in use by the HID driver instance
+//! that is passed in.  The \e pvInstance pointer should be a valid value that
+//! was returned from a call to USBHIDOpen().
+//!
+//! \return None.
+//
+//*****************************************************************************
+static void
+HIDDriverClose(void *pvInstance)
+{
+    tHIDInstance *psInst;
+
+    //
+    // Get our instance pointer.
+    //
+    psInst = (tHIDInstance *)pvInstance;
+
+    //
+    // Reset the device pointer.
+    //
+    psInst->psDevice = 0;
+
+    //
+    // Free the Interrupt IN pipe.
+    //
+    if(psInst->ui32IntInPipe != 0)
+    {
+        USBHCDPipeFree(psInst->ui32IntInPipe);
+    }
+
+    //
+    // If the callback exists, call it with a DISCONNECTED event.
+    //
+    if(psInst->pfnCallback != 0)
+    {
+        psInst->pfnCallback(psInst->pvCBData, USB_EVENT_DISCONNECTED,
+                            (uint32_t)pvInstance, 0);
+    }
+}
+
+//*****************************************************************************
+//
+//! This function is used to set the idle timeout for a HID device.
+//!
+//! \param psHIDInstance is the value that was returned from the call to
+//! USBHHIDOpen().
+//! \param ui8Duration is the duration of the timeout in milliseconds.
+//! \param ui8ReportID is the report identifier to set the timeout on.
+//!
+//! This function will send the Set Idle command to a HID device to set the
+//! idle timeout for a given report.  The length of the timeout is specified
+//! by the \e ui8Duration parameter and the report the timeout for is in the
+//! \e ui8ReportID value.
+//!
+//! \return Always returns 0.
+//
+//*****************************************************************************
+uint32_t
+USBHHIDSetIdle(tHIDInstance *psHIDInstance, uint8_t ui8Duration,
+               uint8_t ui8ReportID)
+{
+    tUSBRequest sSetupPacket;
+
+    //
+    // This is a Class specific interface OUT request.
+    //
+    sSetupPacket.bmRequestType = USB_RTYPE_DIR_OUT | USB_RTYPE_CLASS |
+                                 USB_RTYPE_INTERFACE;
+
+    //
+    // Request a Device Descriptor.
+    //
+    sSetupPacket.bRequest = USBREQ_SET_IDLE;
+    sSetupPacket.wValue = (ui8Duration << 8) | ui8ReportID;
+
+    //
+    // Set this on interface 1.
+    //
+    sSetupPacket.wIndex = 0;
+
+    //
+    // This is always 0 for this request.
+    //
+    sSetupPacket.wLength = 0;
+
+    //
+    // Put the setup packet in the buffer.
+    //
+    return(USBHCDControlTransfer(0, &sSetupPacket, psHIDInstance->psDevice,
+                                 0, 0, MAX_PACKET_SIZE_EP0));
+}
+
+//*****************************************************************************
+//
+//! This function can be used to retrieve the report descriptor for a given
+//! device instance.
+//!
+//! \param psHIDInstance is the value that was returned from the call to
+//! USBHHIDOpen().
+//! \param pui8Buffer is the memory buffer to use to store the report
+//! descriptor.
+//! \param ui32Size is the size in bytes of the buffer pointed to by
+//! \e pui8Buffer.
+//!
+//! This function is used to return a report descriptor from a HID device
+//! instance so that it can determine how to interpret reports that are
+//! returned from the device indicated by the \e psHIDInstance parameter.
+//! This call is blocking and will return the number of bytes read into the
+//! \e pui8Buffer.
+//!
+//! \return Returns the number of bytes read into the \e pui8Buffer.
+//
+//*****************************************************************************
+uint32_t
+USBHHIDGetReportDescriptor(tHIDInstance *psHIDInstance, uint8_t *pui8Buffer,
+                           uint32_t ui32Size)
+{
+    tUSBRequest sSetupPacket;
+    uint32_t ui32Bytes;
+
+    //
+    // This is a Standard Device IN request.
+    //
+    sSetupPacket.bmRequestType = USB_RTYPE_DIR_IN | USB_RTYPE_STANDARD |
+                                 USB_RTYPE_INTERFACE;
+
+    //
+    // Request a Report Descriptor.
+    //
+    sSetupPacket.bRequest = USBREQ_GET_DESCRIPTOR;
+    sSetupPacket.wValue = USB_HID_DTYPE_REPORT << 8;
+
+    //
+    // Index is always 0 for device requests.
+    //
+    sSetupPacket.wIndex = 0;
+
+    //
+    // All devices must have at least an 8 byte max packet size so just ask
+    // for 8 bytes to start with.
+    //
+    sSetupPacket.wLength = ui32Size;
+
+    //
+    // Now get the full descriptor now that the actual maximum packet size
+    // is known.
+    //
+    ui32Bytes = USBHCDControlTransfer(0, &sSetupPacket,
+                psHIDInstance->psDevice, pui8Buffer, ui32Size,
+                psHIDInstance->psDevice->sDeviceDescriptor.bMaxPacketSize0);
+
+    return(ui32Bytes);
+}
+
+//*****************************************************************************
+//
+//! This function is used to set or clear the boot protocol state of a device.
+//!
+//! \param psHIDInstance is the value that was returned from the call to
+//! USBHHIDOpen().
+//! \param ui32BootProtocol is either zero or non-zero to indicate which
+//! protocol to use for the device.
+//!
+//! A USB host device can use this function to set the protocol for a connected
+//! HID device.  This is commonly used to set keyboards and mice into their
+//! simplified boot protocol modes to fix the report structure to a know
+//! state.
+//!
+//! \return This function returns 0.
+//
+//*****************************************************************************
+uint32_t
+USBHHIDSetProtocol(tHIDInstance *psHIDInstance, uint32_t ui32BootProtocol)
+{
+    tUSBRequest sSetupPacket;
+
+    //
+    // This is a Standard Device IN request.
+    //
+    sSetupPacket.bmRequestType = USB_RTYPE_DIR_OUT | USB_RTYPE_CLASS |
+                                 USB_RTYPE_INTERFACE;
+
+    //
+    // Request a Report Descriptor.
+    //
+    sSetupPacket.bRequest = USBREQ_SET_PROTOCOL;
+
+    if(ui32BootProtocol)
+    {
+        //
+        // Boot Protocol.
+        //
+        sSetupPacket.wValue = 0;
+    }
+    else
+    {
+        //
+        // Report Protocol.
+        //
+        sSetupPacket.wValue = 1;
+    }
+
+    //
+    // Index is always 0 for device requests.
+    //
+    sSetupPacket.wIndex = 0;
+
+    //
+    // Always 0.
+    //
+    sSetupPacket.wLength = 0;
+
+    //
+    // Now get the full descriptor now that the actual maximum packet size
+    // is known.
+    //
+    USBHCDControlTransfer(0, &sSetupPacket, psHIDInstance->psDevice, 0, 0,
+                psHIDInstance->psDevice->sDeviceDescriptor.bMaxPacketSize0);
+
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! This function is used to retrieve a report from a HID device.
+//!
+//! \param psHIDInstance is the value that was returned from the call to
+//! USBHHIDOpen().
+//! \param ui32Interface is the interface to retrieve the report from.
+//! \param pui8Data is the memory buffer to use to store the report.
+//! \param ui32Size is the size in bytes of the buffer pointed to by
+//! \e pui8Buffer.
+//!
+//! This function is used to retrieve a report from a USB pipe.  It is usually
+//! called when the USB HID layer has detected a new data available in a USB
+//! pipe.  The USB HID host device code will receive a
+//! \b USB_EVENT_RX_AVAILABLE event when data is available, allowing the
+//! callback function to retrieve the data.
+//!
+//! \return Returns the number of bytes read from report.
+//
+//*****************************************************************************
+uint32_t
+USBHHIDGetReport(tHIDInstance *psHIDInstance, uint32_t ui32Interface,
+                 uint8_t *pui8Data, uint32_t ui32Size)
+{
+    //
+    // Read the Data out.
+    //
+    ui32Size = USBHCDPipeReadNonBlocking(psHIDInstance->ui32IntInPipe,
+                                         pui8Data, ui32Size);
+
+    //
+    // Return the number of bytes read from the interrupt in pipe.
+    //
+    return(ui32Size);
+}
+
+//*****************************************************************************
+//
+//! This function is used to send a report to a HID device.
+//!
+//! \param psHIDInstance is the value that was returned from the call to
+//! USBHHIDOpen().
+//! \param ui32Interface is the interface to send the report to.
+//! \param pui8Data is the memory buffer to use to store the report.
+//! \param ui32Size is the size in bytes of the buffer pointed to by
+//! \e pui8Buffer.
+//!
+//! This function is used to send a report to a USB HID device.  It can be
+//! only be called from outside the callback context as this function will not
+//! return from the call until the data has been sent successfully.
+//!
+//! \return Returns the number of bytes sent to the device.
+//
+//*****************************************************************************
+uint32_t
+USBHHIDSetReport(tHIDInstance *psHIDInstance, uint32_t ui32Interface,
+                 uint8_t *pui8Data, uint32_t ui32Size)
+{
+    tUSBRequest sSetupPacket;
+
+    //
+    // This is a class specific OUT request.
+    //
+    sSetupPacket.bmRequestType = USB_RTYPE_DIR_OUT | USB_RTYPE_CLASS |
+                                 USB_RTYPE_INTERFACE;
+
+    //
+    // Request a Report Descriptor.
+    //
+    sSetupPacket.bRequest = USBREQ_SET_REPORT;
+    sSetupPacket.wValue = USB_HID_REPORT_OUTPUT << 8;
+
+    //
+    // Index is always 0 for device requests.
+    //
+    sSetupPacket.wIndex = (uint16_t)ui32Interface;
+
+    //
+    // Always 0.
+    //
+    sSetupPacket.wLength = ui32Size;
+
+    //
+    // Now get the full descriptor now that the actual maximum packet size
+    // is known.
+    //
+    USBHCDControlTransfer(0, &sSetupPacket, psHIDInstance->psDevice,
+            pui8Data, ui32Size,
+            psHIDInstance->psDevice->sDeviceDescriptor.bMaxPacketSize0);
+
+    return(ui32Size);
+}
+
+//*****************************************************************************
+//
+//! This function forwards an LPM request for a device to enter L1 sleep state.
+//!
+//! \param psHIDInstance is the HID instance that was returned from the call
+//! to USBHHIDOpen().
+//!
+//! This function forwards a request from a HID device class to the host
+//! controller to request that a device enter the LPM L1 sleep state.  The
+//! caller must check the return value to see if the request can be
+//! attempted at this time.  If another LPM transaction is busy on this or
+//! another device, then this function returns \b USBHCD_LPM_PENDING.  If
+//! the LPM request was scheduled to be sent the function returns
+//! \b USBHCD_LPM_AVAIL.  The caller should check the USBHCDLPMStatus()
+//! function to determine if the request completed successfully or if there
+//! was an error.
+//!
+//! \return This function returns the following values:
+//! - USBHCD_LPM_AVAIL - The transition to L1 state is scheduled to be sent.
+//! - USBHCD_LPM_PENDING - There is already an LPM request pending.
+//
+//*****************************************************************************
+uint32_t
+USBHHIDLPMSleep(tHIDInstance *psHIDInstance)
+{
+    //
+    // Forward the request to the control endpoint of the device.
+    //
+    return(USBHCDLPMSleep(psHIDInstance->psDevice));
+}
+
+//*****************************************************************************
+//
+//! This function returns the current status of an LPM request.
+//!
+//! \param psHIDInstance is the HID instance that was returned from the call
+//! to USBHHIDOpen().
+//!
+//! This function returns the current status of LPM requests for a given
+//! device.  This is called to determine if a previous request completed
+//! successfully or if there was an error.
+//!
+//! \return This function returns the following values:
+//! - \b USBHCD_LPM_AVAIL - There are no pending LPM requests on this specific
+//!   device or the last request completed successfully.
+//! - \b USBHCD_LPM_ERROR - The last LPM request for this device did not
+//!   complete successfully.
+//! - \b USBHCD_LPM_PENDING - The last LPM request has not completed.
+//
+//*****************************************************************************
+uint32_t
+USBHHIDLPMStatus(tHIDInstance *psHIDInstance)
+{
+    //
+    // Call the host controller function to get the current LPM status.
+    //
+    return(USBHCDLPMStatus(psHIDInstance->psDevice));
+}
+
+//*****************************************************************************
+//
+//! @}
+//
+//*****************************************************************************
diff --git a/bsp/tm4c129x/libraries/usblib/host/usbhhid.h b/bsp/tm4c129x/libraries/usblib/host/usbhhid.h
new file mode 100755
index 0000000..776154b
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/host/usbhhid.h
@@ -0,0 +1,166 @@
+//*****************************************************************************
+//
+// usbhhid.h - This hold the host driver for hid class.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#ifndef __USBHHID_H__
+#define __USBHHID_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+//*****************************************************************************
+//
+//! \addtogroup usblib_host_class
+//! @{
+//
+//*****************************************************************************
+
+typedef struct tHIDInstance tHIDInstance;
+
+//*****************************************************************************
+//
+// These defines are the the events that will be passed in the ui32Event
+// parameter of the callback from the driver.
+//
+//*****************************************************************************
+#define USBH_EVENT_HID_SETRPT   USBH_HID_EVENT_BASE + 0
+#define USBH_EVENT_HID_REPORT   USBH_HID_EVENT_BASE + 1
+
+//
+//! The HID keyboard detected a key being pressed.
+//
+#define USBH_EVENT_HID_KB_PRESS USBH_HID_EVENT_BASE + 16
+
+//
+//! The HID keyboard detected a key being released.
+//
+#define USBH_EVENT_HID_KB_REL   USBH_HID_EVENT_BASE + 17
+
+//
+//! The HID keyboard detected one of the keyboard modifiers being pressed.
+//
+#define USBH_EVENT_HID_KB_MOD   USBH_HID_EVENT_BASE + 18
+
+//
+//! A button was pressed on a HID mouse.
+//
+#define USBH_EVENT_HID_MS_PRESS USBH_HID_EVENT_BASE + 32
+
+//
+//! A button was released on a HID mouse.
+//
+#define USBH_EVENT_HID_MS_REL   USBH_HID_EVENT_BASE + 33
+
+//
+//! The HID mouse detected movement in the X direction.
+//
+#define USBH_EVENT_HID_MS_X     USBH_HID_EVENT_BASE + 34
+
+//
+//! The HID mouse detected movement in the Y direction.
+//
+#define USBH_EVENT_HID_MS_Y     USBH_HID_EVENT_BASE + 35
+
+//*****************************************************************************
+//
+//! The following values are used to register callbacks to the USB HOST HID
+//! device class layer.
+//
+//*****************************************************************************
+typedef enum
+{
+    //
+    //! No device should be used.  This value should not be used by
+    //! applications.
+    //
+    eUSBHHIDClassNone = 0,
+
+    //
+    //! This is a keyboard device.
+    //
+    eUSBHHIDClassKeyboard,
+
+    //
+    //! This is a mouse device.
+    //
+    eUSBHHIDClassMouse,
+
+    //
+    //! This is a vendor specific device.
+    //
+    eUSBHHIDClassVendor
+}
+tHIDSubClassProtocol;
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Prototypes.
+//
+//*****************************************************************************
+extern tHIDInstance * USBHHIDOpen(tHIDSubClassProtocol iDeviceType,
+                                  tUSBCallback pfnCallback,
+                                  void *pvCBData);
+extern void USBHHIDClose(tHIDInstance *psHIDInstance);
+extern uint32_t USBHHIDGetReportDescriptor(tHIDInstance *psHIDInstance,
+                                           uint8_t *pui8Buffer,
+                                           uint32_t ui32Size);
+extern uint32_t USBHHIDSetIdle(tHIDInstance *psHIDInstance, uint8_t ui8Duration,
+                               uint8_t ui8ReportID);
+extern uint32_t USBHHIDSetProtocol(tHIDInstance *psHIDInstance,
+                                   uint32_t ui32BootProtocol);
+extern uint32_t USBHHIDSetReport(tHIDInstance *psHIDInstance,
+                                 uint32_t ui32Interface, uint8_t *pui8Data,
+                                 uint32_t ui32Size);
+extern uint32_t USBHHIDGetReport(tHIDInstance *psHIDInstance,
+                                 uint32_t ui32Interface, uint8_t *pui8Data,
+                                 uint32_t ui32Size);
+extern uint32_t USBHHIDLPMSleep(tHIDInstance *psHIDInstance);
+extern uint32_t USBHHIDLPMStatus(tHIDInstance *psHIDInstance);
+
+extern const tUSBHostClassDriver g_sUSBHIDClassDriver;
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __USBHHID_H__
diff --git a/bsp/tm4c129x/libraries/usblib/host/usbhhidkeyboard.c b/bsp/tm4c129x/libraries/usblib/host/usbhhidkeyboard.c
new file mode 100755
index 0000000..cf81bd7
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/host/usbhhidkeyboard.c
@@ -0,0 +1,752 @@
+//*****************************************************************************
+//
+// usbhhidkeyboard.c - This file holds the application interfaces for USB
+//                     keyboard devices.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "inc/hw_types.h"
+#include "usblib/usblib.h"
+#include "usblib/host/usbhost.h"
+#include "usblib/usbhid.h"
+#include "usblib/host/usbhhid.h"
+#include "usblib/host/usbhhidkeyboard.h"
+
+//*****************************************************************************
+//
+//! \addtogroup usblib_host_device
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Prototypes for local functions.
+//
+//*****************************************************************************
+static uint32_t USBHKeyboardCallback(void *pvKeyboard, uint32_t ui32Event,
+                                     uint32_t ui32MsgParam, void *pvMsgData);
+
+//*****************************************************************************
+//
+// The size of a USB keyboard report.
+//
+//*****************************************************************************
+#define USBHKEYB_REPORT_SIZE    8
+
+//*****************************************************************************
+//
+// These are the flags for the tUSBHKeyboard.ui32HIDFlags member variable.
+//
+//*****************************************************************************
+#define USBHKEYB_DEVICE_PRESENT 0x00000001
+
+//*****************************************************************************
+//
+// This is the structure definition for a keyboard device instance.
+//
+//*****************************************************************************
+struct tUSBHKeyboard
+{
+    //
+    // Global flags for an instance of a keyboard.
+    //
+    uint32_t ui32HIDFlags;
+
+    //
+    // The applications registered callback.
+    //
+    tUSBHIDKeyboardCallback pfnCallback;
+
+    //
+    // The HID instance pointer for this keyboard instance.
+    //
+    tHIDInstance *psHIDInstance;
+
+    //
+    // NUM_LOCK, CAPS_LOCK, SCROLL_LOCK, COMPOSE or KANA keys.
+    //
+    uint8_t ui8KeyModSticky;
+
+    //
+    // This is the current state of the keyboard modifier keys.
+    //
+    uint8_t ui8KeyModState;
+
+    //
+    // This holds the keyboard usage codes for keys that are being held down.
+    //
+    uint8_t pui8KeyState[6];
+
+    //
+    // This is a local buffer to hold the current HID report that comes up
+    // from the HID driver layer.
+    //
+    uint8_t pui8Buffer[USBHKEYB_REPORT_SIZE];
+};
+
+//*****************************************************************************
+//
+// This is the per instance information for a keyboard device.
+//
+//*****************************************************************************
+static tUSBHKeyboard g_sUSBHKeyboard =
+{
+    0
+};
+
+//*****************************************************************************
+//
+//! This function is used open an instance of a keyboard.
+//!
+//! \param pfnCallback is the callback function to call when new events occur
+//! with the keyboard returned.
+//! \param pui8Buffer is the memory used by the keyboard to interact with the
+//! USB keyboard.
+//! \param ui32Size is the size of the buffer provided by \e pui8Buffer.
+//!
+//! This function is used to open an instance of the keyboard.  The value
+//! returned from this function should be used as the instance identifier for
+//! all other USBHKeyboard calls.  The \e pui8Buffer memory buffer is used to
+//! access the keyboard.  The buffer size required is at least enough to hold
+//! a normal report descriptor for the device.  If there is not enough space
+//! only a partial report descriptor will be read out.
+//!
+//! \return Returns the instance identifier for the keyboard that is attached.
+//! If there is no keyboard present this will return 0.
+//
+//*****************************************************************************
+tUSBHKeyboard *
+USBHKeyboardOpen(tUSBHIDKeyboardCallback pfnCallback, uint8_t *pui8Buffer,
+                 uint32_t ui32Size)
+{
+    //
+    // Save the callback and data pointers.
+    //
+    g_sUSBHKeyboard.pfnCallback = pfnCallback;
+
+    //
+    // Save the instance pointer for the HID device that was opened.
+    //
+    g_sUSBHKeyboard.psHIDInstance =
+        USBHHIDOpen(eUSBHHIDClassKeyboard, USBHKeyboardCallback,
+                    (void *)&g_sUSBHKeyboard);
+
+    return(&g_sUSBHKeyboard);
+}
+
+//*****************************************************************************
+//
+//! This function is used close an instance of a keyboard.
+//!
+//! \param psKbInstance is the instance value for this keyboard.
+//!
+//! This function is used to close an instance of the keyboard that was opened
+//! with a call to USBHKeyboardOpen().  The \e psKbInstance value is the
+//! value that was returned when the application called USBHKeyboardOpen().
+//!
+//! \return This function returns 0 to indicate success any non-zero value
+//! indicates an error condition.
+//
+//*****************************************************************************
+uint32_t
+USBHKeyboardClose(tUSBHKeyboard *psKbInstance)
+{
+    //
+    // Reset the callback to null.
+    //
+    psKbInstance->pfnCallback = 0;
+
+    //
+    // Call the HID driver layer to close out this instance.
+    //
+    USBHHIDClose(psKbInstance->psHIDInstance);
+
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! This function is used to map a USB usage ID to a printable character.
+//!
+//! \param psKbInstance is the instance value for this keyboard.
+//! \param psTable is the table to use to map the usage ID to characters.
+//! \param ui8UsageID is the USB usage ID to map to a character.
+//!
+//! This function is used to map a USB usage ID to a character.  The provided
+//! \e psTable is used to perform the mapping and is described by the
+//! tHIDKeyboardUsageTable type defined structure.  See the documentation on
+//! the tHIDKeyboardUsageTable structure for more details on the internals of
+//! this structure.  This function uses the current state of the shift keys
+//! and the Caps Lock key to modify the data returned by this function.  The
+//! psTable structure has values indicating which keys are modified by Caps
+//! and alternate values for shifted cases.  The number of bytes returned from
+//! Lock this function depends on the \e psTable structure passed in as it
+//! holds the number of bytes per character in the table.
+//!
+//! \return Returns the character value for the given usage id.
+//
+//*****************************************************************************
+uint32_t
+USBHKeyboardUsageToChar(tUSBHKeyboard *psKbInstance,
+                        const tHIDKeyboardUsageTable *psTable,
+                        uint8_t ui8UsageID)
+{
+    uint32_t ui32Value, ui32Offset, ui32Shift;
+    const uint8_t *pui8KeyBoardMap;
+    const uint16_t *pui16KeyBoardMap;
+
+    //
+    // The added offset for the shifted character value.
+    //
+    ui32Shift = 0;
+
+    //
+    // Offset in the table for the character.
+    //
+    ui32Offset = (ui8UsageID * psTable->ui8BytesPerChar * 2);
+
+    //
+    // Handle the case where CAPS lock has been set.
+    //
+    if(psKbInstance->ui8KeyModSticky &= HID_KEYB_CAPS_LOCK)
+    {
+        //
+        // See if this usage ID is modified by Caps Lock by checking the packed
+        // bit array in the pui32ShiftState member of the psTable array.
+        //
+        if((psTable->pui32CapsLock[ui8UsageID >> 5]) >>
+           (ui8UsageID & 0x1f) & 1)
+        {
+            ui32Shift = psTable->ui8BytesPerChar;
+        }
+    }
+
+    //
+    // Now handle if a shift key is being held.
+    //
+    if((psKbInstance->ui8KeyModState & 0x22) != 0)
+    {
+        //
+        // Not shifted yet so we need to shift.
+        //
+        if(ui32Shift == 0)
+        {
+            ui32Shift = psTable->ui8BytesPerChar;
+        }
+        else
+        {
+            //
+            // Unshift because CAPS LOCK and shift were pressed.
+            //
+            ui32Shift = 0;
+        }
+    }
+
+    //
+    // One byte per character.
+    //
+    if(psTable->ui8BytesPerChar == 1)
+    {
+        //
+        // Get the base address of the table.
+        //
+        pui8KeyBoardMap = psTable->pvCharMapping;
+
+        ui32Value = pui8KeyBoardMap[ui32Offset + ui32Shift];
+    }
+    //
+    // Two bytes per character.
+    //
+    else if(psTable->ui8BytesPerChar == 2)
+    {
+        //
+        // Get the base address of the table.
+        //
+        pui16KeyBoardMap = (uint16_t *)psTable->pvCharMapping;
+
+        ui32Value = pui16KeyBoardMap[ui32Offset + ui32Shift];
+    }
+    //
+    // All other sizes are unsupported for now.
+    //
+    else
+    {
+        ui32Value = 0;
+    }
+
+    return(ui32Value);
+}
+
+//*****************************************************************************
+//
+//! This function is used to set one of the fixed modifier keys on a keyboard.
+//!
+//! \param psKbInstance is the instance value for this keyboard.
+//! \param ui32Modifiers is a bit mask of the modifiers to set on the keyboard.
+//!
+//! This function is used to set the modifier key states on a keyboard.  The
+//! \e ui32Modifiers value is a bitmask of the following set of values:
+//! - \b HID_KEYB_NUM_LOCK
+//! - \b HID_KEYB_CAPS_LOCK
+//! - \b HID_KEYB_SCROLL_LOCK
+//! - \b HID_KEYB_COMPOSE
+//! - \b HID_KEYB_KANA
+//!
+//! Not all of these will be supported on all keyboards however setting values
+//! on a keyboard that does not have them should have no effect.  The
+//! \e psKbInstance value is the value that was returned when the application
+//! called USBHKeyboardOpen().  If the value \b HID_KEYB_CAPS_LOCK is used it
+//! will modify the values returned from the USBHKeyboardUsageToChar()
+//! function.
+//!
+//! \return This function returns 0 to indicate success any non-zero value
+//! indicates an error condition.
+//
+//*****************************************************************************
+uint32_t
+USBHKeyboardModifierSet(tUSBHKeyboard *psKbInstance, uint32_t ui32Modifiers)
+{
+    //
+    // Remember the fact that this is set.
+    //
+    psKbInstance->ui8KeyModSticky = (uint8_t)ui32Modifiers;
+
+    //
+    // Set the LEDs on the keyboard.
+    //
+    USBHHIDSetReport(psKbInstance->psHIDInstance, 0,
+                     (uint8_t *)&ui32Modifiers, 1);
+
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! This function is used to initialize a keyboard interface after a keyboard
+//! has been detected.
+//!
+//! \param psKbInstance is the instance value for this keyboard.
+//!
+//! This function should be called after receiving a \b USB_EVENT_CONNECTED
+//! event in the callback function provided by USBHKeyboardOpen(), however this
+//! function should only be called outside the callback function.  This will
+//! initialize the keyboard interface and determine the keyboard's
+//! layout and how it reports keys to the USB host controller.  The
+//! \e psKbInstance value is the value that was returned when the application
+//! called USBHKeyboardOpen().  This function only needs to be called once
+//! per connection event but it should be called every time a
+//! \b USB_EVENT_CONNECTED event occurs.
+//!
+//! \return This function returns 0 to indicate success any non-zero value
+//! indicates an error condition.
+//
+//*****************************************************************************
+uint32_t
+USBHKeyboardInit(tUSBHKeyboard *psKbInstance)
+{
+    uint8_t ui8ModData;
+    int32_t i32Idx;
+
+    //
+    // Set the initial rate to only update on keyboard state changes.
+    //
+    USBHHIDSetIdle(psKbInstance->psHIDInstance, 0, 0);
+
+    //
+    // Read out the Report Descriptor from the keyboard and parse it for
+    // the format of the reports coming back from the keyboard.
+    //
+    USBHHIDGetReportDescriptor(psKbInstance->psHIDInstance,
+                               psKbInstance->pui8Buffer,
+                               USBHKEYB_REPORT_SIZE);
+
+    //
+    // Set the keyboard to boot protocol.
+    //
+    USBHHIDSetProtocol(psKbInstance->psHIDInstance, 1);
+
+    //
+    // Used to clear the initial state of all on keyboard modifiers.
+    //
+    ui8ModData = 0;
+
+    //
+    // Update the keyboard LED state.
+    //
+    USBHHIDSetReport(psKbInstance->psHIDInstance, 0, &ui8ModData, 1);
+
+    //
+    // Reset the key state.
+    //
+    for(i32Idx = 0;
+        i32Idx < sizeof(psKbInstance->pui8KeyState) / sizeof(uint8_t);
+        i32Idx++)
+    {
+        psKbInstance->pui8KeyState[i32Idx] =0;
+    }
+
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! This function is used to set the automatic poll rate of the keyboard.
+//!
+//! \param psKbInstance is the instance value for this keyboard.
+//! \param ui32PollRate is the rate in ms to cause the keyboard to update the
+//! host regardless of no change in key state.
+//!
+//! This function will allow an application to tell the keyboard how often it
+//! should send updates to the USB host controller regardless of any changes
+//! in keyboard state.  The \e psKbInstance value is the value that was
+//! returned when the application called USBHKeyboardOpen().  The
+//! \e ui32PollRate is the new value in ms for the update rate on the keyboard.
+//! This value is initially set to 0 which indicates that the keyboard should
+//! only to update when the keyboard state changes.  Any value other than 0 can
+//! be used to force the keyboard to generate auto-repeat sequences for the
+//! application.
+//!
+//! \return This function returns 0 to indicate success any non-zero value
+//! indicates an error condition.
+//
+//*****************************************************************************
+uint32_t
+USBHKeyboardPollRateSet(tUSBHKeyboard *psKbInstance, uint32_t ui32PollRate)
+{
+    //
+    // Send the Set Idle command to the USB keyboard.
+    //
+    USBHHIDSetIdle(psKbInstance->psHIDInstance, ui32PollRate, 0);
+
+    return(0);
+}
+
+//*****************************************************************************
+//
+// This is an internal function used to modify the current keyboard state.
+//
+// This function checks for changes in the keyboard state due to a new report
+// being received from the device.  It first checks if this is a "roll-over"
+// case by seeing if 0x01 is in the first position of the new keyboard report.
+// This indicates that too many keys were pressed to handle and to ignore this
+// report.  Next the keyboard modifier state is stored and if any changes are
+// detected a \b USBH_EVENT_HID_KB_MOD event is sent back to the application.
+// Then this function will check for any keys that have been released and send
+// a \b USBH_EVENT_HID_KB_REL even for each of these keys.  The last check is
+// for any new keys that are pressed and a \b USBH_EVENT_HID_KB_PRESS event
+// will be sent for each new key pressed.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+UpdateKeyboardState(tUSBHKeyboard *psKbInstance)
+{
+    int32_t i32NewKey, i32OldKey;
+
+    //
+    // rollover code so ignore this buffer.
+    //
+    if(psKbInstance->pui8Buffer[2] == 0x01)
+    {
+        return;
+    }
+
+    //
+    // Handle the keyboard modifier states.
+    //
+    if(psKbInstance->ui8KeyModState != psKbInstance->pui8Buffer[0])
+    {
+        //
+        // Notify the application of the event.
+        //
+        psKbInstance->pfnCallback(0, USBH_EVENT_HID_KB_MOD,
+                                  psKbInstance->pui8Buffer[0], 0);
+
+        //
+        // Save the new state of the modifier keys.
+        //
+        psKbInstance->ui8KeyModState = psKbInstance->pui8Buffer[0];
+    }
+
+    //
+    // This loop checks for keys that have been released to make room for new
+    // ones that may have been pressed.
+    //
+    for(i32OldKey = 0; i32OldKey < 6; i32OldKey++)
+    {
+        //
+        // If there is no old key pressed in this entry go to the next one.
+        //
+        if(psKbInstance->pui8KeyState[i32OldKey] == 0)
+        {
+            continue;
+        }
+
+        //
+        // Check if this old key is still in the list of currently pressed
+        // keys.
+        //
+        for(i32NewKey = 2; i32NewKey < 8; i32NewKey++)
+        {
+            //
+            // Break out if the key is still present.
+            //
+            if(psKbInstance->pui8Buffer[i32NewKey] ==
+               psKbInstance->pui8KeyState[i32OldKey])
+            {
+                break;
+            }
+        }
+        //
+        // If the old key was no longer in the list of pressed keys then
+        // notify the application of the key release.
+        //
+        if(i32NewKey == 8)
+        {
+            //
+            // Send the key release notification to the application.
+            //
+            psKbInstance->pfnCallback(0, USBH_EVENT_HID_KB_REL,
+                                      psKbInstance->pui8KeyState[i32OldKey],
+                                      0);
+            //
+            // Remove the old key from the currently held key list.
+            //
+            psKbInstance->pui8KeyState[i32OldKey] = 0;
+
+        }
+    }
+
+    //
+    // This loop checks for new keys that have been pressed.
+    //
+    for(i32NewKey = 2; i32NewKey < 8; i32NewKey++)
+    {
+        //
+        // The new list is empty so no new keys are pressed.
+        //
+        if(psKbInstance->pui8Buffer[i32NewKey] == 0)
+        {
+            break;
+        }
+
+        //
+        // This loop checks if the current key was already pressed.
+        //
+        for(i32OldKey = 0; i32OldKey < 6; i32OldKey++)
+        {
+            //
+            // If it is in both lists then it was already pressed so ignore it.
+            //
+            if(psKbInstance->pui8Buffer[i32NewKey] ==
+               psKbInstance->pui8KeyState[i32OldKey])
+            {
+                break;
+            }
+        }
+        //
+        // The key in the new list was not found so it is new.
+        //
+        if(i32OldKey == 6)
+        {
+            //
+            // Look for a free location to store this key usage code.
+            //
+            for(i32OldKey = 0; i32OldKey < 6; i32OldKey++)
+            {
+                //
+                // If an empty location is found, store it and notify the
+                // application.
+                //
+                if(psKbInstance->pui8KeyState[i32OldKey] == 0)
+                {
+                    //
+                    // Save the newly pressed key.
+                    //
+                    psKbInstance->pui8KeyState[i32OldKey] =
+                                        psKbInstance->pui8Buffer[i32NewKey];
+
+                    //
+                    // Notify the application of the new key that has been
+                    // pressed.
+                    //
+                    psKbInstance->pfnCallback( 0, USBH_EVENT_HID_KB_PRESS,
+                                        psKbInstance->pui8Buffer[i32NewKey],
+                                        0);
+
+                    break;
+                }
+            }
+        }
+    }
+}
+
+//*****************************************************************************
+//
+//! This function handles event callbacks from the USB HID driver layer.
+//!
+//! \param pvKeyboard is the pointer that was passed in to the USBHHIDOpen()
+//! call.
+//! \param ui32Event is the event that has been passed up from the HID driver.
+//! \param ui32MsgParam has meaning related to the \e ui32Event that occurred.
+//! \param pvMsgData has meaning related to the \e ui32Event that occurred.
+//!
+//! This function will receive all event updates from the HID driver layer.
+//! The keyboard driver itself will mostly be concerned with report callbacks
+//! from the HID driver layer and parsing them into keystrokes for the
+//! application that has registered for callbacks with the USBHKeyboardOpen()
+//! call.
+//!
+//! \return Non-zero values should be assumed to indicate an error condition.
+//
+//*****************************************************************************
+static uint32_t
+USBHKeyboardCallback(void *pvKeyboard, uint32_t ui32Event,
+                     uint32_t ui32MsgParam, void *pvMsgData)
+{
+    tUSBHKeyboard *psKbInstance;
+
+    //
+    // Recover the pointer to the instance data.
+    //
+    psKbInstance = (tUSBHKeyboard *)pvKeyboard;
+
+    switch (ui32Event)
+    {
+        //
+        // New keyboard has been connected so notify the application.
+        //
+        case USB_EVENT_CONNECTED:
+        {
+            //
+            // Remember that a keyboard is present.
+            //
+            psKbInstance->ui32HIDFlags |= USBHKEYB_DEVICE_PRESENT;
+
+            //
+            // Notify the application that a new keyboard was connected.
+            //
+            psKbInstance->pfnCallback(0, ui32Event, ui32MsgParam, pvMsgData);
+
+            break;
+        }
+        case USB_EVENT_DISCONNECTED:
+        {
+            //
+            // No keyboard is present.
+            //
+            psKbInstance->ui32HIDFlags &= ~USBHKEYB_DEVICE_PRESENT;
+
+            //
+            // Notify the application that the keyboard was disconnected.
+            //
+            psKbInstance->pfnCallback(0, ui32Event, ui32MsgParam, pvMsgData);
+
+            break;
+        }
+        case USB_EVENT_RX_AVAILABLE:
+        {
+            //
+            // New keyboard report structure was received.
+            //
+            USBHHIDGetReport(psKbInstance->psHIDInstance, 0,
+                             psKbInstance->pui8Buffer,
+                             USBHKEYB_REPORT_SIZE);
+
+            //
+            // Update the application on the changes in the keyboard state.
+            //
+            UpdateKeyboardState(psKbInstance);
+
+            break;
+        }
+    }
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! This function forwards an LPM request for a device to enter L1 sleep state.
+//!
+//! \param psKbInstance is the HID keyboard instance that was
+//! returned from the call to USBHKeyboardOpen().
+//!
+//! This function forwards a request from an application to the HID device
+//! class to request that a device enter the LPM L1 sleep state.  The
+//! caller must check the return value to see if the request can be
+//! attempted at this time.  If another LPM transaction is busy on this or
+//! another device, then this function returns \b USBHCD_LPM_PENDING.  If
+//! the LPM request was scheduled to be sent the function returns
+//! \b USBHCD_LPM_AVAIL.  The caller should check the USBHCDLPMStatus()
+//! function to determine if the request completed successfully or if there
+//! was an error.
+//!
+//! \return This function returns the following values:
+//! - \b USBHCD_LPM_AVAIL - The transition to L1 state is scheduled to be sent.
+//! - \b USBHCD_LPM_PENDING - There is already an LPM request pending.
+//
+//*****************************************************************************
+uint32_t
+USBHKeyboardLPMSleep(tUSBHKeyboard *psKbInstance)
+{
+    //
+    // Call the HID function to send the sleep command.
+    //
+    return(USBHHIDLPMSleep(psKbInstance->psHIDInstance));
+}
+
+//*****************************************************************************
+//
+//! This function returns the current status of an LPM request.
+//!
+//! \param psKbInstance is the HID keyboard instance that was
+//! returned from the call to USBHKeyboardOpen().
+//!
+//! This function returns the current status of LPM requests for a given
+//! device.  This is called to determine if a previous request completed
+//! successfully or if there was an error.
+//!
+//! \return This function returns the following values:
+//! - \b USBHCD_LPM_AVAIL - There are no pending LPM requests on this specific
+//!   device or the last request completed successfully.
+//! - \b USBHCD_LPM_ERROR - The last LPM request for this device did not
+//!   complete successfully.
+//! - \b USBHCD_LPM_PENDING - The last LPM request has not completed.
+//
+//*****************************************************************************
+uint32_t
+USBHKeyboardLPMStatus(tUSBHKeyboard *psKbInstance)
+{
+    //
+    // Call the HID function to get the current LPM status.
+    //
+    return(USBHHIDLPMStatus(psKbInstance->psHIDInstance));
+}
+
+//*****************************************************************************
+//
+//! @}
+//
+//*****************************************************************************
diff --git a/bsp/tm4c129x/libraries/usblib/host/usbhhidkeyboard.h b/bsp/tm4c129x/libraries/usblib/host/usbhhidkeyboard.h
new file mode 100755
index 0000000..bbcd46a
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/host/usbhhidkeyboard.h
@@ -0,0 +1,89 @@
+//*****************************************************************************
+//
+// usbhhidkeyboard.h - This file holds the application interfaces for USB
+//                     keyboard devices.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#ifndef __USBHHIDKEYBOARD_H__
+#define __USBHHIDKEYBOARD_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+//*****************************************************************************
+//
+//! \addtogroup usblib_host_device
+//! @{
+//
+//*****************************************************************************
+
+typedef struct tUSBHKeyboard tUSBHKeyboard;
+
+//*****************************************************************************
+//
+// The prototype for the host USB Keyboard driver callback function.
+//
+//*****************************************************************************
+typedef void (*tUSBHIDKeyboardCallback)(tUSBHKeyboard *psKbInstance,
+                                        uint32_t ui32Event,
+                                        uint32_t ui32MsgParam,
+                                        void *pvMsgData);
+
+extern tUSBHKeyboard * USBHKeyboardOpen(tUSBHIDKeyboardCallback pfnCallback,
+                                        uint8_t *pui8Buffer,
+                                        uint32_t ui32BufferSize);
+extern uint32_t USBHKeyboardClose(tUSBHKeyboard *psKbInstance);
+extern uint32_t USBHKeyboardInit(tUSBHKeyboard *psKbInstance);
+extern uint32_t USBHKeyboardModifierSet(tUSBHKeyboard *psKbInstance,
+                                        uint32_t ui32Modifiers);
+extern uint32_t USBHKeyboardPollRateSet(tUSBHKeyboard *psKbInstance,
+                                        uint32_t ui32PollRate);
+extern uint32_t USBHKeyboardLPMSleep(tUSBHKeyboard *psKbInstance);
+extern uint32_t USBHKeyboardLPMStatus(tUSBHKeyboard *psKbInstance);
+extern uint32_t USBHKeyboardUsageToChar(tUSBHKeyboard *psKbInstance,
+                                        const tHIDKeyboardUsageTable *psTable,
+                                        uint8_t ui8UsageID);
+
+//*****************************************************************************
+//
+//! @}
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/bsp/tm4c129x/libraries/usblib/host/usbhhidmouse.c b/bsp/tm4c129x/libraries/usblib/host/usbhhidmouse.c
new file mode 100755
index 0000000..5378b78
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/host/usbhhidmouse.c
@@ -0,0 +1,452 @@
+//*****************************************************************************
+//
+// usbhhidmouse.c - This file holds the application interfaces for USB
+//                  mouse devices.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "inc/hw_types.h"
+#include "usblib/usblib.h"
+#include "usblib/host/usbhost.h"
+#include "usblib/usbhid.h"
+#include "usblib/host/usbhhid.h"
+#include "usblib/host/usbhhidmouse.h"
+
+//*****************************************************************************
+//
+//! \addtogroup usblib_host_device
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Prototypes for local functions.
+//
+//*****************************************************************************
+static uint32_t USBHMouseCallback(void *pvMouse, uint32_t ui32Event,
+                                  uint32_t ui32MsgParam, void *pvMsgData);
+
+//*****************************************************************************
+//
+// The size of a USB mouse report.
+//
+//*****************************************************************************
+#define USBHMS_REPORT_SIZE      4
+
+//*****************************************************************************
+//
+// These are the flags for the tUSBHMouse.ui32HIDFlags member variable.
+//
+//*****************************************************************************
+#define USBHMS_DEVICE_PRESENT   0x00000001
+
+//*****************************************************************************
+//
+// This is the structure definition for a mouse device instance.
+//
+//*****************************************************************************
+struct tUSBHMouse
+{
+    //
+    // Global flags for an instance of a mouse.
+    //
+    uint32_t ui32HIDFlags;
+
+    //
+    // The applications registered callback.
+    //
+    tUSBHIDMouseCallback pfnCallback;
+
+    //
+    // The current state of the buttons.
+    //
+    uint8_t ui8Buttons;
+
+    //
+    // This is a local buffer to hold the current HID report that comes up
+    // from the HID driver layer.
+    //
+    uint8_t pui8Buffer[USBHMS_REPORT_SIZE];
+
+    //
+    // Heap data for the mouse currently used to read the HID Report
+    // Descriptor.
+    //
+    uint8_t *pui8Heap;
+
+    //
+    // Size of the heap in bytes.
+    //
+    uint32_t ui32HeapSize;
+
+    //
+    // This is the instance value for the HID device that will be used for the
+    // mouse.
+    //
+    tHIDInstance *psHIDInstance;
+};
+
+//*****************************************************************************
+//
+// This is the per instance information for a mouse device.
+//
+//*****************************************************************************
+static tUSBHMouse g_sUSBHMouse =
+{
+    0
+};
+
+//*****************************************************************************
+//
+//! This function is used open an instance of a mouse.
+//!
+//! \param pfnCallback is the callback function to call when new events occur
+//! with the mouse returned.
+//! \param pui8Buffer is the memory used by the driver to interact with the
+//! USB mouse.
+//! \param ui32Size is the size of the buffer provided by \e pui8Buffer.
+//!
+//! This function is used to open an instance of the mouse.  The value
+//! returned from this function should be used as the instance identifier for
+//! all other USBHMouse calls.  The \e pui8Buffer memory buffer is used to
+//! access the mouse.  The buffer size required is at least enough to hold
+//! a normal report descriptor for the device.
+//!
+//! \return Returns the instance identifier for the mouse that is attached.
+//! If there is no mouse present this will return 0.
+//
+//*****************************************************************************
+tUSBHMouse *
+USBHMouseOpen(tUSBHIDMouseCallback pfnCallback, uint8_t *pui8Buffer,
+              uint32_t ui32Size)
+{
+    //
+    // Save the callback and data pointers.
+    //
+    g_sUSBHMouse.pfnCallback = pfnCallback;
+
+    //
+    // Save the instance pointer for the HID device that was opened.
+    //
+    g_sUSBHMouse.psHIDInstance = USBHHIDOpen(eUSBHHIDClassMouse,
+                                             USBHMouseCallback,
+                                             (void *)&g_sUSBHMouse);
+
+    //
+    // Save the heap buffer and size.
+    //
+    g_sUSBHMouse.pui8Heap = pui8Buffer;
+    g_sUSBHMouse.ui32HeapSize = ui32Size;
+
+    return(&g_sUSBHMouse);
+}
+
+//*****************************************************************************
+//
+//! This function is used close an instance of a mouse.
+//!
+//! \param psMsInstance is the instance value for this mouse.
+//!
+//! This function is used to close an instance of the mouse that was opened
+//! with a call to USBHMouseOpen().  The \e psMsInstance value is the value
+//! that was returned when the application called USBHMouseOpen().
+//!
+//! \return Returns 0.
+//
+//*****************************************************************************
+uint32_t
+USBHMouseClose(tUSBHMouse *psMsInstance)
+{
+    //
+    // Reset the callback to null.
+    //
+    psMsInstance->pfnCallback = 0;
+
+    //
+    // Call the HID driver layer to close out this instance.
+    //
+    USBHHIDClose(psMsInstance->psHIDInstance);
+
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! This function is used to initialize a mouse interface after a mouse has
+//! been detected.
+//!
+//! \param psMsInstance is the instance value for this mouse.
+//!
+//! This function should be called after receiving a \b USB_EVENT_CONNECTED
+//! event in the callback function provided by USBHMouseOpen(), however it
+//! should only be called outside of the callback function.  This will
+//! initialize the mouse interface and determine how it reports events to the
+//! USB host controller.  The \e psMsInstance value is the value that was
+//! returned when the application called USBHMouseOpen().  This function only
+//! needs to be called once per connection event but it should be called every
+//! time a \b USB_EVENT_CONNECTED event occurs.
+//!
+//! \return Non-zero values should be assumed to indicate an error condition.
+//
+//*****************************************************************************
+uint32_t
+USBHMouseInit(tUSBHMouse *psMsInstance)
+{
+    //
+    // Set the initial rate to only update on mouse state changes.
+    //
+    USBHHIDSetIdle(psMsInstance->psHIDInstance, 0, 0);
+
+    //
+    // Read out the Report Descriptor from the mouse and parse it for
+    // the format of the reports coming back from the mouse.
+    //
+    USBHHIDGetReportDescriptor(psMsInstance->psHIDInstance,
+                               psMsInstance->pui8Heap,
+                               psMsInstance->ui32HeapSize);
+
+    //
+    // Set the mouse to boot protocol.
+    //
+    USBHHIDSetProtocol(psMsInstance->psHIDInstance, 1);
+
+    return(0);
+}
+
+//*****************************************************************************
+//
+// This function handles updating the state of the mouse buttons and axis.
+//
+// \param psMsInstance is the pointer to an instance of the mouse data.
+//
+// This function will check for updates to buttons or X/Y movements and send
+// callbacks to the mouse callback function.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+UpdateMouseState(tUSBHMouse *psMsInstance)
+{
+    uint32_t ui32Button;
+
+    if(psMsInstance->pui8Buffer[0] != psMsInstance->ui8Buttons)
+    {
+        for(ui32Button = 1; ui32Button <= 0x4; ui32Button <<= 1)
+        {
+            if(((psMsInstance->pui8Buffer[0] & ui32Button) != 0) &&
+               ((psMsInstance->ui8Buttons & ui32Button) == 0))
+            {
+                //
+                // Send the mouse button press notification to the application.
+                //
+                psMsInstance->pfnCallback(0, USBH_EVENT_HID_MS_PRESS,
+                                          ui32Button, 0);
+            }
+            if(((psMsInstance->pui8Buffer[0] & ui32Button) == 0) &&
+               ((psMsInstance->ui8Buttons & ui32Button) != 0))
+            {
+                //
+                // Send the mouse button release notification to the
+                // application.
+                //
+                psMsInstance->pfnCallback(0, USBH_EVENT_HID_MS_REL,
+                                         ui32Button, 0);
+            }
+        }
+
+        //
+        // Save the new state.
+        //
+        psMsInstance->ui8Buttons = psMsInstance->pui8Buffer[0];
+    }
+
+    if(psMsInstance->pui8Buffer[1] != 0)
+    {
+        //
+        // Send the mouse button release notification to the
+        // application.
+        //
+        psMsInstance->pfnCallback(0, USBH_EVENT_HID_MS_X,
+                                  (uint32_t)psMsInstance->pui8Buffer[1], 0);
+    }
+
+    if(psMsInstance->pui8Buffer[2] != 0)
+    {
+        //
+        // Send the mouse button release notification to the
+        // application.
+        //
+        psMsInstance->pfnCallback(0, USBH_EVENT_HID_MS_Y,
+                                  (uint32_t)psMsInstance->pui8Buffer[2], 0);
+    }
+}
+
+//*****************************************************************************
+//
+//! This function handles event callbacks from the USB HID driver layer.
+//!
+//! \param pvMouse is the pointer that was passed in to the USBHHIDOpen()
+//! call.
+//! \param ui32Event is the event that has been passed up from the HID driver.
+//! \param ui32MsgParam has meaning related to the \e ui32Event that occurred.
+//! \param pvMsgData has meaning related to the \e ui32Event that occurred.
+//!
+//! This function will receive all event updates from the HID driver layer.
+//! The mouse driver itself will mostly be concerned with report callbacks
+//! from the HID driver layer and parsing them into keystrokes for the
+//! application that has registered for callbacks with the USBHMouseOpen()
+//! call.
+//!
+//! \return Non-zero values should be assumed to indicate an error condition.
+//
+//*****************************************************************************
+uint32_t
+USBHMouseCallback(void *pvMouse, uint32_t ui32Event,
+                  uint32_t ui32MsgParam, void *pvMsgData)
+{
+    tUSBHMouse *psMsInstance;
+
+    //
+    // Recover the pointer to the instance data.
+    //
+    psMsInstance = (tUSBHMouse *)pvMouse;
+
+    switch(ui32Event)
+    {
+        //
+        // New mouse has been connected so notify the application.
+        //
+        case USB_EVENT_CONNECTED:
+        {
+            //
+            // Remember that a mouse is present.
+            //
+            psMsInstance->ui32HIDFlags |= USBHMS_DEVICE_PRESENT;
+
+            //
+            // Notify the application that a new mouse was connected.
+            //
+            psMsInstance->pfnCallback(0, ui32Event, ui32MsgParam, pvMsgData);
+
+            break;
+        }
+        case USB_EVENT_DISCONNECTED:
+        {
+            //
+            // No mouse is present.
+            //
+            psMsInstance->ui32HIDFlags &= ~USBHMS_DEVICE_PRESENT;
+
+            //
+            // Notify the application that the mouse was disconnected.
+            //
+            psMsInstance->pfnCallback(0, ui32Event, ui32MsgParam, pvMsgData);
+
+            break;
+        }
+        case USB_EVENT_RX_AVAILABLE:
+        {
+            //
+            // New mouse report structure was received.
+            //
+            USBHHIDGetReport(psMsInstance->psHIDInstance, 0,
+                             psMsInstance->pui8Buffer, USBHMS_REPORT_SIZE);
+
+            //
+            // Update the current state of the mouse and notify the application
+            // of any changes.
+            //
+            UpdateMouseState(psMsInstance);
+
+            break;
+        }
+    }
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! This function forwards an LPM request for a device to enter L1 sleep state.
+//!
+//! \param psMsInstance is the HID keyboard instance that was returned
+//! from the call to USBHMouseOpen().
+//!
+//! This function forwards a request from an application to the HID device
+//! class to request that a device enter the LPM L1 sleep state.  The
+//! caller must check the return value to see if the request can be
+//! attempted at this time.  If another LPM transaction is busy on this or
+//! another device, then this function returns \b USBHCD_LPM_PENDING.  If
+//! the LPM request was scheduled to be sent the function returns
+//! \b USBHCD_LPM_AVAIL.  The caller should check the USBHCDLPMStatus()
+//! function to determine if the request completed successfully or if there
+//! was an error.
+//!
+//! \return This function returns the following values:
+//! - \b USBHCD_LPM_AVAIL - The transition to L1 state is scheduled to be sent.
+//! - \b USBHCD_LPM_PENDING - There is already an LPM request pending.
+//
+//*****************************************************************************
+uint32_t
+USBHMouseLPMSleep(tUSBHMouse *psMsInstance)
+{
+    //
+    // Call the HID function to send the sleep command.
+    //
+    return(USBHHIDLPMSleep(psMsInstance->psHIDInstance));
+}
+
+//*****************************************************************************
+//
+//! This function returns the current status of an LPM request.
+//!
+//! \param psMsInstance is the HID keyboard instance that was returned
+//! from the call to USBHMouseOpen().
+//!
+//! This function returns the current status of LPM requests for a given
+//! device.  This is called to determine if a previous request completed
+//! successfully or if there was an error.
+//!
+//! \return This function returns the following values:
+//! - \b USBHCD_LPM_AVAIL - There are no pending LPM requests on this specific
+//!   device or the last request completed successfully.
+//! - \b USBHCD_LPM_ERROR - The last LPM request for this device did not
+//!   complete successfully.
+//! - \b USBHCD_LPM_PENDING - The last LPM request has not completed.
+//
+//*****************************************************************************
+uint32_t
+USBHMouseLPMStatus(tUSBHMouse *psMsInstance)
+{
+    //
+    // Call the HID function to get the current LPM status.
+    //
+    return(USBHHIDLPMStatus(psMsInstance->psHIDInstance));
+}
+
+//*****************************************************************************
+//
+//! @}
+//
+//*****************************************************************************
diff --git a/bsp/tm4c129x/libraries/usblib/host/usbhhidmouse.h b/bsp/tm4c129x/libraries/usblib/host/usbhhidmouse.h
new file mode 100755
index 0000000..8f0faa0
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/host/usbhhidmouse.h
@@ -0,0 +1,81 @@
+//*****************************************************************************
+//
+// usbhhidmouse.h - This file holds the application interfaces for USB
+// mouse devices.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#ifndef __USBHHIDMOUSE_H__
+#define __USBHHIDMOUSE_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+//*****************************************************************************
+//
+//! \addtogroup usblib_host_device
+//! @{
+//
+//*****************************************************************************
+
+typedef struct tUSBHMouse tUSBHMouse;
+
+//*****************************************************************************
+//
+// The prototype for the host USB mouse driver callback function.
+//
+//*****************************************************************************
+typedef void (*tUSBHIDMouseCallback)(tUSBHMouse *psMsInstance,
+                                     uint32_t ui32Event,
+                                     uint32_t ui32MsgParam,
+                                     void *pvMsgData);
+
+extern tUSBHMouse * USBHMouseOpen(tUSBHIDMouseCallback pfnCallback,
+                                  uint8_t *pui8Buffer, uint32_t ui32Size);
+extern uint32_t USBHMouseClose(tUSBHMouse *psMsInstance);
+extern uint32_t USBHMouseInit(tUSBHMouse *psMsInstance);
+extern uint32_t USBHMouseLPMSleep(tUSBHMouse *psMsInstance);
+extern uint32_t USBHMouseLPMStatus(tUSBHMouse *psMsInstance);
+
+//*****************************************************************************
+//
+//! @}
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/bsp/tm4c129x/libraries/usblib/host/usbhhub.c b/bsp/tm4c129x/libraries/usblib/host/usbhhub.c
new file mode 100755
index 0000000..6a9e358
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/host/usbhhub.c
@@ -0,0 +1,1522 @@
+//*****************************************************************************
+//
+// usbhhub.c - This file contains the host HID driver.
+//
+// Copyright (c) 2011-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "inc/hw_types.h"
+#include "inc/hw_ints.h"
+#include "inc/hw_sysctl.h"
+#include "driverlib/usb.h"
+#include "driverlib/interrupt.h"
+#include "driverlib/rom_map.h"
+#include "driverlib/rtos_bindings.h"
+#include "usblib/usblib.h"
+#include "usblib/host/usbhost.h"
+#include "usblib/host/usbhostpriv.h"
+#include "usblib/host/usbhhub.h"
+#ifdef INCLUDE_DEBUG_OUTPUT
+#include "utils/uartstdio.h"
+#define DEBUG_OUTPUT UARTprintf
+#else
+#define DEBUG_OUTPUT while(0)((int (*)(char *, ...))0)
+#endif
+
+//*****************************************************************************
+//
+//! \addtogroup usblib_host_class
+//! @{
+//
+//*****************************************************************************
+
+#ifdef ewarm
+#pragma pack(1)
+#endif
+
+//*****************************************************************************
+//
+//! The USB standard hub descriptor structure.  Full documentation for the
+//! contents of this structure can be found in chapter 11.23.2.1 of the USB
+//! 2.0 specification.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The total number of bytes in the descriptor (including this field).
+    //
+    uint8_t bLength;
+
+    //
+    //! The descriptor type. For a hub descriptor, this will be USB_DTYPE_HUB
+    //! (0x29 or 41 decimal).
+    //
+    uint8_t bDescType;
+
+    //
+    //! The number of downstream-facing ports that the hub supports.
+    //
+    uint8_t bNbrPorts;
+
+    //
+    //! Characteristics of the hub device including its power switching
+    //! capabilities and over-current protection mode.
+    //
+    uint16_t wHubCharacteristics;
+
+    //
+    //! The time between the start of the power-on sequence for a port and
+    //! the power to the port becoming stable.  This is expressed in 2mS units.
+    //
+    uint8_t bPwrOn2PwrGood;
+
+    //
+    //! The maximum current requirement for the hub circuitry in mA.
+    //
+    uint8_t bHubContrCurrent;
+
+    //
+    //! The last two fields in the structure are bit masks indicating which
+    //! downstream ports support removable devices and, following this, another
+    //! obsolete field from USB1.0 related to port power control.  Each field
+    //! is byte aligned and contains a bit for each hub port.  This structure
+    //! definition is set up with enough storage to handle ROOT_HUB_MAX_PORTS
+    //! ports but beware that the actual size of each field is dependent upon
+    //! the bNbrPorts field above.
+    //
+    uint8_t PortInfo[((ROOT_HUB_MAX_PORTS + 7) / 8) * 2];
+}
+PACKED tUsbHubDescriptor;
+
+#ifdef ewarm
+#pragma pack()
+#endif
+
+//*****************************************************************************
+//
+// This structure holds all data specific to a single hub port.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    // The handle used by the HCD layer to identify this device.
+    //
+    uint32_t ui32DevHandle;
+
+    //
+    // The current state of the port.
+    //
+    volatile tHubPortState iState;
+
+    //
+    // General counter used in various states.
+    //
+    volatile uint32_t ui32Count;
+
+    //
+    // A flag used to indicate that the downstream device is a low speed
+    // device.
+    //
+    bool bLowSpeed;
+
+    //
+    // The speed of the device on this port.
+    //
+    uint32_t ui32Speed;
+
+    //
+    // This flag is set if the hub reports that a change is pending on this
+    // port.
+    //
+    volatile bool bChanged;
+}
+tHubPort;
+
+//*****************************************************************************
+//
+// USB hub flags values for tHubInstance.ui32Flags.
+//
+//*****************************************************************************
+#define USBLIB_HUB_ACTIVE       0x00000001
+#define USBLIB_HUB_HS           0x00000002
+#define USBLIB_HUB_MULTI_TT     0x00000004
+
+//*****************************************************************************
+//
+// This is the structure that holds all of the data for a given instance of
+// a Hub device.
+//
+//*****************************************************************************
+struct tHubInstance
+{
+    //
+    // Save the device instance.
+    //
+    tUSBHostDevice *psDevice;
+
+    //
+    // Used to save the callback function pointer.
+    //
+    tUSBHHubCallback pfnCallback;
+
+    //
+    // Callback data provided by caller.
+    //
+    uint32_t ui32CBData;
+
+    //
+    // Interrupt IN pipe.
+    //
+    uint32_t ui32IntInPipe;
+
+    //
+    // Hub characteristics as reported in the class-specific hub descriptor.
+    //
+    uint16_t ui16HubCharacteristics;
+
+    //
+    // The number of downstream-facing ports the hub supports.
+    //
+    uint8_t ui8NumPorts;
+
+    //
+    // The number of ports on the hub that we can actually talk to.  This will
+    // be the smaller of the number of ports on the hub and MAX_USB_DEVICES.
+    //
+    uint8_t ui8NumPortsInUse;
+
+    //
+    // The size of a status change packet sent by the hub.  This is determined
+    // from the number of ports supported by the hub.
+    //
+    uint8_t ui8ReportSize;
+
+    //
+    // Flags indicating whether the hub is connected.
+    //
+    uint32_t ui32Flags;
+
+    //
+    // Flag indicating that a device is currently in process of being
+    // enumerated.
+    //
+    volatile bool bEnumerationBusy;
+
+    //
+    // This is valid if bEnumerationBusy is set and indicates the port
+    // that is in the process of enumeration.
+    //
+    uint8_t ui8EnumIdx;
+
+    //
+    // The state of each of the ports we support on the hub.
+    //
+    tHubPort psPorts[MAX_USB_DEVICES];
+
+    //
+    // The interrupt number for this instance.
+    //
+    uint32_t ui32IntNum;
+};
+
+//*****************************************************************************
+//
+//! Forward references to the hub class driver functions.
+//
+//*****************************************************************************
+static void *HubDriverOpen(tUSBHostDevice *psDevice);
+static void HubDriverClose(void *pvHubDevice);
+
+//*****************************************************************************
+//
+//! This constant global structure defines the Hub Class Driver that is
+//! provided with the USB library.
+//
+//*****************************************************************************
+const tUSBHostClassDriver g_sUSBHubClassDriver =
+{
+    USB_CLASS_HUB,
+    HubDriverOpen,
+    HubDriverClose,
+    0
+};
+
+//*****************************************************************************
+//
+// The instance data storage for attached hub.
+//
+//*****************************************************************************
+static tHubInstance g_sRootHub;
+
+//*****************************************************************************
+//
+// Hub and port state change flags as reported via the hub's IN endpoint.
+//
+//*****************************************************************************
+static volatile uint32_t g_ui32ChangeFlags;
+
+//
+// Note: The following assumes ROOT_HUB_MAX_PORTS is less than 32!
+//
+static uint32_t g_ui32HubChanges;
+
+//*****************************************************************************
+//
+// This function is called to set the operating speed of a given port.
+//
+// \param ui8Port is the port number for this request.
+// \param ui32Speed is one of the HUB_FEATURE_PORT_* values.
+//
+// This function sets the operating speed of the hub port specified in the
+// \e ui8Port parameter.  A \e ui8Port value of 0 is an access to the hub
+// itself and not one of the hub ports.  The \e ui32Speed value is one of the
+// \b USB_EP_SPEED_ values.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+USBHubPortSpeedSet(uint8_t ui8Port, uint32_t ui32Speed)
+{
+    g_sRootHub.psPorts[ui8Port].ui32Speed = ui32Speed;
+}
+
+//*****************************************************************************
+//
+// This function is called to send a request to the hub to set a feature on
+// a given port.
+//
+// \param psHubInstance is the hub device instance.
+// \param ui8Port is the port number for this request.
+// \param ui16Feature is one of the HUB_FEATURE_PORT_* values.
+//
+// This function will send the set feature request to the hub indicated by the
+// \e psHubInstance parameter.  The \e ui8Port value indicates which port
+// number to send this request to and can range from 0 to the number of valid
+// ports on the given hub.  A \e ui8Port value of 0 is an access to the hub
+// itself and not one of the hub ports.  The \e ui16Feature is the feature
+//  request toset on the given port.  For example, a \e ui16Feature value of
+// \e HUB_FEATURE_PORT_RESET and \e ui8Port value of 1 will cause reset
+// signaling to hub port 1.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+HubSetPortFeature(tHubInstance *psHubInstance, uint8_t ui8Port,
+                  uint16_t ui16Feature)
+{
+    tUSBRequest sSetupPacket;
+    tUSBHostDevice *psDevice;
+
+    //
+    // Retrieve the hub instance and device pointer.
+    //
+    psDevice = psHubInstance->psDevice;
+
+    //
+    // This is a standard OUT request.
+    //
+    sSetupPacket.bmRequestType = USB_RTYPE_DIR_OUT | USB_RTYPE_CLASS |
+                                 USB_RTYPE_OTHER;
+
+    //
+    // Set the field to clear the requested port feature.
+    //
+    sSetupPacket.bRequest = USBREQ_SET_FEATURE;
+    sSetupPacket.wValue = ui16Feature;
+    sSetupPacket.wIndex = ui8Port;
+    sSetupPacket.wLength = 0;
+
+    //
+    // Send the request.
+    //
+    USBHCDControlTransfer(0, &sSetupPacket, psDevice, 0, 0,
+                          psDevice->sDeviceDescriptor.bMaxPacketSize0);
+}
+
+//*****************************************************************************
+//
+// This function is called to send a request to the hub to clear a feature on
+// a given port.
+//
+// \param psHubInstance is the hub device instance.
+// \param ui8Port is the port number for this request.
+// \param ui16Feature is one of the HUB_FEATURE_PORT_* values.
+//
+// This function will send the clear feature request to the hub indicated by
+// the \e psHubInstance parameter.  The \e ui8Port value indicates which port
+// number to send this request to and can range from 0 to the number of valid
+// ports on the given hub.  A \e ui8Port value of 0 is an access to the hub
+// itself and not one of the hub ports.  The \e ui16Feature is the feature
+// request to clear on the given port.  For example, a \e ui16Feature value of
+// \e HUB_FEATURE_C_PORT_RESET and \e ui8Port value of 1 will clear the reset
+// complete signaling on hub port 1.  Values like the reset feature will
+// remain set until actively cleared by this function.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+HubClearPortFeature(tHubInstance *psHubInstance, uint8_t ui8Port,
+                    uint16_t ui16Feature)
+{
+    tUSBRequest sSetupPacket;
+    tUSBHostDevice *psDevice;
+
+    //
+    // Retrieve the hub instance and device pointer.
+    //
+    psDevice = psHubInstance->psDevice;
+
+    //
+    // This is a standard OUT request.
+    //
+    sSetupPacket.bmRequestType = USB_RTYPE_DIR_OUT | USB_RTYPE_CLASS |
+                                 USB_RTYPE_OTHER;
+
+    //
+    // Set the field to clear the requested port feature.
+    //
+    sSetupPacket.bRequest = USBREQ_CLEAR_FEATURE;
+    sSetupPacket.wValue = ui16Feature;
+    sSetupPacket.wIndex = ui8Port;
+    sSetupPacket.wLength = 0;
+
+    //
+    // Send the request.
+    //
+    USBHCDControlTransfer(0, &sSetupPacket, psDevice, 0, 0,
+                          psDevice->sDeviceDescriptor.bMaxPacketSize0);
+}
+
+//*****************************************************************************
+//
+// This function is used to retrieve the current status of a port on the
+// hub.
+//
+// \param psHubInstance is the hub device instance.
+// \param ui8Port is the port number for this request.
+// \param pui16PortStatus is a pointer to the memory to store the current
+// status of the port.
+// \param pui16PortChange is a pointer to the memory to store the current
+// change status of the ports.
+//
+// This function is used to retrieve the current overall status and change
+// status for the port given in the \e ui8Port parameter.  The \e ui8Port value
+// indicates which port number to send this request to and can range from 0 to
+// the number of valid ports on the given hub.  A \e ui8Port value of 0 is an
+// access to the hub itself and not one of the hub ports.
+//
+// \return None.
+//
+//*****************************************************************************
+static bool
+HubGetPortStatus(tHubInstance *psHubInstance, uint8_t ui8Port,
+                 uint16_t *pui16PortStatus, uint16_t *pui16PortChange)
+{
+    uint32_t ui32Data, ui32Read;
+    tUSBRequest sSetupPacket;
+    tUSBHostDevice *psDevice;
+
+    //
+    // Retrieve the device pointer.
+    //
+    psDevice = psHubInstance->psDevice;
+
+    //
+    // This is a standard OUT request.
+    //
+    sSetupPacket.bmRequestType = USB_RTYPE_DIR_IN | USB_RTYPE_CLASS |
+                                 USB_RTYPE_OTHER;
+
+    //
+    // Set the fields to get the hub status.
+    //
+    sSetupPacket.bRequest = USBREQ_GET_STATUS;
+    sSetupPacket.wValue = 0;
+    sSetupPacket.wIndex = (uint16_t)ui8Port;
+    sSetupPacket.wLength = 4;
+
+    //
+    // Send the request.
+    //
+    ui32Read = USBHCDControlTransfer(0, &sSetupPacket, psDevice,
+                                (uint8_t *)&ui32Data, 4,
+                                psDevice->sDeviceDescriptor.bMaxPacketSize0);
+
+    //
+    // Check that we received the correct number of bytes.
+    //
+    if(ui32Read != 4)
+    {
+        return(false);
+    }
+    else
+    {
+        //
+        // We got 4 bytes from the device. Now translate these into the 2
+        // 16-bit values we pass back to the caller.
+        //
+        *pui16PortStatus = (uint16_t)(ui32Data & 0xFFFF);
+        *pui16PortChange = (uint16_t)(ui32Data >> 16);
+
+        DEBUG_OUTPUT("Port %d, status 0x%04x, change 0x%04x\n", ui8Port,
+                     *pui16PortStatus, *pui16PortChange);
+    }
+
+    //
+    // All is well.
+    //
+    return(true);
+}
+
+//*****************************************************************************
+//
+// This function handles callbacks for the interrupt IN endpoint for the hub
+// device.
+//
+//*****************************************************************************
+static void
+HubIntINCallback(uint32_t ui32Pipe, uint32_t ui32Event)
+{
+    switch (ui32Event)
+    {
+        //
+        // Handles a request to schedule a new request on the interrupt IN
+        // pipe.
+        //
+        case USB_EVENT_SCHEDULER:
+        {
+            //
+            // Set things up to read the next change indication from the hub.
+            //
+            USBHCDPipeSchedule(ui32Pipe, (uint8_t *)&g_ui32HubChanges,
+                               (uint32_t)g_sRootHub.ui8ReportSize);
+            break;
+        }
+
+        //
+        // Called when new data is available on the interrupt IN pipe.
+        //
+        case USB_EVENT_RX_AVAILABLE:
+        {
+            //
+            // For data transfers on INT IN endpoints, we need to acknowledge
+            // the data from this callback.
+            //
+            USBHCDPipeDataAck(ui32Pipe);
+
+            //
+            // Update our global "ports needing service" flags with the latest
+            // information we have just received.
+            //
+            g_ui32ChangeFlags |= g_ui32HubChanges;
+
+            //
+            // Send the report data to the USB host hub device class driver if
+            // we have been given a callback function.
+            //
+            if(g_sRootHub.pfnCallback)
+            {
+                g_sRootHub.pfnCallback((void *)g_sRootHub.ui32CBData,
+                                       USB_EVENT_RX_AVAILABLE,
+                                       ui32Pipe, &g_ui32HubChanges);
+            }
+
+            break;
+        }
+        case USB_EVENT_ERROR:
+        {
+            break;
+        }
+    }
+}
+
+//*****************************************************************************
+//
+// Query the class-specific hub descriptor.
+//
+//*****************************************************************************
+static bool
+GetHubDescriptor(tUsbHubDescriptor *psDesc)
+{
+    uint32_t ui32Read;
+    tUSBRequest sSetupPacket;
+    tUSBHostDevice *psDevice;
+
+    //
+    // Retrieve the device pointer.
+    //
+    psDevice = g_sRootHub.psDevice;
+
+    //
+    // This is a standard OUT request.
+    //
+    sSetupPacket.bmRequestType = USB_RTYPE_DIR_IN | USB_RTYPE_CLASS |
+                                 USB_RTYPE_DEVICE;
+
+    //
+    // Set the fields to get the hub descriptor.  Initially, we request only
+    // the first 4 bytes of the descriptor.  This will give us the size which
+    // we use to determine how many bytes to read to get the full descriptor.
+    // This is necessary since we don't know how many ports the hub can support
+    // and we only support up to MAX_USB_DEVICES.
+    //
+    sSetupPacket.bRequest = USBREQ_GET_DESCRIPTOR;
+    sSetupPacket.wValue = (USB_DTYPE_HUB << 8);
+    sSetupPacket.wIndex = 0;
+    sSetupPacket.wLength = sizeof(tUsbHubDescriptor);
+
+    //
+    // Send the request.
+    //
+    ui32Read = USBHCDControlTransfer(0, &sSetupPacket, psDevice,
+                                (void *)psDesc, sizeof(tUsbHubDescriptor),
+                                psDevice->sDeviceDescriptor.bMaxPacketSize0);
+
+     //
+     // Make sure we got at least some data.
+     //
+     if(ui32Read == 0)
+     {
+         return(false);
+     }
+
+    //
+    // All is well.
+    //
+    return(true);
+}
+
+//*****************************************************************************
+//
+// Open an instance of the hub driver.  This is called when the USB host
+// has enumerated a new hub device.
+//
+//*****************************************************************************
+static void *
+HubDriverOpen(tUSBHostDevice *psDevice)
+{
+    tEndpointDescriptor *psEndpointDescriptor;
+    tInterfaceDescriptor *psInterface;
+    tUsbHubDescriptor sHubDesc;
+    bool bRetcode;
+    uint32_t ui32Loop;
+
+    //
+    // If we are already talking to a hub, fail the call.  We only support
+    // a single hub.
+    //
+    if(g_sRootHub.ui32Flags & USBLIB_HUB_ACTIVE)
+    {
+        return(0);
+    }
+
+    //
+    // Get pointers to the device descriptors we need to look at.
+    //
+    psInterface = USBDescGetInterface(psDevice->psConfigDescriptor, 0, 0);
+    psEndpointDescriptor = USBDescGetInterfaceEndpoint(psInterface, 0,
+                                      psDevice->ui32ConfigDescriptorSize);
+
+    //
+    // If there are no endpoints, something is wrong since a hub must have
+    // a single INT endpoint for signaling.
+    //
+    if(psEndpointDescriptor == 0)
+    {
+        return 0;
+    }
+
+    //
+    // Make sure we really are talking to a hub.
+    //
+    if((psInterface->bInterfaceClass != USB_CLASS_HUB) ||
+       (psInterface->bInterfaceSubClass != 0))
+    {
+        //
+        // Something is wrong - this isn't a hub or, if it is, we don't
+        // understand the protocol it is using.
+        //
+        return(0);
+    }
+
+    //
+    // Remember that this is a high speed hub with either single or multiple
+    // transaction translators.
+    //
+    if(psInterface->bInterfaceProtocol == USB_HUB_PROTOCOL_SINGLE)
+    {
+        g_sRootHub.ui32Flags |= USBLIB_HUB_HS;
+    }
+    else if(psInterface->bInterfaceProtocol == USB_HUB_PROTOCOL_MULTI)
+    {
+        g_sRootHub.ui32Flags |= USBLIB_HUB_HS | USBLIB_HUB_MULTI_TT;
+    }
+
+    //
+    // Remember the device information for later.
+    //
+    g_sRootHub.psDevice = psDevice;
+
+    //
+    // A hub must support an interrupt endpoint so check this.
+    //
+    if((psEndpointDescriptor->bmAttributes & USB_EP_ATTR_TYPE_M) ==
+       USB_EP_ATTR_INT)
+    {
+        //
+        // The endpoint is the correct type. Is it an IN endpoint?
+        //
+        if(psEndpointDescriptor->bEndpointAddress & USB_EP_DESC_IN)
+        {
+            //
+            // Yes - all is well with the hub endpoint so allocate a pipe to
+            // handle traffic from the hub.
+            //
+            g_sRootHub.ui32IntInPipe = USBHCDPipeAlloc(0, USBHCD_PIPE_INTR_IN,
+                                                       psDevice,
+                                                       HubIntINCallback);
+            USBHCDPipeConfig(g_sRootHub.ui32IntInPipe,
+                             psEndpointDescriptor->wMaxPacketSize,
+                             psEndpointDescriptor->bInterval,
+                             psEndpointDescriptor->bEndpointAddress &
+                             USB_EP_DESC_NUM_M);
+        }
+    }
+
+    //
+    // Did we allocate the endpoint successfully?
+    //
+    if(!g_sRootHub.ui32IntInPipe)
+    {
+        //
+        // No - return an error.
+        //
+        return 0;
+    }
+
+    //
+    // Assuming we have a callback, call it to tell the owner that a hub is
+    // now connected.
+    //
+    if(g_sRootHub.pfnCallback != 0)
+    {
+        g_sRootHub.pfnCallback((void *)g_sRootHub.ui32CBData,
+                               USB_EVENT_CONNECTED, (uint32_t)&g_sRootHub, 0);
+    }
+
+    //
+    // Get the hub descriptor and store information we'll need for later.
+    //
+    bRetcode = GetHubDescriptor(&sHubDesc);
+    if(bRetcode)
+    {
+
+        //
+        // We read the descriptor successfully so extract the parts we need.
+        //
+        g_sRootHub.ui8NumPorts = sHubDesc.bNbrPorts;
+        g_sRootHub.ui16HubCharacteristics = sHubDesc.wHubCharacteristics;
+        g_sRootHub.ui8NumPortsInUse =
+            (sHubDesc.bNbrPorts > MAX_USB_DEVICES) ? MAX_USB_DEVICES :
+                                                     sHubDesc.bNbrPorts;
+
+        //
+        // The size of the status change report that the hub sends is dependent
+        // upon the number of ports that the hub supports.  Calculate this by
+        // adding 1 to the number of ports (bit 0 of the report is the hub
+        // status, higher bits are one per port) then dividing by 8 (bits per
+        // byte) and rounding up.
+        //
+        g_sRootHub.ui8ReportSize = ((sHubDesc.bNbrPorts + 1) + 7) / 8;
+
+        //
+        // Enable power to all ports on the hub.
+        //
+        for(ui32Loop = 1; ui32Loop <= sHubDesc.bNbrPorts; ui32Loop++)
+        {
+            //
+            // Turn on power to this port.
+            //
+            HubSetPortFeature(&g_sRootHub, ui32Loop,
+                              HUB_FEATURE_PORT_POWER);
+        }
+
+        //
+        // Clear out our port state structures.
+        //
+        for(ui32Loop = 0; ui32Loop < MAX_USB_DEVICES; ui32Loop++)
+        {
+            g_sRootHub.psPorts[ui32Loop].bChanged = false;
+            g_sRootHub.psPorts[ui32Loop].iState = ePortIdle;
+        }
+    }
+    else
+    {
+        //
+        // Oops - we can't read the hub descriptor!  Tidy up and return
+        // an error.
+        //
+        USBHCDPipeFree(g_sRootHub.ui32IntInPipe);
+        g_sRootHub.pfnCallback = 0;
+        g_sRootHub.ui32Flags &= ~USBLIB_HUB_ACTIVE;
+        return(0);
+    }
+
+    //
+    // If we get here, all is well so remember that the hub is connected and
+    // active.
+    //
+    g_sRootHub.ui32Flags |= USBLIB_HUB_ACTIVE;
+
+    //
+    // Return our instance data pointer to the caller to use as a handle.
+    //
+    return((void *)&g_sRootHub);
+}
+
+//*****************************************************************************
+//
+// Close an instance of the hub driver.
+//
+//*****************************************************************************
+static void
+HubDriverClose(void *pvHubDevice)
+{
+    uint32_t ui32Loop;
+
+    //
+    // No device so just exit.
+    //
+    if(g_sRootHub.psDevice == 0)
+    {
+        return;
+    }
+
+    //
+    // Disconnect any devices that are currently connected to the hub.
+    //
+    for(ui32Loop = 0; ui32Loop < MAX_USB_DEVICES; ui32Loop++)
+    {
+        //
+        // Does this port have a device connected to it that we have previously
+        // reported to the host control layer?h
+        //
+        if((g_sRootHub.psPorts[ui32Loop].iState == ePortActive) ||
+           (g_sRootHub.psPorts[ui32Loop].iState == ePortResetWait) ||
+           (g_sRootHub.psPorts[ui32Loop].iState == ePortEnumerated) ||
+           (g_sRootHub.psPorts[ui32Loop].iState == ePortError))
+        {
+            //
+            // Yes - tell the host controller to disconnect the device.
+            //
+            USBHCDHubDeviceDisconnected(0,
+                g_sRootHub.psPorts[ui32Loop].ui32DevHandle);
+
+        }
+
+        //
+        // Make sure that the state returns to idle.
+        //
+        g_sRootHub.psPorts[ui32Loop].iState = ePortIdle;
+
+    }
+
+    //
+    // Reset the device pointer.
+    //
+    g_sRootHub.psDevice = 0;
+
+    //
+    // Mark the hub as absent.
+    //
+    g_sRootHub.ui32Flags &= ~USBLIB_HUB_ACTIVE;
+
+    //
+    // Note that we are not in the middle of enumerating anything.
+    //
+    g_sRootHub.bEnumerationBusy = false;
+
+    //
+    // Free the Interrupt IN pipe.
+    //
+    if(g_sRootHub.ui32IntInPipe != 0)
+    {
+        USBHCDPipeFree(g_sRootHub.ui32IntInPipe);
+    }
+
+    //
+    // If the callback exists, call it with a DISCONNECTED event.
+    //
+    if(g_sRootHub.pfnCallback != 0)
+    {
+        g_sRootHub.pfnCallback((void *)g_sRootHub.ui32CBData,
+                               USB_EVENT_DISCONNECTED, (uint32_t)&g_sRootHub,
+                               0);
+    }
+}
+
+//*****************************************************************************
+//
+// Perform any processing required as a result of a change in the reset
+// signaling for a given port.
+//
+//*****************************************************************************
+static void
+HubDriverReset(uint8_t ui8Port, bool bResetActive)
+{
+    //
+    // Did the reset sequence end or begin?
+    //
+    if(!bResetActive)
+    {
+        //
+        // The reset ended.  Now wait for at least 10ms before signaling
+        // USB enumeration code that a new device is waiting to be enumerated.
+        //
+        g_sRootHub.psPorts[ui8Port].iState = ePortResetWait;
+
+        //
+        // Set the wait to 10ms (10 frames) from now.
+        //
+        g_sRootHub.psPorts[ui8Port].ui32Count = 10;
+    }
+    else
+    {
+        //
+        // Was this device previously active?
+        //
+        if(g_sRootHub.psPorts[ui8Port].iState == ePortActive)
+        {
+            USBHCDHubDeviceDisconnected(0,
+                g_sRootHub.psPorts[ui8Port].ui32DevHandle);
+        }
+
+        //
+        // The reset is active so mark our port as in reset.
+        //
+        g_sRootHub.psPorts[ui8Port].iState = ePortResetActive;
+    }
+}
+
+//*****************************************************************************
+//
+// Start the process of enumerating a new device by issuing a reset to the
+// appropriate downstream port.
+//
+//*****************************************************************************
+static void
+HubDriverDeviceReset(uint8_t ui8Port)
+{
+    DEBUG_OUTPUT("Starting enumeration for port %d\n", ui8Port);
+
+    //
+    // Record the fact that we are in the process of enumerating a device.
+    //
+    g_sRootHub.bEnumerationBusy = true;
+
+    //
+    // Save the port that is being enumerated.
+    //
+    g_sRootHub.ui8EnumIdx = ui8Port;
+
+    //
+    // Mark the port as being reset.
+    //
+    g_sRootHub.psPorts[ui8Port].iState = ePortResetActive;
+
+    //
+    // Initiate a reset on the relevant port to start the enumeration process.
+    //
+    HubSetPortFeature(&g_sRootHub, ui8Port, HUB_FEATURE_PORT_RESET);
+}
+
+//*****************************************************************************
+//
+// A new device has been connected to the hub.  Allocate resources to manage
+// it and pass details back to the main USB host enumeration code to have the
+// device enumerated.
+//
+//*****************************************************************************
+static void
+HubDriverDeviceConnect(uint8_t ui8Port)
+{
+    DEBUG_OUTPUT("HubDriverDeviceConnect\n");
+
+    //
+    // We've allocated a port table entry so fill it in then initiate a reset
+    // on the device.
+    //
+    g_sRootHub.psPorts[ui8Port].bChanged = false;
+
+    //
+    // Mark the port as having a device present but not enumerated.
+    //
+    DEBUG_OUTPUT("Deferring enumeration for port %d\n", ui8Port);
+    g_sRootHub.psPorts[ui8Port].iState = ePortConnected;
+
+    //
+    // Wait 100ms to reset the device.
+    //
+    g_sRootHub.psPorts[ui8Port].ui32Count = 100;
+}
+
+//*****************************************************************************
+//
+// An existing device has been removed from the hub.  Tidy up and let the main
+// USB host code know so that it can free device resources.
+//
+//*****************************************************************************
+static void
+HubDriverDeviceDisconnect(uint8_t ui8Port)
+{
+    //
+    // This is a device we are currently managing.  Have we already informed
+    // the host controller that it is present?
+    //
+    if((g_sRootHub.psPorts[ui8Port].iState == ePortActive) ||
+       (g_sRootHub.psPorts[ui8Port].iState == ePortResetWait) ||
+       (g_sRootHub.psPorts[ui8Port].iState == ePortEnumerated) ||
+       (g_sRootHub.psPorts[ui8Port].iState == ePortError))
+    {
+        //
+        // Yes - tell the host controller that the device is not longer
+        // connected.
+        //
+        USBHCDHubDeviceDisconnected(0,
+                                g_sRootHub.psPorts[ui8Port].ui32DevHandle);
+    }
+
+    //
+    // If the device was being enumerated, make sure we clear the flag
+    // indicating that an enumeration is still ongoing.
+    //
+    if((g_sRootHub.psPorts[ui8Port].iState == ePortResetActive) ||
+       (g_sRootHub.psPorts[ui8Port].iState == ePortResetWait) ||
+       (g_sRootHub.psPorts[ui8Port].iState == ePortActive))
+    {
+        g_sRootHub.bEnumerationBusy = false;
+    }
+
+    //
+    // Free up the port state structure.
+    //
+    g_sRootHub.psPorts[ui8Port].iState = ePortIdle;
+}
+
+//*****************************************************************************
+//
+// This function is called periodically by USBHCDMain().  We use it to handle
+// the hub port state machine.
+//
+//*****************************************************************************
+void
+USBHHubMain(void)
+{
+    uint16_t ui16Status, ui16Changed;
+    uint_fast8_t ui8Port;
+    bool bRetcode;
+
+    //
+    // If the hub is not present, just return.
+    //
+    if((g_sRootHub.ui32Flags & USBLIB_HUB_ACTIVE) == 0)
+    {
+        return;
+    }
+
+    //
+    // Initialize the status variables.
+    //
+    ui16Status = 0;
+    ui16Changed = 0;
+
+    //
+    // The hub is active and something changed. Check to see which port changed
+    // state and handle as necessary.
+    //
+    for(ui8Port = 0; ui8Port <= g_sRootHub.ui8NumPortsInUse; ui8Port++)
+    {
+        //
+        // Decrement any wait counter if there is one present.
+        //
+        if(g_sRootHub.psPorts[ui8Port].ui32Count != 0)
+        {
+            g_sRootHub.psPorts[ui8Port].ui32Count--;
+        }
+
+        //
+        // Is this port waiting to be enumerated and is the last device
+        // enumeration finished?
+        //
+        if((g_sRootHub.psPorts[ui8Port].iState == ePortConnected) &&
+           (!g_sRootHub.bEnumerationBusy) &&
+           (g_sRootHub.psPorts[ui8Port].ui32Count == 0))
+        {
+            //
+            // Yes - start the enumeration processing for this device.
+            //
+            HubDriverDeviceReset(ui8Port);
+        }
+
+        //
+        // If the state is ePortResetWait then the hub is waiting before
+        // accessing device as the USB 2.0 specification requires.
+        //
+        if((g_sRootHub.psPorts[ui8Port].iState == ePortResetWait) &&
+           (g_sRootHub.psPorts[ui8Port].ui32Count == 0))
+        {
+            //
+            // Start the enumeration process if the timeout has passed and
+            // the hub is waiting to start enumerating the device.
+            //
+            g_sRootHub.psPorts[ui8Port].iState = ePortActive;
+
+            //
+            // Call the main host controller layer to have it enumerate the
+            // newly connected device.
+            //
+            g_sRootHub.psPorts[ui8Port].ui32DevHandle =
+                USBHCDHubDeviceConnected(0, 1, ui8Port,
+                                        g_sRootHub.psPorts[ui8Port].ui32Speed);
+        }
+
+        //
+        // If an enumeration is in progress and the loop is not on the port
+        // being enumerated then skip the port.
+        //
+        if(g_sRootHub.bEnumerationBusy &&
+           (g_sRootHub.ui8EnumIdx != ui8Port))
+        {
+            continue;
+        }
+
+        //
+        // Did something change for this particular port?
+        //
+        if(g_ui32ChangeFlags & (1 << ui8Port))
+        {
+            //
+            // Yes - query the port status.
+            //
+            bRetcode = HubGetPortStatus(&g_sRootHub, ui8Port, &ui16Status,
+                                        &ui16Changed);
+
+            //
+            // Clear this change with the USB interrupt temporarily disabled to
+            // ensure that we do not clear a flag that the interrupt routine
+            // has just set.
+            //
+            OS_INT_DISABLE(g_sRootHub.ui32IntNum);
+            g_ui32ChangeFlags &= ~(1 << ui8Port);
+            OS_INT_ENABLE(g_sRootHub.ui32IntNum);
+
+            //
+            // If there was an error, go on and look at the next bit.
+            //
+            if(!bRetcode)
+            {
+                continue;
+            }
+
+            //
+            // Now consider what changed and handle it as necessary.
+            //
+
+            //
+            // Was a device connected to or disconnected from the port?
+            //
+            if(ui16Changed & HUB_PORT_CHANGE_DEVICE_PRESENT)
+            {
+                DEBUG_OUTPUT("Connection change on port %d\n", ui8Port);
+
+                //
+                // Clear the condition.
+                //
+                HubClearPortFeature(&g_sRootHub, ui8Port,
+                                    HUB_FEATURE_C_PORT_CONNECTION);
+
+                //
+                // Was a device connected or disconnected?
+                //
+                if(ui16Status & HUB_PORT_STATUS_DEVICE_PRESENT)
+                {
+                    DEBUG_OUTPUT("Connected\n");
+
+                    //
+                    // A device was connected.
+                    //
+                    HubDriverDeviceConnect(ui8Port);
+                }
+                else
+                {
+                    DEBUG_OUTPUT("Disconnected\n");
+
+                    //
+                    // A device was disconnected.
+                    //
+                    HubDriverDeviceDisconnect(ui8Port);
+                }
+            }
+
+            //
+            // Did a reset on the port complete?
+            //
+            if(ui16Changed & HUB_PORT_CHANGE_RESET)
+            {
+                //
+                // Clear the condition.
+                //
+                HubClearPortFeature(&g_sRootHub, ui8Port,
+                                    HUB_FEATURE_C_PORT_RESET);
+
+                //
+                // Yes - query the port status.
+                //
+                bRetcode = HubGetPortStatus(&g_sRootHub, ui8Port,
+                                            &ui16Status, &ui16Changed);
+
+                DEBUG_OUTPUT("Reset %s for port %d\n",
+                        ((ui16Status & HUB_PORT_STATUS_RESET) ? "asserted" :
+                        "deasserted"), ui8Port);
+
+                //
+                // Handle the reset case.
+                //
+                HubDriverReset(ui8Port, (ui16Status & HUB_PORT_STATUS_RESET) ?
+                               true : false);
+
+                //
+                // A device was connected.
+                //
+                if(ui16Status & HUB_PORT_STATUS_LOW_SPEED)
+                {
+                    USBHubPortSpeedSet(ui8Port, USB_EP_SPEED_LOW);
+                }
+                else if(ui16Status & HUB_PORT_STATUS_HIGH_SPEED)
+                {
+                    USBHubPortSpeedSet(ui8Port, USB_EP_SPEED_HIGH);
+                }
+                else
+                {
+                    USBHubPortSpeedSet(ui8Port, USB_EP_SPEED_FULL);
+                }
+            }
+
+            //
+            // Did an over-current reset on the port complete?
+            //
+            if(ui16Changed & HUB_PORT_CHANGE_OVER_CURRENT)
+            {
+                DEBUG_OUTPUT("Port %d over current.\n", ui8Port);
+
+                //
+                // Currently we ignore this and just clear the condition.
+                //
+                HubClearPortFeature(&g_sRootHub, ui8Port,
+                                    HUB_FEATURE_C_PORT_OVER_CURRENT);
+            }
+
+            //
+            // Has the port been enabled or disabled?
+            //
+            if(ui16Changed & HUB_PORT_CHANGE_ENABLED)
+            {
+                DEBUG_OUTPUT("Enable change for port %d.\n", ui8Port);
+
+                //
+                // Currently we ignore this and just clear the condition.
+                //
+                HubClearPortFeature(&g_sRootHub, ui8Port,
+                                    HUB_FEATURE_C_PORT_ENABLE);
+            }
+
+            //
+            // Has the port been suspended or resumed?
+            //
+            if(ui16Changed & HUB_PORT_CHANGE_SUSPENDED)
+            {
+                DEBUG_OUTPUT("Suspend change for port %d.\n", ui8Port);
+
+                //
+                // Currently we ignore this and just clear the condition.
+                //
+                HubClearPortFeature(&g_sRootHub, ui8Port,
+                                    HUB_FEATURE_C_PORT_SUSPEND);
+            }
+        }
+    }
+}
+
+//*****************************************************************************
+//
+//! Informs the hub class driver that a downstream device has been enumerated.
+//!
+//! \param ui8Hub is the address of the hub to which the downstream device
+//! is attached.
+//! \param ui8Port is the port on the hub to which the downstream device is
+//! attached.
+//!
+//! This function is called by the host controller driver to inform the hub
+//! class driver that a downstream device has been enumerated successfully.
+//! The hub driver then moves on and continues enumeration of any other newly
+//! connected devices.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBHHubEnumerationComplete(uint8_t ui8Hub, uint8_t ui8Port)
+{
+    DEBUG_OUTPUT("Enumeration complete for hub %d, port %d\n", ui8Hub, ui8Port);
+
+    //
+    // Record the fact that the device is up and running.
+    //
+    g_sRootHub.psPorts[ui8Port].iState = ePortEnumerated;
+
+    //
+    // Clear the flag we use to defer further enumerations.  This will cause
+    // the next connected device (if any) to start enumeration on the next
+    // call to USBHHubMain().
+    //
+    g_sRootHub.bEnumerationBusy = false;
+}
+
+//*****************************************************************************
+//
+//! Informs the hub class driver that a downstream device failed to enumerate.
+//!
+//! \param ui8Hub is the address of the hub to which the downstream device
+//! is attached.
+//! \param ui8Port is the port on the hub to which the downstream device is
+//! attached.
+//!
+//! This function is called by the host controller driver to inform the hub
+//! class driver that an attempt to enumerate a downstream device has failed.
+//! The hub driver then cleans up and continues enumeration of any other newly
+//! connected devices.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBHHubEnumerationError(uint8_t ui8Hub, uint8_t ui8Port)
+{
+    DEBUG_OUTPUT("Enumeration error for hub %d, port %d\n", ui8Hub, ui8Port);
+
+    //
+    // Record the fact that the device is not working correctly.
+    //
+    g_sRootHub.psPorts[ui8Port].iState = ePortError;
+
+    //
+    // Clear the flag we use to defer further enumerations.  This will cause
+    // the next connected device (if any) to start enumeration on the next
+    // call to USBHHubMain().
+    //
+    g_sRootHub.bEnumerationBusy = false;
+}
+
+//*****************************************************************************
+//
+//! This function is used to enable the host hub class driver before any
+//! devices are present.
+//!
+//! \param pfnCallback is the driver call back for host hub events.
+//!
+//! This function is called to open an instance of a host hub device and
+//! provides a valid callback function for host hub events in the
+//! \e pfnCallback parameter.  This function must be called before the USB
+//! host code can successfully enumerate a hub device or any devices attached
+//! to the hub.  The \e pui8HubPool is memory provided to the hub class to
+//! manage the devices that are connected to the hub.  The \e ui32PoolSize is
+//! the number of bytes and should be at least 32 bytes per device including
+//! the hub device itself.  A simple formula for providing memory to the hub
+//! class is \b MAX_USB_DEVICES * 32 bytes of data to allow for proper
+//! enumeration of connected devices.  The value for \b MAX_USB_DEVICES is
+//! defined in the usblib.h file and controls the number of devices
+//! supported by the USB library.  The \e ui32NumHubs parameter
+//! defaults to one and only one buffer of size tHubInstance is required to
+//! be passed in the \e psHubInstance parameter.
+//!
+//! \note Changing the value of \b MAX_USB_DEVICES requires a rebuild of the
+//! USB library to have an effect on the library.
+//!
+//! \return This function returns the driver instance to use for the other
+//! host hub functions.  If there is no instance available at the time of
+//! this call, this function returns zero.
+//
+//*****************************************************************************
+tHubInstance *
+USBHHubOpen(tUSBHHubCallback pfnCallback)
+{
+    //
+    // Only one hub is supported.
+    //
+    if(g_sRootHub.pfnCallback)
+    {
+        DEBUG_OUTPUT("USBHHubOpen failed - already connected.\n");
+        return(0);
+    }
+
+    //
+    // Save the instance data for this device.
+    //
+    g_sRootHub.pfnCallback = pfnCallback;
+
+    DEBUG_OUTPUT("USBHHubOpen completed.\n");
+
+    //
+    // Return the device instance pointer.
+    //
+    return(&g_sRootHub);
+}
+
+//*****************************************************************************
+//
+//! This function is used to release a hub device instance.
+//!
+//! \param psHubInstance is the hub device instance that is to be released.
+//!
+//! This function is called when an instance of the hub device must be
+//! released.  This function is typically made in preparation for shutdown or a
+//! switch to function as a USB device when in OTG mode.  Following this call,
+//! the hub device is no longer available, but it can be opened again using a
+//! call to USBHHubOpen().  After calling USBHHubClose(), the host hub driver
+//! no longer provides any callbacks or accepts calls to other hub driver APIs.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBHHubClose(tHubInstance *psHubInstance)
+{
+    //
+    // Forget the instance pointer and callback.
+    //
+    psHubInstance->psDevice = 0;
+    psHubInstance->pfnCallback = 0;
+
+    DEBUG_OUTPUT("USBHHubClose completed.\n");
+}
+
+//*****************************************************************************
+//
+// This function is used to initialize the Hub driver.  This is an internal
+// function that should not be called by the application.
+//
+//*****************************************************************************
+void
+USBHHubInit(void)
+{
+    //
+    // Initialize Hub state.
+    //
+    g_ui32ChangeFlags = 0;
+    g_ui32HubChanges = 0;
+
+    if(g_sRootHub.psDevice != 0)
+    {
+        //
+        // Save the USB interrupt number.
+        //
+        g_sRootHub.ui32IntNum = INT_USB0_TM4C123;
+
+        //
+        // These devices have a different USB interrupt number.
+        //
+        if(CLASS_IS_TM4C129)
+        {
+            g_sRootHub.ui32IntNum = INT_USB0_TM4C129;
+        }
+    }
+}
+
+//*****************************************************************************
+//
+//! This function forwards an LPM request for a device to enter L1 sleep state.
+//!
+//! \param psHubInstance is the hub device instance that was returned
+//! from the call to USBHHubOpen().
+//!
+//! This function forwards a request from an application to the hub device
+//! class to request that a device enter the LPM L1 sleep state.  The
+//! caller must check the return value to see if the request can be
+//! attempted at this time.  If another LPM transaction is busy on this or
+//! another device, then this function returns \b USBHCD_LPM_PENDING.  If
+//! the LPM request was scheduled to be sent the function returns
+//! \b USBHCD_LPM_AVAIL.  The caller should check the USBHCDLPMStatus()
+//! function to determine if the request completed successfully or if there
+//! was an error.
+//!
+//! \return This function returns the following values:
+//! - \b USBHCD_LPM_AVAIL - The transition to L1 state is scheduled to be sent.
+//! - \b USBHCD_LPM_PENDING - There is already an LPM request pending.
+//
+//*****************************************************************************
+uint32_t
+USBHHubLPMSleep(tHubInstance *psHubInstance)
+{
+    //
+    // Call the host controller function to send the sleep command.
+    //
+    return(USBHCDLPMSleep(psHubInstance->psDevice));
+}
+
+//*****************************************************************************
+//
+//! This function returns the current status of an LPM request.
+//!
+//! \param psHubInstance is the hub device instance that was returned
+//! from the call to USBHHubOpen().
+//!
+//! This function returns the current status of LPM requests for a given
+//! device.  This is called to determine if a previous request completed
+//! successfully or if there was an error.
+//!
+//! \return This function returns the following values:
+//! - \b USBHCD_LPM_AVAIL - There are no pending LPM requests on this specific
+//!   device or the last request completed successfully.
+//! - \b USBHCD_LPM_ERROR - The last LPM request for this device did not
+//!   complete successfully.
+//! - \b USBHCD_LPM_PENDING - The last LPM request has not completed.
+//
+//*****************************************************************************
+uint32_t
+USBHHubLPMStatus(tHubInstance *psHubInstance)
+{
+    //
+    // Call the host controller function to get the current LPM status.
+    //
+    return(USBHCDLPMStatus(psHubInstance->psDevice));
+}
+
+//*****************************************************************************
+//
+//! @}
+//
+//*****************************************************************************
diff --git a/bsp/tm4c129x/libraries/usblib/host/usbhhub.h b/bsp/tm4c129x/libraries/usblib/host/usbhhub.h
new file mode 100755
index 0000000..ad33b2e
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/host/usbhhub.h
@@ -0,0 +1,174 @@
+//*****************************************************************************
+//
+// usbhhub.h - This hold the host driver for hid class.
+//
+// Copyright (c) 2011-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#ifndef __USBHHUB_H__
+#define __USBHHUB_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+typedef struct tHubInstance tHubInstance;
+
+extern const tUSBHostClassDriver g_sUSBHubClassDriver;
+
+//*****************************************************************************
+//
+// The USB standard allows for up to 127 downstream ports on a single hub.
+// This would require rather more memory than we would like to set aside so the
+// default configuration of the hub driver supports hubs with up to 7
+// downstream-facing ports.  In practice, this should be more than enough
+// since this covers the vast majority of consumer hubs.  Note that, by
+// default, we will only support 4 devices so you can't fully populate a 7 port
+// hub and have everything work.
+//
+// Feel free to change this but bad things will happen if you increase it above
+// 31 since we assume the reports will always fit inside a 4 byte buffer.
+//
+//*****************************************************************************
+#define ROOT_HUB_MAX_PORTS 7
+
+//*****************************************************************************
+//
+// Values used as the ui16Feature parameter to USBHHubClearHubFeature().
+//
+//*****************************************************************************
+#define HUB_FEATURE_C_HUB_LOCAL_POWER                                         \
+                                0
+#define HUB_FEATURE_C_HUB_OVER_CURRENT                                        \
+                                1
+
+//*****************************************************************************
+//
+// Values used as the ui16Feature parameter to USBHHubSetPortFeature() and
+// USBHHubClearPortFeature().
+//
+//*****************************************************************************
+#define HUB_FEATURE_PORT_CONNECTION                                           \
+                                0
+#define HUB_FEATURE_PORT_ENABLE 1
+#define HUB_FEATURE_PORT_SUSPEND                                              \
+                                2
+#define HUB_FEATURE_PORT_OVER_CURRENT                                         \
+                                3
+#define HUB_FEATURE_PORT_RESET  4
+#define HUB_FEATURE_PORT_POWER  8
+#define HUB_FEATURE_PORT_LOW_SPEED                                            \
+                                9
+#define HUB_FEATURE_C_PORT_CONNECTION                                         \
+                                16
+#define HUB_FEATURE_C_PORT_ENABLE                                             \
+                                17
+#define HUB_FEATURE_C_PORT_SUSPEND                                            \
+                                18
+#define HUB_FEATURE_C_PORT_OVER_CURRENT                                       \
+                                19
+#define HUB_FEATURE_C_PORT_RESET                                              \
+                                20
+#define HUB_FEATURE_PORT_TEST   21
+#define HUB_FEATURE_PORT_INDICATOR                                            \
+                                22
+
+//*****************************************************************************
+//
+// Values returned via the *pui16HubStatus and *pui16HubChange parameters
+// passed to USBHHubGetHubStatus().  These may be ORed together into the
+// returned status value.
+//
+//*****************************************************************************
+#define HUB_STATUS_PWR_LOST     1
+#define HUB_STATUS_OVER_CURRENT 2
+
+//*****************************************************************************
+//
+// Values returned via the *pui16PortStatus parameter passed to
+// USBHHubGetPortStatus().  These may be ORed together into the returned status
+// value.
+//
+//*****************************************************************************
+#define HUB_PORT_STATUS_DEVICE_PRESENT                                        \
+                                0x0001
+#define HUB_PORT_STATUS_ENABLED 0x0002
+#define HUB_PORT_STATUS_SUSPENDED                                             \
+                                0x0004
+#define HUB_PORT_STATUS_OVER_CURRENT                                          \
+                                0x0008
+#define HUB_PORT_STATUS_RESET   0x0010
+#define HUB_PORT_STATUS_POWERED 0x0100
+#define HUB_PORT_STATUS_LOW_SPEED                                             \
+                                0x0200
+#define HUB_PORT_STATUS_HIGH_SPEED                                            \
+                                0x0400
+#define HUB_PORT_STATUS_TEST_MODE                                             \
+                                0x0800
+#define HUB_PORT_STATUS_INDICATOR_CONTROL                                     \
+                                0x1000
+
+//*****************************************************************************
+//
+// Values returned via the *pui16PortChange parameter passed to
+// USBHHubGetPortStatus().  These may be ORed together into the returned status
+// value.
+//
+//*****************************************************************************
+#define HUB_PORT_CHANGE_DEVICE_PRESENT                                        \
+                                0x0001
+#define HUB_PORT_CHANGE_ENABLED 0x0002
+#define HUB_PORT_CHANGE_SUSPENDED                                             \
+                                0x0004
+#define HUB_PORT_CHANGE_OVER_CURRENT                                          \
+                                0x0008
+#define HUB_PORT_CHANGE_RESET   0x0010
+
+//*****************************************************************************
+//
+// The prototype for the USB Hub host driver callback function.
+//
+//*****************************************************************************
+typedef void (*tUSBHHubCallback)(tHubInstance *psHubInstance,
+                                 uint32_t ui32Event, uint32_t ui32MsgParam,
+                                 void *pvMsgData);
+
+//*****************************************************************************
+//
+// Public function prototypes for the HUB class driver.
+//
+//*****************************************************************************
+extern tHubInstance * USBHHubOpen(tUSBHHubCallback pfnCallback);
+extern void USBHHubClose(tHubInstance *psHubInstance);
+extern uint32_t USBHHubLPMSleep(tHubInstance *psHubInstance);
+extern uint32_t USBHHubLPMStatus(tHubInstance *psHubInstance);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __USBHHUB_H__
diff --git a/bsp/tm4c129x/libraries/usblib/host/usbhmsc.c b/bsp/tm4c129x/libraries/usblib/host/usbhmsc.c
new file mode 100755
index 0000000..79b91ae
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/host/usbhmsc.c
@@ -0,0 +1,756 @@
+//*****************************************************************************
+//
+// usbhmsc.c - USB MSC host driver.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "inc/hw_types.h"
+#include "driverlib/usb.h"
+#include "usblib/usblib.h"
+#include "usblib/usblibpriv.h"
+#include "usblib/usbmsc.h"
+#include "usblib/host/usbhost.h"
+#include "usblib/host/usbhostpriv.h"
+#include "usblib/host/usbhmsc.h"
+#include "usblib/host/usbhscsi.h"
+
+//*****************************************************************************
+//
+//! \addtogroup usblib_host_class
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Forward declarations for the driver open and close calls.
+//
+//*****************************************************************************
+static void *USBHMSCOpen(tUSBHostDevice *psDevice);
+static void USBHMSCClose(void *pvInstance);
+
+//*****************************************************************************
+//
+// This is the structure for an instance of a USB MSC host driver.
+//
+//*****************************************************************************
+struct tUSBHMSCInstance
+{
+    //
+    // Save the device instance.
+    //
+    tUSBHostDevice *psDevice;
+
+    //
+    // Used to save the callback.
+    //
+    tUSBHMSCCallback pfnCallback;
+
+    //
+    // The Maximum LUNs
+    //
+    uint32_t ui32MaxLUN;
+
+    //
+    // The total number of blocks associated with this device.
+    //
+    uint32_t ui32NumBlocks;
+
+    //
+    // The size of the blocks associated with this device.
+    //
+    uint32_t ui32BlockSize;
+
+    //
+    // Bulk IN pipe.
+    //
+    uint32_t ui32BulkInPipe;
+
+    //
+    // Bulk OUT pipe.
+    //
+    uint32_t ui32BulkOutPipe;
+};
+
+//*****************************************************************************
+//
+// The array of USB MSC host drivers.
+//
+//*****************************************************************************
+static tUSBHMSCInstance g_sUSBHMSCDevice =
+{
+    0
+};
+
+//*****************************************************************************
+//
+//! This constant global structure defines the Mass Storage Class Driver that
+//! is provided with the USB library.
+//
+//*****************************************************************************
+const tUSBHostClassDriver g_sUSBHostMSCClassDriver =
+{
+    USB_CLASS_MASS_STORAGE,
+    USBHMSCOpen,
+    USBHMSCClose,
+    0
+};
+
+//*****************************************************************************
+//
+//! This function is used to open an instance of the MSC driver.
+//!
+//! \param psDevice is a pointer to the device information structure.
+//!
+//! This function will attempt to open an instance of the MSC driver based on
+//! the information contained in the \e psDevice structure.  This call can fail
+//! if there are not sufficient resources to open the device.  The function
+//! returns a value that should be passed back into USBMSCClose() when the
+//! driver is no longer needed.
+//!
+//! \return The function will return a pointer to a MSC driver instance.
+//
+//*****************************************************************************
+static void *
+USBHMSCOpen(tUSBHostDevice *psDevice)
+{
+    int32_t i32Idx;
+    tEndpointDescriptor *psEndpointDescriptor;
+    tInterfaceDescriptor *psInterface;
+
+    //
+    // Don't allow the device to be opened without closing first.
+    //
+    if(g_sUSBHMSCDevice.psDevice)
+    {
+        return(0);
+    }
+
+    //
+    // Save the device pointer.
+    //
+    g_sUSBHMSCDevice.psDevice = psDevice;
+
+    //
+    // Get the interface descriptor.
+    //
+    psInterface = USBDescGetInterface(psDevice->psConfigDescriptor, 0, 0);
+
+    //
+    // Loop through the endpoints of the device.
+    //
+    for(i32Idx = 0; i32Idx < 3; i32Idx++)
+    {
+        //
+        // Get the first endpoint descriptor.
+        //
+        psEndpointDescriptor =
+            USBDescGetInterfaceEndpoint(psInterface, i32Idx,
+                                        psDevice->ui32ConfigDescriptorSize);
+
+        //
+        // If no more endpoints then break out.
+        //
+        if(psEndpointDescriptor == 0)
+        {
+            break;
+        }
+
+        //
+        // See if this is a bulk endpoint.
+        //
+        if((psEndpointDescriptor->bmAttributes & USB_EP_ATTR_TYPE_M) ==
+           USB_EP_ATTR_BULK)
+        {
+            //
+            // See if this is bulk IN or bulk OUT.
+            //
+            if(psEndpointDescriptor->bEndpointAddress & USB_EP_DESC_IN)
+            {
+                //
+                // Allocate the USB Pipe for this Bulk IN endpoint.
+                //
+                g_sUSBHMSCDevice.ui32BulkInPipe =
+                    USBHCDPipeAllocSize(0, USBHCD_PIPE_BULK_IN_DMA,
+                                        psDevice,
+                                        psEndpointDescriptor->wMaxPacketSize,
+                                        0);
+                //
+                // Configure the USB pipe as a Bulk IN endpoint.
+                //
+                USBHCDPipeConfig(g_sUSBHMSCDevice.ui32BulkInPipe,
+                                 psEndpointDescriptor->wMaxPacketSize,
+                                 0,
+                                 (psEndpointDescriptor->bEndpointAddress &
+                                  USB_EP_DESC_NUM_M));
+            }
+            else
+            {
+                //
+                // Allocate the USB Pipe for this Bulk OUT endpoint.
+                //
+                g_sUSBHMSCDevice.ui32BulkOutPipe =
+                    USBHCDPipeAllocSize(0, USBHCD_PIPE_BULK_OUT_DMA,
+                                        psDevice,
+                                        psEndpointDescriptor->wMaxPacketSize,
+                                        0);
+                //
+                // Configure the USB pipe as a Bulk OUT endpoint.
+                //
+                USBHCDPipeConfig(g_sUSBHMSCDevice.ui32BulkOutPipe,
+                                 psEndpointDescriptor->wMaxPacketSize,
+                                 0,
+                                 (psEndpointDescriptor->bEndpointAddress &
+                                  USB_EP_DESC_NUM_M));
+            }
+        }
+    }
+
+    //
+    // If the callback exists, call it with an Open event.
+    //
+    if(g_sUSBHMSCDevice.pfnCallback != 0)
+    {
+        g_sUSBHMSCDevice.pfnCallback(&g_sUSBHMSCDevice, MSC_EVENT_OPEN, 0);
+    }
+
+
+    g_sUSBHMSCDevice.ui32MaxLUN = 0xffffffff;
+
+    //
+    // Return the only instance of this device.
+    //
+    return(&g_sUSBHMSCDevice);
+}
+
+//*****************************************************************************
+//
+//! This function is used to release an instance of the MSC driver.
+//!
+//! \param pvInstance is an instance pointer that needs to be released.
+//!
+//! This function will free up any resources in use by the MSC driver instance
+//! that is passed in.  The \e pvInstance pointer should be a valid value that
+//! was returned from a call to USBMSCOpen().
+//!
+//! \return None.
+//
+//*****************************************************************************
+static void
+USBHMSCClose(void *pvInstance)
+{
+    //
+    // Do nothing if there is not a driver open.
+    //
+    if(g_sUSBHMSCDevice.psDevice == 0)
+    {
+        return;
+    }
+
+    //
+    // Reset the device pointer.
+    //
+    g_sUSBHMSCDevice.psDevice = 0;
+
+    //
+    // Free the Bulk IN pipe.
+    //
+    if(g_sUSBHMSCDevice.ui32BulkInPipe != 0)
+    {
+        USBHCDPipeFree(g_sUSBHMSCDevice.ui32BulkInPipe);
+    }
+
+    //
+    // Free the Bulk OUT pipe.
+    //
+    if(g_sUSBHMSCDevice.ui32BulkOutPipe != 0)
+    {
+        USBHCDPipeFree(g_sUSBHMSCDevice.ui32BulkOutPipe);
+    }
+
+    //
+    // If the callback exists then call it.
+    //
+    if(g_sUSBHMSCDevice.pfnCallback != 0)
+    {
+        g_sUSBHMSCDevice.pfnCallback(&g_sUSBHMSCDevice, MSC_EVENT_CLOSE, 0);
+    }
+}
+
+//*****************************************************************************
+//
+//! This function retrieves the maximum number of the logical units on a
+//! mass storage device.
+//!
+//! \param psDevice is the device instance pointer for this request.
+//! \param ui32Interface is the interface number on the device specified by the
+//! \e ui32Address parameter.
+//! \param pui8MaxLUN is the byte value returned from the device for the
+//! device's maximum logical unit.
+//!
+//! The device will return one byte of data that contains the maximum LUN
+//! supported by the device.  For example, if the device supports four LUNs
+//! then the LUNs would be numbered from 0 to 3 and the return value would be
+//! 3.  If no LUN is associated with the device, the value returned shall be 0.
+//!
+//! \return None.
+//
+//*****************************************************************************
+static void
+USBHMSCGetMaxLUN(tUSBHostDevice *psDevice, uint32_t ui32Interface,
+                 uint8_t *pui8MaxLUN)
+{
+    tUSBRequest sSetupPacket;
+
+    //
+    // This is a Class specific interface IN request.
+    //
+    sSetupPacket.bmRequestType =
+        USB_RTYPE_DIR_IN | USB_RTYPE_CLASS | USB_RTYPE_INTERFACE;
+
+    //
+    // Request a the Max LUN for this interface.
+    //
+    sSetupPacket.bRequest = USBREQ_GET_MAX_LUN;
+    sSetupPacket.wValue = 0;
+
+    //
+    // Indicate the interface to use.
+    //
+    sSetupPacket.wIndex = (uint16_t)ui32Interface;
+
+    //
+    // Only request a single byte of data.
+    //
+    sSetupPacket.wLength = 1;
+
+    //
+    // Put the setup packet in the buffer and send the command.
+    //
+    if(USBHCDControlTransfer(0, &sSetupPacket, psDevice, pui8MaxLUN, 1,
+                             MAX_PACKET_SIZE_EP0) != 1)
+    {
+        *pui8MaxLUN = 0;
+    }
+}
+
+//*****************************************************************************
+//
+//! This function checks if a drive is ready to be accessed.
+//!
+//! \param psMSCInstance is the device instance to use for this read.
+//!
+//! This function checks if the current device is ready to be accessed.
+//! It uses the \e psMSCInstance parameter to determine which device to check
+//! and returns zero when the device is ready.  Any non-zero return code
+//! indicates that the device was not ready.
+//!
+//! \return This function returns zero if the device is ready and it
+//! returns a other value if the device is not ready or if an error occurred.
+//
+//*****************************************************************************
+int32_t
+USBHMSCDriveReady(tUSBHMSCInstance *psMSCInstance)
+{
+    uint8_t ui8MaxLUN, pui8Buffer[SCSI_INQUIRY_DATA_SZ];
+    uint32_t ui32Size;
+
+    //
+    // If there is no device present then return an error.
+    //
+    if(psMSCInstance->psDevice == 0)
+    {
+        return(-1);
+    }
+
+    //
+    // Only request the maximum number of LUNs once.
+    //
+    if(g_sUSBHMSCDevice.ui32MaxLUN == 0xffffffff)
+    {
+        //
+        // Get the Maximum LUNs on this device.
+        //
+        USBHMSCGetMaxLUN(g_sUSBHMSCDevice.psDevice,
+                         g_sUSBHMSCDevice.psDevice->ui32Interface, &ui8MaxLUN);
+
+        //
+        // Save the Maximum number of LUNs on this device.
+        //
+        g_sUSBHMSCDevice.ui32MaxLUN = ui8MaxLUN;
+    }
+
+    //
+    // Just return if the device is returning not present.
+    //
+    ui32Size = SCSI_REQUEST_SENSE_SZ;
+    if(USBHSCSIRequestSense(psMSCInstance->ui32BulkInPipe,
+                            psMSCInstance->ui32BulkOutPipe, pui8Buffer,
+                            &ui32Size) != SCSI_CMD_STATUS_PASS)
+    {
+        return(-1);
+    }
+
+    if((pui8Buffer[SCSI_RS_SKEY] == SCSI_RS_KEY_UNIT_ATTN) &&
+       (pui8Buffer[SCSI_RS_SKEY_AD_SKEY] == SCSI_RS_KEY_NOTPRSNT))
+    {
+        return(-1);
+    }
+
+    //
+    // Issue a SCSI Inquiry to get basic information on the device
+    //
+    ui32Size = SCSI_INQUIRY_DATA_SZ;
+    if((USBHSCSIInquiry(psMSCInstance->ui32BulkInPipe,
+                        psMSCInstance->ui32BulkOutPipe, pui8Buffer,
+                        &ui32Size) != SCSI_CMD_STATUS_PASS))
+    {
+        return(-1);
+    }
+
+    //
+    // Get the size of the drive.
+    //
+    ui32Size = SCSI_INQUIRY_DATA_SZ;
+    if(USBHSCSIReadCapacity(psMSCInstance->ui32BulkInPipe,
+                            psMSCInstance->ui32BulkOutPipe, pui8Buffer,
+                            &ui32Size) != SCSI_CMD_STATUS_PASS)
+    {
+        //
+        // Get the current sense data from the device to see why it failed
+        // the Read Capacity command.
+        //
+        ui32Size = SCSI_REQUEST_SENSE_SZ;
+        USBHSCSIRequestSense(psMSCInstance->ui32BulkInPipe,
+                             psMSCInstance->ui32BulkOutPipe, pui8Buffer,
+                             &ui32Size);
+
+        //
+        // If the read capacity failed then check if the drive is ready.
+        //
+        if(USBHSCSITestUnitReady(psMSCInstance->ui32BulkInPipe,
+                                 psMSCInstance->ui32BulkOutPipe) !=
+           SCSI_CMD_STATUS_PASS)
+        {
+            //
+            // Get the current sense data from the device to see why it failed
+            // the Test Unit Ready command.
+            //
+            ui32Size = SCSI_REQUEST_SENSE_SZ;
+            USBHSCSIRequestSense(psMSCInstance->ui32BulkInPipe,
+                                 psMSCInstance->ui32BulkOutPipe, pui8Buffer,
+                                 &ui32Size);
+        }
+
+        return(-1);
+    }
+    else
+    {
+        //
+        // Read the block size out, value is stored big endian.
+        //
+        psMSCInstance->ui32BlockSize =
+             (pui8Buffer[7] | (pui8Buffer[6] << 8) | pui8Buffer[5] << 16 |
+              (pui8Buffer[4] << 24));
+
+        //
+        // Read the block size out.
+        //
+        psMSCInstance->ui32NumBlocks =
+            (pui8Buffer[3] | (pui8Buffer[2] << 8) | pui8Buffer[1] << 16 |
+             (pui8Buffer[0] << 24));
+    }
+
+    //
+    // See if the drive is ready to use.
+    //
+    if(USBHSCSITestUnitReady(psMSCInstance->ui32BulkInPipe,
+                             psMSCInstance->ui32BulkOutPipe) !=
+       SCSI_CMD_STATUS_PASS)
+    {
+        //
+        // Get the current sense data from the device to see why it failed
+        // the Test Unit Ready command.
+        //
+        ui32Size = SCSI_REQUEST_SENSE_SZ;
+        USBHSCSIRequestSense(psMSCInstance->ui32BulkInPipe,
+                             psMSCInstance->ui32BulkOutPipe, pui8Buffer,
+                             &ui32Size);
+
+        return(-1);
+    }
+
+    //
+    // Success.
+    //
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! This function should be called before any devices are present to enable
+//! the mass storage device class driver.
+//!
+//! \param ui32Drive is the drive number to open.
+//! \param pfnCallback is the driver callback for any mass storage events.
+//!
+//! This function is called to open an instance of a mass storage device.  It
+//! should be called before any devices are connected to allow for proper
+//! notification of drive connection and disconnection.  The \e ui32Drive
+//! parameter is a zero based index of the drives present in the system.
+//! There are a constant number of drives, and this number should only
+//! be greater than 0 if there is a USB hub present in the system.  The
+//! application should also provide the \e pfnCallback to be notified of mass
+//! storage related events like device enumeration and device removal.
+//!
+//! \return This function will return the driver instance to use for the other
+//! mass storage functions.  If there is no driver available at the time of
+//! this call, this function will return zero.
+//
+//*****************************************************************************
+tUSBHMSCInstance *
+USBHMSCDriveOpen(uint32_t ui32Drive, tUSBHMSCCallback pfnCallback)
+{
+    //
+    // Only the first drive is supported and only one callback is supported.
+    //
+    if((ui32Drive != 0) || (g_sUSBHMSCDevice.pfnCallback))
+    {
+        return(0);
+    }
+
+    //
+    // Save the callback.
+    //
+    g_sUSBHMSCDevice.pfnCallback = pfnCallback;
+
+    //
+    // Return the requested device instance.
+    //
+    return(&g_sUSBHMSCDevice);
+}
+
+//*****************************************************************************
+//
+//! This function should be called to release a drive instance.
+//!
+//! \param psMSCInstance is the device instance that is to be released.
+//!
+//! This function is called when an MSC drive is to be released in preparation
+//! for shutdown or a switch to USB device mode, for example.  Following this
+//! call, the drive is available for other clients who may open it again using
+//! a call to USBHMSCDriveOpen().
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBHMSCDriveClose(tUSBHMSCInstance *psMSCInstance)
+{
+    //
+    // Close the drive (if it is already open)
+    //
+    USBHMSCClose((void *)psMSCInstance);
+
+    //
+    // Clear the callback indicating that the device is now closed.
+    //
+    psMSCInstance->pfnCallback = 0;
+}
+
+//*****************************************************************************
+//
+//! This function performs a block read to an MSC device.
+//!
+//! \param psMSCInstance is the device instance to use for this read.
+//! \param ui32LBA is the logical block address to read on the device.
+//! \param pui8Data is a pointer to the returned data buffer.
+//! \param ui32NumBlocks is the number of blocks to read from the device.
+//!
+//! This function will perform a block sized read from the device associated
+//! with the \e psMSCInstance parameter.  The \e ui32LBA parameter specifies
+//! the logical block address to read on the device.  This function will only
+//! perform \e ui32NumBlocks block sized reads.  In most cases this is a read
+//! of 512 bytes of data.  The \e *pui8Data buffer should be at least
+//! \e ui32NumBlocks * 512 bytes in size.
+//!
+//! \return The function returns zero for success and any negative value
+//! indicates a failure.
+//
+//*****************************************************************************
+int32_t
+USBHMSCBlockRead(tUSBHMSCInstance *psMSCInstance, uint32_t ui32LBA,
+                 uint8_t *pui8Data, uint32_t ui32NumBlocks)
+{
+    uint32_t ui32Size;
+
+    //
+    // If there is no device present then return an error.
+    //
+    if(psMSCInstance->psDevice == 0)
+    {
+        return(-1);
+    }
+
+    //
+    // Calculate the actual byte size of the read.
+    //
+    ui32Size = psMSCInstance->ui32BlockSize * ui32NumBlocks;
+
+    //
+    // Perform the SCSI read command.
+    //
+    if(USBHSCSIRead10(psMSCInstance->ui32BulkInPipe,
+                      psMSCInstance->ui32BulkOutPipe, ui32LBA, pui8Data,
+                      &ui32Size, ui32NumBlocks) != SCSI_CMD_STATUS_PASS)
+    {
+        return(-1);
+    }
+
+    //
+    // Success.
+    //
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! This function performs a block write to an MSC device.
+//!
+//! \param psMSCInstance is the device instance to use for this write.
+//! \param ui32LBA is the logical block address to write on the device.
+//! \param pui8Data is a pointer to the data to write out.
+//! \param ui32NumBlocks is the number of blocks to write to the device.
+//!
+//! This function will perform a block sized write to the device associated
+//! with the \e psMSCInstance parameter.  The \e ui32LBA parameter specifies
+//! the logical block address to write on the device.  This function will only
+//! perform \e ui32NumBlocks block sized writes.  In most cases this is a write
+//! of 512 bytes of data.  The \e *pui8Data buffer should contain at least
+//! \e ui32NumBlocks * 512 bytes in size to prevent unwanted data being written
+//! to the device.
+//!
+//! \return The function returns zero for success and any negative value
+//! indicates a failure.
+//
+//*****************************************************************************
+int32_t
+USBHMSCBlockWrite(tUSBHMSCInstance *psMSCInstance, uint32_t ui32LBA,
+                  uint8_t *pui8Data, uint32_t ui32NumBlocks)
+{
+    uint32_t ui32Size;
+
+    //
+    // If there is no device present then return an error.
+    //
+    if(psMSCInstance->psDevice == 0)
+    {
+        return(-1);
+    }
+
+    //
+    // Calculate the actual byte size of the write.
+    //
+    ui32Size = psMSCInstance->ui32BlockSize * ui32NumBlocks;
+
+    //
+    // Perform the SCSI write command.
+    //
+    if(USBHSCSIWrite10(psMSCInstance->ui32BulkInPipe,
+                       psMSCInstance->ui32BulkOutPipe, ui32LBA, pui8Data,
+                       &ui32Size, ui32NumBlocks) != SCSI_CMD_STATUS_PASS)
+    {
+        return(-1);
+    }
+
+    //
+    // Success.
+    //
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! This function forwards an LPM request for a device to enter L1 sleep state.
+//!
+//! \param psMSCInstance is the host mass storage class instance that was
+//! returned from the call to USBHMSCDriveOpen().
+//!
+//! This function forwards a request from an application to the mass storage
+//! device class to request that a device enter the LPM L1 sleep state.  The
+//! caller must check the return value to see if the request can be
+//! attempted at this time.  If another LPM transaction is busy on this or
+//! another device, then this function returns \b USBHCD_LPM_PENDING.  If
+//! the LPM request was scheduled to be sent the function returns
+//! \b USBHCD_LPM_AVAIL.  The caller should check the USBHCDLPMStatus()
+//! function to determine if the request completed successfully or if there
+//! was an error.
+//!
+//! \return This function returns the following values:
+//! - USBHCD_LPM_AVAIL - The transition to L1 state is scheduled to be sent.
+//! - USBHCD_LPM_PENDING - There is already an LPM request pending.
+//
+//*****************************************************************************
+uint32_t
+USBHMSCLPMSleep(tUSBHMSCInstance *psMSCInstance)
+{
+    //
+    // Call the host controller function to send the sleep command.
+    //
+    return(USBHCDLPMSleep(psMSCInstance->psDevice));
+}
+
+//*****************************************************************************
+//
+//! This function returns the current status of an LPM request.
+//!
+//! \param psMSCInstance is the host mass storage class instance that was
+//! returned from the call to USBHMSCDriveOpen().
+//!
+//! This function returns the current status of LPM requests for a given
+//! device.  This is called to determine if a previous request completed
+//! successfully or if there was an error.
+//!
+//! \return This function returns the following values:
+//! - \b USBHCD_LPM_AVAIL - There are no pending LPM requests on this specific
+//!   device or the last request completed successfully.
+//! - \b USBHCD_LPM_ERROR - The last LPM request for this device did not
+//!   complete successfully.
+//! - \b USBHCD_LPM_PENDING - The last LPM request has not completed.
+//
+//*****************************************************************************
+uint32_t
+USBHMSCLPMStatus(tUSBHMSCInstance *psMSCInstance)
+{
+    //
+    // Call the host controller function to get the current LPM status.
+    //
+    return(USBHCDLPMStatus(psMSCInstance->psDevice));
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
diff --git a/bsp/tm4c129x/libraries/usblib/host/usbhmsc.h b/bsp/tm4c129x/libraries/usblib/host/usbhmsc.h
new file mode 100755
index 0000000..b186524
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/host/usbhmsc.h
@@ -0,0 +1,99 @@
+//*****************************************************************************
+//
+// usbhmsc.h - Definitions for the USB MSC host driver.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#ifndef __USBHMSC_H__
+#define __USBHMSC_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+//*****************************************************************************
+//
+//! \addtogroup usblib_host_class
+//! @{
+//
+//*****************************************************************************
+
+typedef struct tUSBHMSCInstance tUSBHMSCInstance;
+
+//*****************************************************************************
+//
+// These defines are the the events that will be passed in the \e ui32Event
+// parameter of the callback from the driver.
+//
+//*****************************************************************************
+#define MSC_EVENT_OPEN          1
+#define MSC_EVENT_CLOSE         2
+
+//*****************************************************************************
+//
+// The prototype for the USB MSC host driver callback function.
+//
+//*****************************************************************************
+typedef void (*tUSBHMSCCallback)(tUSBHMSCInstance *psMSCInstance,
+                                 uint32_t ui32Event,
+                                 void *pvEventData);
+
+//*****************************************************************************
+//
+// Prototypes for the USB MSC host driver APIs.
+//
+//*****************************************************************************
+extern tUSBHMSCInstance * USBHMSCDriveOpen(uint32_t ui32Drive,
+                                           tUSBHMSCCallback pfnCallback);
+extern void USBHMSCDriveClose(tUSBHMSCInstance *psMSCInstance);
+extern int32_t USBHMSCDriveReady(tUSBHMSCInstance *psMSCInstance);
+extern int32_t USBHMSCBlockRead(tUSBHMSCInstance *psMSCInstance,
+                                uint32_t ui32LBA, uint8_t *pui8Data,
+                                uint32_t ui32NumBlocks);
+extern int32_t USBHMSCBlockWrite(tUSBHMSCInstance *psMSCInstance,
+                                 uint32_t ui32LBA, uint8_t *pui8Data,
+                                 uint32_t ui32NumBlocks);
+extern uint32_t USBHMSCLPMSleep(tUSBHMSCInstance *psMSCInstance);
+extern uint32_t USBHMSCLPMStatus(tUSBHMSCInstance *psMSCInstance);
+
+//*****************************************************************************
+//
+//! @}
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __USBHMSC_H__
diff --git a/bsp/tm4c129x/libraries/usblib/host/usbhost.h b/bsp/tm4c129x/libraries/usblib/host/usbhost.h
new file mode 100755
index 0000000..5b0a42b
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/host/usbhost.h
@@ -0,0 +1,295 @@
+//*****************************************************************************
+//
+// usbhost.h - Host specific definitions for the USB host library.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#ifndef __USBHOST_H__
+#define __USBHOST_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+//*****************************************************************************
+//
+//! \addtogroup usblib_hcd
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// This is the type used to identify what the pipe is currently in use for.
+//
+//*****************************************************************************
+#define USBHCD_PIPE_UNUSED          0x00100000
+#define USBHCD_PIPE_CONTROL         0x00130000
+#define USBHCD_PIPE_BULK_OUT        0x00210000
+#define USBHCD_PIPE_BULK_IN         0x00220000
+#define USBHCD_PIPE_INTR_OUT        0x00410000
+#define USBHCD_PIPE_INTR_IN         0x00420000
+#define USBHCD_PIPE_ISOC_OUT        0x00810000
+#define USBHCD_PIPE_ISOC_IN         0x00820000
+#define USBHCD_PIPE_ISOC_OUT_DMA    0x01810000
+#define USBHCD_PIPE_ISOC_IN_DMA     0x01820000
+#define USBHCD_PIPE_BULK_OUT_DMA    0x01210000
+#define USBHCD_PIPE_BULK_IN_DMA     0x01220000
+
+//*****************************************************************************
+//
+// These are the defines that are used with USBHCDPowerConfigInit().
+//
+//*****************************************************************************
+#define USBHCD_FAULT_LOW        0x00000010
+#define USBHCD_FAULT_HIGH       0x00000030
+#define USBHCD_FAULT_VBUS_NONE  0x00000000
+#define USBHCD_FAULT_VBUS_TRI   0x00000140
+#define USBHCD_FAULT_VBUS_DIS   0x00000400
+#define USBHCD_VBUS_MANUAL      0x00000004
+#define USBHCD_VBUS_AUTO_LOW    0x00000002
+#define USBHCD_VBUS_AUTO_HIGH   0x00000003
+#define USBHCD_VBUS_FILTER      0x00010000
+
+//*****************************************************************************
+//
+// These are the defines that are used with USBHCDLPMStatus().
+//
+//*****************************************************************************
+#define USBHCD_LPM_AVAIL        0x00000000
+#define USBHCD_LPM_ERROR        0x00000001
+#define USBHCD_LPM_PENDING      0x00000002
+
+//*****************************************************************************
+//
+//! This macro is used to declare an instance of an Event driver for the USB
+//! library.
+//!
+//! \param VarName is the name of the variable.
+//! \param pfnOpen is the callback for the Open call to this driver.  This
+//! value is currently reserved and should be set to 0.
+//! \param pfnClose is the callback for the Close call to this driver.  This
+//! value is currently reserved and should be set to 0.
+//! \param pfnEvent is the callback that will be called for various USB events.
+//!
+//! The first parameter is the actual name of the variable that will
+//! be declared by this macro.  The second and third parameter are reserved
+//! for future functionality and are unused and should be set to zero.  The
+//! last parameter is the actual callback function and is specified as
+//! a function pointer of the type:
+//!
+//! \verbatim
+//! void (*pfnEvent)(void *pvData);
+//! \endverbatim
+//!
+//! When the \e pfnEvent function is called the void pointer that is passed in
+//! as a parameter should be cast to a pointer to a structure of type
+//! tEventInfo.  This will contain the event that caused the pfnEvent function
+//! to be called.
+//
+//*****************************************************************************
+#define DECLARE_EVENT_DRIVER(VarName, pfnOpen, pfnClose, pfnEvent)          \
+void IntFn(void *pvData);                                                   \
+const tUSBHostClassDriver VarName =                                         \
+{                                                                           \
+    USB_CLASS_EVENTS,                                                       \
+    0,                                                                      \
+    0,                                                                      \
+    pfnEvent                                                                \
+}
+
+//*****************************************************************************
+//
+// This is the type definition a callback for events on USB Pipes allocated
+// by USBHCDPipeAlloc().
+//
+// \param ui32Pipe is well the pipe
+// \param ui32Event is well the event
+//
+// This prototype is used by any Pipe callbacks that are used in the host
+// class drivers.  These functions typically handle data events like
+// USB_EVENT_RX_AVAILABLE or USB_EVENT_TX_COMPLETE but can be sent other events
+// depending on the USB host class in use.  See the documentation for the
+// individual classes for the valid events for that class.
+//
+// \return None.
+//
+//*****************************************************************************
+typedef void (* tHCDPipeCallback)(uint32_t ui32Pipe, uint32_t ui32Event);
+
+//*****************************************************************************
+//
+// Predeclare the private tUSBHostDevice structure.
+//
+//*****************************************************************************
+typedef struct tUSBHostDevice tUSBHostDevice;
+
+//*****************************************************************************
+//
+//! This structure defines a USB host class driver interface, it is parsed to
+//! find a USB class driver once a USB device is enumerated.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The interface class that this device class driver supports.
+    //
+    uint32_t ui32InterfaceClass;
+
+    //
+    //! The function is called when this class of device has been detected.
+    //
+    void *(*pfnOpen)(tUSBHostDevice *psDevice);
+
+    //
+    //! The function is called when the device, originally opened with a call
+    //! to the pfnOpen function, is disconnected.
+    //
+    void (*pfnClose)(void *pvInstance);
+
+    //
+    //! This is the optional interrupt handler that will be called when an
+    //! endpoint associated with this device instance generates an interrupt.
+    //
+    void (*pfnIntHandler)(void *pvInstance);
+}
+tUSBHostClassDriver;
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// If the g_USBEventDriver is included in the host controller driver list then
+// this function must be provided by the application.
+//
+//*****************************************************************************
+extern void USBHCDEvents(void *pvData);
+
+//*****************************************************************************
+//
+// Prototypes for the USB Host controller APIs.
+//
+//*****************************************************************************
+extern void USBHCDMain(void);
+extern int32_t USBHCDEventEnable(uint32_t ui32Index, void *pvEventDriver,
+                                 uint32_t ui32Event);
+extern int32_t USBHCDEventDisable(uint32_t ui32Index, void *pvEventDriver,
+                                  uint32_t ui32Event);
+extern void USBHCDInit(uint32_t ui32Index, void *pvData,
+                       uint32_t ui32Size);
+extern void USBHCDPowerConfigInit(uint32_t ui32Index,
+                                  uint32_t ui32Flags);
+extern uint32_t USBHCDPowerConfigGet(uint32_t ui32Index);
+extern uint32_t USBHCDPowerConfigSet(uint32_t ui32Index,
+                                     uint32_t ui32Config);
+extern uint32_t USBHCDPowerAutomatic(uint32_t ui32Index);
+extern void USBHCDRegisterDrivers(uint32_t ui32Index,
+                            const tUSBHostClassDriver * const *ppsHClassDrvrs,
+                            uint32_t ui32NumDrivers);
+extern void USBHCDTerm(uint32_t ui32Index);
+extern void USBHCDSetConfig(uint32_t ui32Index, uint32_t ui32Device,
+                            uint32_t ui32Configuration);
+extern void USBHCDSetInterface(uint32_t ui32Index, uint32_t ui32Device,
+                               uint32_t ui32Interface,
+                               uint32_t ui32AltSetting);
+extern void USBHCDSuspend(uint32_t ui32Index);
+extern void USBHCDResume(uint32_t ui32Index);
+extern void USBHCDReset(uint32_t ui32Index);
+extern void USBHCDPipeFree(uint32_t ui32Pipe);
+extern uint32_t USBHCDPipeAlloc(uint32_t ui32Index,
+                                uint32_t ui32EndpointType,
+                                tUSBHostDevice *psDevice,
+                                tHCDPipeCallback pfnCallback);
+extern uint32_t USBHCDPipeAllocSize(uint32_t ui32Index,
+                                     uint32_t ui32EndpointType,
+                                     tUSBHostDevice *psDevice,
+                                     uint32_t ui32FIFOSize,
+                                     tHCDPipeCallback pfnCallback);
+extern uint32_t USBHCDPipeConfig(uint32_t ui32Pipe, uint32_t ui32MaxPayload,
+                                 uint32_t ui32Interval,
+                                 uint32_t ui32TargetEndpoint);
+extern uint32_t USBHCDPipeStatus(uint32_t ui32Pipe);
+extern uint32_t USBHCDPipeWrite(uint32_t ui32Pipe, uint8_t *pui8Data,
+                                uint32_t ui32Size);
+extern uint32_t USBHCDPipeRead(uint32_t ui32Pipe, uint8_t *pui8Data,
+                               uint32_t ui32Size);
+extern uint32_t USBHCDPipeSchedule(uint32_t ui32Pipe, uint8_t *pui8Data,
+                                   uint32_t ui32Size);
+extern uint32_t USBHCDPipeTransferSizeGet(uint32_t ui32Pipe);
+extern void USBHCDPipeDataAck(uint32_t ui32Pipe);
+extern uint32_t USBHCDPipeReadNonBlocking(uint32_t ui32Pipe, uint8_t *pui8Data,
+                                          uint32_t ui32Size);
+extern uint32_t USBHCDStringDescriptorGet(tUSBHostDevice *psDevice,
+                                          uint8_t *pui8Buffer,
+                                          uint32_t ui32Size,
+                                          uint32_t ui32LangID,
+                                          uint32_t ui32StringIndex);
+extern uint32_t USBHCDControlTransfer(uint32_t ui32Index,
+                                      tUSBRequest *psSetupPacket,
+                                      tUSBHostDevice *psDevice,
+                                      uint8_t *pui8Data, uint32_t ui32Size,
+                                      uint32_t ui32MaxPacketSize);
+extern void USB0HostIntHandler(void);
+
+extern uint8_t USBHCDDevHubPort(uint32_t ui32Instance);
+extern uint8_t USBHCDDevAddress(uint32_t ui32Instance);
+extern uint8_t USBHCDDevClass(uint32_t ui32Instance, uint32_t ui32Interface);
+extern uint8_t USBHCDDevSubClass(uint32_t ui32Instance,
+                                 uint32_t ui32Interface);
+extern uint8_t USBHCDDevProtocol(uint32_t ui32Instance,
+                                 uint32_t ui32Interface);
+extern bool USBHCDFeatureSet(uint32_t ui32Index, uint32_t ui32Feature,
+                             void *pvFeature);
+extern uint32_t USBHCDLPMSleep(tUSBHostDevice *psDevice);
+extern void USBHCDLPMResume(uint32_t ui32Index);
+
+//*****************************************************************************
+//
+// The host class drivers supported by the USB library.
+//
+//*****************************************************************************
+extern const tUSBHostClassDriver g_sUSBHostMSCClassDriver;
+extern const tUSBHostClassDriver g_sUSBHIDClassDriver;
+extern const tUSBHostClassDriver g_sUSBHostAudioClassDriver;
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __USBHOST_H__
diff --git a/bsp/tm4c129x/libraries/usblib/host/usbhostenum.c b/bsp/tm4c129x/libraries/usblib/host/usbhostenum.c
new file mode 100755
index 0000000..6702003
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/host/usbhostenum.c
@@ -0,0 +1,6284 @@
+//*****************************************************************************
+//
+// usbhostenum.c - Device enumeration code for the USB host library.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "inc/hw_ints.h"
+#include "inc/hw_memmap.h"
+#include "inc/hw_sysctl.h"
+#include "inc/hw_types.h"
+#include "driverlib/rom.h"
+#include "driverlib/rom_map.h"
+#include "driverlib/debug.h"
+#include "driverlib/interrupt.h"
+#include "driverlib/sysctl.h"
+#include "driverlib/usb.h"
+#include "driverlib/rtos_bindings.h"
+#include "usblib/usblib.h"
+#include "usblib/usblibpriv.h"
+#include "usblib/usbulpi.h"
+#include "usblib/host/usbhost.h"
+#include "usblib/host/usbhostpriv.h"
+#include "usblib/host/usbhhub.h"
+
+#ifdef INCLUDE_DEBUG_OUTPUT
+#include "utils/uartstdio.h"
+#define DEBUG_OUTPUT UARTprintf
+#else
+#define DEBUG_OUTPUT while(0)((int32_t (*)(char *, ...))0)
+#endif
+
+//*****************************************************************************
+//
+//! \addtogroup usblib_hcd
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// External prototypes.
+//
+//*****************************************************************************
+extern tUSBMode g_iUSBMode;
+
+extern void OTGDeviceDisconnect(uint32_t ui32Index);
+
+//*****************************************************************************
+//
+// Internal function prototypes.
+//
+//*****************************************************************************
+static void USBHCDEP0StateTx(void);
+static void USBHCDEnumHandler(void);
+static void USBHCDClearFeature(uint32_t ui32DevAddress, uint32_t ui32Endpoint,
+                               uint32_t ui32Feature);
+
+//*****************************************************************************
+//
+// Automatic power enable.
+//
+//*****************************************************************************
+#define USB_HOST_PWREN_AUTO     0x00000002
+
+//*****************************************************************************
+//
+// Flags used to signal between the interrupt handler and USBHCDMain().
+//
+//*****************************************************************************
+#define INT_EVENT_VBUS_ERR      0x01
+#define INT_EVENT_CONNECT       0x02
+#define INT_EVENT_DISCONNECT    0x04
+#define INT_EVENT_POWER_FAULT   0x08
+#define INT_EVENT_SOF           0x10
+#define INT_EVENT_ENUM          0x20
+#define INT_EVENT_LPM_PEND      0x40
+#define INT_EVENT_LPM           0x80
+
+//*****************************************************************************
+//
+// Flags used with the tUSBHostDevice.ui32Flags structure member.
+//
+//*****************************************************************************
+#define USBHDEV_FLAG_NOTIFYINT  0x00000001
+#define USBHDEV_FLAG_LPMPEND    0x00000002
+#define USBHDEV_FLAG_LPMERROR   0x00000004
+#define USBHDEV_FLAG_ALLOCATED  0x80000000
+
+//*****************************************************************************
+//
+// This holds the current power configuration that is used when USBHCDInit()
+// is called.
+//
+//*****************************************************************************
+static uint32_t g_ui32PowerConfig = USBHCD_VBUS_AUTO_HIGH;
+
+//*****************************************************************************
+//
+// The states for endpoint 0 during enumeration.
+//
+//*****************************************************************************
+typedef enum
+{
+    //
+    // The USB device is waiting on a request from the host controller on
+    // endpoint 0.
+    //
+    eEP0StateIdle,
+
+    //
+    // Setup packet is expecting data IN.
+    //
+    eEP0StateSetupIN,
+
+    //
+    // Setup packet is sending data OUT.
+    //
+    eEP0StateSetupOUT,
+
+    //
+    // The USB device is receiving data from the device due to an SETUP IN
+    // request.
+    //
+    eEP0StateRx,
+
+    //
+    // The USB device has completed the IN or OUT request and is now waiting
+    // for the host to acknowledge the end of the IN/OUT transaction.  This
+    // is the status phase for a USB control transaction.
+    //
+    eEP0StateStatus,
+
+    //
+    // This state is for when a response only has a status phase and no
+    // data phase.
+    //
+    eEP0StateStatusIN,
+
+    //
+    // This endpoint has signaled a stall condition and is waiting for the
+    // stall to be acknowledged by the host controller.
+    //
+    eEP0StateStall,
+
+    //
+    // An error has occurred on endpoint 0.
+    //
+    eEP0StateError
+}
+tEP0State;
+
+//*****************************************************************************
+//
+// This structure holds the full state for the device enumeration.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    // This is the pointer to the current data being sent out or received
+    // on endpoint 0.
+    //
+    uint8_t *pui8Data;
+
+    //
+    // This is the number of bytes that remain to be sent from or received
+    // into the g_DeviceState.pEP0Data data buffer.
+    //
+    volatile uint32_t ui32BytesRemaining;
+
+    //
+    // The amount of data being sent/received due to a request.
+    //
+    uint32_t ui32DataSize;
+
+    //
+    // This is the current device address in use by endpoint 0.
+    //
+    uint32_t ui32DevAddress;
+
+    //
+    // The maximum packet size for the device responding to the setup packet.
+    //
+    uint32_t ui32MaxPacketSize;
+
+    //
+    // The host controller's state.
+    //
+    tEP0State iState;
+}
+tHostState;
+
+//*****************************************************************************
+//
+// This variable holds the current state of endpoint 0.
+//
+//*****************************************************************************
+static volatile tHostState g_sUSBHEP0State =
+{
+    0,                          // pui8Data
+    0,                          // ui32BytesRemaining
+    0,                          // ui32DataSize
+    0,                          // ui32DevAddress
+    0,                          // ui32MaxPacketSize
+    eEP0StateIdle               // iState
+};
+
+//*****************************************************************************
+//
+// The global delay time for use by SysCtlDelay() function.  This is
+// initialized to an appropriate value for a 50MHz clock.  The correct value
+// will be set in USBHCDInit().
+//
+//*****************************************************************************
+static uint32_t g_ui32Tickms = 0;
+static volatile uint32_t g_ui32CurrentTick = 0;
+
+//*****************************************************************************
+//
+// This is 480000000/60000000 or a PLL Divide of 8.
+//
+//*****************************************************************************
+static uint32_t g_ui32PLLDiv = 8;
+
+//*****************************************************************************
+//
+// Holds the ULPI configuration.
+//
+//*****************************************************************************
+static uint32_t g_ui32ULPISupport;
+
+//*****************************************************************************
+//
+// The current active drivers.
+//
+//*****************************************************************************
+static int32_t g_pi32USBHActiveDriver[MAX_USB_DEVICES + 1];
+static void *g_ppvDriverInstance[MAX_USB_DEVICES + 1];
+
+//*****************************************************************************
+//
+// This is the structure used to hold the information for a given USB pipe
+// that is attached to a device.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    // The current address for this pipe.
+    //
+    tUSBHostDevice *psDevice;
+
+    //
+    // The current address for this pipe.
+    //
+    uint8_t ui8EPNumber;
+
+    //
+    // The DMA channel assigned to this endpoint.
+    //
+    uint8_t ui8DMAChannel;
+
+    //
+    // The current type for this pipe.
+    //
+    uint32_t ui32Type;
+
+    //
+    // The millisecond interval for this pipe.
+    //
+    uint32_t ui32Interval;
+
+    //
+    // The next tick value to trigger and event on this pipe.
+    //
+    uint32_t ui32NextEventTick;
+
+    //
+    // The current call back for this pipe.
+    //
+    tHCDPipeCallback pfnCallback;
+
+    //
+    // The pointer to which IN data must be copied.
+    //
+    uint8_t *pui8ReadPtr;
+
+    //
+    // The size of the buffer pointed to by pui8ReadPtr.
+    //
+    uint32_t ui32ReadSize;
+
+    //
+    // The number of bytes read, which can be less than ui32ReadSize.
+    //
+    uint32_t ui32DataRead;
+
+    //
+    // The state of a given USB pipe.
+    //
+    volatile enum
+    {
+        ePipeReading,
+        ePipeReadDMA,
+        ePipeReadDMAWait,
+        ePipeReadSingle,
+        ePipeDataReady,
+        ePipeDataSent,
+        ePipeWriting,
+        ePipeWriteDMA,
+        ePipeWriteDMASend,
+        ePipeWriteDMAWait,
+        ePipeWriteSingle,
+        ePipeStalled,
+        ePipeError,
+        ePipeIdle,
+        ePipeDisabled
+    }
+    iState;
+
+    //
+    // The actual FIFO offset allocated to this endpoint.
+    //
+    uint16_t ui16FIFOAddr;
+
+    //
+    // The size of the FIFO entry based on the size parameter.  These are
+    // equivalent to the USB_FIFO_SZ_* values in usb.h.
+    //
+    uint8_t ui8FIFOSize;
+
+    //
+    // The bit offset in the allocation structure.
+    //
+    uint8_t ui8FIFOBitOffset;
+}
+tUSBHCDPipe;
+
+//*****************************************************************************
+//
+// The internal state of the device.
+//
+//*****************************************************************************
+typedef enum
+{
+    eHCDDevDisconnected,
+    eHCDDevConnected,
+    eHCDDevConnectedHub,
+    eHCDDevRequest,
+    eHCDDevReset,
+    eHCDDevAddressed,
+    eHCDDevConfigured,
+    eHCDDevGetStrings,
+    eHCDDevError,
+    eHCDVBUSError,
+    eHCDPowerFault,
+    eHCDIdle
+}
+tUSBHDeviceState;
+
+static void ProcessUSBDeviceStateMachine(tUSBHDeviceState iOldState,
+                                         uint32_t ui32DevIndex);
+
+//*****************************************************************************
+//
+// This is a fixed number as it relates to the maximum number of USB pipes
+// available on any USB controller.  The actual number on a given device may
+// be less than this number.
+//
+//*****************************************************************************
+#define MAX_NUM_PIPES           15
+
+//*****************************************************************************
+//
+// This is a fixed number as it relates to the number of USB pipes available
+// in the USB controller.
+//
+//*****************************************************************************
+#define MAX_NUM_DMA_CHANNELS    6
+
+//*****************************************************************************
+//
+// Marker for an unused DMA channel slot.
+//
+//*****************************************************************************
+#define USBHCD_DMA_UNUSED       0xff
+
+//*****************************************************************************
+//
+// These definitions are used to manipulate the values returned as allocated
+// USB pipes.
+//
+//*****************************************************************************
+#define EP_PIPE_TYPE_LOW_SPEED  0x02000000
+#define EP_PIPE_USE_UDMA        0x01000000
+#define EP_PIPE_TYPE_ISOC       0x00800000
+#define EP_PIPE_TYPE_INTR       0x00400000
+#define EP_PIPE_TYPE_BULK       0x00200000
+#define EP_PIPE_TYPE_CONTROL    0x00100000
+#define EP_PIPE_TYPE_IN         0x00020000
+#define EP_PIPE_TYPE_OUT        0x00010000
+#define EP_PIPE_IDX_M           0x0000ffff
+
+//*****************************************************************************
+//
+// This creates a USB pipe handle from an index.
+//
+//*****************************************************************************
+#define OUT_PIPE_HANDLE(ui32Idx)                                              \
+                                (g_sUSBHCD.psUSBOUTPipes[ui32Idx].ui32Type |  \
+                                 ui32Idx)
+#define IN_PIPE_HANDLE(ui32Idx) (g_sUSBHCD.psUSBINPipes[ui32Idx].ui32Type |   \
+                                 ui32Idx)
+
+//*****************************************************************************
+//
+// Converts from an endpoint specifier to the offset of the endpoint's
+// control/status registers.
+//
+//*****************************************************************************
+#define EP_OFFSET(Endpoint)     (Endpoint - 0x10)
+
+//*****************************************************************************
+//
+// This structure holds the state information for a given host controller.
+//
+//*****************************************************************************
+typedef struct
+{
+    uint32_t ui32USBBase;
+
+    tUSBHCDPipe sUSBControlPipe;
+    tUSBHCDPipe psUSBOUTPipes[MAX_NUM_PIPES];
+    tUSBHCDPipe psUSBINPipes[MAX_NUM_PIPES];
+
+    //
+    // Each devices state.  We support a total of (MAX_USB_DEVICES + 1) devices
+    // to allow for the use if MAX_USB_DEVICES through a single hub (which is
+    // itself a device).
+    //
+    tUSBHostDevice psUSBDevice[MAX_USB_DEVICES + 1];
+
+    //
+    // Holds the current state of the device.
+    //
+    volatile tUSBHDeviceState piDeviceState[MAX_USB_DEVICES + 1];
+
+    //
+    // Pointer to the memory pool for this controller.
+    //
+    void *pvPool;
+
+    //
+    // The pool size for this controller.
+    //
+    uint32_t ui32PoolSize;
+
+    //
+    // The number of endpoint pairs supported by the controller.
+    //
+    uint32_t ui32NumEndpoints;
+
+    //
+    // The class drivers for this controller.
+    //
+    const tUSBHostClassDriver * const *ppsClassDrivers;
+
+    //
+    // The number of class drivers.
+    //
+    uint32_t ui32NumClassDrivers;
+
+    //
+    // This is the index in the driver list of the event driver.
+    //
+    int32_t i32EventDriver;
+
+    //
+    // These are the generic event information used by the event driver.
+    //
+    uint32_t ui32EventEnables;
+
+    uint32_t ui32Class;
+
+    //
+    // The DMA instance information for this class.
+    //
+    tUSBDMAInstance *psDMAInstance;
+
+    //
+    // The interrupt number for this instance.
+    //
+    uint32_t ui32IntNum;
+
+    //
+    // The pending interrupt events that are processed in USBHCDMain().
+    //
+    uint32_t ui32IntEvents;
+
+    //
+    // Features.
+    //
+    uint32_t ui32Features;
+
+    //
+    // The host initiated resume duration in us.
+    //
+    uint32_t ui32LPMHIRD;
+}
+tUSBHCD;
+
+//*****************************************************************************
+//
+// The global to hold all of the state information for a given host controller.
+//
+//*****************************************************************************
+static tUSBHCD g_sUSBHCD;
+
+//*****************************************************************************
+//
+// Allocates the memory needed to support configuration descriptors for
+// devices.
+//
+//*****************************************************************************
+uint32_t
+ConfigDescAlloc(tUSBHostDevice *psDevice, uint32_t ui32Size)
+{
+    uint32_t ui32Idx, ui32BlockSize, ui32PoolSize;
+    uint8_t *pui8Pool;
+
+    if(g_sUSBHCD.psUSBDevice[0].psConfigDescriptor == 0)
+    {
+        //
+        // 32 bit align the allocation.
+        //
+        ui32Size = (ui32Size + 3) & ~3;
+
+        if(g_sUSBHCD.ui32PoolSize < ui32Size)
+        {
+            return(0);
+        }
+
+        //
+        // Allocate the root connection to the device.
+        //
+        g_sUSBHCD.psUSBDevice[0].psConfigDescriptor = g_sUSBHCD.pvPool;
+        g_sUSBHCD.psUSBDevice[0].ui32ConfigDescriptorSize = ui32Size;
+
+        //
+        // Allocate the hub memory pools (these can end up null).
+        //
+        pui8Pool = (uint8_t *)g_sUSBHCD.pvPool + ui32Size;
+        ui32PoolSize = g_sUSBHCD.ui32PoolSize - ui32Size;
+
+        //
+        // Divide the pool up into blocks, one for each supported port.  We make
+        // sure that each block is a multiple of 4 bytes.
+        //
+        ui32BlockSize = (ui32PoolSize / MAX_USB_DEVICES) & ~3;
+        for(ui32Idx = 1; ui32Idx < MAX_USB_DEVICES; ui32Idx++)
+        {
+            g_sUSBHCD.psUSBDevice[ui32Idx].psConfigDescriptor =
+                        (tConfigDescriptor *)(pui8Pool +
+                                              (ui32Idx * ui32BlockSize));
+            g_sUSBHCD.psUSBDevice[ui32Idx].ui32ConfigDescriptorSize =
+                            ui32BlockSize;
+        }
+    }
+    return(ui32Size);
+}
+
+//*****************************************************************************
+//
+// Frees the memory needed to support configuration descriptors for
+// devices.
+//
+//*****************************************************************************
+void
+ConfigDescFree(tUSBHostDevice *psDevice)
+{
+    uint32_t ui32Idx;
+
+    //
+    // If this is the root device then deallocate.
+    //
+    if(&g_sUSBHCD.psUSBDevice[0] == psDevice)
+    {
+        for(ui32Idx = 0; ui32Idx < MAX_USB_DEVICES; ui32Idx++)
+        {
+            g_sUSBHCD.psUSBDevice[ui32Idx].ui32Flags &=
+                                                    ~USBHDEV_FLAG_ALLOCATED;
+            g_sUSBHCD.psUSBDevice[ui32Idx].psConfigDescriptor = 0;
+            g_sUSBHCD.psUSBDevice[ui32Idx].ui32ConfigDescriptorSize = 0;
+        }
+    }
+}
+
+//*****************************************************************************
+//
+// Return the device index from a ui32Instance value passed from an external
+// source.
+//
+//*****************************************************************************
+static uint8_t
+HCDInstanceToDevIndex(uint32_t ui32Instance)
+{
+    uint32_t ui32DevIndex;
+
+    //
+    // Get the device instance from the instance value.
+    //
+    ui32DevIndex = (ui32Instance & 0xff);
+
+    //
+    // If the above math went negative or is too large just return 0xff.
+    //
+    if(ui32DevIndex > MAX_USB_DEVICES)
+    {
+        ui32DevIndex = 0xff;
+    }
+
+    return(ui32DevIndex);
+}
+
+//=============================================================================
+//
+// This is the internal function that will map an event to a valid event flag.
+//
+// \param ui32Event specifies which event flag to retrieve.
+//
+// \return The event flag or 0 if there is no support event flag for the
+// event specified by the \e ui32Event parameter.
+//
+//=============================================================================
+static uint32_t
+GetEventFlag(uint32_t ui32Event)
+{
+    uint32_t ui32EventFlag;
+
+    ui32EventFlag = 0;
+
+    //
+    // Search for a valid event flag for the requested event.
+    //
+    switch(ui32Event)
+    {
+        case USB_EVENT_SOF:
+        {
+            ui32EventFlag |= USBHCD_EVFLAG_SOF;
+            break;
+        }
+        case USB_EVENT_CONNECTED:
+        {
+            ui32EventFlag |= USBHCD_EVFLAG_CONNECT;
+            break;
+        }
+        case USB_EVENT_DISCONNECTED:
+        {
+            ui32EventFlag |= USBHCD_EVFLAG_DISCNCT;
+            break;
+        }
+        case USB_EVENT_UNKNOWN_CONNECTED:
+        {
+            ui32EventFlag |= USBHCD_EVFLAG_UNKCNCT;
+            break;
+        }
+        case USB_EVENT_POWER_FAULT:
+        {
+            ui32EventFlag |= USBHCD_EVFLAG_PWRFAULT;
+            break;
+        }
+        case USB_EVENT_POWER_DISABLE:
+        {
+            ui32EventFlag |= USBHCD_EVFLAG_PWRDIS;
+            break;
+        }
+        case USB_EVENT_POWER_ENABLE:
+        {
+            ui32EventFlag |= USBHCD_EVFLAG_PWREN;
+            break;
+        }
+        default:
+        {
+            break;
+        }
+    }
+    return(ui32EventFlag);
+}
+
+//=============================================================================
+//
+//! This function is called to enable a specific USB HCD event notification.
+//!
+//! \param ui32Index specifies which USB controller to use.
+//! \param pvEventDriver is the event driver structure that was passed into
+//! the USBHCDRegisterDrivers() function as part of the array of
+//! tUSBHostClassDriver structures.
+//! \param ui32Event is the event to enable.
+//!
+//! This function is called to enable event callbacks for a specific USB HCD
+//! event.  The requested event is passed in the \e ui32Event parameter.  Not
+//! all events can be enables so the function will return zero if the event
+//! provided cannot be enabled.  The \e pvEventDriver is a pointer to the
+//! event driver structure that the caller passed into the
+//! USBHCDRegisterDrivers() function.  This structure is typically declared
+//! with the DECLARE_EVENT_DRIVER() macro and included as part of the array
+//! of pointers to tUSBHostClassDriver structures that is passed to the
+//! USBHCDRegisterDrivers() function.
+//!
+//! \return This function returns a non-zero number if the event was
+//! successfully enabled and returns zero if the event cannot be enabled.
+//
+//=============================================================================
+int32_t
+USBHCDEventEnable(uint32_t ui32Index, void *pvEventDriver, uint32_t ui32Event)
+{
+    int32_t i32Ret;
+    uint32_t ui32EventFlag;
+
+    ASSERT(ui32Index == 0);
+
+    //
+    // Default the return to fail the call unless a valid event is found.
+    //
+    i32Ret = 0;
+
+    //
+    // Get the event flag for this event.
+    //
+    ui32EventFlag = GetEventFlag(ui32Event);
+
+    //
+    // Check if there was an event flag for the corresponding event.
+    //
+    if(ui32EventFlag)
+    {
+        //
+        // Set the enable for this event.
+        //
+        g_sUSBHCD.ui32EventEnables |= ui32EventFlag;
+
+        //
+        // Indicate that the event was valid and is now enabled.
+        //
+        i32Ret = 1;
+    }
+
+    return(i32Ret);
+}
+
+//=============================================================================
+//
+//! This function is called to disable a specific USB HCD event notification.
+//!
+//! \param ui32Index specifies which USB controller to use.
+//! \param pvEventDriver is the event driver structure that was passed into
+//! the USBHCDRegisterDrivers() function as part of the array of
+//! tUSBHostClassDriver structures.
+//! \param ui32Event is the event to disable.
+//!
+//! This function is called to disable event callbacks for a specific USB HCD
+//! event.  The requested event is passed in the \e ui32Event parameter.  Not
+//! all events can be enables so the function will return zero if the event
+//! provided cannot be enabled.  The \e pvEventDriver is a pointer to the
+//! event driver structure that the caller passed into the
+//! USBHCDRegisterDrivers() function.  This structure is typically declared
+//! with the DECLARE_EVENT_DRIVER() macro and included as part of the array
+//! of pointers to tUSBHostClassDriver structures that is passed to the
+//! USBHCDRegisterDrivers() function.
+//!
+//! \return This function returns a non-zero number if the event was
+//! successfully disabled and returns zero if the event cannot be disabled.
+//
+//=============================================================================
+int32_t
+USBHCDEventDisable(uint32_t ui32Index, void *pvEventDriver, uint32_t ui32Event)
+{
+    int32_t i32Ret;
+    uint32_t ui32EventFlag;
+
+    ASSERT(ui32Index == 0);
+
+    //
+    // Default the return to fail the call unless a valid event is found.
+    //
+    i32Ret = 0;
+
+    //
+    // Get the event flag for this event.
+    //
+    ui32EventFlag = GetEventFlag(ui32Event);
+
+    //
+    // Check if there was an event flag for the corresponding event.
+    //
+    if(ui32EventFlag)
+    {
+        //
+        // Clear the enable for this event.
+        //
+        g_sUSBHCD.ui32EventEnables &= ~ui32EventFlag;
+
+        //
+        // Indicate that the event was valid and is now disabled.
+        //
+        i32Ret = 1;
+    }
+
+    return(i32Ret);
+}
+
+//*****************************************************************************
+//
+// If there is an event driver this function will send out a generic connection
+// event USB_EVENT_UNKNOWN_CONNECTED indicating that an unknown connection
+// event has occurred.
+//
+//*****************************************************************************
+static void
+SendUnknownConnect(uint32_t ui32Index, uint32_t ui32Class)
+{
+    tEventInfo sEvent;
+
+    //
+    // If there is an event driver registered and it has a event handler and
+    // the USBHCD_EVFLAG_UNKCNCT is enabled then call the function.
+    //
+    sEvent.ui32Event = USB_EVENT_UNKNOWN_CONNECTED;
+    sEvent.ui32Instance = ui32Class;
+    InternalUSBHCDSendEvent(0, &sEvent, USBHCD_EVFLAG_UNKCNCT);
+}
+
+//*****************************************************************************
+//
+// Internal memory allocation space is two 32-bit values where each
+// bit represents a 64 byte block in the FIFO.  This requires 64 bits for
+// the 4096 bytes of FIFO available.
+//
+//*****************************************************************************
+static uint32_t g_pui32Alloc[2];
+
+//*****************************************************************************
+//
+// This function handles freeing FIFO memory that has been allocated using the
+// FIFOAlloc() function.
+//
+//*****************************************************************************
+static void
+FIFOFree(tUSBHCDPipe *psUSBPipe)
+{
+    uint32_t ui32Mask;
+
+    //
+    // Calculate the mask value to use to clear off the allocated blocks used
+    // by the USB pipe specified by psUSBPipe.
+    //
+    ui32Mask = (1 << (psUSBPipe->ui8FIFOSize - 2)) - 1;
+    ui32Mask = ui32Mask << psUSBPipe->ui8FIFOBitOffset;
+
+    //
+    // Determine which 32 bit word to access based on the size.
+    //
+    if(psUSBPipe->ui8FIFOSize > USB_FIFO_SZ_64)
+    {
+        //
+        // If the FIFO size is greater than 64 then use the upper 32 bits.
+        //
+        g_pui32Alloc[1] &= ~ui32Mask;
+    }
+    else
+    {
+        //
+        // If the FIFO size is less than or equal to 64 then use the lower
+        // 32 bits.
+        //
+        g_pui32Alloc[0] &= ~ui32Mask;
+    }
+}
+
+//*****************************************************************************
+//
+// This function is used to allocate FIFO memory to a given USB pipe.
+//
+// \param psUSBPipe is the USB pipe that needs FIFO memory allocated.
+// \param ui32Size is the minimum size in bytes of the FIFO to allocate.
+//
+// This function will allocate \e ui32Size bytes to the USB pipe in the
+// \e psUSBPipe parameter.  The function will fill the psUSBPipe structure
+// members ui8FIFOSize and ui8FIFOAddr with values that can be used with the
+// USBFIFOConfigSet() API.  This allocation uses a first fit algorithm.
+//
+// \return This function returns the size of the block allocated.
+//
+//*****************************************************************************
+static uint32_t
+FIFOAlloc(tUSBHCDPipe *psUSBPipe, uint32_t ui32Size)
+{
+    uint32_t ui32Blocks, ui32Start, ui32BlockSize, ui32Temp, ui32Index;
+    uint16_t ui16FIFOAddr;
+
+    //
+    // Save which 32 bit value to access, the upper is for blocks greater
+    // than 64 and the lower is for block 64 or less.
+    //
+    if(ui32Size > 64)
+    {
+        ui32Index = 1;
+    }
+    else
+    {
+        ui32Index = 0;
+    }
+
+    //
+    // Initial FIFO address is 0.
+    //
+    ui16FIFOAddr = 0;
+
+    //
+    // Initialize the bit pattern and bit location.
+    //
+    ui32Blocks = 1;
+    ui32Start = 0;
+
+    //
+    // The initial block size is always the minimum size of 64 bytes.
+    //
+    ui32BlockSize = 64;
+
+    //
+    // The initial size and offset are 64 and 0.
+    //
+    psUSBPipe->ui8FIFOBitOffset = 0;
+    psUSBPipe->ui8FIFOSize = 3;
+
+    //
+    // Scan through 32 bits looking for a memory block large enough to fill
+    // the request.
+    //
+    while(ui16FIFOAddr <= 32)
+    {
+        //
+        // If the pattern is zero then it is a possible match.
+        //
+        if((g_pui32Alloc[ui32Index] & ui32Blocks) == 0)
+        {
+            //
+            // If the size is large enough then save it and break out of the
+            // loop.
+            //
+            if(ui32BlockSize >= ui32Size)
+            {
+                //
+                // Mark the memory as allocated.
+                //
+                g_pui32Alloc[ui32Index] |= ui32Blocks;
+
+                break;
+            }
+
+            //
+            // Increment the size of the FIFO block.
+            //
+            psUSBPipe->ui8FIFOSize++;
+
+            //
+            // Add in a new bit to the size of the allocation.
+            //
+            ui32Blocks = ui32Blocks | (ui32Blocks << 1) ;
+
+            //
+            // Double the current size.
+            //
+            ui32BlockSize <<= 1;
+
+        }
+        else
+        {
+            //
+            // Need to start over looking because the last allocation match
+            // failed, so reset the bit offset to the current location and the
+            // size to 64 bytes.
+            //
+            psUSBPipe->ui8FIFOBitOffset = ui16FIFOAddr;
+            psUSBPipe->ui8FIFOSize = 3;
+
+            //
+            // Reset the block size to the minimum (64 bytes).
+            //
+            ui32BlockSize = 64;
+
+            //
+            // Store the current starting bit location and set the block mask
+            // to this value.
+            //
+            ui32Start = 1 << ui16FIFOAddr;
+            ui32Blocks = ui32Start;
+        }
+
+        //
+        // Increase the address of the FIFO offset.
+        //
+        ui16FIFOAddr++;
+    }
+
+    //
+    // If there was no block large enough then fail this call.
+    //
+    if(ui16FIFOAddr > 32)
+    {
+        ui32BlockSize = 0;
+        psUSBPipe->ui16FIFOAddr = 0;
+        psUSBPipe->ui8FIFOBitOffset = 0;
+        psUSBPipe->ui8FIFOSize = 0;
+    }
+    else
+    {
+        //
+        // Calculate the offset in the FIFO.
+        //
+        ui32Temp = psUSBPipe->ui8FIFOBitOffset * 64;
+
+        //
+        // Sizes greater than 64 are allocated in the second half of the FIFO
+        // memory space.
+        //
+        if(ui32Size > 64)
+        {
+            ui32Temp += 2048;
+        }
+
+        //
+        // Convert this to the value that can be set in the USB controller.
+        //
+        psUSBPipe->ui16FIFOAddr = (uint16_t)ui32Temp;
+    }
+    return(ui32BlockSize);
+}
+
+//*****************************************************************************
+//
+//! This function returns the current byte count of a USB HCD pipe.
+//!
+//! \param ui32Pipe is the allocated endpoint to modify.
+//!
+//! This call returns the current or last byte count for a transfer using the
+//! pipe specified by the \e ui32Pipe parameter.  This is typically used to
+//! determine the actual byte count received when a \b USB_EVENT_RX_AVAILABLE
+//! occurs.
+//!
+//! \return If the call was successful, this function returns the number of
+//! bytes transfered by the USB pipe.
+//
+//*****************************************************************************
+uint32_t
+USBHCDPipeTransferSizeGet(uint32_t ui32Pipe)
+{
+    uint32_t ui32Index;
+
+    //
+    // Get the index number from the allocated pipe.
+    //
+    ui32Index = (ui32Pipe & EP_PIPE_IDX_M);
+
+    return(g_sUSBHCD.psUSBINPipes[ui32Index].ui32DataRead);
+}
+
+//*****************************************************************************
+//
+//! This function is used to allocate a USB HCD pipe.
+//!
+//! \param ui32Index specifies which USB controller to use.
+//! \param ui32EndpointType is the type of endpoint that this pipe will be
+//! communicating with.
+//! \param psDevice is the device instance associated with this endpoint.
+//! \param ui32Size is the size of the FIFO in bytes.
+//! \param pfnCallback is the function that will be called when events occur on
+//! this USB Pipe.
+//!
+//! Since there are a limited number of USB HCD pipes that can be used in the
+//! host controller, this function is used to temporarily or permanently
+//! acquire one of the endpoints.  Unlike the USBHCDPipeAlloc() function this
+//! function allows the caller to specify the size of the FIFO allocated to
+//! this endpoint in the \e ui32Size parameter.  This function also provides a
+//! method to register a callback for status changes on this endpoint.  If no
+//! callbacks are desired then the \e pfnCallback function should be set to 0.
+//! The callback should be used when using the USBHCDPipeSchedule() function
+//! so that the caller is notified when the action is complete.
+//!
+//! \return This function returns a value indicating which pipe was reserved.
+//! If the value is 0 then there were no pipes currently available.  This value
+//! should be passed to any USBHCDPipe APIs to indicate which pipe is being
+//! accessed.
+//
+//*****************************************************************************
+uint32_t
+USBHCDPipeAllocSize(uint32_t ui32Index, uint32_t ui32EndpointType,
+                    tUSBHostDevice *psDevice, uint32_t ui32Size,
+                    tHCDPipeCallback pfnCallback)
+{
+    int32_t i32Idx;
+
+    uint32_t ui32HubAddr;
+
+    ASSERT(ui32Index == 0);
+
+    //
+    // Find a USB pipe that is free.
+    //
+    for(i32Idx = 0; i32Idx < MAX_NUM_PIPES; i32Idx++)
+    {
+        //
+        // Handle OUT Pipes.
+        //
+        if(ui32EndpointType & EP_PIPE_TYPE_OUT)
+        {
+            //
+            // A zero address indicates free.
+            //
+            if(g_sUSBHCD.psUSBOUTPipes[i32Idx].psDevice == 0)
+            {
+                //
+                // Set up uDMA for the pipe.
+                //
+                if(ui32EndpointType & EP_PIPE_USE_UDMA)
+                {
+                    //
+                    // Allocate a DMA channel to the endpoint.
+                    //
+                    g_sUSBHCD.psUSBOUTPipes[i32Idx].ui8DMAChannel =
+                        USBLibDMAChannelAllocate(g_sUSBHCD.psDMAInstance,
+                                                 IndexToUSBEP(i32Idx + 1),
+                                                 ui32Size,
+                                                 USB_DMA_EP_TX |
+                                                 USB_DMA_EP_HOST);
+
+                    //
+                    // If no DMA channel was available then just disable DMA
+                    // on this pipe.
+                    //
+                    if(g_sUSBHCD.psUSBOUTPipes[i32Idx].ui8DMAChannel == 0)
+                    {
+                        ui32EndpointType &= ~EP_PIPE_USE_UDMA;
+                    }
+                }
+
+                //
+                // Save the endpoint type and device address and callback
+                // function.
+                //
+                g_sUSBHCD.psUSBOUTPipes[i32Idx].ui32Type = ui32EndpointType;
+                g_sUSBHCD.psUSBOUTPipes[i32Idx].psDevice = psDevice;
+                g_sUSBHCD.psUSBOUTPipes[i32Idx].pfnCallback = pfnCallback;
+
+                //
+                // Clear out any pending status on this endpoint in case it
+                // was in use before a allowing a new device class to use it.
+                //
+                MAP_USBHostEndpointStatusClear(USB0_BASE,
+                                               IndexToUSBEP(i32Idx + 1),
+                                               USB_HOST_OUT_STATUS);
+
+                //
+                // Make sure to reset the data toggle.
+                //
+                USBEndpointDataToggleClear(USB0_BASE, IndexToUSBEP(i32Idx + 1),
+                                           USB_EP_HOST_OUT);
+
+                //
+                // Initialize the endpoint as idle.
+                //
+                g_sUSBHCD.psUSBOUTPipes[i32Idx].iState = ePipeIdle;
+
+                //
+                // Allocate space in the FIFO for this endpoint.
+                //
+                if(FIFOAlloc(&g_sUSBHCD.psUSBOUTPipes[i32Idx], ui32Size) != 0)
+                {
+                    //
+                    // Configure the FIFO.
+                    //
+                    MAP_USBFIFOConfigSet(USB0_BASE,
+                                IndexToUSBEP(i32Idx + 1),
+                                g_sUSBHCD.psUSBOUTPipes[i32Idx].ui16FIFOAddr,
+                                g_sUSBHCD.psUSBOUTPipes[i32Idx].ui8FIFOSize,
+                                USB_EP_HOST_OUT);
+                }
+
+                //
+                // Set the function address for this endpoint.
+                //
+                MAP_USBHostAddrSet(USB0_BASE, IndexToUSBEP(i32Idx + 1),
+                                   psDevice->ui32Address, USB_EP_HOST_OUT);
+
+                //
+                // Set the hub and port address for the endpoint.
+                //
+                ui32HubAddr = psDevice->ui8Hub | (psDevice->ui8HubPort << 8);
+                USBHostHubAddrSet(USB0_BASE, IndexToUSBEP(i32Idx + 1),
+                                  ui32HubAddr, (USB_EP_HOST_OUT |
+                                                psDevice->ui32Speed));
+                break;
+            }
+        }
+        //
+        // Handle IN Pipes.
+        //
+        else if(ui32EndpointType & EP_PIPE_TYPE_IN)
+        {
+            //
+            // A zero address indicates free.
+            //
+            if(g_sUSBHCD.psUSBINPipes[i32Idx].psDevice == 0)
+            {
+                //
+                // Set up uDMA for the pipe.
+                //
+                if(ui32EndpointType & EP_PIPE_USE_UDMA)
+                {
+                    //
+                    // Allocate a DMA channel to the endpoint.
+                    //
+                    g_sUSBHCD.psUSBINPipes[i32Idx].ui8DMAChannel =
+                            USBLibDMAChannelAllocate(g_sUSBHCD.psDMAInstance,
+                                                     IndexToUSBEP(i32Idx + 1),
+                                                     ui32Size,
+                                                     USB_DMA_EP_RX |
+                                                     USB_DMA_EP_HOST);
+
+                    //
+                    // If no DMA channel was available then just disable DMA
+                    // on this pipe.
+                    //
+                    if(g_sUSBHCD.psUSBINPipes[i32Idx].ui8DMAChannel == 0)
+                    {
+                        ui32EndpointType &= ~EP_PIPE_USE_UDMA;
+                    }
+                }
+
+                //
+                // Save the endpoint type and device address and callback
+                // function.
+                //
+                g_sUSBHCD.psUSBINPipes[i32Idx].ui32Type = ui32EndpointType;
+                g_sUSBHCD.psUSBINPipes[i32Idx].psDevice = psDevice;
+                g_sUSBHCD.psUSBINPipes[i32Idx].pfnCallback = pfnCallback;
+
+                //
+                // Clear out any pending status on this endpoint in case it
+                // was in use before a allowing a new device class to use it.
+                //
+                MAP_USBHostEndpointStatusClear(USB0_BASE,
+                                               IndexToUSBEP(i32Idx + 1),
+                                               USB_HOST_IN_STATUS);
+
+                //
+                // Make sure to reset the data toggle.
+                //
+                USBEndpointDataToggleClear(USB0_BASE, IndexToUSBEP(i32Idx + 1),
+                                           USB_EP_HOST_IN);
+
+                //
+                // Allocate space in the FIFO for this endpoint.
+                //
+                if(FIFOAlloc(&g_sUSBHCD.psUSBINPipes[i32Idx], ui32Size) != 0)
+                {
+                    //
+                    // Configure the FIFO.
+                    //
+                    MAP_USBFIFOConfigSet(USB0_BASE,
+                                IndexToUSBEP(i32Idx + 1),
+                                g_sUSBHCD.psUSBINPipes[i32Idx].ui16FIFOAddr,
+                                g_sUSBHCD.psUSBINPipes[i32Idx].ui8FIFOSize,
+                                USB_EP_HOST_IN);
+                }
+
+                //
+                // Set the function address for this endpoint.
+                //
+                MAP_USBHostAddrSet(USB0_BASE, IndexToUSBEP(i32Idx + 1),
+                                   psDevice->ui32Address, USB_EP_HOST_IN);
+
+                //
+                // Set the hub and port address for the endpoint.
+                //
+                ui32HubAddr = psDevice->ui8Hub | (psDevice->ui8HubPort << 8);
+                USBHostHubAddrSet(USB0_BASE, IndexToUSBEP(i32Idx + 1),
+                                  ui32HubAddr, (USB_EP_HOST_IN |
+                                                psDevice->ui32Speed));
+
+                //
+                // Reset the state of the pipe to idle.
+                //
+                g_sUSBHCD.psUSBINPipes[i32Idx].iState = ePipeIdle;
+
+                break;
+            }
+        }
+    }
+
+    //
+    // Did not find a free pipe.
+    //
+    if(i32Idx == MAX_NUM_PIPES)
+    {
+        return(0);
+    }
+
+    //
+    // Return the pipe index and type that was allocated.
+    //
+    return(ui32EndpointType | i32Idx);
+}
+
+//*****************************************************************************
+//
+//! This function is used to allocate a USB HCD pipe.
+//!
+//! \param ui32Index specifies which USB controller to use.
+//! \param ui32EndpointType is the type of endpoint that this pipe will be
+//! communicating with.
+//! \param psDevice is the device instance associated with this endpoint.
+//! \param pfnCallback is the function that will be called when events occur on
+//! this USB Pipe.
+//!
+//! Since there are a limited number of USB HCD pipes that can be used in the
+//! host controller, this function is used to temporarily or permanently
+//! acquire one of the endpoints.  It also provides a method to register a
+//! callback for status changes on this endpoint.  If no callbacks are desired
+//! then the \e pfnCallback function should be set to 0.  The callback should
+//! be used when using the USBHCDPipeSchedule() function so that the caller is
+//! notified when the action is complete.
+//!
+//! \return This function returns a value indicating which pipe was reserved.
+//! If the value is 0 then there were no pipes currently available.  This value
+//! should be passed to any USBHCDPipe APIs to indicate which pipe is being
+//! accessed.
+//
+//*****************************************************************************
+uint32_t
+USBHCDPipeAlloc(uint32_t ui32Index, uint32_t ui32EndpointType,
+                tUSBHostDevice *psDevice, tHCDPipeCallback pfnCallback)
+{
+    //
+    // The old API allocated only 64 bytes to each endpoint.
+    //
+    return(USBHCDPipeAllocSize(ui32Index, ui32EndpointType, psDevice, 64,
+                               pfnCallback));
+}
+
+//*****************************************************************************
+//
+//! This function is used to configure a USB HCD pipe.
+//!
+//! This should be called after allocating a USB pipe with a call to
+//! USBHCDPipeAlloc().  It is used to set the configuration associated with an
+//! endpoint like the max payload and target endpoint.  The \e ui32MaxPayload
+//! parameter is typically read directly from the devices endpoint descriptor
+//! and is expressed in bytes.
+//!
+//! Setting the \e ui32Interval parameter depends on the type of endpoint being
+//! configured.  For endpoints that do not need to use the \e ui32Interval
+//! parameter \e ui32Interval should be set to 0.  For Bulk \e ui32Interval is
+//! a value from 2-16 and will set the NAK timeout value as
+//! 2^(\e ui32Interval-1) frames.  For interrupt endpoints \e ui32Interval is a
+//! value from 1-255 and is the count in frames between polling the endpoint.
+//! For isochronous endpoints \e ui32Interval ranges from 1-16 and is the
+//! polling interval in frames represented as 2^(\e ui32Interval-1) frames.
+//!
+//! \param ui32Pipe is the allocated endpoint to modify.
+//! \param ui32MaxPayload is maximum data that can be handled per transaction.
+//! \param ui32Interval is the polling interval for data transfers expressed in
+//! frames.
+//! \param ui32TargetEndpoint is the target endpoint on the device to
+//! communicate with.
+//!
+//! \return If the call was successful, this function returns zero any other
+//! value indicates an error.
+//
+//*****************************************************************************
+uint32_t
+USBHCDPipeConfig(uint32_t ui32Pipe, uint32_t ui32MaxPayload,
+                 uint32_t ui32Interval, uint32_t ui32TargetEndpoint)
+{
+    uint32_t ui32Flags;
+    uint32_t ui32Index;
+
+    //
+    // Get the index number from the allocated pipe.
+    //
+    ui32Index = (ui32Pipe & EP_PIPE_IDX_M);
+
+    //
+    // Set the direction.
+    //
+    if(ui32Pipe & EP_PIPE_TYPE_OUT)
+    {
+        //
+        // Set the mode for this endpoint.
+        //
+        if(g_sUSBHCD.psUSBOUTPipes[ui32Index].ui32Type & EP_PIPE_TYPE_BULK)
+        {
+            ui32Flags = USB_EP_MODE_BULK;
+        }
+        else if(g_sUSBHCD.psUSBOUTPipes[ui32Index].ui32Type &
+                EP_PIPE_TYPE_INTR)
+        {
+            ui32Flags = USB_EP_MODE_INT;
+        }
+        else if(g_sUSBHCD.psUSBOUTPipes[ui32Index].ui32Type &
+                EP_PIPE_TYPE_ISOC)
+        {
+            ui32Flags = USB_EP_MODE_ISOC;
+        }
+        else
+        {
+            ui32Flags = USB_EP_MODE_CTRL;
+        }
+
+        ui32Flags |= USB_EP_HOST_OUT;
+
+        g_sUSBHCD.psUSBOUTPipes[ui32Index].ui8EPNumber =
+                                                (uint8_t)ui32TargetEndpoint;
+
+        //
+        // Save the interval and the next tick to trigger a scheduler event.
+        //
+        g_sUSBHCD.psUSBOUTPipes[ui32Index].ui32Interval = ui32Interval;
+        g_sUSBHCD.psUSBOUTPipes[ui32Index].ui32NextEventTick =
+                                            ui32Interval + g_ui32CurrentTick;
+
+        //
+        // Set the device speed.
+        //
+        ui32Flags |= (g_sUSBHCD.psUSBOUTPipes[ui32Index].psDevice->ui32Speed);
+
+        //
+        // Set up the appropriate flags if uDMA is used.
+        //
+        if(ui32Pipe & EP_PIPE_USE_UDMA)
+        {
+            ui32Flags |= USB_EP_DMA_MODE_0 | USB_EP_AUTO_SET;
+        }
+    }
+    else
+    {
+        //
+        // Set the mode for this endpoint.
+        //
+        if(g_sUSBHCD.psUSBINPipes[ui32Index].ui32Type & EP_PIPE_TYPE_BULK)
+        {
+            ui32Flags = USB_EP_MODE_BULK;
+        }
+        else if(g_sUSBHCD.psUSBINPipes[ui32Index].ui32Type & EP_PIPE_TYPE_INTR)
+        {
+            ui32Flags = USB_EP_MODE_INT;
+        }
+        else if(g_sUSBHCD.psUSBINPipes[ui32Index].ui32Type & EP_PIPE_TYPE_ISOC)
+        {
+            ui32Flags = USB_EP_MODE_ISOC;
+        }
+        else
+        {
+            ui32Flags = USB_EP_MODE_CTRL;
+        }
+        ui32Flags |= USB_EP_HOST_IN;
+
+        g_sUSBHCD.psUSBINPipes[ui32Index].ui8EPNumber =
+                                                (uint8_t)ui32TargetEndpoint;
+
+        //
+        // Save the interval and the next tick to trigger a scheduler event.
+        //
+        g_sUSBHCD.psUSBINPipes[ui32Index].ui32Interval = ui32Interval;
+        g_sUSBHCD.psUSBINPipes[ui32Index].ui32NextEventTick =
+                                            ui32Interval + g_ui32CurrentTick;
+
+        //
+        // Set the device speed.
+        //
+        ui32Flags |= g_sUSBHCD.psUSBINPipes[ui32Index].psDevice->ui32Speed;
+        //
+        // Set up the appropriate flags if uDMA is used.
+        //
+        if(ui32Pipe & EP_PIPE_USE_UDMA)
+        {
+            ui32Flags |= USB_EP_DMA_MODE_1 | USB_EP_AUTO_CLEAR |
+                         USB_EP_AUTO_REQUEST;
+        }
+    }
+
+
+    //
+    // Configure the endpoint according to the flags determined above.
+    //
+    USBHostEndpointConfig(USB0_BASE,
+                          IndexToUSBEP((ui32Pipe & EP_PIPE_IDX_M) + 1),
+                          ui32MaxPayload, ui32Interval, ui32TargetEndpoint,
+                          ui32Flags);
+
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! This function is used to return the current status of a USB HCD pipe.
+//!
+//! This function will return the current status for a given USB pipe.  If
+//! there is no status to report this call will simply return
+//! \b USBHCD_PIPE_NO_CHANGE.
+//!
+//! \param ui32Pipe is the USB pipe for this status request.
+//!
+//! \return This function returns the current status for the given endpoint.
+//! This will be one of the \b USBHCD_PIPE_* values.
+//
+//*****************************************************************************
+uint32_t
+USBHCDPipeStatus(uint32_t ui32Pipe)
+{
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! This function is used to write data to a USB HCD pipe.
+//!
+//! \param ui32Pipe is the USB pipe to put data into.
+//! \param pui8Data is a pointer to the data to send.
+//! \param ui32Size is the amount of data to send.
+//!
+//! This function will block until it has sent as much data as was
+//! requested using the USB pipe's FIFO.  The caller should have registered a
+//! callback with the USBHCDPipeAlloc() call in order to be informed when the
+//! data has been transmitted.  The value returned by this function can be less
+//! than the \e ui32Size requested if the USB pipe has less space available
+//! than this request is making.
+//!
+//! \return This function returns the number of bytes that were scheduled to
+//! be sent on the given USB pipe.
+//
+//*****************************************************************************
+uint32_t
+USBHCDPipeWrite(uint32_t ui32Pipe, uint8_t *pui8Data, uint32_t ui32Size)
+{
+    uint32_t ui32Endpoint, ui32RemainingBytes, ui32ByteToSend, ui32PipeIdx;
+    bool bUseDMA;
+
+    //
+    // Determine which endpoint interface that this pipe is using.
+    //
+    ui32Endpoint = IndexToUSBEP((EP_PIPE_IDX_M & ui32Pipe) + 1);
+
+    //
+    // Get index used for looking up pipe data
+    //
+    ui32PipeIdx = ui32Pipe & EP_PIPE_IDX_M;
+
+    //
+    // Set the total number of bytes to send out.
+    //
+    ui32RemainingBytes = ui32Size;
+
+    //
+    // Default to using DMA.
+    //
+    bUseDMA = false;
+
+    //
+    // Initialize the bytes to send to all of the remaining bytes.
+    //
+    ui32ByteToSend = ui32RemainingBytes;
+
+    //
+    // Send all of the requested data.
+    //
+    while(ui32RemainingBytes != 0)
+    {
+        //
+        // If uDMA is not enabled for this pipe, or if the uDMA workaround
+        // is applied, then don't use uDMA for this transfer.
+        //
+        if(ui32Pipe & EP_PIPE_USE_UDMA)
+        {
+            //
+            // Disable the USB interrupt.
+            //
+            OS_INT_DISABLE(g_sUSBHCD.ui32IntNum);
+
+            //
+            // Start the DMA transfer.
+            //
+            if(USBLibDMATransfer(g_sUSBHCD.psDMAInstance,
+                            g_sUSBHCD.psUSBOUTPipes[ui32PipeIdx].ui8DMAChannel,
+                            pui8Data, ui32RemainingBytes) != 0)
+            {
+                if(ui32RemainingBytes < 64)
+                {
+                    g_sUSBHCD.psUSBOUTPipes[ui32PipeIdx].iState =
+                                                            ePipeWriteDMASend;
+                }
+                else if((ui32RemainingBytes % 64) == 0)
+                {
+                    g_sUSBHCD.psUSBOUTPipes[ui32PipeIdx].iState =
+                                                                ePipeWriteDMA;
+                }
+                else
+                {
+                    g_sUSBHCD.psUSBOUTPipes[ui32PipeIdx].iState =
+                                                        ePipeWriteDMASend;
+                }
+
+                bUseDMA = true;
+            }
+
+            //
+            // Enable the USB interrupt.
+            //
+            OS_INT_ENABLE(g_sUSBHCD.ui32IntNum);
+        }
+
+        if(bUseDMA == false)
+        {
+            //
+            // Only send 64 bytes at a time if not using DMA.
+            //
+            if(ui32ByteToSend > 64)
+            {
+                ui32ByteToSend = 64;
+            }
+            else
+            {
+                //
+                // Send the requested number of bytes.
+                //
+                ui32ByteToSend = ui32RemainingBytes;
+            }
+
+            //
+            // Start a write request.
+            //
+            g_sUSBHCD.psUSBOUTPipes[ui32PipeIdx].iState = ePipeWriting;
+
+            //
+            // Disable uDMA on the USB endpoint
+            //
+            MAP_USBEndpointDMADisable(USB0_BASE, ui32Endpoint,
+                                      USB_EP_HOST_OUT);
+
+            //
+            // Put the data in the buffer.
+            //
+            MAP_USBEndpointDataPut(USB0_BASE, ui32Endpoint, pui8Data,
+                                   ui32ByteToSend);
+
+            //
+            // Schedule the data to be sent.
+            //
+            MAP_USBEndpointDataSend(USB0_BASE, ui32Endpoint, USB_TRANS_OUT);
+        }
+
+        //
+        // Wait for a status change.
+        //
+        while(1)
+        {
+            //
+            // If an error event occurs then exit out of the loop.
+            //
+            if(g_sUSBHCD.ui32IntEvents & (INT_EVENT_DISCONNECT |
+                                          INT_EVENT_VBUS_ERR |
+                                          INT_EVENT_POWER_FAULT))
+            {
+                //
+                // Set the pipe state to error.
+                //
+                g_sUSBHCD.psUSBOUTPipes[ui32PipeIdx].iState = ePipeError;
+
+                //
+                // Needs to be set to exit out of large while loop.
+                //
+                ui32RemainingBytes = 0;
+
+                break;
+            }
+            //
+            // If the data was successfully sent then decrement the count and
+            // continue.
+            //
+            else if(g_sUSBHCD.psUSBOUTPipes[ui32PipeIdx].iState ==
+                    ePipeDataSent)
+            {
+                //
+                // Decrement the remaining data and advance the pointer.
+                //
+                ui32RemainingBytes -= ui32ByteToSend;
+                pui8Data += ui32ByteToSend;
+
+                //
+                // If there are less than 64 bytes to send then this is the
+                // last of the data to go out.
+                //
+                if(ui32RemainingBytes < 64)
+                {
+                    ui32ByteToSend = ui32RemainingBytes;
+                }
+                break;
+            }
+            else if(g_sUSBHCD.psUSBOUTPipes[ui32PipeIdx].iState ==
+                    ePipeStalled)
+            {
+                //
+                // Zero out the size so that the caller knows that no data was
+                // written.
+                //
+                ui32Size = 0;
+
+                //
+                // Needs to be set to exit out of large while loop.
+                //
+                ui32RemainingBytes = 0;
+
+                //
+                // If DMA is being used, then disable the channel.
+                //
+                if(bUseDMA == true)
+                {
+                    //
+                    // Disable the DMA channel.
+                    //
+                    USBLibDMAChannelDisable(g_sUSBHCD.psDMAInstance,
+                        g_sUSBHCD.psUSBOUTPipes[ui32PipeIdx].ui8DMAChannel);
+                }
+
+                //
+                // This is the actual endpoint number.
+                //
+                USBHCDClearFeature(
+                    g_sUSBHCD.psUSBOUTPipes[ui32PipeIdx].psDevice->ui32Address,
+                    ui32Pipe, USB_FEATURE_EP_HALT);
+
+                //
+                // If there was a stall, then no more data is coming so break
+                // out.
+                //
+                break;
+            }
+            else if(g_sUSBHCD.psUSBOUTPipes[ui32PipeIdx].iState == ePipeError)
+            {
+                //
+                // An error occurred so stop this transaction and set the
+                // number of bytes to zero.
+                //
+                ui32Size = 0;
+
+                //
+                // Needs to be set to exit out of large while loop.
+                //
+                ui32RemainingBytes = 0;
+
+                break;
+            }
+        }
+    }
+
+    //
+    // Go Idle once this state has been reached.
+    //
+    g_sUSBHCD.psUSBOUTPipes[ui32PipeIdx].iState = ePipeIdle;
+
+    return(ui32Size);
+}
+
+//*****************************************************************************
+//
+//! This function is used to schedule and IN transaction on a USB HCD pipe.
+//!
+//! \param ui32Pipe is the USB pipe to read data from.
+//! \param pui8Data is a pointer to store the data that is received.
+//! \param ui32Size is the size in bytes of the buffer pointed to by
+//! \e pui8Data.
+//!
+//! This function will not block depending on the type of pipe passed in will
+//! schedule either a send of data to the device or a read of data from the
+//! device.  In either case the amount of data will be limited to what will
+//! fit in the FIFO for a given endpoint.
+//!
+//! \return This function returns the number of bytes that were sent in the
+//! case of a transfer of data or it will return 0 for a request on a USB IN
+//! pipe.
+//
+//*****************************************************************************
+uint32_t
+USBHCDPipeSchedule(uint32_t ui32Pipe, uint8_t *pui8Data, uint32_t ui32Size)
+{
+    uint32_t ui32Endpoint, ui32PipeIdx;
+
+    //
+    // Get index used for looking up pipe data
+    //
+    ui32PipeIdx = ui32Pipe & EP_PIPE_IDX_M;
+
+    //
+    // Determine which endpoint interface that this pipe is using.
+    //
+    ui32Endpoint = IndexToUSBEP((EP_PIPE_IDX_M & ui32Pipe) + 1);
+
+    if(ui32Pipe & EP_PIPE_TYPE_OUT)
+    {
+        //
+        // Check if uDMA is enabled on this pipe.
+        //
+        if(ui32Pipe & EP_PIPE_USE_UDMA)
+        {
+            //
+            // Start a write request.
+            //
+            g_sUSBHCD.psUSBOUTPipes[EP_PIPE_IDX_M & ui32Pipe].iState =
+                                                            ePipeWriteDMASend;
+
+            USBLibDMATransfer(g_sUSBHCD.psDMAInstance,
+                            g_sUSBHCD.psUSBOUTPipes[ui32PipeIdx].ui8DMAChannel,
+                            pui8Data, ui32Size);
+        }
+        else
+        {
+            //
+            // Start a write request.
+            //
+            g_sUSBHCD.psUSBOUTPipes[EP_PIPE_IDX_M & ui32Pipe].iState =
+                                                                ePipeWriting;
+
+            //
+            // Put the data in the buffer.
+            //
+            MAP_USBEndpointDataPut(USB0_BASE, ui32Endpoint, pui8Data,
+                                   ui32Size);
+
+            //
+            // Schedule the data to be sent.
+            //
+            MAP_USBEndpointDataSend(USB0_BASE, ui32Endpoint, USB_TRANS_OUT);
+        }
+    }
+    else
+    {
+        //
+        // If uDMA is not enabled for this pipe, or if the uDMA workaround
+        // is applied, then do not use uDMA for this transfer.
+        //
+        if((ui32Pipe & EP_PIPE_USE_UDMA) == 0)
+        {
+            //
+            // Start a read request.
+            //
+            g_sUSBHCD.psUSBINPipes[EP_PIPE_IDX_M & ui32Pipe].iState =
+                                                                ePipeReading;
+
+            //
+            // Disable uDMA on the endpoint
+            //
+            MAP_USBEndpointDMADisable(USB0_BASE, ui32Endpoint, USB_EP_HOST_IN);
+        }
+        //
+        // Otherwise, uDMA should be used for this transfer, so set up
+        // the uDMA channel in advance of triggering the IN request.
+        //
+        else
+        {
+            g_sUSBHCD.psUSBINPipes[EP_PIPE_IDX_M & ui32Pipe].iState =
+                                                                ePipeReadDMA;
+
+            USBLibDMATransfer(g_sUSBHCD.psDMAInstance,
+                            g_sUSBHCD.psUSBINPipes[ui32PipeIdx].ui8DMAChannel,
+                            pui8Data, ui32Size);
+        }
+
+        //
+        // Remember details of the buffer into which the data will be read.
+        //
+        g_sUSBHCD.psUSBINPipes[ui32PipeIdx].pui8ReadPtr = pui8Data;
+        g_sUSBHCD.psUSBINPipes[ui32PipeIdx].ui32ReadSize = ui32Size;
+
+        //
+        // Trigger a request for data from the device.
+        //
+        MAP_USBHostRequestIN(USB0_BASE, ui32Endpoint);
+
+        //
+        // No data was put into or read from the buffer.
+        //
+        ui32Size = 0;
+    }
+    return(ui32Size);
+}
+
+//*****************************************************************************
+//
+//! This function is used to read data from a USB HCD pipe.
+//!
+//! \param ui32Pipe is the USB pipe to read data from.
+//! \param pui8Data is a pointer to store the data that is received.
+//! \param ui32Size is the size in bytes of the buffer pointed to by
+//! \e pui8Data.
+//!
+//! This function will not block and will only read as much data as requested
+//! or as much data is currently available from the USB pipe.  The caller
+//! should have registered a callback with the USBHCDPipeAlloc() call in order
+//! to be informed when the data has been received.  The value returned by this
+//! function can be less than the \e ui32Size requested if the USB pipe has
+//! less data available than was requested.
+//!
+//! \return This function returns the number of bytes that were returned in the
+//! \e pui8Data buffer.
+//
+//*****************************************************************************
+uint32_t
+USBHCDPipeReadNonBlocking(uint32_t ui32Pipe, uint8_t *pui8Data,
+                          uint32_t ui32Size)
+{
+    uint32_t ui32Endpoint;
+
+    //
+    // Determine which endpoint interface that this pipe is using.
+    //
+    ui32Endpoint = IndexToUSBEP((EP_PIPE_IDX_M & ui32Pipe) + 1);
+
+    //
+    // Read the data out of the USB endpoint interface.
+    //
+    MAP_USBEndpointDataGet(USB0_BASE, ui32Endpoint, pui8Data, &ui32Size);
+
+    //
+    // Acknowledge that the data was read from the endpoint.
+    //
+    MAP_USBHostEndpointDataAck(USB0_BASE, ui32Endpoint);
+
+    //
+    // Go Idle once this state has been reached.
+    //
+    g_sUSBHCD.psUSBINPipes[EP_PIPE_IDX_M & ui32Pipe].iState = ePipeIdle;
+
+    return(ui32Size);
+}
+
+//*****************************************************************************
+//
+//! This function acknowledges data received via an interrupt IN pipe.
+//!
+//! \param ui32Pipe is the USB INT pipe whose last packet is to be
+//! acknowledged.
+//!
+//! This function is used to acknowledge reception of data on an interrupt IN
+//! pipe.  A transfer on an interrupt IN endpoint is scheduled via a call to
+//! USBHCDPipeSchedule() and the application is notified when data is received
+//! using a \b USB_EVENT_RX_AVAILABLE event.  In the handler for this event,
+//! the application must call USBHCDPipeDataAck() to have the USB controller
+//! ACK the data from the device and complete the transaction.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBHCDPipeDataAck(uint32_t ui32Pipe)
+{
+    uint32_t ui32Endpoint;
+
+    //
+    // Determine which endpoint interface that this pipe is using.
+    //
+    ui32Endpoint = IndexToUSBEP((EP_PIPE_IDX_M & ui32Pipe) + 1);
+
+    //
+    // Acknowledge that the data was read from the endpoint.
+    //
+    USBHostEndpointDataAck(USB0_BASE, ui32Endpoint);
+
+    //
+    // Go Idle once this state has been reached.
+    //
+    g_sUSBHCD.psUSBINPipes[EP_PIPE_IDX_M & ui32Pipe].iState = ePipeIdle;
+}
+
+//*****************************************************************************
+//
+//! This function is used to read data from a USB HCD pipe.
+//!
+//! \param ui32Pipe is the USB pipe to read data from.
+//! \param pui8Data is a pointer to store the data that is received.
+//! \param ui32Size is the size in bytes of the buffer pointed to by
+//! \e pui8Data.
+//!
+//! This function will block and will only return when it has read as much data
+//! as requested from the USB pipe.  The caller must register a callback with
+//! the USBHCDPipeAlloc() call in order to be informed when the data has been
+//! received.  If the caller provides a non-zero pointer in the \e pui8Data
+//! parameter then the data is copied into the buffer before the callback
+//! occurs.  If the caller provides a zero in \e pui8Data parameter
+//! then the caller is responsible for reading the data out of the FIFO when
+//! the \b USB_EVENT_RX_AVAILABLE callback event occurs.   The value returned
+//! by this function can be less than the \e ui32Size requested if the USB pipe
+//! has less data available than was requested.
+//!
+//! \return This function returns the number of bytes that were returned in the
+//! \e pui8Data buffer.
+//
+//*****************************************************************************
+uint32_t
+USBHCDPipeRead(uint32_t ui32Pipe, uint8_t *pui8Data, uint32_t ui32Size)
+{
+    uint32_t ui32Endpoint, ui32RemainingBytes, ui32BytesRead, ui32PipeIdx;
+    bool bUseDMA;
+
+    //
+    // Get index used for looking up pipe data
+    //
+    ui32PipeIdx = ui32Pipe & EP_PIPE_IDX_M;
+
+    //
+    // Initialized the number of bytes read.
+    //
+    ui32BytesRead = 0;
+
+    //
+    // Determine which endpoint interface that this pipe is using.
+    //
+    ui32Endpoint = IndexToUSBEP(ui32PipeIdx + 1);
+
+    //
+    // Set the remaining bytes to received.
+    //
+    ui32RemainingBytes = ui32Size;
+
+    //
+    // Default to using DMA.
+    //
+    bUseDMA = true;
+
+    //
+    // Continue until all data requested has been received.
+    //
+    while(ui32RemainingBytes != 0)
+    {
+        //
+        // Start a read request.
+        //
+        g_sUSBHCD.psUSBINPipes[ui32PipeIdx].iState = ePipeReading;
+
+        //
+        // Try the DMA transfer should be used for this transfer, so set up
+        // the uDMA channel in advance of triggering the IN request.
+        //
+        if(ui32Pipe & EP_PIPE_USE_UDMA)
+        {
+            //
+            // Disable the USB interrupt.
+            //
+            OS_INT_DISABLE(g_sUSBHCD.ui32IntNum);
+
+            if(USBLibDMATransfer(g_sUSBHCD.psDMAInstance,
+                            g_sUSBHCD.psUSBINPipes[ui32PipeIdx].ui8DMAChannel,
+                            pui8Data, ui32Size) != 0)
+            {
+                g_sUSBHCD.psUSBINPipes[ui32PipeIdx].iState = ePipeReadDMA;
+
+                ui32BytesRead = ui32Size;
+            }
+            else
+            {
+                bUseDMA = false;
+            }
+
+            //
+            // Disable the USB interrupt.
+            //
+            OS_INT_ENABLE(g_sUSBHCD.ui32IntNum);
+        }
+
+        //
+        // If unable to use DMA then get ready to transfer without DMA.
+        //
+        if(bUseDMA == false)
+        {
+            //
+            // Disable uDMA on the endpoint
+            //
+            MAP_USBEndpointDMADisable(USB0_BASE, ui32Endpoint, USB_EP_HOST_IN);
+
+            //
+            // Set up for the next transaction.
+            //
+            g_sUSBHCD.psUSBINPipes[ui32PipeIdx].pui8ReadPtr = pui8Data;
+            g_sUSBHCD.psUSBINPipes[ui32PipeIdx].ui32ReadSize =
+                        (ui32RemainingBytes < 64) ? ui32RemainingBytes : 64;
+        }
+
+        //
+        // Trigger a request for data from the device.
+        //
+        MAP_USBHostRequestIN(USB0_BASE, ui32Endpoint);
+
+        //
+        // Wait for a status change.
+        //
+        while(1)
+        {
+            //
+            // Check if the device stalled the request.
+            //
+            if(g_sUSBHCD.psUSBINPipes[ui32PipeIdx].iState == ePipeStalled)
+            {
+                //
+                // Zero out the size so that the caller knows that no data was
+                // read.
+                //
+                ui32Size = 0;
+
+                //
+                // There are also no remaining bytes to read.
+                //
+                ui32RemainingBytes = 0;
+
+                //
+                // If DMA is being used, then disable the channel.
+                //
+                if(bUseDMA == true)
+                {
+                    USBLibDMAChannelDisable(
+                            g_sUSBHCD.psDMAInstance,
+                            g_sUSBHCD.psUSBINPipes[ui32PipeIdx].ui8DMAChannel);
+                }
+
+                //
+                // This is the actual endpoint number.
+                //
+                USBHCDClearFeature(
+                    g_sUSBHCD.psUSBINPipes[ui32PipeIdx].psDevice->ui32Address,
+                    ui32Pipe, USB_FEATURE_EP_HALT);
+
+                //
+                // If there was a stall, then no more data is coming so break
+                // out.
+                //
+                break;
+            }
+
+            //
+            // If any error event occurs then exit out of the loop.
+            //
+            if(g_sUSBHCD.ui32IntEvents & (INT_EVENT_DISCONNECT |
+                                          INT_EVENT_VBUS_ERR |
+                                          INT_EVENT_POWER_FAULT))
+            {
+                //
+                // Set the pipe state to error.
+                //
+                g_sUSBHCD.psUSBINPipes[ui32PipeIdx].iState = ePipeError;
+                break;
+            }
+
+            //
+            // If data is ready then return it.
+            //
+            if(g_sUSBHCD.psUSBINPipes[ui32PipeIdx].iState == ePipeDataReady)
+            {
+                //
+                // If not using DMA then read the data from the USB.  Otherwise
+                // the data will already be in the buffer.
+                //
+                if(bUseDMA == false)
+                {
+                    //
+                    // Compute bytes to transfer and set up transfer
+                    //
+                    ui32BytesRead =
+                            ui32RemainingBytes > 64 ? 64 : ui32RemainingBytes;
+
+                    //
+                    // Acknowledge that the data was read from the endpoint.
+                    //
+                    MAP_USBHostEndpointDataAck(USB0_BASE, ui32Endpoint);
+                }
+
+                //
+                // Subtract the number of bytes read from the bytes remaining.
+                //
+                ui32RemainingBytes -= ui32BytesRead;
+
+                //
+                // If there were less than 64 bytes read, then this was a short
+                // packet and no more data will be returned.
+                //
+                if(ui32BytesRead < 64)
+                {
+                    //
+                    // Subtract off the bytes that were not received and exit
+                    // the loop.
+                    //
+                    ui32Size = ui32Size - ui32RemainingBytes;
+                    break;
+                }
+                else
+                {
+                    //
+                    // Move the buffer ahead to receive more data into the
+                    // buffer.
+                    //
+                    pui8Data += 64;
+                }
+                break;
+            }
+            else if(g_sUSBHCD.psUSBINPipes[ui32PipeIdx].iState == ePipeError)
+            {
+                //
+                // An error occurred so stop this transaction and set the
+                // number of bytes to zero.
+                //
+                ui32Size = 0;
+                ui32RemainingBytes = 0;
+
+                break;
+            }
+            else if((g_sUSBHCD.psUSBINPipes[ui32PipeIdx].iState ==
+                     ePipeReadDMAWait) &&
+                    (USBLibDMAChannelStatus(g_sUSBHCD.psDMAInstance,
+                        g_sUSBHCD.psUSBINPipes[ui32PipeIdx].ui8DMAChannel) &
+                     USBLIBSTATUS_DMA_COMPLETE))
+            {
+                break;
+            }
+        }
+    }
+
+    //
+    // Go Idle once this state has been reached.
+    //
+    g_sUSBHCD.psUSBINPipes[ui32PipeIdx].iState = ePipeIdle;
+
+    return(ui32Size);
+}
+
+//*****************************************************************************
+//
+//! This function is used to release a USB pipe.
+//!
+//! \param ui32Pipe is the allocated USB pipe to release.
+//!
+//! This function is used to release a USB pipe that was allocated by a call to
+//! USBHCDPipeAlloc() for use by some other device endpoint in the system.
+//! Freeing an unallocated or invalid pipe will not generate an error and will
+//! instead simply return.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBHCDPipeFree(uint32_t ui32Pipe)
+{
+    uint32_t ui32Index;
+
+    //
+    // Get the index number from the allocated pipe.
+    //
+    ui32Index = (ui32Pipe & EP_PIPE_IDX_M);
+
+    if(ui32Pipe & EP_PIPE_TYPE_OUT)
+    {
+        //
+        // Clear the address and type for this endpoint to free it up.
+        //
+        g_sUSBHCD.psUSBOUTPipes[ui32Index].psDevice = 0;
+        g_sUSBHCD.psUSBOUTPipes[ui32Index].ui32Type = 0;
+        g_sUSBHCD.psUSBOUTPipes[ui32Index].pfnCallback = 0;
+
+        //
+        // Check if this pipe has allocated a DMA channel.
+        //
+        if(g_sUSBHCD.psUSBOUTPipes[ui32Index].ui8DMAChannel !=
+           USBHCD_DMA_UNUSED)
+        {
+            //
+            // Release the DMA channel associated with this endpoint.
+            //
+            USBLibDMAChannelRelease(g_sUSBHCD.psDMAInstance,
+                    g_sUSBHCD.psUSBOUTPipes[ui32Index].ui8DMAChannel);
+
+            //
+            // Clear out the current channel in use by this pipe.
+            //
+            g_sUSBHCD.psUSBOUTPipes[ui32Index].ui8DMAChannel =
+                                                            USBHCD_DMA_UNUSED;
+        }
+
+        //
+        // Free up the FIFO memory used by this endpoint.
+        //
+        if(g_sUSBHCD.psUSBOUTPipes[ui32Index].ui8FIFOSize)
+        {
+            FIFOFree(&g_sUSBHCD.psUSBOUTPipes[ui32Index]);
+        }
+
+        //
+        // Set the function address for this endpoint back to zero.
+        //
+        USBHostAddrSet(USB0_BASE, IndexToUSBEP(ui32Index + 1),
+                       0, USB_EP_HOST_OUT);
+
+        //
+        // Set the hub and port address for the endpoint back to zero and the
+        // speed back to LOW.
+        //
+        USBHostHubAddrSet(USB0_BASE, IndexToUSBEP(ui32Index + 1),
+                          0, (USB_EP_HOST_OUT | USB_EP_SPEED_LOW));
+    }
+    else if(ui32Pipe & EP_PIPE_TYPE_IN)
+    {
+        //
+        // Clear the address and type for this endpoint to free it up.
+        //
+        g_sUSBHCD.psUSBINPipes[ui32Index].psDevice = 0;
+        g_sUSBHCD.psUSBINPipes[ui32Index].ui32Type = 0;
+        g_sUSBHCD.psUSBINPipes[ui32Index].pfnCallback = 0;
+
+        //
+        // Check if this pipe has allocated a DMA channel.
+        //
+        if(g_sUSBHCD.psUSBINPipes[ui32Index].ui8DMAChannel !=
+           USBHCD_DMA_UNUSED)
+        {
+            //
+            // Release the DMA channel associated with this endpoint.
+            //
+            USBLibDMAChannelRelease(g_sUSBHCD.psDMAInstance,
+                    g_sUSBHCD.psUSBINPipes[ui32Index].ui8DMAChannel);
+
+            //
+            // Clear out the current channel in use by this pipe.
+            //
+            g_sUSBHCD.psUSBINPipes[ui32Index].ui8DMAChannel =
+                                                            USBHCD_DMA_UNUSED;
+        }
+
+        //
+        // Free up the FIFO memory used by this endpoint.
+        //
+        if(g_sUSBHCD.psUSBINPipes[ui32Pipe & EP_PIPE_IDX_M].ui8FIFOSize)
+        {
+            FIFOFree(&g_sUSBHCD.psUSBINPipes[ui32Pipe & EP_PIPE_IDX_M]);
+        }
+
+        //
+        // Set the function address for this endpoint back to zero.
+        //
+        USBHostAddrSet(USB0_BASE, IndexToUSBEP(ui32Index + 1),
+                       0, USB_EP_HOST_IN);
+
+        //
+        // Set the hub and port address for the endpoint back to zero and the
+        // speed back to LOW.
+        //
+        USBHostHubAddrSet(USB0_BASE, IndexToUSBEP(ui32Index + 1),
+                          0, (USB_EP_HOST_IN | USB_EP_SPEED_LOW));
+
+        //
+        // Clear any pending IN transactions.
+        //
+        USBHostRequestINClear(USB0_BASE, IndexToUSBEP(ui32Index + 1));
+    }
+}
+
+//*****************************************************************************
+//
+// This internal function initializes the HCD code.
+//
+// \param ui32Index specifies which USB controller to use.
+// \param pvPool is a pointer to the data to use as a memory pool for this
+// controller.
+// \param ui32PoolSize is the size in bytes of the buffer passed in as pvPool.
+//
+// This function will perform all the necessary operations to allow the USB
+// host controller to begin enumeration and communication with a device.  This
+// function should typically be called once at the start of an application
+// before any other calls are made to the host controller.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+USBHCDInitInternal(uint32_t ui32Index, void *pvPool, uint32_t ui32PoolSize)
+{
+    int32_t i32Idx;
+
+    ASSERT(ui32Index == 0);
+
+    //
+    // Get the number of endpoints supported by this device.
+    //
+    g_sUSBHCD.ui32NumEndpoints = USBNumEndpointsGet(USB0_BASE);
+
+    //
+    // The first 64 Bytes are allocated to endpoint 0.
+    //
+    g_pui32Alloc[0] = 1;
+    g_pui32Alloc[1] = 0;
+
+    //
+    // Save the base address for this controller.
+    //
+    g_sUSBHCD.ui32USBBase = USB0_BASE;
+
+    //
+    // Save the USB interrupt number.
+    //
+    g_sUSBHCD.ui32IntNum = INT_USB0_TM4C123;
+
+    //
+    // These devices have a different USB interrupt number.
+    //
+    if(CLASS_IS_TM4C129)
+    {
+        g_sUSBHCD.ui32IntNum = INT_USB0_TM4C129;
+    }
+
+    //
+    // All Pipes are unused at start.
+    //
+    for(i32Idx = 0; i32Idx < MAX_NUM_PIPES; i32Idx++)
+    {
+        g_sUSBHCD.psUSBINPipes[i32Idx].psDevice = 0;
+        g_sUSBHCD.psUSBINPipes[i32Idx].ui32Type = USBHCD_PIPE_UNUSED;
+        g_sUSBHCD.psUSBINPipes[i32Idx].ui8DMAChannel = USBHCD_DMA_UNUSED;
+        g_sUSBHCD.psUSBOUTPipes[i32Idx].psDevice = 0;
+        g_sUSBHCD.psUSBOUTPipes[i32Idx].ui32Type = USBHCD_PIPE_UNUSED;
+        g_sUSBHCD.psUSBOUTPipes[i32Idx].ui8DMAChannel = USBHCD_DMA_UNUSED;
+    }
+
+    //
+    // Make sure that the hub driver is initialized since it is called even
+    // if it is not present in the system.
+    //
+    USBHHubInit();
+
+    //
+    // Initialize the DMA interface.
+    //
+    g_sUSBHCD.psDMAInstance = USBLibDMAInit(g_sUSBHCD.ui32USBBase);
+
+    //
+    // Initialized the device structures.
+    //
+    for(i32Idx = 0; i32Idx <= MAX_USB_DEVICES; i32Idx++)
+    {
+        //
+        // Clear the configuration descriptor and state.
+        //
+        g_sUSBHCD.piDeviceState[i32Idx] = eHCDIdle;
+        g_sUSBHCD.psUSBDevice[i32Idx].psConfigDescriptor = 0;
+        g_sUSBHCD.psUSBDevice[i32Idx].bConfigRead = false;
+
+        //
+        // Initialize the device descriptor.
+        //
+        g_sUSBHCD.psUSBDevice[i32Idx].sDeviceDescriptor.bLength = 0;
+        g_sUSBHCD.psUSBDevice[i32Idx].sDeviceDescriptor.bMaxPacketSize0 = 0;
+
+        //
+        // Initialize the device address.
+        //
+        g_sUSBHCD.psUSBDevice[i32Idx].ui32Address = 0;
+
+        //
+        // Set the current interface to 0.
+        //
+        g_sUSBHCD.psUSBDevice[i32Idx].ui32Interface = 0;
+
+        //
+        // Clear the active driver for the device.
+        //
+        g_pi32USBHActiveDriver[i32Idx] = -1;
+
+        //
+        // Initialize the device flags.
+        //
+        g_sUSBHCD.psUSBDevice[i32Idx].ui32Flags = 0;
+    }
+
+    //
+    // Allocate the memory needed for reading descriptors.
+    //
+    g_sUSBHCD.pvPool = pvPool;
+    g_sUSBHCD.ui32PoolSize = ui32PoolSize;
+
+    //
+    // Initialize the device class.
+    //
+    g_sUSBHCD.ui32Class = USB_CLASS_EVENTS;
+
+    //
+    // Default enable connect, disconnect, unknown device and power fault
+    // event notifications.
+    //
+    g_sUSBHCD.ui32EventEnables = USBHCD_EVFLAG_CONNECT |
+                                 USBHCD_EVFLAG_UNKCNCT |
+                                 USBHCD_EVFLAG_DISCNCT |
+                                 USBHCD_EVFLAG_PWRFAULT |
+                                 USBHCD_EVFLAG_PWREN |
+                                 USBHCD_EVFLAG_PWRDIS;
+
+    //
+    // Initialize the USB tick module.
+    //
+    InternalUSBTickInit();
+
+    //
+    // Only do hardware update if the stack is in Host mode, do not touch the
+    // hardware for OTG mode operation.
+    //
+    if((g_iUSBMode == eUSBModeHost) || (g_iUSBMode == eUSBModeForceHost))
+    {
+        //
+        // Configure the End point 0.
+        //
+        USBHostEndpointConfig(USB0_BASE, USB_EP_0, 64, 0, 0,
+                              (USB_EP_MODE_CTRL | USB_EP_SPEED_FULL |
+                               USB_EP_HOST_OUT));
+
+        //
+        // Enable USB Interrupts.
+        //
+        MAP_USBIntEnableControl(USB0_BASE, USB_INTCTRL_RESET |
+                                           USB_INTCTRL_DISCONNECT |
+                                           USB_INTCTRL_SOF |
+                                           USB_INTCTRL_SESSION |
+                                           USB_INTCTRL_BABBLE |
+                                           USB_INTCTRL_CONNECT |
+                                           USB_INTCTRL_RESUME |
+                                           USB_INTCTRL_SUSPEND |
+                                           USB_INTCTRL_VBUS_ERR |
+                                           USB_INTCTRL_POWER_FAULT);
+
+        MAP_USBIntEnableEndpoint(USB0_BASE, USB_INTEP_ALL);
+
+        //
+        // Enable the USB interrupt.
+        //
+        OS_INT_ENABLE(g_sUSBHCD.ui32IntNum);
+
+        //
+        // There is no automatic power in pure host mode.
+        //
+        USBHCDPowerConfigSet(ui32Index, (g_ui32PowerConfig &
+                                         ~USB_HOST_PWREN_AUTO));
+
+        //
+        // Force the power on as well as this point.
+        //
+        MAP_USBHostPwrEnable(USB0_BASE);
+
+        //
+        // This is required to get into host mode on some parts.
+        //
+        USBOTGSessionRequest(USB0_BASE, true);
+    }
+
+    //
+    // Configure LPM if it is enabled.
+    //
+    if(g_sUSBHCD.ui32Features & USBLIB_FEATURE_LPM_EN)
+    {
+        if(g_sUSBHCD.ui32Features & USBLIB_FEATURE_LPM_RMT_WAKE)
+        {
+            USBHostLPMConfig(USB0_BASE, g_sUSBHCD.ui32LPMHIRD,
+                             USB_DEV_LPM_LS_L1 | USB_DEV_LPM_LS_RMTWAKE);
+        }
+        else
+        {
+            USBHostLPMConfig(USB0_BASE, g_sUSBHCD.ui32LPMHIRD,
+                             USB_DEV_LPM_LS_L1);
+        }
+
+        //
+        // Enable USB interrupts for LPM mode, these enables have no effect on
+        // devices that do not support LPM.
+        //
+        USBLPMIntEnable(USB0_BASE, USB_INTLPM_ERROR | USB_INTLPM_RESUME |
+                                   USB_INTLPM_INCOMPLETE | USB_INTLPM_ACK |
+                                   USB_INTLPM_NYET | USB_INTLPM_STALL);
+    }
+}
+
+//*****************************************************************************
+//
+//! This function is used to set the power pin and power fault configuration.
+//!
+//! \param ui32Index specifies which USB controller to use.
+//! \param ui32PwrConfig is the power configuration to use for the application.
+//!
+//! This function must be called before HCDInit() is called so that the power
+//! pin configuration can be set before power is enabled.  The \e ui32PwrConfig
+//! flags specify the power fault level sensitivity, the power fault action,
+//! and the power enable pin level and source.
+//!
+//! One of the following can be selected as the power fault level sensitivity:
+//!
+//! - \b USBHCD_FAULT_LOW - An external power fault is indicated by the pin
+//!                         being driven low.
+//! - \b USBHCD_FAULT_HIGH - An external power fault is indicated by the pin
+//!                          being driven high.
+//!
+//! One of the following can be selected as the power fault action:
+//!
+//! - \b USBHCD_FAULT_VBUS_NONE - No automatic action when power fault
+//!   detected.
+//! - \b USBHCD_FAULT_VBUS_TRI - Automatically Tri-state the USBnEPEN pin on a
+//!                              power fault.
+//! - \b USBHCD_FAULT_VBUS_DIS - Automatically drive the USBnEPEN pin to it's
+//!                              inactive state on a power fault.
+//!
+//! One of the following can be selected as the power enable level and source:
+//!
+//! - \b USBHCD_VBUS_MANUAL - Power control is completely managed by the
+//!                           application, the USB library will provide a
+//!                           power callback to request power state changes.
+//! - \b USBHCD_VBUS_AUTO_LOW - USBEPEN is driven low by the USB controller
+//!                             automatically if USBOTGSessionRequest() has
+//!                             enabled a session.
+//! - \b USBHCD_VBUS_AUTO_HIGH - USBEPEN is driven high by the USB controller
+//!                              automatically if USBOTGSessionRequest() has
+//!                              enabled a session.
+//!
+//! If \b USBHCD_VBUS_MANUAL is used then the application must provide an
+//! event driver to receive the \b USB_EVENT_POWER_ENABLE and
+//! \b USB_EVENT_POWER_DISABLE events and enable and disable power to VBUS when
+//! requested by the USB library.  The application should respond to a power
+//! control callback by enabling or disabling VBUS as soon as possible and
+//! before returning from the callback function.
+//!
+//! \note The following values should no longer be used with the USB
+//! library: \b USB_HOST_PWRFLT_LOW, \b USB_HOST_PWRFLT_HIGH,
+//! \b USB_HOST_PWRFLT_EP_NONE, \b USB_HOST_PWRFLT_EP_TRI,
+//! \b USB_HOST_PWRFLT_EP_LOW, \b USB_HOST_PWRFLT_EP_HIGH,
+//! \b USB_HOST_PWREN_LOW, \b USB_HOST_PWREN_HIGH, \b USB_HOST_PWREN_VBLOW, and
+//! \b USB_HOST_PWREN_VBHIGH.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBHCDPowerConfigInit(uint32_t ui32Index, uint32_t ui32PwrConfig)
+{
+    ASSERT(ui32Index == 0);
+
+    //
+    // Save the value as it will be used later.
+    //
+    g_ui32PowerConfig = ui32PwrConfig;
+}
+
+//*****************************************************************************
+//
+//! This function is used to get the power pin and power fault configuration.
+//!
+//! \param ui32Index specifies which USB controller to use.
+//!
+//! This function will return the current power control pin configuration as
+//! set by the USBHCDPowerConfigInit() function or the defaults if not yet set.
+//! See the USBHCDPowerConfigInit() documentation for the meaning of the bits
+//! that are returned by this function.
+//!
+//! \return The configuration of the power control pins.
+//!
+//*****************************************************************************
+uint32_t
+USBHCDPowerConfigGet(uint32_t ui32Index)
+{
+    ASSERT(ui32Index == 0);
+
+    //
+    // Save the value as it will be used later.
+    //
+    return(g_ui32PowerConfig);
+}
+
+//*****************************************************************************
+//
+//! This function is used to set the power pin and power fault configuration.
+//!
+//! \param ui32Index specifies which USB controller to use.
+//! \param ui32Config specifies which USB power configuration to use.
+//!
+//! This function will set the current power control pin configuration as
+//! set by the USBHCDPowerConfigInit() function or the defaults if not yet set.
+//! See the USBHCDPowerConfigInit() documentation for the meaning of the bits
+//! that are set by this function.
+//!
+//! \return Returns zero to indicate the power setting is now active.
+//!
+//*****************************************************************************
+uint32_t
+USBHCDPowerConfigSet(uint32_t ui32Index, uint32_t ui32Config)
+{
+    ASSERT(ui32Index == 0);
+
+    //
+    // Remember the current setting.
+    //
+    g_ui32PowerConfig = ui32Config;
+
+    //
+    // Clear out the two flag bits.
+    //
+    ui32Config = g_ui32PowerConfig & ~(USBHCD_VBUS_MANUAL |
+                                       USBHCD_FAULT_VBUS_DIS);
+
+    //
+    // If there is an automatic disable power action specified then set the
+    // polarity of the signal to match EPEN.
+    //
+    if(g_ui32PowerConfig & USBHCD_FAULT_VBUS_DIS)
+    {
+        //
+        // Insure that the assumption below is true.
+        //
+        ASSERT((USBHCD_VBUS_AUTO_HIGH & 1) == 1);
+        ASSERT((USBHCD_VBUS_AUTO_LOW & 1) == 0);
+
+        //
+        // This is taking advantage of the difference between
+        // USBHCD_VBUS_AUTO_LOW and USBHCD_VBUS_AUTO_HIGH being that bit
+        // one is set when EPEN is active high.
+        //
+        if(g_ui32PowerConfig & 1)
+        {
+            g_ui32PowerConfig |= USB_HOST_PWRFLT_EP_LOW;
+            ui32Config |= USB_HOST_PWRFLT_EP_LOW;
+        }
+        else
+        {
+            g_ui32PowerConfig |= USB_HOST_PWRFLT_EP_HIGH;
+            ui32Config |= USB_HOST_PWRFLT_EP_HIGH;
+        }
+    }
+
+    //
+    // Initialize the power configuration.
+    //
+    MAP_USBHostPwrConfig(USB0_BASE, ui32Config);
+
+    //
+    // If not in manual mode then just turn on power.
+    //
+    if((g_ui32PowerConfig & USBHCD_VBUS_MANUAL) == 0)
+    {
+        //
+        // Power the USB bus.
+        //
+        MAP_USBHostPwrEnable(USB0_BASE);
+    }
+
+    //
+    // Return success.
+    //
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! This function returns if the current power settings will automatically
+//! handle enabling and disabling VBUS power.
+//!
+//! \param ui32Index specifies which USB controller to query.
+//!
+//! This function returns if the current power control pin configuration will
+//! automatically apply power or whether it will be left to the application
+//! to turn on power when it is notified.
+//!
+//! \return A non-zero value indicates that power is automatically applied and
+//! a value of zero indicates that the application must manually apply power.
+//!
+//*****************************************************************************
+uint32_t
+USBHCDPowerAutomatic(uint32_t ui32Index)
+{
+    //
+    // Check if the controller is automatically applying power or not.
+    //
+    if(g_ui32PowerConfig & USBHCD_VBUS_MANUAL)
+    {
+        return(0);
+    }
+    return(1);
+}
+
+//*****************************************************************************
+//
+//! This function is used to initialize the HCD code.
+//!
+//! \param ui32Index specifies which USB controller to use.
+//! \param pvPool is a pointer to the data to use as a memory pool for this
+//! controller.
+//! \param ui32PoolSize is the size in bytes of the buffer passed in as
+//! \e pvPool.
+//!
+//! This function will perform all the necessary operations to allow the USB
+//! host controller to begin enumeration and communication with devices.  This
+//! function should typically be called once at the start of an application
+//! once all of the device and class drivers are ready for normal operation.
+//! This call will start up the USB host controller and any connected device
+//! will immediately start the enumeration sequence.
+//!
+//! The USBStackModeSet() function can be called with eUSBModeHost in order to
+//! cause the USB library to force the USB operating mode to a host controller.
+//! This allows the application to used the USBVBUS and USBID pins as GPIOs on
+//! devices that support forcing OTG to operate as a host only controller.  By
+//! default the USB library will assume that the USBVBUS and USBID pins are
+//! configured as USB pins and not GPIOs.
+//!
+//! The memory pool passed to this function must be at least as large as a
+//! typical configuration descriptor for devices that are to be supported.
+//! This value is application-dependent however it should never be less than 32
+//! bytes and, in most cases, should be at least 64 bytes.  If there is not
+//! sufficient memory to load a configuration descriptor from a device, the
+//! device will not be recognized by the USB library's host controller driver.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBHCDInit(uint32_t ui32Index, void *pvPool, uint32_t ui32PoolSize)
+{
+    int32_t i32Driver;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(ui32Index == 0);
+
+    //
+    // Make sure there is at least enough to read the configuration descriptor.
+    //
+    ASSERT(ui32PoolSize >= sizeof(tConfigDescriptor));
+
+    //
+    // Should not call this if the stack is in device mode.
+    //
+    ASSERT(g_iUSBMode != eUSBModeDevice);
+    ASSERT(g_iUSBMode != eUSBModeForceDevice);
+
+    //
+    // If the mode was not set then default to eUSBModeHost.
+    //
+    if(g_iUSBMode == eUSBModeNone)
+    {
+        g_iUSBMode = eUSBModeHost;
+    }
+
+    //
+    // Reset the USB controller.
+    //
+    MAP_SysCtlPeripheralReset(SYSCTL_PERIPH_USB0);
+
+    //
+    // Enable Clocking to the USB controller.
+    //
+    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_USB0);
+
+    //
+    // Turn on USB Phy clock.
+    //
+    MAP_SysCtlUSBPLLEnable();
+
+    //
+    // Set the PLL to USB clock divider.
+    //
+    if(g_ui32PLLDiv == 0)
+    {
+        USBClockEnable(USB0_BASE, g_ui32PLLDiv, USB_CLOCK_EXTERNAL);
+    }
+    else
+    {
+        USBClockEnable(USB0_BASE, g_ui32PLLDiv, USB_CLOCK_INTERNAL);
+    }
+
+    //
+    // Configure ULPI support.
+    //
+    if(g_ui32ULPISupport != USBLIB_FEATURE_ULPI_NONE)
+    {
+        USBULPIEnable(USB0_BASE);
+
+        if(g_ui32ULPISupport & USBLIB_FEATURE_ULPI_HS)
+        {
+            ULPIConfigSet(USB0_BASE, ULPI_CFG_HS);
+        }
+        else
+        {
+            ULPIConfigSet(USB0_BASE, ULPI_CFG_FS);
+        }
+    }
+    else
+    {
+        USBULPIDisable(USB0_BASE);
+    }
+
+    //
+    // If the application not requesting OTG mode then set the mode to forced
+    // host mode.  If the mode is actually eUSBModeHost, this will be switched
+    // off when ID pin detection is complete and the ID is no longer in use.
+    //
+    if(g_iUSBMode != eUSBModeOTG)
+    {
+        //
+        // Force Host mode on devices that support force host mode.
+        //
+        MAP_USBHostMode(USB0_BASE);
+    }
+
+    //
+    // Call our internal function to perform the initialization.
+    //
+    USBHCDInitInternal(ui32Index, pvPool, ui32PoolSize);
+
+    //
+    // No event driver is present by default.
+    //
+    g_sUSBHCD.i32EventDriver = -1;
+
+    //
+    // Search through the Host Class driver list for the devices class.
+    //
+    for(i32Driver = 0; i32Driver < g_sUSBHCD.ui32NumClassDrivers; i32Driver++)
+    {
+        if(g_sUSBHCD.ppsClassDrivers[i32Driver]->ui32InterfaceClass ==
+           USB_CLASS_EVENTS)
+        {
+            //
+            // Event driver was found so remember it.
+            //
+            g_sUSBHCD.i32EventDriver = i32Driver;
+        }
+    }
+
+    //
+    // Get the number of ticks per millisecond, this is only used by blocking
+    // delays using the SysCtlDelay() function.
+    //
+    if(g_ui32Tickms == 0)
+    {
+        if(CLASS_IS_TM4C129)
+        {
+            g_ui32Tickms = 120000000 / 3000;
+        }
+        else
+        {
+            g_ui32Tickms = 80000000 / 3000;
+        }
+    }
+}
+
+//*****************************************************************************
+//
+//! This function is used to initialize the HCD class driver list.
+//!
+//! \param ui32Index specifies which USB controller to use.
+//! \param ppsHClassDrvs is an array of host class drivers that are
+//! supported on this controller.
+//! \param ui32NumDrivers is the number of entries in the \e pHostClassDrivers
+//! array.
+//!
+//! This function will set the host classes supported by the host controller
+//! specified by the \e ui32Index parameter.  This function should be called
+//! before enabling the host controller driver with the USBHCDInit() function.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBHCDRegisterDrivers(uint32_t ui32Index,
+                      const tUSBHostClassDriver * const *ppsHClassDrvs,
+                      uint32_t ui32NumDrivers)
+{
+    ASSERT(ui32Index == 0);
+
+    //
+    // Save the class drivers.
+    //
+    g_sUSBHCD.ppsClassDrivers = ppsHClassDrvs;
+
+    //
+    // Save the number of class drivers.
+    //
+    g_sUSBHCD.ui32NumClassDrivers = ui32NumDrivers;
+}
+
+//*****************************************************************************
+//
+//! This function is used to terminate the HCD code.
+//!
+//! \param ui32Index specifies which USB controller to release.
+//!
+//! This function will clean up the USB host controller and disable it in
+//! preparation for shutdown or a switch to USB device mode.  Once this call is
+//! made, \e USBHCDInit() may be called to reinitialize the controller and
+//! prepare for host mode operation.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBHCDTerm(uint32_t ui32Index)
+{
+    int32_t i32Idx;
+
+    ASSERT(ui32Index == 0);
+
+    //
+    // End the session.
+    //
+    USBOTGSessionRequest(USB0_BASE, false);
+
+    //
+    // Remove power from the USB bus.
+    //
+    MAP_USBHostPwrDisable(USB0_BASE);
+
+    //
+    // Disable USB interrupts.
+    //
+    OS_INT_DISABLE(g_sUSBHCD.ui32IntNum);
+
+    MAP_USBIntDisableControl(USB0_BASE, USB_INTCTRL_ALL);
+
+    MAP_USBIntDisableEndpoint(USB0_BASE, USB_INTEP_ALL);
+
+    //
+    // Set the host controller state back to it's initial values.
+    //
+    for(i32Idx = 0; i32Idx < MAX_NUM_PIPES; i32Idx++)
+    {
+        g_sUSBHCD.psUSBINPipes[i32Idx].ui32Type = USBHCD_PIPE_UNUSED;
+        g_sUSBHCD.psUSBOUTPipes[i32Idx].ui32Type = USBHCD_PIPE_UNUSED;
+    }
+
+    //
+    // Free the memory used by the configuration descriptor.
+    //
+    ConfigDescFree(&g_sUSBHCD.psUSBDevice[0]);
+
+    g_sUSBHCD.piDeviceState[0] = eHCDIdle;
+    g_sUSBHCD.psUSBDevice[0].psConfigDescriptor = 0;
+    g_sUSBHCD.psUSBDevice[0].bConfigRead = false;
+    g_sUSBHCD.psUSBDevice[0].sDeviceDescriptor.bLength = 0;
+    g_sUSBHCD.psUSBDevice[0].sDeviceDescriptor.bMaxPacketSize0 = 0;
+    g_sUSBHCD.psUSBDevice[0].ui32Address = 0;
+    g_sUSBHCD.psUSBDevice[0].ui32Interface = 0;
+    g_sUSBHCD.pvPool = 0;
+    g_sUSBHCD.ui32PoolSize = 0;
+}
+
+//*****************************************************************************
+//
+//! This function generates reset signaling on the USB bus.
+//!
+//! \param ui32Index specifies which USB controller to use.
+//!
+//! This function handles sending out reset signaling on the USB bus.  After
+//! returning from this function, any attached device on the USB bus should
+//! have returned to it's reset state.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBHCDReset(uint32_t ui32Index)
+{
+    ASSERT(ui32Index == 0);
+
+    //
+    // Start the reset signaling.
+    //
+    MAP_USBHostReset(USB0_BASE, 1);
+
+    //
+    // Wait 20ms
+    //
+    OS_DELAY(g_ui32Tickms * 20);
+
+    //
+    // End reset signaling on the bus.
+    //
+    MAP_USBHostReset(USB0_BASE, 0);
+
+    //
+    // Need to wait at least 10ms to let the device recover from
+    // the reset.  This is the delay specified in the USB 2.0 spec.
+    // We will hold the reset for 20ms.
+    //
+    OS_DELAY(g_ui32Tickms * 20);
+}
+
+//*****************************************************************************
+//
+//! This function will generate suspend signaling on the USB bus.
+//!
+//! \param ui32Index specifies which USB controller to use.
+//!
+//! This function is used to generate suspend signaling on the USB bus.  In
+//! order to leave the suspended state, the application should call
+//! USBHCDResume().
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBHCDSuspend(uint32_t ui32Index)
+{
+    ASSERT(ui32Index == 0);
+
+    //
+    // Start the suspend signaling.
+    //
+    MAP_USBHostSuspend(USB0_BASE);
+}
+
+//*****************************************************************************
+//
+//! This function will generate resume signaling on the USB bus.
+//!
+//! \param ui32Index specifies which USB controller to use.
+//!
+//! This function is used to generate resume signaling on the USB bus in order
+//! to cause  USB devices to leave their suspended state.  This call should
+//! not be made unless a preceding call to USBHCDSuspend() has been made.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBHCDResume(uint32_t ui32Index)
+{
+    ASSERT(ui32Index == 0);
+
+    //
+    // Start the resume signaling.
+    //
+    MAP_USBHostResume(USB0_BASE, 1);
+
+    //
+    // Wait 100ms
+    //
+    OS_DELAY(g_ui32Tickms * 100);
+
+    //
+    // End reset signaling on the bus.
+    //
+    MAP_USBHostResume(USB0_BASE, 0);
+}
+
+//*****************************************************************************
+//
+//! This function issues a request for the current configuration descriptor
+//! from a device.
+//!
+//! \param ui32Index specifies which USB controller to use.
+//! \param psDevice is a pointer to the device structure that holds the buffer
+//! to store the configuration descriptor.
+//!
+//! This function will request the configuration descriptor from the device.
+//! The \e psDevice->ConfigDescriptor member variable is used to hold the data
+//! for this request.  This buffer will be allocated from the pool provided by
+//! the HCDInit() function.  \e psDevice->sDeviceDescriptor.bMaxPacketSize0
+//! should be valid prior to this call in order to correctly receive the
+//! configuration descriptor.  If this variable is not valid then this call
+//! will not return accurate data.
+//!
+//! \return The number of bytes returned due to the request.  This value can be
+//! zero if the device did not respond.
+//
+//*****************************************************************************
+static uint32_t
+USBHCDGetConfigDescriptor(uint32_t ui32Index, tUSBHostDevice *psDevice)
+{
+    tUSBRequest sSetupPacket;
+    uint32_t ui32Bytes;
+    tConfigDescriptor sConfigDescriptor;
+
+    ASSERT(ui32Index == 0);
+
+    ui32Bytes = 0;
+
+    //
+    // This is a Standard Device IN request.
+    //
+    sSetupPacket.bmRequestType =
+        USB_RTYPE_DIR_IN | USB_RTYPE_STANDARD | USB_RTYPE_DEVICE;
+
+    //
+    // Request a Device Descriptor.
+    //
+    sSetupPacket.bRequest = USBREQ_GET_DESCRIPTOR;
+    sSetupPacket.wValue = USB_DTYPE_CONFIGURATION << 8;
+
+    //
+    // Index is always 0 for device configurations requests.
+    //
+    sSetupPacket.wIndex = 0;
+
+    //
+    // Only ask for the configuration header first to see how big the
+    // whole thing is.
+    //
+    if(!psDevice->bConfigRead)
+    {
+        //
+        // Only request the space available.
+        //
+        sSetupPacket.wLength = sizeof(tConfigDescriptor);
+
+        //
+        // Put the setup packet in the buffer.
+        //
+        ui32Bytes =
+            USBHCDControlTransfer(0, &sSetupPacket, psDevice,
+                                  (uint8_t *)&sConfigDescriptor,
+                                  sizeof(tConfigDescriptor),
+                                  psDevice->sDeviceDescriptor.bMaxPacketSize0);
+    }
+
+    //
+    // If the Configuration header was successfully returned then get the
+    // full configuration descriptor.
+    //
+    if(ui32Bytes == sizeof(tConfigDescriptor))
+    {
+        //
+        // Save the total size and request the full configuration descriptor.
+        //
+        sSetupPacket.wLength = sConfigDescriptor.wTotalLength;
+
+        //
+        // Not enough space to hold this configuration descriptor.
+        //
+        if(ConfigDescAlloc(psDevice, sConfigDescriptor.wTotalLength) == 0)
+        {
+            return(0);
+        }
+
+        //
+        // Don't allow the buffer to be larger than was allocated.
+        //
+        if(sSetupPacket.wLength > psDevice->ui32ConfigDescriptorSize)
+        {
+            return(0);
+        }
+
+        //
+        // Put the setup packet in the buffer.
+        //
+        ui32Bytes =
+            USBHCDControlTransfer(0, &sSetupPacket, psDevice,
+                                  (uint8_t *)psDevice->psConfigDescriptor,
+                                  sSetupPacket.wLength,
+                                  psDevice->sDeviceDescriptor.bMaxPacketSize0);
+
+        //
+        // If we read the descriptor, remember the fact.
+        //
+        if(ui32Bytes)
+        {
+            psDevice->bConfigRead = true;
+        }
+    }
+
+    return(ui32Bytes);
+}
+
+//*****************************************************************************
+//
+//! This function issues a request for a device descriptor from a device.
+//!
+//! \param ui32Index specifies which USB controller to use.
+//! \param psDevice is a pointer to the device structure that holds the buffer
+//! to store the device descriptor into.
+//!
+//! This function will request the device descriptor from the device.  The
+//! \e psDevice->sDeviceDescriptor descriptor is used to hold the data for this
+//! request.  \e psDevice->sDeviceDescriptor.bMaxPacketSize0 should be
+//! initialized to zero or to the valid maximum packet size if it is known.  If
+//! this variable is not set to zero, then this call will determine the maximum
+//! packet size for endpoint 0 and save it in the structure member
+//! bMaxPacketSize0.
+//!
+//! \return The number of bytes returned due to the request.  This value can be
+//! zero if the device did not respond.
+//
+//*****************************************************************************
+static uint32_t
+USBHCDGetDeviceDescriptor(uint32_t ui32Index, tUSBHostDevice *psDevice)
+{
+    tUSBRequest sSetupPacket;
+    uint32_t ui32Bytes;
+
+    ASSERT(ui32Index == 0);
+
+    //
+    // This is a Standard Device IN request.
+    //
+    sSetupPacket.bmRequestType =
+        USB_RTYPE_DIR_IN | USB_RTYPE_STANDARD | USB_RTYPE_DEVICE;
+
+    //
+    // Request a Device Descriptor.
+    //
+    sSetupPacket.bRequest = USBREQ_GET_DESCRIPTOR;
+    sSetupPacket.wValue = USB_DTYPE_DEVICE << 8;
+
+    //
+    // Index is always 0 for device requests.
+    //
+    sSetupPacket.wIndex = 0;
+
+    //
+    // All devices must have at least an 8 byte max packet size so just ask
+    // for 8 bytes to start with.
+    //
+    sSetupPacket.wLength = sizeof(tDeviceDescriptor);
+
+    ui32Bytes = 0;
+
+    //
+    // Discover the max packet size for endpoint 0.
+    //
+    if(psDevice->sDeviceDescriptor.bMaxPacketSize0 == 0)
+    {
+        //
+        // Put the setup packet in the buffer.
+        //
+        ui32Bytes =
+            USBHCDControlTransfer(ui32Index, &sSetupPacket, psDevice,
+                                  (uint8_t *)&(psDevice->sDeviceDescriptor),
+                                  sizeof(tDeviceDescriptor), 8);
+    }
+
+    //
+    // Now get the full descriptor now that the actual maximum packet size
+    // is known.
+    //
+    if(ui32Bytes < sizeof(tDeviceDescriptor))
+    {
+        sSetupPacket.wLength = (uint16_t)sizeof(tDeviceDescriptor);
+
+        ui32Bytes =
+            USBHCDControlTransfer(ui32Index, &sSetupPacket, psDevice,
+                                  (uint8_t *)&(psDevice->sDeviceDescriptor),
+                                  sizeof(tDeviceDescriptor),
+                                  psDevice->sDeviceDescriptor.bMaxPacketSize0);
+    }
+
+    return(ui32Bytes);
+}
+
+//*****************************************************************************
+//
+//! This function issues a request for a string descriptor from a device.
+//!
+//! \param psDevice is the device for this request.
+//! \param pui8Buffer is the pointer to the buffer to store the requested
+//! string descriptor.
+//! \param ui32Size is the size of the buffer passed in the buffer that will
+//! be used for this request.
+//! \param ui32LangID is the ID of the language for the requested string.
+//! \param ui32StringIndex is the index for the request.
+//!
+//! This function will request a string descriptor from the device of the type
+//! specified in the \e ui32DescriptorType parameter.  The \e pui8Descriptor
+//! pointer is the location where the request results will be stored.  The
+//! \e ui32Size should be passed in to indicate the size of the
+//! \e pui8Descriptor buffer.  The \e ui32DevAddress parameter is used to
+//! specify the device address to communicate with on the USB bus.  This value
+//! should be specified as 0 for any non-configured device on the USB bus and
+//! be changed to the address set by a call to USBHCDSetAddress().
+//!
+//! \return The number of bytes returned in the \e pui8Buffer due to the
+//! request.  This value can be zero if the device did not respond.
+//
+//*****************************************************************************
+uint32_t
+USBHCDStringDescriptorGet(tUSBHostDevice *psDevice, uint8_t *pui8Buffer,
+                          uint32_t ui32Size, uint32_t ui32LangID,
+                          uint32_t ui32StringIndex)
+{
+    uint32_t ui32BytesReturned;
+    tUSBRequest sSetupPacket;
+
+    //
+    // Default the number of bytes to zero.
+    //
+    ui32BytesReturned = 0;
+
+    //
+    // This is a Standard Device IN request.
+    //
+    sSetupPacket.bmRequestType =
+        USB_RTYPE_DIR_IN | USB_RTYPE_STANDARD | USB_RTYPE_DEVICE;
+
+    //
+    // Request a Device Descriptor.
+    //
+    sSetupPacket.bRequest = USBREQ_GET_DESCRIPTOR;
+
+    //
+    // Request for a string descriptor.
+    //
+    sSetupPacket.wValue = (USB_DTYPE_STRING << 8) |
+                         (uint16_t)ui32StringIndex;
+
+    //
+    // Set the language ID.
+    //
+    sSetupPacket.wIndex = ui32LangID;
+
+    //
+    // Only request the space available.
+    //
+    sSetupPacket.wLength = (uint16_t)ui32Size;
+
+    //
+    // Put the setup packet in the buffer.
+    //
+    ui32BytesReturned =
+        USBHCDControlTransfer(0, &sSetupPacket, psDevice, pui8Buffer, ui32Size,
+                              psDevice->sDeviceDescriptor.bMaxPacketSize0);
+
+    //
+    // Return the number of bytes in the string.
+    //
+    return(ui32BytesReturned);
+}
+
+//*****************************************************************************
+//
+//! This function is used to send the set address command to a device.
+//!
+//! \param ui32DevIndex is the index of the device whose address is to be
+//! set.  This value must be 0 to indicate that the device is connected
+//! directly to the host controller.  Higher values indicate devices connected
+//!  via a hub.
+//! \param ui32DevAddress is the new device address to use for a device.
+//!
+//! The USBHCDSetAddress() function is used to set the USB device address, once
+//! a device has been discovered on the bus.  This call is typically issued
+//! following a USB reset triggered by a call the USBHCDReset().  The
+//! address passed into this function via the \e ui32DevAddress parameter is
+//! used for all further communications with the device after this function
+//! returns.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBHCDSetAddress(uint32_t ui32DevIndex, uint32_t ui32DevAddress)
+{
+    tUSBRequest sSetupPacket;
+
+    //
+    // This is a Standard Device OUT request.
+    //
+    sSetupPacket.bmRequestType =
+        USB_RTYPE_DIR_OUT | USB_RTYPE_STANDARD | USB_RTYPE_DEVICE;
+
+    //
+    // Request a Device Descriptor.
+    //
+    sSetupPacket.bRequest = USBREQ_SET_ADDRESS;
+    sSetupPacket.wValue = ui32DevAddress;
+
+    //
+    // Index is always 0 for device requests.
+    //
+    sSetupPacket.wIndex = 0;
+
+    //
+    // Only request the space available.
+    //
+    sSetupPacket.wLength = 0;
+
+    //
+    // Put the setup packet in the buffer.
+    //
+    USBHCDControlTransfer(0, &sSetupPacket,
+                          &g_sUSBHCD.psUSBDevice[ui32DevIndex], 0,
+                          0, MAX_PACKET_SIZE_EP0);
+
+    //
+    // Must delay 2ms after setting the address.
+    //
+    OS_DELAY(g_ui32Tickms * 2);
+}
+
+//*****************************************************************************
+//
+//! This function is used to send a Clear Feature request to a device.
+//!
+//! \param ui32DevAddress is the USB bus address of the device that will
+//! receive this request.
+//! \param ui32Pipe is the pipe that will be used to send the request.
+//! \param ui32Feature is one of the USB_FEATURE_* definitions.
+//!
+//! This function will issue a Clear Feature request to the device indicated
+//! by the \e ui32DevAddress parameter.  The \e ui32Pipe parameter is the USB
+//! pipe that should be used to send this request.  The \e ui32Feature
+//! parameter should be one of the following values:
+//!
+//! * \b USB_FEATURE_EP_HALT is used to end a HALT condition on a devices
+//!   endpoint.
+//! * \b USB_FEATURE_REMOTE_WAKE is used to disable a device's remote wake
+//!   feature.
+//! * \b USB_FEATURE_TEST_MODE is used take the USB device out of test mode.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBHCDClearFeature(uint32_t ui32DevAddress, uint32_t ui32Pipe,
+                   uint32_t ui32Feature)
+{
+    tUSBRequest sSetupPacket;
+    uint32_t ui32Index;
+
+    //
+    // Get the index number from the allocated pipe.
+    //
+    ui32Index = (ui32Pipe & EP_PIPE_IDX_M);
+
+    //
+    // This is a Standard Device OUT request.
+    //
+    sSetupPacket.bmRequestType =
+        USB_RTYPE_DIR_OUT | USB_RTYPE_STANDARD | USB_RTYPE_ENDPOINT;
+
+    //
+    // Request a Device Descriptor.
+    //
+    sSetupPacket.bRequest = USBREQ_CLEAR_FEATURE;
+    sSetupPacket.wValue = ui32Feature;
+
+    //
+    // Set the endpoint to access.
+    //
+    if(ui32Pipe & EP_PIPE_TYPE_IN)
+    {
+        sSetupPacket.wIndex = g_sUSBHCD.psUSBINPipes[ui32Index].ui8EPNumber |
+                              0x80;
+    }
+    else
+    {
+        sSetupPacket.wIndex = g_sUSBHCD.psUSBOUTPipes[ui32Index].ui8EPNumber;
+    }
+
+    //
+    // This is always 0.
+    //
+    sSetupPacket.wLength = 0;
+
+    //
+    // Put the setup packet in the buffer.
+    //
+    USBHCDControlTransfer(0, &sSetupPacket,
+                          &g_sUSBHCD.psUSBDevice[ui32DevAddress - 1], 0, 0,
+                          MAX_PACKET_SIZE_EP0);
+
+    //
+    // Set the endpoint to access.
+    //
+    if(ui32Pipe & EP_PIPE_TYPE_IN)
+    {
+        MAP_USBEndpointDataToggleClear(USB0_BASE,
+                                       IndexToUSBEP(ui32Index + 1),
+                                       USB_EP_HOST_IN);
+    }
+    else
+    {
+        MAP_USBEndpointDataToggleClear(USB0_BASE,
+                                       IndexToUSBEP(ui32Index + 1),
+                                       USB_EP_HOST_OUT);
+    }
+
+    //
+    // Must delay 2ms after clearing the feature.
+    //
+    OS_DELAY(g_ui32Tickms * 2);
+}
+
+//*****************************************************************************
+//
+//! This function is used to set the current configuration for a device.
+//!
+//! \param ui32Index specifies which USB controller to use.
+//! \param ui32Device is the USB device for this function.
+//! \param ui32Configuration is one of the devices valid configurations.
+//!
+//! This function is used to set the current device configuration for a USB
+//! device.  The \e ui32Configuration value must be one of the configuration
+//! indexes that was returned in the configuration descriptor from the device,
+//! or a value of 0.  If 0 is passed in, the device will return to it's
+//! addressed state and no longer be in a configured state.  If the value is
+//! non-zero then the device will change to the requested configuration.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBHCDSetConfig(uint32_t ui32Index, uint32_t ui32Device,
+                uint32_t ui32Configuration)
+{
+    tUSBRequest sSetupPacket;
+    tUSBHostDevice *psDevice;
+
+    ASSERT(ui32Index == 0);
+
+    psDevice = (tUSBHostDevice *)ui32Device;
+
+    //
+    // This is a Standard Device OUT request.
+    //
+    sSetupPacket.bmRequestType =
+        USB_RTYPE_DIR_OUT | USB_RTYPE_STANDARD | USB_RTYPE_DEVICE;
+
+    //
+    // Request a Device Descriptor.
+    //
+    sSetupPacket.bRequest = USBREQ_SET_CONFIG;
+    sSetupPacket.wValue = ui32Configuration;
+
+    //
+    // Index is always 0 for device requests.
+    //
+    sSetupPacket.wIndex = 0;
+
+    //
+    // Only request the space available.
+    //
+    sSetupPacket.wLength = 0;
+
+    //
+    // Put the setup packet in the buffer.
+    //
+    USBHCDControlTransfer(0, &sSetupPacket, psDevice, 0, 0,
+                          MAX_PACKET_SIZE_EP0);
+}
+
+//*****************************************************************************
+//
+//! This function is used to set the current interface and alternate setting
+//! for an interface on a device.
+//!
+//! \param ui32Index specifies which USB controller to use.
+//! \param ui32Device is the USB device for this function.
+//! \param ui32Interface is one of the valid interface numbers for a device.
+//! \param ui32AltSetting is one of the valid alternate interfaces for the
+//! \e ui32Interface number.
+//!
+//! This function is used to change the alternate setting for one of the valid
+//! interfaces on a USB device.  The \e ui32Device specifies the device
+//! instance that was returned when the device was connected.  This call will
+//! set the USB device's interface based on the \e ui32Interface and
+//! \e ui32AltSetting.
+//!
+//! \b Example: Set the USB device interface 2 to alternate setting 1.
+//!
+//! \verbatim
+//! USBHCDSetInterface(0, ui32Device, 2, 1);
+//! \endverbatim
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBHCDSetInterface(uint32_t ui32Index, uint32_t ui32Device,
+                   uint32_t ui32Interface, uint32_t ui32AltSetting)
+{
+    tUSBRequest sSetupPacket;
+    tUSBHostDevice *psDevice;
+
+    ASSERT(ui32Index == 0);
+
+    psDevice = (tUSBHostDevice *)ui32Device;
+
+    //
+    // This is a Standard Device OUT request.
+    //
+    sSetupPacket.bmRequestType =
+        USB_RTYPE_DIR_OUT | USB_RTYPE_STANDARD | USB_RTYPE_INTERFACE;
+
+    //
+    // Request a Device Descriptor.
+    //
+    sSetupPacket.bRequest = USBREQ_SET_INTERFACE;
+
+    //
+    // Index is the interface to access.
+    //
+    sSetupPacket.wIndex = ui32Interface;
+
+    //
+    // wValue is the alternate setting.
+    //
+    sSetupPacket.wValue = ui32AltSetting;
+
+
+    //
+    // Only request the space available.
+    //
+    sSetupPacket.wLength = 0;
+
+    //
+    // Put the setup packet in the buffer.
+    //
+    USBHCDControlTransfer(0, &sSetupPacket, psDevice, 0, 0,
+                          MAX_PACKET_SIZE_EP0);
+}
+
+//*****************************************************************************
+//
+// The internal function to see if a new schedule event should occur.
+//
+// This function is called by the main interrupt handler due to start of frame
+// interrupts to determine if a new scheduler event should be sent to the USB
+// pipe.
+//
+// \return None.
+//
+//*****************************************************************************
+void
+USBHostCheckPipes(void)
+{
+    int32_t i32Idx;
+
+    g_ui32CurrentTick++;
+
+    for(i32Idx = 0; i32Idx < g_sUSBHCD.ui32NumEndpoints; i32Idx++)
+    {
+        //
+        // Skip unused pipes.
+        //
+        if(g_sUSBHCD.psUSBINPipes[i32Idx].ui32Type == USBHCD_PIPE_UNUSED)
+        {
+            continue;
+        }
+
+        //
+        // If the tick has expired and it has an interval then update it.
+        //
+        if((g_sUSBHCD.psUSBINPipes[i32Idx].ui32Interval != 0) &&
+           (g_sUSBHCD.psUSBINPipes[i32Idx].ui32NextEventTick ==
+            g_ui32CurrentTick))
+        {
+            //
+            // Schedule the next event.
+            //
+            g_sUSBHCD.psUSBINPipes[i32Idx].ui32NextEventTick +=
+                g_sUSBHCD.psUSBINPipes[i32Idx].ui32Interval;
+
+            //
+            // If the pipe is IDLE and there is a callback, let the higher
+            // level drivers know that a new transfer can be scheduled.
+            //
+            if((g_sUSBHCD.psUSBINPipes[i32Idx].iState == ePipeIdle) &&
+               (g_sUSBHCD.psUSBINPipes[i32Idx].pfnCallback))
+            {
+                g_sUSBHCD.psUSBINPipes[i32Idx].pfnCallback(
+                                                        IN_PIPE_HANDLE(i32Idx),
+                                                        USB_EVENT_SCHEDULER);
+            }
+        }
+    }
+}
+
+//*****************************************************************************
+//
+// The internal USB host mode interrupt handler.
+//
+// \param ui32Index is the USB controller associated with this interrupt.
+// \param ui32Status is the current interrupt status as read via a call to
+// \e USBIntStatusControl().
+//
+// This the main USB interrupt handler called when operating in host mode.
+// This handler will branch the interrupt off to the appropriate handlers
+// depending on the current status of the USB controller.
+//
+// The two-tiered structure for the interrupt handler ensures that it is
+// possible to use the same handler code in both host and OTG modes and
+// means that device code can be excluded from applications that only require
+// support for USB host mode operation.
+//
+// \return None.
+//
+//*****************************************************************************
+void
+USBHostIntHandlerInternal(uint32_t ui32Index, uint32_t ui32Status)
+{
+    uint32_t ui32EPStatus, ui32DMAIntStatus, ui32Idx, ui32DevIndex;
+    static uint32_t ui32SOFDivide = 0;
+    int32_t i32ClassDrvr;
+
+    //
+    // By default, assume we are dealing with the device directly connected
+    // to the host controller and that we need to notify its class driver of
+    // this interrupt.
+    //
+    g_sUSBHCD.psUSBDevice[0].ui32Flags |= USBHDEV_FLAG_NOTIFYINT;
+
+    if(ui32Status & USB_INTCTRL_SOF)
+    {
+        //
+        // Indicate that a start of frame has occurred.
+        //
+        g_sUSBHCD.ui32IntEvents |= INT_EVENT_SOF;
+    }
+
+    //
+    // A power fault has occurred so notify the application.
+    //
+    if(ui32Status & USB_INTCTRL_POWER_FAULT)
+    {
+        //
+        // Indicate that a power fault has occurred.
+        //
+        g_sUSBHCD.ui32IntEvents |= INT_EVENT_POWER_FAULT;
+
+        //
+        // Turn off power to the bus.
+        //
+        MAP_USBHostPwrDisable(USB0_BASE);
+
+        //
+        // Disable USB interrupts.
+        //
+        OS_INT_DISABLE(g_sUSBHCD.ui32IntNum);
+
+        return;
+    }
+
+    //
+    // In the event of a USB VBUS error, end the session and remove power to
+    // the device.
+    //
+    if(ui32Status & USB_INTCTRL_VBUS_ERR)
+    {
+        //
+        // Set the VBUS error event.  We deliberately clear all other events
+        // since this one means anything else that is outstanding is
+        // irrelevant.
+        //
+        g_sUSBHCD.ui32IntEvents = INT_EVENT_VBUS_ERR;
+        return;
+    }
+
+    //
+    // Received a reset from the host.
+    //
+    if(ui32Status & USB_INTCTRL_BABBLE)
+    {
+    }
+
+    //
+    // Suspend was signaled on the bus.
+    //
+    if(ui32Status & USB_INTCTRL_SUSPEND)
+    {
+    }
+
+    //
+    // Start the session.
+    //
+    if(ui32Status & USB_INTCTRL_SESSION)
+    {
+        //
+        // Power the USB bus.
+        //
+        MAP_USBHostPwrEnable(USB0_BASE);
+
+        USBOTGSessionRequest(USB0_BASE, true);
+    }
+
+    //
+    // Resume was signaled on the bus.
+    //
+    if(ui32Status & USB_INTCTRL_RESUME)
+    {
+    }
+
+    //
+    // Device connected so tell the main routine to issue a reset.
+    //
+    if(ui32Status & USB_INTCTRL_CONNECT)
+    {
+        //
+        // Set the connect flag and clear disconnect if it happens to be set.
+        //
+        g_sUSBHCD.ui32IntEvents |= INT_EVENT_CONNECT;
+        g_sUSBHCD.ui32IntEvents &= ~INT_EVENT_DISCONNECT;
+
+        //
+        // Power the USB bus.
+        //
+        MAP_USBHostPwrEnable(USB0_BASE);
+    }
+
+    //
+    // Handle the ID detection so that the ID pin can be used as a
+    // GPIO in eUSBModeHost.
+    //
+    if(ui32Status & USB_INTCTRL_MODE_DETECT)
+    {
+        //
+        // If in eUSBModeHost mode then switch back to OTG detection
+        // so that VBUS can be monitored but free up the ID pin.
+        //
+        if(g_iUSBMode == eUSBModeHost)
+        {
+            USBOTGMode(USB0_BASE);
+        }
+    }
+
+    //
+    // Device was unplugged.
+    //
+    if(ui32Status & USB_INTCTRL_DISCONNECT)
+    {
+        //
+        // Set the disconnect flag and clear connect if it happens to be set.
+        //
+        g_sUSBHCD.ui32IntEvents |= INT_EVENT_DISCONNECT;
+        g_sUSBHCD.ui32IntEvents &= ~INT_EVENT_CONNECT;
+    }
+
+    //
+    // Start of Frame was received.
+    //
+    if(ui32Status & USB_INTCTRL_SOF)
+    {
+        //
+        // Increment the global Start of Frame counter.
+        //
+        g_ui32USBSOFCount++;
+
+        //
+        // Increment our SOF divider.
+        //
+        ui32SOFDivide++;
+
+        //
+        // Have we counted enough SOFs to allow us to call the tick function?
+        //
+        if(ui32SOFDivide == USB_SOF_TICK_DIVIDE)
+        {
+            //
+            // Yes - reset the divider and call the SOF tick handler.
+            //
+            ui32SOFDivide = 0;
+            InternalUSBStartOfFrameTick(USB_SOF_TICK_DIVIDE);
+        }
+    }
+
+    //
+    // Handle the LPM interrupt
+    //
+    ui32Status = USBLPMIntStatus(USB0_BASE);
+
+    if(ui32Status)
+    {
+        //
+        // Set the LPM interrupt event and clear the pending event.
+        //
+        g_sUSBHCD.ui32IntEvents |= INT_EVENT_LPM;
+        g_sUSBHCD.ui32IntEvents &= ~INT_EVENT_LPM_PEND;
+
+        //
+        // Anything other than and acknowledge means that the transfer
+        // was not complete for some reason.
+        //
+        for(ui32Idx = 0; ui32Idx < (MAX_USB_DEVICES + 1); ui32Idx++)
+        {
+            if((ui32Status != USB_INTLPM_ACK) &&
+               (g_sUSBHCD.psUSBDevice[ui32Idx].ui32Flags &
+                USBHDEV_FLAG_LPMPEND))
+            {
+                g_sUSBHCD.psUSBDevice[ui32Idx].ui32Flags |=
+                                                        USBHDEV_FLAG_LPMERROR;
+            }
+            g_sUSBHCD.psUSBDevice[ui32Idx].ui32Flags &= ~USBHDEV_FLAG_LPMPEND;
+        }
+    }
+
+    //
+    // Check to see if any DMA transfers are pending
+    //
+    ui32DMAIntStatus = USBLibDMAIntStatus(g_sUSBHCD.psDMAInstance);
+
+    if(ui32DMAIntStatus)
+    {
+        //
+        // Handle any DMA interrupt processing.
+        //
+        USBLibDMAIntHandler(g_sUSBHCD.psDMAInstance, ui32DMAIntStatus);
+
+        for(ui32Idx = 0; ui32Idx < MAX_NUM_PIPES; ui32Idx++)
+        {
+            if((g_sUSBHCD.psUSBINPipes[ui32Idx].iState == ePipeReadDMAWait) ||
+               (g_sUSBHCD.psUSBINPipes[ui32Idx].iState == ePipeReadDMA))
+            {
+                //
+                // If the DMA channel transfer is complete, send an ack.
+                //
+                if(USBLibDMAChannelStatus(g_sUSBHCD.psDMAInstance,
+                       g_sUSBHCD.psUSBINPipes[ui32Idx].ui8DMAChannel) ==
+                   USBLIBSTATUS_DMA_COMPLETE)
+                {
+                    //
+                    // Acknowledge the IN request.
+                    //
+                    MAP_USBHostEndpointDataAck(USB0_BASE,
+                                               IndexToUSBEP(ui32Idx + 1));
+
+                    //
+                    // If using uDMA then the endpoint status interrupt will
+                    // not occur.  So process the data ready event here.
+                    //
+                    g_sUSBHCD.psUSBINPipes[ui32Idx].iState = ePipeDataReady;
+
+                    //
+                    // Only call a handler if one is present.
+                    //
+                    if(g_sUSBHCD.psUSBINPipes[ui32Idx].pfnCallback)
+                    {
+                        g_sUSBHCD.psUSBINPipes[ui32Idx].pfnCallback(
+                            IN_PIPE_HANDLE(ui32Idx), USB_EVENT_RX_AVAILABLE);
+                    }
+
+                    //
+                    // Remember that we need to notify this device's class
+                    // driver that an interrupt occurred.
+                    //
+                    g_sUSBHCD.psUSBINPipes[ui32Idx].psDevice->ui32Flags |=
+                                                    USBHDEV_FLAG_NOTIFYINT;
+                }
+            }
+            else if(g_sUSBHCD.psUSBOUTPipes[ui32Idx].iState ==
+                    ePipeWriteDMASend)
+            {
+                //
+                // If the uDMA channel transfer is complete, then tell
+                // the USB controller to go ahead and send the data
+                //
+                if(USBLibDMAChannelStatus(g_sUSBHCD.psDMAInstance,
+                       g_sUSBHCD.psUSBOUTPipes[ui32Idx].ui8DMAChannel) &
+                   USBLIBSTATUS_DMA_COMPLETE)
+                {
+                    MAP_USBEndpointDataSend(USB0_BASE,
+                                            IndexToUSBEP(ui32Idx + 1),
+                                            USB_TRANS_OUT);
+
+                    //
+                    // Now waiting on the final endpoint interrupt.
+                    //
+                    g_sUSBHCD.psUSBOUTPipes[ui32Idx].iState =
+                                                            ePipeWriteDMAWait;
+                }
+            }
+            else if(g_sUSBHCD.psUSBOUTPipes[ui32Idx].iState == ePipeWriteDMA)
+            {
+                //
+                // Data was transmitted successfully.
+                //
+                g_sUSBHCD.psUSBOUTPipes[ui32Idx].iState = ePipeDataSent;
+
+                //
+                // Only call a handler if one is present.
+                //
+                if(g_sUSBHCD.psUSBOUTPipes[ui32Idx].pfnCallback)
+                {
+                    //
+                    // Notify the pipe that its last transaction was completed.
+                    //
+                    g_sUSBHCD.psUSBOUTPipes[ui32Idx].pfnCallback(
+                            OUT_PIPE_HANDLE(ui32Idx),
+                            USB_EVENT_TX_COMPLETE);
+                }
+            }
+        }
+    }
+
+    //
+    // Get the current endpoint interrupt status.
+    //
+    ui32Status = MAP_USBIntStatusEndpoint(USB0_BASE);
+
+    //
+    // Handle end point 0 interrupts.
+    //
+    if(ui32Status & USB_INTEP_0)
+    {
+        //
+        // Indicate that a start of frame has occurred.
+        //
+        g_sUSBHCD.ui32IntEvents |= INT_EVENT_ENUM;
+    }
+
+    for(ui32Idx = 0; ui32Idx < MAX_NUM_PIPES; ui32Idx++)
+    {
+        //
+        // Check the next pipe, the first time through this will clear out
+        // any interrupts dealing with endpoint zero since it was handled
+        // above.
+        //
+        ui32Status >>= 1;
+
+        //
+        // Break out if there are no more pending interrupts.
+        //
+        if(ui32Status == 0)
+        {
+            break;
+        }
+
+        //
+        // Check the status of the receive(IN) pipes.
+        //
+        if(ui32Status & 0x10000)
+        {
+            //
+            // Clear the status flag for the IN Pipe.
+            //
+            ui32Status &= ~0x10000;
+
+            //
+            // Read the status of the endpoint connected to this pipe.
+            //
+            ui32EPStatus = MAP_USBEndpointStatus(USB0_BASE,
+                                               IndexToUSBEP(ui32Idx + 1));
+
+            //
+            // Check if the device stalled the request.
+            //
+            if(ui32EPStatus & USB_HOST_IN_STALL)
+            {
+                //
+                // Clear the stall condition on this endpoint pipe.
+                //
+                MAP_USBHostEndpointStatusClear(USB0_BASE,
+                                               IndexToUSBEP(ui32Idx + 1),
+                                               USB_HOST_IN_STALL);
+
+                //
+                // Save the STALLED state.
+                //
+                g_sUSBHCD.psUSBINPipes[ui32Idx].iState = ePipeStalled;
+
+                //
+                // Notify the pipe that it was stalled.
+                //
+                if(g_sUSBHCD.psUSBINPipes[ui32Idx].pfnCallback)
+                {
+                    g_sUSBHCD.psUSBINPipes[ui32Idx].pfnCallback(
+                                                    IN_PIPE_HANDLE(ui32Idx),
+                                                    USB_EVENT_STALL);
+                }
+            }
+            else if(ui32EPStatus & USB_HOST_IN_ERROR)
+            {
+                //
+                // We can no longer communicate with this device for some
+                // reason.  It may have been disconnected from a hub, for
+                // example.  Merely clear the status and continue.
+                //
+                USBHostEndpointStatusClear(USB0_BASE,
+                                           IndexToUSBEP(ui32Idx + 1),
+                                           USB_HOST_IN_ERROR);
+
+                //
+                // Save the STALLED state.
+                //
+                g_sUSBHCD.psUSBINPipes[ui32Idx].iState = ePipeError;
+
+                //
+                // Notify the pipe that it was stalled.
+                //
+                if(g_sUSBHCD.psUSBINPipes[ui32Idx].pfnCallback)
+                {
+                    g_sUSBHCD.psUSBINPipes[ui32Idx].pfnCallback(
+                                                    IN_PIPE_HANDLE(ui32Idx),
+                                                    USB_EVENT_ERROR);
+                }
+            }
+            //
+            // Handle the case where the pipe is reading a single packet.
+            //
+            else if(g_sUSBHCD.psUSBINPipes[ui32Idx].iState == ePipeReadDMA)
+            {
+                void *pvAddr;
+
+                //
+                // Enable the DMA channel and wait for it to complete.
+                //
+                g_sUSBHCD.psUSBINPipes[ui32Idx].iState = ePipeReadDMAWait;
+
+                pvAddr = USBLibDMAAddrGet(g_sUSBHCD.psDMAInstance,
+                                g_sUSBHCD.psUSBINPipes[ui32Idx].ui8DMAChannel);
+
+                //
+                // Save the amount of data available.
+                //
+                g_sUSBHCD.psUSBINPipes[ui32Idx].ui32DataRead =
+                            USBEndpointDataAvail(USB0_BASE,
+                                                 IndexToUSBEP(ui32Idx + 1));
+
+                //
+                // Only request what is available.
+                //
+                if(g_sUSBHCD.psUSBINPipes[ui32Idx].ui32DataRead <=
+                   g_sUSBHCD.psUSBINPipes[ui32Idx].ui32ReadSize)
+                {
+                    //
+                    // Reset the transfer size.
+                    //
+                    USBLibDMATransfer(g_sUSBHCD.psDMAInstance,
+                                 g_sUSBHCD.psUSBINPipes[ui32Idx].ui8DMAChannel,
+                                 pvAddr,
+                                 g_sUSBHCD.psUSBINPipes[ui32Idx].ui32DataRead);
+                }
+                else
+                {
+                    //
+                    // The transfer size did not change, this leaves some
+                    // data in the FIFO.
+                    //
+                    g_sUSBHCD.psUSBINPipes[ui32Idx].ui32DataRead =
+                            g_sUSBHCD.psUSBINPipes[ui32Idx].ui32ReadSize;
+                }
+
+                USBLibDMAChannelEnable(
+                        g_sUSBHCD.psDMAInstance,
+                        g_sUSBHCD.psUSBINPipes[ui32Idx].ui8DMAChannel);
+            }
+            else if(g_sUSBHCD.psUSBINPipes[ui32Idx].iState == ePipeReading)
+            {
+                //
+                // Data is available.
+                //
+                g_sUSBHCD.psUSBINPipes[ui32Idx].iState = ePipeDataReady;
+
+                //
+                // Read the data out of the USB endpoint interface into the
+                // buffer provided by the caller to USBHCDPipeRead() or
+                // USBHCDPipeSchedule() if a buffer was provided already.
+                //
+                if(g_sUSBHCD.psUSBINPipes[ui32Idx].pui8ReadPtr)
+                {
+                    g_sUSBHCD.psUSBINPipes[ui32Idx].ui32DataRead =
+                                g_sUSBHCD.psUSBINPipes[ui32Idx].ui32ReadSize;
+
+                    USBEndpointDataGet(USB0_BASE, IndexToUSBEP(ui32Idx + 1),
+                                g_sUSBHCD.psUSBINPipes[ui32Idx].pui8ReadPtr,
+                                &g_sUSBHCD.psUSBINPipes[ui32Idx].ui32DataRead);
+                }
+
+                //
+                // Notify the pipe that its last transaction was completed.
+                //
+                if(g_sUSBHCD.psUSBINPipes[ui32Idx].pfnCallback)
+                {
+                    g_sUSBHCD.psUSBINPipes[ui32Idx].pfnCallback(
+                                                    IN_PIPE_HANDLE(ui32Idx),
+                                                    USB_EVENT_RX_AVAILABLE);
+                }
+
+            }
+
+            //
+            // Remember that we need to notify this device's class
+            // driver that an interrupt occurred.
+            //
+            g_sUSBHCD.psUSBINPipes[ui32Idx].psDevice->ui32Flags |=
+                                                    USBHDEV_FLAG_NOTIFYINT;
+        }
+
+        //
+        // Check the status of the transmit(OUT) pipes.
+        //
+        if(ui32Status & 1)
+        {
+            //
+            // Read the status of the endpoint connected to this pipe.
+            //
+            ui32EPStatus = MAP_USBEndpointStatus(USB0_BASE,
+                                               IndexToUSBEP(ui32Idx + 1));
+
+            //
+            // Check if the device stalled the request.
+            //
+            if(ui32EPStatus & USB_HOST_OUT_STALL)
+            {
+                //
+                // Clear the stall condition on this endpoint pipe.
+                //
+                MAP_USBHostEndpointStatusClear(USB0_BASE,
+                                               IndexToUSBEP(ui32Idx + 1),
+                                               USB_HOST_OUT_STALL);
+
+                //
+                // Save the STALLED state.
+                //
+                g_sUSBHCD.psUSBOUTPipes[ui32Idx].iState = ePipeStalled;
+
+                //
+                // Only call a handler if one is present.
+                //
+                if(g_sUSBHCD.psUSBOUTPipes[ui32Idx].pfnCallback)
+                {
+                    //
+                    // Notify the pipe that it was stalled.
+                    //
+                    g_sUSBHCD.psUSBOUTPipes[ui32Idx].pfnCallback(
+                            OUT_PIPE_HANDLE(ui32Idx),
+                            USB_EVENT_STALL);
+                }
+            }
+            else if(ui32EPStatus & USB_HOST_OUT_ERROR)
+            {
+                //
+                // Clear the error condition on this endpoint pipe.
+                //
+                MAP_USBHostEndpointStatusClear(USB0_BASE,
+                                               IndexToUSBEP(ui32Idx + 1),
+                                               USB_HOST_OUT_ERROR);
+
+                //
+                // Save the Pipes error state.
+                //
+                g_sUSBHCD.psUSBOUTPipes[ui32Idx].iState = ePipeError;
+
+                //
+                // Only call a handler if one is present.
+                //
+                if(g_sUSBHCD.psUSBOUTPipes[ui32Idx].pfnCallback)
+                {
+                    //
+                    // Notify the pipe that had an error.
+                    //
+                    g_sUSBHCD.psUSBOUTPipes[ui32Idx].pfnCallback(
+                            OUT_PIPE_HANDLE(ui32Idx),
+                            USB_EVENT_ERROR);
+                }
+            }
+            else if((g_sUSBHCD.psUSBOUTPipes[ui32Idx].iState ==
+                     ePipeWriting) ||
+                    (g_sUSBHCD.psUSBOUTPipes[ui32Idx].iState ==
+                     ePipeWriteDMAWait))
+            {
+                //
+                // Data was transmitted successfully.
+                //
+                g_sUSBHCD.psUSBOUTPipes[ui32Idx].iState = ePipeDataSent;
+
+                //
+                // Only call a handler if one is present.
+                //
+                if(g_sUSBHCD.psUSBOUTPipes[ui32Idx].pfnCallback)
+                {
+                    //
+                    // Notify the pipe that its last transaction was completed.
+                    //
+                    g_sUSBHCD.psUSBOUTPipes[ui32Idx].pfnCallback(
+                            OUT_PIPE_HANDLE(ui32Idx),
+                            USB_EVENT_TX_COMPLETE);
+                }
+            }
+
+            //
+            // Clear the stall condition on this endpoint pipe.
+            //
+            MAP_USBHostEndpointStatusClear(USB0_BASE,
+                                           IndexToUSBEP(ui32Idx + 1),
+                                           ui32EPStatus & USB_HOST_OUT_STATUS);
+            //
+            // Remember that we need to notify this device's class
+            // driver that an interrupt occurred.
+            //
+            if(g_sUSBHCD.psUSBOUTPipes[ui32Idx].psDevice)
+            {
+                g_sUSBHCD.psUSBINPipes[ui32Idx].psDevice->ui32Flags |=
+                                                    USBHDEV_FLAG_NOTIFYINT;
+            }
+        }
+    }
+
+    //
+    // Send back notifications to any class driver whose endpoint required
+    // service during the handler.
+    //
+    for(ui32DevIndex = 0; ui32DevIndex <= MAX_USB_DEVICES; ui32DevIndex++)
+    {
+        //
+        // Which class driver does this device use?
+        //
+        i32ClassDrvr = g_pi32USBHActiveDriver[ui32DevIndex];
+
+        //
+        // If a class driver is in use, and one of its endpoints was serviced
+        // and the class driver has an interrupt callback...
+        //
+        if((i32ClassDrvr >= 0) &&
+           (g_sUSBHCD.psUSBDevice[ui32DevIndex].ui32Flags &
+            USBHDEV_FLAG_NOTIFYINT) &&
+           (g_sUSBHCD.ppsClassDrivers[i32ClassDrvr]->pfnIntHandler))
+        {
+            //
+            // ...call the class driver's interrupt notification callback.
+            //
+            g_sUSBHCD.ppsClassDrivers[i32ClassDrvr]->pfnIntHandler(
+                                            g_ppvDriverInstance[ui32DevIndex]);
+        }
+    }
+}
+
+//*****************************************************************************
+//
+//! The USB host mode interrupt handler for controller index 0.
+//!
+//! This the main USB interrupt handler entry point.  This handler will branch
+//! the interrupt off to the appropriate handlers depending on the current
+//! status of the USB controller.   This function must be placed in the
+//! interrupt table in order for the USB Library host stack to function.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USB0HostIntHandler(void)
+{
+    uint32_t ui32Status;
+
+    //
+    // Get the control interrupt status.
+    //
+    ui32Status = MAP_USBIntStatusControl(USB0_BASE);
+
+    //
+    // Call the internal handler to process the interrupts.
+    //
+    USBHostIntHandlerInternal(0, ui32Status);
+}
+
+//*****************************************************************************
+//
+//! This function opens the class driver.
+//!
+//! \param ui32Index specifies which USB controller to use.
+//! \param ui32DeviceNum is the device number for the driver to load.
+//!
+//! This function opens the driver needed based on the class value found in
+//! the device's interface descriptor.
+//!
+//! \return This function returns -1 if no driver is found, or it returns the
+//! index of the driver found in the list of host class drivers.
+//
+//*****************************************************************************
+static int32_t
+USBHCDOpenDriver(uint32_t ui32Index, uint32_t ui32DeviceNum)
+{
+    int32_t i32Driver;
+    uint32_t ui32Class;
+    tInterfaceDescriptor *psInterface;
+    tEventInfo sEvent;
+
+    ASSERT(ui32Index == 0);
+
+    //
+    // Get the interface descriptor.
+    //
+    psInterface = USBDescGetInterface(
+                    g_sUSBHCD.psUSBDevice[ui32DeviceNum].psConfigDescriptor,
+                    g_sUSBHCD.psUSBDevice[ui32DeviceNum].ui32Interface,
+                    USB_DESC_ANY);
+
+    //
+    // Read the interface class.
+    //
+    ui32Class = psInterface->bInterfaceClass;
+
+    //
+    // Search through the Host Class driver list for the devices class.
+    //
+    for(i32Driver = 0; i32Driver < g_sUSBHCD.ui32NumClassDrivers; i32Driver++)
+    {
+        //
+        // If a driver was found call the open for this driver and save which
+        // driver is in use.
+        //
+        if(g_sUSBHCD.ppsClassDrivers[i32Driver]->ui32InterfaceClass ==
+           ui32Class)
+        {
+            //
+            // Call the open function for the class driver.
+            //
+            g_ppvDriverInstance[ui32DeviceNum] =
+                    g_sUSBHCD.ppsClassDrivers[i32Driver]->pfnOpen(
+                            &g_sUSBHCD.psUSBDevice[ui32DeviceNum]);
+
+            //
+            // If the driver was successfully loaded then break out of the
+            // loop.
+            //
+            if(g_ppvDriverInstance[ui32DeviceNum] != 0)
+            {
+                break;
+            }
+        }
+    }
+
+    //
+    // If no drivers were found then return -1 to indicate an invalid
+    // driver instance.
+    //
+    if(i32Driver == g_sUSBHCD.ui32NumClassDrivers)
+    {
+        //
+        // Send an unknown connection event.
+        //
+        SendUnknownConnect(ui32Index, (ui32Index << 16) | ui32DeviceNum);
+
+        //
+        // Indicate that no driver was found.
+        //
+        i32Driver = -1;
+    }
+    else
+    {
+        //
+        // If the connect event is enabled then send the event.
+        //
+        sEvent.ui32Event = USB_EVENT_CONNECTED;
+        sEvent.ui32Instance = (ui32Index << 16) | ui32DeviceNum;
+        InternalUSBHCDSendEvent(0, &sEvent, USBHCD_EVFLAG_CONNECT);
+    }
+
+    return(i32Driver);
+}
+
+//*****************************************************************************
+//
+// This function will send an event to a registered event driver.
+//
+// \param ui32Index specifies which USB controller to use.
+// \param psEvent is a pointer to the event structure to send.
+//
+// This function is only used internally to the USB library and will check
+// if an event driver is registered and send on the event.
+//
+// Note: This function should not be called outside of the USB library.
+//
+// \return None.
+//
+//*****************************************************************************
+void
+InternalUSBHCDSendEvent(uint32_t ui32Index, tEventInfo *psEvent,
+                        uint32_t ui32EvFlag)
+{
+    //
+    // Make sure that an event driver has been registered.
+    //
+    if((g_sUSBHCD.i32EventDriver != -1) &&
+       (g_sUSBHCD.ppsClassDrivers[g_sUSBHCD.i32EventDriver]->pfnIntHandler) &&
+       (g_sUSBHCD.ui32EventEnables & ui32EvFlag))
+    {
+        g_sUSBHCD.ppsClassDrivers[g_sUSBHCD.i32EventDriver]->pfnIntHandler(
+                                                                    psEvent);
+    }
+}
+
+//*****************************************************************************
+//
+// This function handles the necessary clean up for device disconnect.
+//
+// \param ui32Index is the device number for the device that was disconnected.
+//
+// This function handles all of the necessary clean up after a device
+// disconnect has been detected by the stack.  This includes calling back the
+// appropriate driver if necessary.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+USBHCDDeviceDisconnected(uint32_t ui32Index, uint32_t ui32DevIndex)
+{
+    tEventInfo sEvent;
+
+    ASSERT(ui32Index == 0);
+    ASSERT(ui32DevIndex <= MAX_USB_DEVICES);
+
+    //
+    // If there is an event driver with a valid event handler and the
+    // USBHCD_EVFLAG_DISCNCT is enabled, then call the registered event
+    // handler.
+    //
+    sEvent.ui32Event = USB_EVENT_DISCONNECTED;
+    sEvent.ui32Instance = (ui32Index << 16) | ui32DevIndex;
+    InternalUSBHCDSendEvent(0, &sEvent, USBHCD_EVFLAG_DISCNCT);
+
+    //
+    // Reset the class.
+    //
+    g_sUSBHCD.ui32Class = USB_CLASS_EVENTS;
+
+    //
+    // Free the memory used by the configuration descriptor.
+    //
+    ConfigDescFree(&g_sUSBHCD.psUSBDevice[ui32DevIndex]);
+
+    g_sUSBHCD.psUSBDevice[ui32DevIndex].ui32Flags = 0;
+    g_sUSBHCD.psUSBDevice[ui32DevIndex].bConfigRead = false;
+
+    //
+    // Reset the max packet size so that this will be re-read from new devices.
+    //
+    g_sUSBHCD.psUSBDevice[ui32DevIndex].sDeviceDescriptor.bMaxPacketSize0 = 0;
+
+    //
+    // No longer have a device descriptor.
+    //
+    g_sUSBHCD.psUSBDevice[ui32DevIndex].sDeviceDescriptor.bLength = 0;
+
+    //
+    // No longer addressed.
+    //
+    g_sUSBHCD.psUSBDevice[ui32DevIndex].ui32Address = 0;
+
+    //
+    // If this was an active driver then close it out.
+    //
+    if(g_pi32USBHActiveDriver[ui32DevIndex] >= 0)
+    {
+        //
+        // Call the driver Close entry point.
+        //
+        g_sUSBHCD.ppsClassDrivers[g_pi32USBHActiveDriver[ui32DevIndex]]->
+            pfnClose(g_ppvDriverInstance[ui32DevIndex]);
+
+        //
+        // No active driver now present.
+        //
+        g_pi32USBHActiveDriver[ui32DevIndex] = -1;
+        g_ppvDriverInstance[ui32DevIndex] = 0;
+    }
+
+    //
+    // This call is necessary for OTG controllers to know that the host
+    // stack has completed handling the disconnect of the device before
+    // removing power and returning to a state that can allow OTG
+    // negotiations once again.
+    // We only do this if the disconnected device
+    // was attached directly to us (device index 0).
+    //
+    if((ui32DevIndex == 0) && (g_iUSBMode == eUSBModeOTG))
+    {
+        OTGDeviceDisconnect(0);
+    }
+}
+
+//*****************************************************************************
+//
+//! This function is the main routine for the Host Controller Driver.
+//!
+//! This function is the main routine for the host controller driver, and must
+//! be called periodically by the main application outside of a callback
+//! context.  This allows for a simple cooperative system to access the the
+//! host controller driver interface without the need for an RTOS.  All time
+//! critical operations are handled in interrupt context but all blocking
+//! operations are run from the this function to allow them to block and wait
+//! for completion without holding off other interrupts.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBHCDMain(void)
+{
+    tUSBHDeviceState iOldState;
+    int32_t i32Dev;
+    tEventInfo sEvent;
+
+    //
+    // Save the old state to detect changes properly.
+    //
+    iOldState = g_sUSBHCD.piDeviceState[0];
+
+    //
+    // Fix up the state if any important interrupt events occurred.
+    //
+    if(g_sUSBHCD.ui32IntEvents)
+    {
+        //
+        // Disable the USB interrupt.
+        //
+        OS_INT_DISABLE(g_sUSBHCD.ui32IntNum);
+
+        if(g_sUSBHCD.ui32IntEvents & INT_EVENT_POWER_FAULT)
+        {
+            //
+            // A power fault has occurred so notify the application if there
+            // is an event handler and the event has been enabled.
+            //
+            sEvent.ui32Event = USB_EVENT_POWER_FAULT;
+            sEvent.ui32Instance = 0;
+            InternalUSBHCDSendEvent(0, &sEvent, USBHCD_EVFLAG_PWRFAULT);
+
+            g_sUSBHCD.piDeviceState[0] = eHCDPowerFault;
+        }
+        else if(g_sUSBHCD.ui32IntEvents & INT_EVENT_VBUS_ERR)
+        {
+            //
+            // A VBUS error has occurred.  This event trumps connect and
+            // disconnect since it will cause a controller reset.
+            //
+            g_sUSBHCD.piDeviceState[0] = eHCDVBUSError;
+        }
+        else
+        {
+            //
+            // Has a device connected?
+            //
+            if(g_sUSBHCD.ui32IntEvents & INT_EVENT_CONNECT)
+            {
+                g_sUSBHCD.piDeviceState[0] = eHCDDevReset;
+                g_sUSBHCD.psUSBDevice[0].ui8Hub = 0;
+                g_sUSBHCD.psUSBDevice[0].ui8HubPort = 0;
+            }
+            else
+            {
+                //
+                // Has a device disconnected?
+                //
+                if(g_sUSBHCD.ui32IntEvents & INT_EVENT_DISCONNECT)
+                {
+                    g_sUSBHCD.piDeviceState[0] = eHCDDevDisconnected;
+                }
+            }
+
+            //
+            // Handle the start of frame event
+            //
+            if(g_sUSBHCD.ui32IntEvents & INT_EVENT_SOF)
+            {
+                //
+                // If the connect event is enabled then send the event.
+                //
+                sEvent.ui32Event = USB_EVENT_SOF;
+                sEvent.ui32Instance = 0;
+                InternalUSBHCDSendEvent(0, &sEvent, USBHCD_EVFLAG_SOF);
+
+                USBHostCheckPipes();
+
+                //
+                // Call the hub driver to have it perform any necessary
+                // processing to handle downstream devices.
+                //
+                USBHHubMain();
+            }
+
+            //
+            // Handle LPM interrupt events.
+            //
+            if(g_sUSBHCD.ui32IntEvents & INT_EVENT_LPM)
+            {
+                //
+                // There should be a pending LPM request.
+                //
+                ASSERT((g_sUSBHCD.ui32IntEvents & INT_EVENT_LPM_PEND) != 0);
+
+                for(i32Dev = 0; i32Dev < MAX_USB_DEVICES + 1; i32Dev++)
+                {
+                    //
+                    // Find the device with the pending LPM request.
+                    //
+                    if(g_sUSBHCD.psUSBDevice[i32Dev].ui32Flags &
+                       USBHDEV_FLAG_LPMPEND)
+                    {
+                        //
+                        // Clear the pending event at the device level, this
+                        // leaves the error set if it was already set.
+                        //
+                        g_sUSBHCD.psUSBDevice[i32Dev].ui32Flags &=
+                                                    ~USBHDEV_FLAG_LPMPEND;
+
+                        //
+                        // Clear the pending request and event at the host
+                        // controller level.
+                        //
+                        g_sUSBHCD.ui32IntEvents &= ~(INT_EVENT_LPM_PEND |
+                                                     INT_EVENT_LPM);
+                    }
+                }
+            }
+        }
+
+        //
+        // Clear the flags.
+        //
+        g_sUSBHCD.ui32IntEvents = 0;
+
+        //
+        // Enable the USB interrupt.
+        //
+        OS_INT_ENABLE(g_sUSBHCD.ui32IntNum);
+    }
+
+    //
+    // Process the state machine for each connected device.  Yes, the exit
+    // condition for this loop is correct since we support (MAX_USB_DEVICES+1)
+    // devices (the hub counts as one).
+    //
+    for(i32Dev = 0; i32Dev <= MAX_USB_DEVICES; i32Dev++)
+    {
+        //
+        // If this is not the first device (i.e. the one directly connected to
+        // the host controller) then set the old state to the current state
+        // since we won't have mucked with it in any of the previous code.
+        //
+        if(i32Dev != 0)
+        {
+            iOldState = g_sUSBHCD.piDeviceState[i32Dev];
+        }
+
+        //
+        // Process the state machine for this device.
+        //
+        ProcessUSBDeviceStateMachine(iOldState, i32Dev);
+    }
+}
+
+static void
+ProcessUSBDeviceStateMachine(tUSBHDeviceState iOldState,
+                             uint32_t ui32DevIndex)
+{
+    switch(g_sUSBHCD.piDeviceState[ui32DevIndex])
+    {
+        //
+        // There was a power fault condition so shut down and wait for the
+        // application to re-initialized the system.
+        //
+        case eHCDPowerFault:
+        {
+            break;
+        }
+
+        //
+        // There was a VBUS error so handle it.
+        //
+        case eHCDVBUSError:
+        {
+            //
+            // Disable USB interrupts.
+            //
+            OS_INT_DISABLE(g_sUSBHCD.ui32IntNum);
+
+            //
+            // If there was a device in any state of connection then indicate
+            // that it has been disconnected.
+            //
+            if((iOldState != eHCDIdle) && (iOldState != eHCDPowerFault))
+            {
+                //
+                // Handle device disconnect.
+                //
+                USBHCDDeviceDisconnected(0, ui32DevIndex);
+            }
+
+            //
+            // Reset the controller.
+            //
+            MAP_SysCtlPeripheralReset(SYSCTL_PERIPH_USB0);
+
+            //
+            // Wait for 100ms before trying to re-power the device.
+            //
+            OS_DELAY(g_ui32Tickms * 100);
+
+            //
+            // Re-initialize the HCD.
+            //
+            USBHCDInitInternal(0, g_sUSBHCD.pvPool, g_sUSBHCD.ui32PoolSize);
+
+            break;
+        }
+        //
+        // Trigger a reset to the connected device.
+        //
+        case eHCDDevReset:
+        {
+            if(!ui32DevIndex)
+            {
+                //
+                // Trigger a Reset.  This is only ever done for devices
+                // attached directly to the controller.
+                //
+                DEBUG_OUTPUT("USB reset.\n");
+                USBHCDReset(0);
+            }
+
+            //
+            // The state moves to connected but not configured.
+            //
+            g_sUSBHCD.piDeviceState[0] = eHCDDevConnected;
+
+            //
+            // Remember that we don't have a valid configuration descriptor
+            // yet.
+            //
+            g_sUSBHCD.psUSBDevice[0].bConfigRead = false;
+
+            break;
+        }
+        //
+        // Device connection has been established now start enumerating
+        // the device.
+        //
+        case eHCDDevConnected:
+        case eHCDDevConnectedHub:
+        {
+            //
+            // First check if we have read the device descriptor at all
+            // before proceeding.
+            //
+            if(g_sUSBHCD.psUSBDevice[ui32DevIndex].sDeviceDescriptor.bLength ==
+               0)
+            {
+                //
+                // Initialize a request for the device descriptor.
+                //
+                DEBUG_OUTPUT("Connection %d - getting device descriptor\n",
+                             ui32DevIndex);
+
+                //
+                // Hub enumeration has already set the speed so do not
+                // override the setting here.
+                //
+                if(g_sUSBHCD.piDeviceState[ui32DevIndex] == eHCDDevConnected)
+                {
+                    //
+                    // Remember the speed of this device to ensure endpoints
+                    // are properly configured.
+                    //
+                    switch(USBHostSpeedGet(USB0_BASE))
+                    {
+                        case USB_HIGH_SPEED:
+                        {
+                            g_sUSBHCD.psUSBDevice[ui32DevIndex].ui32Speed =
+                                                            USB_EP_SPEED_HIGH;
+                            break;
+                        }
+                        case USB_FULL_SPEED:
+                        {
+                            g_sUSBHCD.psUSBDevice[ui32DevIndex].ui32Speed =
+                                                            USB_EP_SPEED_FULL;
+                            break;
+                        }
+                        default:
+                        {
+                            g_sUSBHCD.psUSBDevice[ui32DevIndex].ui32Speed =
+                                                            USB_EP_SPEED_LOW;
+                            break;
+                        }
+                    }
+                }
+
+                if(USBHCDGetDeviceDescriptor(0,
+                        &g_sUSBHCD.psUSBDevice[ui32DevIndex]) == 0)
+                {
+                    //
+                    // If the device descriptor cannot be read then the device
+                    // will be treated as unknown.
+                    //
+                    g_sUSBHCD.piDeviceState[ui32DevIndex] = eHCDDevError;
+
+                    DEBUG_OUTPUT("Connection %d - failed to get descriptor\n",
+                                 ui32DevIndex);
+
+                    //
+                    // Send an unknown connection event to let the application
+                    // know that there is a device connected but return no
+                    // zero for the instance.
+                    //
+                    SendUnknownConnect(0, 0);
+
+                    //
+                    // If the device is connected via a hub, tell the hub
+                    // driver that we experienced an error enumerating the
+                    // device.
+                    //
+                    if(g_sUSBHCD.psUSBDevice[ui32DevIndex].ui8Hub)
+                    {
+                        USBHHubEnumerationError(
+                            g_sUSBHCD.psUSBDevice[ui32DevIndex].ui8Hub,
+                            g_sUSBHCD.psUSBDevice[ui32DevIndex].ui8HubPort);
+                    }
+                }
+            }
+            //
+            // If we have the device descriptor then move on to setting
+            // the address of the device.
+            //
+            else if(g_sUSBHCD.psUSBDevice[ui32DevIndex].ui32Address == 0)
+            {
+                DEBUG_OUTPUT("Connection %d - setting address %d\n",
+                             ui32DevIndex, ui32DevIndex + 1);
+
+                //
+                // Send the set address command.
+                //
+                USBHCDSetAddress(ui32DevIndex, (ui32DevIndex + 1));
+
+                //
+                // Save the address.
+                //
+                g_sUSBHCD.psUSBDevice[ui32DevIndex].ui32Address =
+                                                            (ui32DevIndex + 1);
+
+                //
+                // Move on to the addressed state.
+                //
+                g_sUSBHCD.piDeviceState[ui32DevIndex] = eHCDDevAddressed;
+            }
+            break;
+        }
+        case eHCDDevAddressed:
+        {
+            //
+            // First check if we have read the configuration descriptor.
+            //
+            if(!g_sUSBHCD.psUSBDevice[ui32DevIndex].bConfigRead)
+            {
+                DEBUG_OUTPUT("Connection %d - getting config descriptor\n",
+                             ui32DevIndex);
+
+                //
+                // Initialize a request for the configuration descriptor.
+                //
+                if(USBHCDGetConfigDescriptor(0,
+                                    &g_sUSBHCD.psUSBDevice[ui32DevIndex]) == 0)
+                {
+                    //
+                    // If the device descriptor cannot be read then the device
+                    // will be treated as unknown.
+                    //
+                    g_sUSBHCD.piDeviceState[ui32DevIndex] = eHCDDevError;
+
+                    DEBUG_OUTPUT("Connection %d - failed to get descriptor\n",
+                                 ui32DevIndex);
+
+                    //
+                    // Send an unknown connection event to let the application
+                    // know that there is a device connected but return no
+                    // zero for the instance.
+                    //
+                    SendUnknownConnect(0, 0);
+
+                    //
+                    // If the device is connected via a hub, tell the hub
+                    // driver that we experienced an error enumerating the
+                    // device.
+                    //
+                    if(g_sUSBHCD.psUSBDevice[ui32DevIndex].ui8Hub)
+                    {
+                        USBHHubEnumerationError(
+                            g_sUSBHCD.psUSBDevice[ui32DevIndex].ui8Hub,
+                            g_sUSBHCD.psUSBDevice[ui32DevIndex].ui8HubPort);
+                    }
+                }
+            }
+            //
+            // Now have addressed and received the device configuration,
+            // so get ready to set the device configuration.
+            //
+            else
+            {
+                DEBUG_OUTPUT("Connection %d - setting configuration.\n",
+                             ui32DevIndex);
+
+                //
+                // Use the first configuration to set the device
+                // configuration.
+                //
+                USBHCDSetConfig(0,
+                            (uint32_t)&g_sUSBHCD.psUSBDevice[ui32DevIndex], 1);
+
+                //
+                // Move on to the configured state.
+                //
+                g_sUSBHCD.piDeviceState[ui32DevIndex] = eHCDDevConfigured;
+
+                //
+                // Open the driver for the device.
+                //
+                g_pi32USBHActiveDriver[ui32DevIndex] = USBHCDOpenDriver(0,
+                                                                ui32DevIndex);
+
+                //
+                // If the device is connected via a hub, tell the hub
+                // driver that enumeration is complete.
+                //
+                if(g_sUSBHCD.psUSBDevice[ui32DevIndex].ui8Hub)
+                {
+                    USBHHubEnumerationComplete(
+                            g_sUSBHCD.psUSBDevice[ui32DevIndex].ui8Hub,
+                            g_sUSBHCD.psUSBDevice[ui32DevIndex].ui8HubPort);
+                }
+            }
+            break;
+        }
+        //
+        // The device was making a request and is now complete.
+        //
+        case eHCDDevRequest:
+        {
+            g_sUSBHCD.piDeviceState[ui32DevIndex] = eHCDDevConnected;
+            break;
+        }
+        //
+        // The strings are currently not accessed.
+        //
+        case eHCDDevGetStrings:
+        {
+            break;
+        }
+        //
+        // Basically Idle at this point.
+        //
+        case eHCDDevDisconnected:
+        {
+            DEBUG_OUTPUT("Connection %d - disconnected.\n",
+                         ui32DevIndex);
+
+            //
+            // Handle device disconnect.
+            //
+            USBHCDDeviceDisconnected(0, ui32DevIndex);
+
+            //
+            // Return to the Idle state.
+            //
+            g_sUSBHCD.piDeviceState[ui32DevIndex] = eHCDIdle;
+            break;
+        }
+
+        //
+        // Connection and enumeration is complete so allow this function
+        // to exit.
+        //
+        case eHCDDevConfigured:
+        {
+            break;
+        }
+
+        //
+        // Poorly behaving device are in limbo in this state until removed.
+        //
+        case eHCDDevError:
+        {
+            DEBUG_OUTPUT("Connection %d - Error!\n", ui32DevIndex);
+
+            //
+            // If this device is connected directly to us, tidy up and ignore
+            // it until it is removed.  If the device is connected to a hub,
+            // we just leave it in the error state until it is removed.
+            //
+            if(ui32DevIndex == 0)
+            {
+                g_sUSBHCD.ui32IntEvents |= INT_EVENT_DISCONNECT;
+                g_sUSBHCD.piDeviceState[ui32DevIndex] = eHCDIdle;
+            }
+            break;
+        }
+        default:
+        {
+            break;
+        }
+    }
+}
+
+//*****************************************************************************
+//
+//! This function completes a control transaction to a device.
+//!
+//! \param ui32Index is the controller index to use for this transfer.
+//! \param psSetupPacket is the setup request to be sent.
+//! \param psDevice is the device instance pointer for this request.
+//! \param pui8Data is the data to send for OUT requests or the receive buffer
+//! for IN requests.
+//! \param ui32Size is the size of the buffer in \e pui8Data.
+//! \param ui32MaxPacketSize is the maximum packet size for the device for this
+//! request.
+//!
+//! This function handles the state changes necessary to send a control
+//! transaction to a device.  This function should not be called from within
+//! an interrupt callback as it is a blocking function.
+//!
+//! \return The number of bytes of data that were sent or received as a result
+//! of this request.
+//
+//*****************************************************************************
+uint32_t
+USBHCDControlTransfer(uint32_t ui32Index, tUSBRequest *psSetupPacket,
+                      tUSBHostDevice *psDevice, uint8_t *pui8Data,
+                      uint32_t ui32Size, uint32_t ui32MaxPacketSize)
+{
+    uint32_t ui32Remaining;
+    uint32_t ui32DataSize;
+
+    //
+    // Debug sanity check.
+    //
+    ASSERT(g_sUSBHEP0State.iState == eEP0StateIdle);
+    ASSERT(ui32Index == 0);
+
+    //
+    // Initialize the state of the data for this request.
+    //
+    g_sUSBHEP0State.pui8Data = pui8Data;
+    g_sUSBHEP0State.ui32BytesRemaining = ui32Size;
+    g_sUSBHEP0State.ui32DataSize = ui32Size;
+
+    //
+    // Set the maximum packet size.
+    //
+    g_sUSBHEP0State.ui32MaxPacketSize = ui32MaxPacketSize;
+
+    //
+    // Save the current address.
+    //
+    g_sUSBHEP0State.ui32DevAddress = psDevice->ui32Address;
+
+    //
+    // Set the address the host will used to communicate with the device.
+    //
+    MAP_USBHostAddrSet(USB0_BASE, USB_EP_0, g_sUSBHEP0State.ui32DevAddress,
+                       USB_EP_HOST_OUT);
+
+    //
+    // Make sure that endpoint 0 has the proper speed setting.
+    //
+    USBHostEndpointConfig(USB0_BASE, USB_EP_0, 64, 0, 0,
+                          (USB_EP_MODE_CTRL | psDevice->ui32Speed |
+                           USB_EP_HOST_OUT));
+
+    //
+    // Put the data in the correct FIFO.
+    //
+    MAP_USBEndpointDataPut(USB0_BASE, USB_EP_0, (uint8_t *)psSetupPacket,
+                           sizeof(tUSBRequest));
+
+    //
+    // If this is an IN request, change to that state.
+    //
+    if(psSetupPacket->bmRequestType & USB_RTYPE_DIR_IN)
+    {
+        g_sUSBHEP0State.iState = eEP0StateSetupIN;
+    }
+    else
+    {
+        //
+        // If there is no data then this is not an OUT request.
+        //
+        if(ui32Size != 0)
+        {
+            //
+            // Since there is data, this is an OUT request.
+            //
+            g_sUSBHEP0State.iState = eEP0StateSetupOUT;
+        }
+        else
+        {
+            //
+            // Otherwise this request has no data and just a status phase.
+            //
+            g_sUSBHEP0State.iState = eEP0StateStatusIN;
+        }
+    }
+
+    //
+    // Make sure we are talking to the correct device.
+    //
+    if(psDevice->ui8Hub == 0)
+    {
+        USBHostHubAddrSet(USB0_BASE, USB_EP_0, 0,
+                          USB_EP_HOST_OUT | psDevice->ui32Speed);
+    }
+    else
+    {
+        USBHostHubAddrSet(USB0_BASE, USB_EP_0,
+                          (psDevice->ui8Hub | (psDevice->ui8HubPort << 8)),
+                          USB_EP_HOST_OUT | psDevice->ui32Speed);
+    }
+
+    //
+    // Send the Setup packet.
+    //
+    MAP_USBEndpointDataSend(USB0_BASE, USB_EP_0, USB_TRANS_SETUP);
+
+    //
+    // Block until endpoint 0 returns to the IDLE state.
+    //
+    while(g_sUSBHEP0State.iState != eEP0StateIdle)
+    {
+        OS_INT_DISABLE(g_sUSBHCD.ui32IntNum);
+
+        if((g_sUSBHCD.ui32IntEvents & (INT_EVENT_ENUM | INT_EVENT_SOF)) ==
+           (INT_EVENT_ENUM | INT_EVENT_SOF))
+        {
+            g_sUSBHCD.ui32IntEvents &= ~(INT_EVENT_ENUM | INT_EVENT_SOF);
+
+            USBHCDEnumHandler();
+        }
+
+        OS_INT_ENABLE(g_sUSBHCD.ui32IntNum);
+
+        if(g_sUSBHEP0State.iState == eEP0StateError)
+        {
+            return(0xffffffff);
+        }
+
+        //
+        // If we aborted the transfer due to an error, tell the caller
+        // that no bytes were transferred.
+        //
+        if(g_sUSBHCD.ui32IntEvents & (INT_EVENT_VBUS_ERR |
+                                      INT_EVENT_DISCONNECT))
+        {
+            return(0xffffffff);
+        }
+    }
+
+    //
+    // Calculate and return the number of bytes that were sent or received.
+    // The extra copy into local variables is required to prevent some
+    // compilers from warning about undefined order of volatile access.
+    //
+    ui32DataSize = g_sUSBHEP0State.ui32DataSize;
+    ui32Remaining = g_sUSBHEP0State.ui32BytesRemaining;
+
+    return(ui32DataSize - ui32Remaining);
+}
+
+//*****************************************************************************
+//
+// Starts enumerating a new device connected via the hub.
+//
+// \param ui32Index is the index of the USB controller to use.
+// \param ui32Hub is the hub address from which the connection is being made.
+// \param ui32Port is the hub port number that the new device is connected to.
+// \param pui8ConfigPool is memory to be used to store the device's
+// configuration descriptor.
+// \param ui32ConfigSize is the number of bytes available in the buffer pointed
+// to by pui8ConfigPool.
+//
+// This function is called by the hub class driver after it has detected a new
+// device connection and reset the device.
+//
+// \return Returns the index of the device allocated or 0 if no resources are
+//         available. Device index 0 is the hub itself.
+//
+//*****************************************************************************
+uint32_t
+USBHCDHubDeviceConnected(uint32_t ui32Index, uint8_t ui8Hub,
+                         uint8_t ui8Port, uint32_t ui32Speed)
+{
+    uint32_t ui32DevIndex;
+
+    //
+    // Debug sanity checks.
+    //
+    ASSERT(ui32Index == 0);
+    ASSERT(ui8Port);
+
+    DEBUG_OUTPUT("Connection from hub %d, port %d.\n", ui8Hub, ui8Port);
+
+    //
+    // Look for a free slot in the device table.
+    //
+    for(ui32DevIndex = 1; ui32DevIndex <= MAX_USB_DEVICES; ui32DevIndex++)
+    {
+        if((g_sUSBHCD.psUSBDevice[ui32DevIndex].ui32Flags &
+            USBHDEV_FLAG_ALLOCATED) == 0)
+        {
+            //
+            // We found one. Set the state to ensure that it gets enumerated.
+            //
+            g_sUSBHCD.psUSBDevice[ui32DevIndex].ui32Flags =
+                                                        USBHDEV_FLAG_ALLOCATED;
+            g_sUSBHCD.psUSBDevice[ui32DevIndex].psConfigDescriptor->bLength = 0;
+            g_sUSBHCD.psUSBDevice[ui32DevIndex].ui8Hub = ui8Hub;
+            g_sUSBHCD.psUSBDevice[ui32DevIndex].ui8HubPort = ui8Port;
+            g_sUSBHCD.psUSBDevice[ui32DevIndex].ui32Speed = ui32Speed;
+            g_sUSBHCD.psUSBDevice[ui32DevIndex].sDeviceDescriptor.bLength = 0;
+
+            //
+            // Set the state to ensure enumeration begins.
+            //
+            g_sUSBHCD.piDeviceState[ui32DevIndex] = eHCDDevConnectedHub;
+
+            DEBUG_OUTPUT("Allocating device %d\n", ui32DevIndex);
+
+            //
+            // Pass the device index back to the hub driver.
+            //
+            return(ui32DevIndex);
+        }
+    }
+
+    //
+    // If we get here, there are device slots available so send back an invalid
+    // device index to tell the caller to ignore this device.
+    //
+    return(0);
+}
+
+//*****************************************************************************
+//
+// Called when a device is disconnected from a hub.
+//
+// \param ui32Index is the index of the USB controller to use.
+// \param ui32DevIndex is the device index for the USB device that was
+// disconnected.
+//
+//*****************************************************************************
+void
+USBHCDHubDeviceDisconnected(uint32_t ui32Index, uint32_t ui32DevIndex)
+{
+    //
+    // Debug sanity checks.
+    //
+    ASSERT(ui32Index == 0);
+    ASSERT(ui32DevIndex && (ui32DevIndex <= MAX_USB_DEVICES));
+
+    DEBUG_OUTPUT("Disconnection from hub %d, port %d, device %d\n",
+            g_sUSBHCD.psUSBDevice[ui32DevIndex].ui8Hub,
+            g_sUSBHCD.psUSBDevice[ui32DevIndex].ui8HubPort, ui32DevIndex);
+
+    //
+    // Set the device state to ensure that USBHCDMain cleans it up.
+    //
+    g_sUSBHCD.piDeviceState[ui32DevIndex] = eHCDDevDisconnected;
+}
+
+//*****************************************************************************
+//
+// This is the endpoint 0 interrupt handler.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+USBHCDEnumHandler(void)
+{
+    uint32_t ui32EPStatus;
+    uint32_t ui32DataSize;
+
+    //
+    // Get the end point 0 status.
+    //
+    ui32EPStatus = MAP_USBEndpointStatus(USB0_BASE, USB_EP_0);
+
+    //
+    // If there was an error then go to the error state.
+    //
+    if(ui32EPStatus == USB_HOST_EP0_ERROR)
+    {
+        //
+        // Clear this status indicating that the status packet was
+        // received.
+        //
+        MAP_USBHostEndpointStatusClear(USB0_BASE, USB_EP_0,
+                                       USB_HOST_EP0_ERROR);
+        MAP_USBFIFOFlush(USB0_BASE, USB_EP_0, 0);
+
+        //
+        // Just go back to the idle state.
+        //
+        g_sUSBHEP0State.iState = eEP0StateError;
+
+        return;
+    }
+
+    switch(g_sUSBHEP0State.iState)
+    {
+        //
+        // Handle the status state, this is a transitory state from
+        // USB_STATE_TX or USB_STATE_RX back to USB_STATE_IDLE.
+        //
+        case eEP0StateStatus:
+        {
+            //
+            // Handle the case of a received status packet.
+            //
+            if(ui32EPStatus & (USB_HOST_EP0_RXPKTRDY | USB_HOST_EP0_STATUS))
+            {
+                //
+                // Clear this status indicating that the status packet was
+                // received.
+                //
+                MAP_USBHostEndpointStatusClear(USB0_BASE, USB_EP_0,
+                                               (USB_HOST_EP0_RXPKTRDY |
+                                                USB_HOST_EP0_STATUS));
+            }
+
+            //
+            // Just go back to the idle state.
+            //
+            g_sUSBHEP0State.iState = eEP0StateIdle;
+
+            break;
+        }
+
+        //
+        // This state triggers a STATUS IN request from the device.
+        //
+        case eEP0StateStatusIN:
+        {
+            //
+            // Generate an IN request from the device.
+            //
+            MAP_USBHostRequestStatus(USB0_BASE);
+
+            //
+            // Change to the status phase and wait for the response.
+            //
+            g_sUSBHEP0State.iState =  eEP0StateStatus;
+
+            break;
+        }
+
+        //
+        // In the IDLE state the code is waiting to receive data from the host.
+        //
+        case eEP0StateIdle:
+        {
+            break;
+        }
+
+        //
+        // Data is still being sent to the host so handle this in the
+        // EP0StateTx() function.
+        //
+        case eEP0StateSetupOUT:
+        {
+            //
+            // Send remaining data if necessary.
+            //
+            USBHCDEP0StateTx();
+
+            break;
+        }
+
+        //
+        // Handle the receive state for commands that are receiving data on
+        // endpoint 0.
+        //
+        case eEP0StateSetupIN:
+        {
+            //
+            // Generate a new IN request to the device.
+            //
+            MAP_USBHostRequestIN(USB0_BASE, USB_EP_0);
+
+            //
+            // Proceed to the RX state to receive the requested data.
+            //
+            g_sUSBHEP0State.iState =  eEP0StateRx;
+
+            break;
+        }
+
+        //
+        // The endpoint remains in this state until all requested data has
+        // been received.
+        //
+        case eEP0StateRx:
+        {
+            //
+            // There was a stall on endpoint 0 so go back to the idle state
+            // as this command has been terminated.
+            //
+            if(ui32EPStatus & USB_HOST_EP0_RX_STALL)
+            {
+                g_sUSBHEP0State.iState = eEP0StateIdle;
+
+                //
+                // Clear the stalled state on endpoint 0.
+                //
+                MAP_USBHostEndpointStatusClear(USB0_BASE, USB_EP_0,
+                                           ui32EPStatus & USB_HOST_IN_STATUS);
+                break;
+            }
+
+            //
+            // Set the number of bytes to get out of this next packet.
+            //
+            ui32DataSize = g_sUSBHEP0State.ui32BytesRemaining;
+            if(ui32DataSize > g_sUSBHEP0State.ui32MaxPacketSize)
+            {
+                //
+                // Don't send more than EP0_MAX_PACKET_SIZE bytes.
+                //
+                ui32DataSize = MAX_PACKET_SIZE_EP0;
+            }
+
+            if(ui32DataSize != 0)
+            {
+                //
+                // Get the data from the USB controller end point 0.
+                //
+                MAP_USBEndpointDataGet(USB0_BASE, USB_EP_0,
+                                       g_sUSBHEP0State.pui8Data,
+                                       &ui32DataSize);
+            }
+
+            //
+            // Advance the pointer.
+            //
+            g_sUSBHEP0State.pui8Data += ui32DataSize;
+
+            //
+            // Decrement the number of bytes that are being waited on.
+            //
+            g_sUSBHEP0State.ui32BytesRemaining -= ui32DataSize;
+
+            //
+            // Need to ack the data on end point 0 in this case
+            // without setting data end.
+            //
+            MAP_USBHostEndpointDataAck(USB0_BASE, USB_EP_0);
+
+            //
+            // If there was not more than the maximum packet size bytes of data
+            // the this was a int16_t packet and indicates that this transfer
+            // is complete.  If there were exactly
+            // g_sUSBHEP0State.ui32MaxPacketSize remaining then there still
+            // needs to be null packet sent before this transfer is complete.
+            //
+            if((ui32DataSize < g_sUSBHEP0State.ui32MaxPacketSize) ||
+               (g_sUSBHEP0State.ui32BytesRemaining == 0))
+            {
+                //
+                // Return to the idle state.
+                //
+                g_sUSBHEP0State.iState =  eEP0StateStatus;
+
+                //
+                // No more data.
+                //
+                g_sUSBHEP0State.pui8Data = 0;
+
+                //
+                // Send a null packet to acknowledge that all data was
+                // received.
+                //
+                MAP_USBEndpointDataSend(USB0_BASE, USB_EP_0, USB_TRANS_STATUS);
+            }
+            else
+            {
+                //
+                // Request more data.
+                //
+                MAP_USBHostRequestIN(USB0_BASE, USB_EP_0);
+            }
+            break;
+        }
+
+        //
+        // The device stalled endpoint zero so check if the stall needs to be
+        // cleared once it has been successfully sent.
+        //
+        case eEP0StateStall:
+        {
+            //
+            // Reset the global end point 0 state to IDLE.
+            //
+            g_sUSBHEP0State.iState = eEP0StateIdle;
+
+            break;
+        }
+
+        //
+        // Halt on an unknown state, but only in DEBUG builds.
+        //
+        default:
+        {
+            ASSERT(0);
+            break;
+        }
+    }
+}
+
+//*****************************************************************************
+//
+// This internal function handles sending data on endpoint 0.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+USBHCDEP0StateTx(void)
+{
+    uint32_t ui32NumBytes;
+    uint8_t *pui8Data;
+
+    //
+    // In the TX state on endpoint 0.
+    //
+    g_sUSBHEP0State.iState = eEP0StateSetupOUT;
+
+    //
+    // Set the number of bytes to send this iteration.
+    //
+    ui32NumBytes = g_sUSBHEP0State.ui32BytesRemaining;
+
+    //
+    // Limit individual transfers to 64 bytes.
+    //
+    if(ui32NumBytes > 64)
+    {
+        ui32NumBytes = 64;
+    }
+
+    //
+    // Save the pointer so that it can be passed to the USBEndpointDataPut()
+    // function.
+    //
+    pui8Data = (uint8_t *)g_sUSBHEP0State.pui8Data;
+
+    //
+    // Advance the data pointer and counter to the next data to be sent.
+    //
+    g_sUSBHEP0State.ui32BytesRemaining -= ui32NumBytes;
+    g_sUSBHEP0State.pui8Data += ui32NumBytes;
+
+    //
+    // Put the data in the correct FIFO.
+    //
+    MAP_USBEndpointDataPut(USB0_BASE, USB_EP_0, pui8Data, ui32NumBytes);
+
+    //
+    // If this is exactly 64 then don't set the last packet yet.
+    //
+    if(ui32NumBytes == 64)
+    {
+        //
+        // There is more data to send or exactly 64 bytes were sent, this
+        // means that there is either more data coming or a null packet needs
+        // to be sent to complete the transaction.
+        //
+        MAP_USBEndpointDataSend(USB0_BASE, USB_EP_0, USB_TRANS_OUT);
+    }
+    else
+    {
+        //
+        // Send the last bit of data.
+        //
+        MAP_USBEndpointDataSend(USB0_BASE, USB_EP_0, USB_TRANS_OUT);
+
+        //
+        // Now go to the status state and wait for the transmit to complete.
+        //
+        g_sUSBHEP0State.iState = eEP0StateStatusIN;
+    }
+}
+
+//*****************************************************************************
+//
+//! This function returns the USB hub port for the requested device instance.
+//!
+//! \param ui32Instance is a unique value indicating which device to query.
+//!
+//! This function returns the USB hub port for the device that is associated
+//! with the \e ui32Instance parameter.  The caller must use the value for
+//! \e ui32Instance was passed to the application when it receives a
+//! \b USB_EVENT_CONNECTED event.  The function returns the USB hub port for
+//! the interface number specified by the \e ui32Interface parameter.
+//!
+//! \return The USB hub port for the requested interface.
+//
+//*****************************************************************************
+uint8_t
+USBHCDDevHubPort(uint32_t ui32Instance)
+{
+    uint32_t ui32DevIndex;
+
+    ui32DevIndex = HCDInstanceToDevIndex(ui32Instance);
+
+    if(ui32DevIndex == 0xff)
+    {
+        return(ui32DevIndex);
+    }
+
+    return(g_sUSBHCD.psUSBDevice[ui32DevIndex].ui8HubPort);
+}
+
+//*****************************************************************************
+//
+//! This function will return the USB address for the requested device
+//! instance.
+//!
+//! \param ui32Instance is a unique value indicating which device to query.
+//!
+//! This function returns the USB address for the device that is associated
+//! with the \e ui32Instance parameter.  The caller must use a value for
+//! \e ui32Instance have been passed to the application when it receives a
+//! \b USB_EVENT_CONNECTED event.  The function will return the USB address for
+//! the interface number specified by the \e ui32Interface parameter.
+//!
+//! \return The USB address for the requested interface.
+//
+//*****************************************************************************
+uint8_t
+USBHCDDevAddress(uint32_t ui32Instance)
+{
+    uint32_t ui32DevIndex;
+
+    ui32DevIndex = HCDInstanceToDevIndex(ui32Instance);
+
+    if(ui32DevIndex == 0xff)
+    {
+        return(ui32DevIndex);
+    }
+
+    return(g_sUSBHCD.psUSBDevice[ui32DevIndex].ui32Address);
+}
+
+//*****************************************************************************
+//
+//! This function will return the USB class for the requested device
+//! instance.
+//!
+//! \param ui32Instance is a unique value indicating which device to query.
+//! \param ui32Interface is the interface number to query for the USB class.
+//!
+//! This function returns the USB class for the device that is associated
+//! with the \e ui32Instance parameter.  The caller must use a value for
+//! \e ui32Instance have been passed to the application when it receives a
+//! \b USB_EVENT_CONNECTED event.  The function will return the USB class for
+//! the interface number specified by the \e ui32Interface parameter.  If
+//! \e ui32Interface is set to 0xFFFFFFFF then the function will return the USB
+//! class for the first interface that is found in the device's USB
+//! descriptors.
+//!
+//! \return The USB class for the requested interface.
+//
+//*****************************************************************************
+uint8_t
+USBHCDDevClass(uint32_t ui32Instance, uint32_t ui32Interface)
+{
+    uint32_t ui32DevIndex;
+    tInterfaceDescriptor *psInterface;
+
+    ui32DevIndex = HCDInstanceToDevIndex(ui32Instance);
+
+    //
+    // If the instance was not valid return an undefined class.
+    //
+    if(ui32DevIndex == 0xff)
+    {
+        return(USB_CLASS_DEVICE);
+    }
+
+    //
+    // Get the interface descriptor.
+    //
+    psInterface = USBDescGetInterface(
+                        g_sUSBHCD.psUSBDevice[ui32DevIndex].psConfigDescriptor,
+                        g_sUSBHCD.psUSBDevice[ui32DevIndex].ui32Interface,
+                        ui32Interface);
+
+    //
+    // Make sure that the interface requested actually exists.
+    //
+    if(psInterface)
+    {
+        //
+        // Return the interface class.
+        //
+        return(psInterface->bInterfaceClass);
+    }
+
+    //
+    // No valid interface so return an undefined class.
+    //
+    return(USB_CLASS_DEVICE);
+}
+
+//*****************************************************************************
+//
+//! This function will return the USB subclass for the requested device
+//! instance.
+//!
+//! \param ui32Instance is a unique value indicating which device to query.
+//! \param ui32Interface is the interface number to query for the USB subclass.
+//!
+//! This function returns the USB subclass for the device that is associated
+//! with the \e ui32Instance parameter.  The caller must use a value for
+//! \e ui32Instance have been passed to the application when it receives a
+//! \b USB_EVENT_CONNECTED event.  The function will return the USB subclass
+//! for the interface number specified by the \e ui32Interface parameter.  If
+//! \e ui32Interface is set to 0xFFFFFFFF then the function will return the USB
+//! subclass for the first interface that is found in the device's USB
+//! descriptors.
+//!
+//! \return The USB subclass for the requested interface.
+//
+//*****************************************************************************
+uint8_t
+USBHCDDevSubClass(uint32_t ui32Instance, uint32_t ui32Interface)
+{
+    uint32_t ui32DevIndex;
+    tInterfaceDescriptor *psInterface;
+
+    ui32DevIndex = HCDInstanceToDevIndex(ui32Instance);
+
+    //
+    // If the instance was not valid return an undefined subclass.
+    //
+    if(ui32DevIndex == 0xff)
+    {
+        return(USB_SUBCLASS_UNDEFINED);
+    }
+
+    //
+    // Get the interface descriptor.
+    //
+    psInterface = USBDescGetInterface(
+                        g_sUSBHCD.psUSBDevice[ui32DevIndex].psConfigDescriptor,
+                        g_sUSBHCD.psUSBDevice[ui32DevIndex].ui32Interface,
+                        ui32Interface);
+
+    //
+    // Make sure that the interface requested actually exists.
+    //
+    if(psInterface)
+    {
+        //
+        // Return the interface subclass.
+        //
+        return(psInterface->bInterfaceSubClass);
+    }
+
+    //
+    // No valid interface so return an undefined subclass.
+    //
+    return(USB_SUBCLASS_UNDEFINED);
+}
+
+//*****************************************************************************
+//
+//! This function returns the USB protocol for the requested device instance.
+//!
+//! \param ui32Instance is a unique value indicating which device to query.
+//! \param ui32Interface is the interface number to query for the USB protocol.
+//!
+//! This function returns the USB protocol for the device that is associated
+//! with the \e ui32Instance parameter.  The caller must use a value for
+//! \e ui32Instance have been passed to the application when it receives a
+//! \b USB_EVENT_CONNECTED event.  The function will return the USB protocol
+//! for the interface number specified by the \e ui32Interface parameter.  If
+//! \e ui32Interface is set to 0xFFFFFFFF then the function will return the USB
+//! protocol for the first interface that is found in the device's USB
+//! descriptors.
+//!
+//! \return The USB protocol for the requested interface.
+//
+//*****************************************************************************
+uint8_t
+USBHCDDevProtocol(uint32_t ui32Instance, uint32_t ui32Interface)
+{
+    uint32_t ui32DevIndex;
+    tInterfaceDescriptor *psInterface;
+
+    ui32DevIndex = HCDInstanceToDevIndex(ui32Instance);
+
+    //
+    // If the instance was not valid return an undefined protocol.
+    //
+    if(ui32DevIndex == 0xff)
+    {
+        return(USB_PROTOCOL_UNDEFINED);
+    }
+
+    //
+    // Get the interface descriptor.
+    //
+    psInterface = USBDescGetInterface(
+                        g_sUSBHCD.psUSBDevice[ui32DevIndex].psConfigDescriptor,
+                        g_sUSBHCD.psUSBDevice[ui32DevIndex].ui32Interface,
+                        ui32Interface);
+
+    //
+    // Make sure that the interface requested actually exists.
+    //
+    if(psInterface)
+    {
+        //
+        // Return the interface protocol.
+        //
+        return(psInterface->bInterfaceProtocol);
+    }
+
+    //
+    // No valid interface so return an undefined protocol.
+    //
+    return(USB_PROTOCOL_UNDEFINED);
+}
+
+//*****************************************************************************
+//
+//! This function sets one of the \b USBLIB_FEATURE_ requests.
+//!
+//! \param ui32Index is the index of the USB controller to access.
+//! \param ui32Feature is one of the \b USBLIB_FEATURE_ defines.
+//! \param pvFeature is a pointer to the data for the \b USBLIB_FEATURE
+//!        request.
+//!
+//! This function sends the requested feature request to the USB library.
+//! Not all features are supported by all devices so see the documentation
+//! for the \b USBLIB_FEATURE_ to determine if the feature is supported.
+//!
+//! \return Returns \b true if the feature was set and \b false if the feature
+//! is not supported or could not be changed to the requested value.
+//
+//*****************************************************************************
+bool
+USBHCDFeatureSet(uint32_t ui32Index, uint32_t ui32Feature,
+                 void *pvFeature)
+{
+    bool bRetCode;
+    tLPMFeature *psLPMFeature;
+
+    bRetCode = true;
+
+    switch(ui32Feature)
+    {
+        case USBLIB_FEATURE_CPUCLK:
+        {
+            //
+            // Set the ticks per millisecond.
+            //
+            g_ui32Tickms = (*(uint32_t *)pvFeature / 3000);
+            break;
+        }
+        case USBLIB_FEATURE_LPM:
+        {
+            psLPMFeature = (tLPMFeature *)pvFeature;
+
+            if(psLPMFeature->ui32Features & USBLIB_FEATURE_LPM_EN)
+            {
+                g_sUSBHCD.ui32Features |= USBLIB_FEATURE_LPM_EN;
+
+                if(psLPMFeature->ui32Features & USBLIB_FEATURE_LPM_RMT_WAKE)
+                {
+                    g_sUSBHCD.ui32Features |= USBLIB_FEATURE_LPM_RMT_WAKE;
+                }
+                g_sUSBHCD.ui32LPMHIRD = psLPMFeature->ui32HIRD;
+            }
+            else
+            {
+                psLPMFeature->ui32Features &= ~USBLIB_FEATURE_LPM_EN;
+            }
+            break;
+        }
+        case USBLIB_FEATURE_USBPLL:
+        {
+            //
+            // If the PLL rate is not evenly divisible by 60MHz then
+            // do not set it.
+            //
+            if((*(uint32_t *)pvFeature % 60000000) != 0)
+            {
+                bRetCode = false;
+            }
+            else
+            {
+                //
+                // Save the new PLL rate.
+                //
+                g_ui32PLLDiv = (*(uint32_t *)pvFeature / 60000000);
+            }
+            break;
+        }
+        case USBLIB_FEATURE_USBULPI:
+        {
+            //
+            // Save the ULPI support level.
+            //
+            g_ui32ULPISupport = *(uint32_t *)pvFeature;
+
+            break;
+        }
+        default:
+        {
+            bRetCode = false;
+            break;
+        }
+    }
+    return(bRetCode);
+}
+
+//*****************************************************************************
+//
+//! This function returns the current status of an LPM request.
+//!
+//! \param psDevice is the device to query.
+//!
+//! This function returns the current status of LPM requests for a given
+//! device.  This is called to determine if a previous request completed
+//! successfully or if there was an error.
+//!
+//! \return This function returns the following values:
+//! - \b USBHCD_LPM_AVAIL - There are no pending LPM requests on this specific
+//!   device or the last request completed successfully.
+//! - \b USBHCD_LPM_ERROR - The last LPM request for this device did not
+//!   complete successfully.
+//! - \b USBHCD_LPM_PENDING - The last LPM request has not completed.
+//
+//*****************************************************************************
+uint32_t
+USBHCDLPMStatus(tUSBHostDevice *psDevice)
+{
+    uint32_t ui32Ret;
+
+    ASSERT(psDevice != 0);
+
+    //
+    // Should never have both USBHDEV_FLAG_LPMERROR and USBHDEV_FLAG_LPMPEND
+    // set at the same time.
+    //
+    ASSERT((psDevice->ui32Flags &
+            (USBHDEV_FLAG_LPMERROR | USBHDEV_FLAG_LPMPEND)) !=
+           (USBHDEV_FLAG_LPMERROR | USBHDEV_FLAG_LPMPEND));
+
+    //
+    // Default to no pending transfers or errors.
+    //
+    ui32Ret = USBHCD_LPM_AVAIL;
+
+    if(psDevice->ui32Flags & USBHDEV_FLAG_LPMERROR)
+    {
+        //
+        // An error occurred after the last call to send an LPM command.
+        //
+        ui32Ret = USBHCD_LPM_ERROR;
+    }
+    else if(psDevice->ui32Flags & USBHDEV_FLAG_LPMPEND)
+    {
+        //
+        // Still have a pending transfer.
+        //
+        ui32Ret = USBHCD_LPM_PENDING;
+    }
+
+    return(ui32Ret);
+}
+
+//*****************************************************************************
+//
+//! This function generates an LPM request for a device to enter L1 sleep
+//! state.
+//!
+//! \param psDevice is the device to query.
+//!
+//! This function sends a request to a device to enter the LPM L1 sleep state.
+//! The caller must check the return value to see if the request can be
+//! attempted at this time.  If another LPM transaction is busy on another
+//! device this function will return \b USBHCD_LPM_PENDING or
+//! \b USBHCD_LPM_AVAIL if the LPM request was scheduled to be sent.  The
+//! caller should check the USBHCDLPMStatus() function to determine if the
+//! request has completed.
+//!
+//! \return This function returns the following values:
+//! - USBHCD_LPM_AVAIL - The transition to L1 state is scheduled to be sent.
+//! - USBHCD_LPM_PENDING - There is already an LPM request pending.
+//
+//*****************************************************************************
+uint32_t
+USBHCDLPMSleep(tUSBHostDevice *psDevice)
+{
+    uint32_t ui32Ret;
+
+    ASSERT(psDevice != 0);
+
+     //
+     // Disable the USB interrupt.
+     //
+     OS_INT_DISABLE(g_sUSBHCD.ui32IntNum);
+
+     //
+     // If there is no current LPM pending then send the request.
+     //
+     if((g_sUSBHCD.ui32IntEvents & INT_EVENT_LPM_PEND) ||
+        (psDevice->ui32Flags & USBHDEV_FLAG_LPMPEND))
+     {
+         ui32Ret = USBHCD_LPM_PENDING;
+     }
+     else
+     {
+         //
+         // New pending LPM transfer at the host controller level.
+         //
+         g_sUSBHCD.ui32IntEvents |= INT_EVENT_LPM_PEND;
+
+         //
+         // New pending request and clear any previous error for this
+         // device in case it was already set.
+         //
+         psDevice->ui32Flags |= USBHDEV_FLAG_LPMPEND;
+         psDevice->ui32Flags &= ~USBHDEV_FLAG_LPMERROR;
+
+         USBHostLPMSend(USB0_BASE, psDevice->ui32Address, USB_EP_0);
+
+         ui32Ret = USBHCD_LPM_AVAIL;
+     }
+
+     //
+     // Disable the USB interrupt.
+     //
+     OS_INT_ENABLE(g_sUSBHCD.ui32IntNum);
+
+    return(ui32Ret);
+}
+
+//*****************************************************************************
+//
+//! This function generates an LPM request for a device to exit L1 sleep state.
+//!
+//! \param ui32Index specifies which USB controller to use.
+//!
+//! This function will start LPM resume signaling on the USB bus.  This wakes
+//! all devices and is similar to USBHCDResume() call but is triggered by an
+//! LPM request.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBHCDLPMResume(uint32_t ui32Index)
+{
+    ASSERT(ui32Index == 0);
+
+    USBHostLPMResume(USB0_BASE);
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
diff --git a/bsp/tm4c129x/libraries/usblib/host/usbhostpriv.h b/bsp/tm4c129x/libraries/usblib/host/usbhostpriv.h
new file mode 100755
index 0000000..b74cbfa
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/host/usbhostpriv.h
@@ -0,0 +1,201 @@
+//*****************************************************************************
+//
+// usbhostpriv.h - Internal header file for USB host functions.
+//
+// Copyright (c) 2011-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#ifndef __USBHOSTPRIV_H__
+#define __USBHOSTPRIV_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+//*****************************************************************************
+//
+// The states a hub port can be in during device connection.
+//
+//*****************************************************************************
+typedef enum
+{
+    //
+    // The port has no device connected.
+    //
+    ePortIdle,
+
+    //
+    // The port has a device present and is waiting for the enumeration
+    // sequence to begin.
+    //
+    ePortConnected,
+
+    //
+    // A device connection notification has been received and we have initiated
+    // a reset to the port.  We are waiting for the reset to complete.
+    //
+    ePortResetActive,
+
+    //
+    // The Port reset has completed but now the hub is waiting the required
+    // 10ms before accessing the device.
+    //
+    ePortResetWait,
+
+    //
+    // A device is connected and the port has been reset.  Control has been
+    // passed to the main host handling portion of USBLib to enumerate the
+    // device.
+    //
+    ePortActive,
+
+    //
+    // A device has completed enumeration.
+    //
+    ePortEnumerated,
+
+    //
+    // A device is attached to the port but enumeration failed.
+    //
+    ePortError
+}
+tHubPortState;
+
+//*****************************************************************************
+//
+// The list of valid event flags in the g_sUSBHCD.ui32EventEnables member
+// variable.
+//
+//*****************************************************************************
+#define USBHCD_EVFLAG_SOF       0x00000001
+#define USBHCD_EVFLAG_CONNECT   0x00000002
+#define USBHCD_EVFLAG_UNKCNCT   0x00000004
+#define USBHCD_EVFLAG_DISCNCT   0x00000008
+#define USBHCD_EVFLAG_PWRFAULT  0x00000010
+#define USBHCD_EVFLAG_PWRDIS    0x00000020
+#define USBHCD_EVFLAG_PWREN     0x00000040
+
+//*****************************************************************************
+//
+// This is the structure that holds all of the information for devices
+// that are enumerated in the system.  It is passed in to Open function of
+// USB host class drivers so that they can allocate any endpoints and parse
+// out other information that the device class needs to complete enumeration.
+//
+//*****************************************************************************
+struct tUSBHostDevice
+{
+    //
+    // The current device address for this device.
+    //
+    uint32_t ui32Address;
+
+    //
+    // The current interface for this device.
+    //
+    uint32_t ui32Interface;
+
+    //
+    // A flag used to record whether this is a low-speed or a full-speed
+    // device.
+    //
+    bool bLowSpeed;
+
+    //
+    // The USB connection speed for this device.
+    //
+    uint32_t ui32Speed;
+
+    //
+    // A flag indicating whether or not we have read the device's
+    // configuration descriptor yet.
+    //
+    bool bConfigRead;
+
+    //
+    // The hub number to which this device is attached.
+    //
+    uint8_t ui8Hub;
+
+    //
+    // The hub port number to which the device is attached.
+    //
+    uint8_t ui8HubPort;
+
+    //
+    // The device descriptor for this device.
+    //
+    tDeviceDescriptor sDeviceDescriptor;
+
+    //
+    // A pointer to the configuration descriptor for this device.
+    //
+    tConfigDescriptor *psConfigDescriptor;
+
+    //
+    // The size of the buffer allocated to psConfigDescriptor.
+    //
+    uint32_t ui32ConfigDescriptorSize;
+
+    //
+    // Internal flags used by the host controller driver.
+    //
+    uint32_t ui32Flags;
+};
+
+//*****************************************************************************
+//
+// Functions within the host controller that are called by the hub class driver
+//
+//*****************************************************************************
+extern uint32_t USBHCDHubDeviceConnected(uint32_t ui32Index, uint8_t ui8Hub,
+                                         uint8_t ui8Port, uint32_t ui32Speed);
+extern void USBHCDHubDeviceDisconnected(uint32_t ui32Index,
+                                        uint32_t ui32DevIndex);
+
+//*****************************************************************************
+//
+// Functions in the hub class driver that are called by the host controller.
+//
+//*****************************************************************************
+extern void USBHHubMain(void);
+extern void USBHHubInit(void);
+extern void USBHHubEnumerationComplete(uint8_t ui8Hub, uint8_t ui8Port);
+extern void USBHHubEnumerationError(uint8_t ui8Hub, uint8_t ui8Port);
+extern uint32_t USBHCDLPMSleep(tUSBHostDevice *psDevice);
+extern uint32_t USBHCDLPMStatus(tUSBHostDevice *psDevice);
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __USBHOSTPRIV_H__
diff --git a/bsp/tm4c129x/libraries/usblib/host/usbhscsi.c b/bsp/tm4c129x/libraries/usblib/host/usbhscsi.c
new file mode 100755
index 0000000..fd25c14
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/host/usbhscsi.c
@@ -0,0 +1,777 @@
+//*****************************************************************************
+//
+// usbhscsi.c - USB host SCSI layer used by the USB host MSC driver.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "inc/hw_types.h"
+#include "usblib/usblib.h"
+#include "usblib/usbmsc.h"
+#include "usblib/host/usbhost.h"
+#include "usblib/host/usbhmsc.h"
+#include "usblib/host/usbhscsi.h"
+
+//*****************************************************************************
+//
+//! \addtogroup usblib_host_class
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// This is the data verify tag passed between requests.
+//
+//*****************************************************************************
+#define CBW_TAG_VALUE           0x54231990
+
+//*****************************************************************************
+//
+//! This function is used to issue SCSI commands via USB.
+//!
+//! \param ui32InPipe is the USB IN pipe to use for this command.
+//! \param ui32OutPipe is the USB OUT pipe to use for this command.
+//! \param psSCSICmd is the SCSI command structure to send.
+//! \param pui8Data is pointer to the command data to be sent.
+//! \param pui32Size is the number of bytes is the number of bytes expected or
+//! sent by the command.
+//!
+//! This internal function is used to handle SCSI commands sent by other
+//! functions.  It serves as a layer between the SCSI command and the USB
+//! interface being used to send the command.  The \e pSCSI parameter contains
+//! the SCSI command to send.  For commands that expect data back, the
+//! \e pui8Data is the buffer to store the data into and \e pui32Size is used
+//! to store the amount of data to request as well as used to indicate how many
+//! bytes were filled into the \e pui8Data buffer on return.  For commands that
+//! are sending data, \e pui8Data is the data to be sent and \e pui32Size is
+//! the number of bytes to send.
+//!
+//! \return This function returns the SCSI status from the command.  The value
+//! will be either \b SCSI_CMD_STATUS_PASS or \b SCSI_CMD_STATUS_FAIL.
+//
+//*****************************************************************************
+static uint32_t
+USBHSCSISendCommand(uint32_t ui32InPipe, uint32_t ui32OutPipe,
+                    tMSCCBW *psSCSICmd, uint8_t *pui8Data, uint32_t *pui32Size)
+{
+    tMSCCSW sCmdStatus;
+    uint32_t ui32Bytes;
+
+    //
+    // Initialize the command status.
+    //
+    sCmdStatus.dCSWSignature = 0;
+    sCmdStatus.dCSWTag = 0;
+    sCmdStatus.bCSWStatus = SCSI_CMD_STATUS_FAIL;
+
+    //
+    // Set the CBW signature and tag.
+    //
+    psSCSICmd->dCBWSignature = CBW_SIGNATURE;
+    psSCSICmd->dCBWTag = CBW_TAG_VALUE;
+
+    //
+    // Set the size of the data to be returned by the device.
+    //
+    psSCSICmd->dCBWDataTransferLength = *pui32Size;
+
+    //
+    // Send the command.
+    //
+    ui32Bytes = USBHCDPipeWrite(ui32OutPipe, (uint8_t*)psSCSICmd,
+                                sizeof(tMSCCBW));
+
+    //
+    // If no bytes went out then the command failed.
+    //
+    if(ui32Bytes == 0)
+    {
+        return(SCSI_CMD_STATUS_FAIL);
+    }
+
+    //
+    // Only request data if there is data to request.
+    //
+    if(psSCSICmd->dCBWDataTransferLength != 0)
+    {
+        //
+        // See if this is a read or a write.
+        //
+        if(psSCSICmd->bmCBWFlags & CBWFLAGS_DIR_IN)
+        {
+            //
+            // Read the data back.
+            //
+            *pui32Size = USBHCDPipeRead(ui32InPipe, pui8Data, *pui32Size);
+        }
+        else
+        {
+            //
+            // Write the data out.
+            //
+            *pui32Size = USBHCDPipeWrite(ui32OutPipe, pui8Data, *pui32Size);
+        }
+    }
+
+    //
+    // Get the status of the command.
+    //
+    ui32Bytes = USBHCDPipeRead(ui32InPipe, (uint8_t *)&sCmdStatus,
+                               sizeof(tMSCCSW));
+
+
+    //
+    // If the status was invalid or did not have the correct signature then
+    // indicate a failure.
+    //
+    if((ui32Bytes == 0) || (sCmdStatus.dCSWSignature != CSW_SIGNATURE) ||
+       (sCmdStatus.dCSWTag != CBW_TAG_VALUE))
+    {
+        return(SCSI_CMD_STATUS_FAIL);
+    }
+
+    //
+    // Return the status.
+    //
+    return((uint32_t)sCmdStatus.bCSWStatus);
+}
+
+//*****************************************************************************
+//
+//! This will issue the SCSI inquiry command to a device.
+//!
+//! \param ui32InPipe is the USB IN pipe to use for this command.
+//! \param ui32OutPipe is the USB OUT pipe to use for this command.
+//! \param pui8Data is the data buffer to return the results into.
+//! \param pui32Size is the size of buffer that was passed in on entry and the
+//! number of bytes returned.
+//!
+//! This function should be used to issue a SCSI Inquiry command to a mass
+//! storage device.  To allow for multiple devices, the \e ui32InPipe and
+//! \e ui32OutPipe parameters indicate which USB pipes to use for this call.
+//!
+//! \note The \e pui8Data buffer pointer should have at least
+//! \b SCSI_INQUIRY_DATA_SZ bytes of data or this function will overflow the
+//! buffer.
+//!
+//! \return This function returns the SCSI status from the command.  The value
+//! will be either \b SCSI_CMD_STATUS_PASS or \b SCSI_CMD_STATUS_FAIL.
+//
+//*****************************************************************************
+uint32_t
+USBHSCSIInquiry(uint32_t ui32InPipe, uint32_t ui32OutPipe,
+                uint8_t *pui8Data, uint32_t *pui32Size)
+{
+    tMSCCBW sSCSICmd;
+    uint32_t *pui32Data;
+
+    //
+    // Create a local 32-bit pointer to the command.
+    //
+    pui32Data = (uint32_t *)sSCSICmd.CBWCB;
+
+    //
+    // The number of bytes of data that the host expects to transfer on the
+    // Bulk-In or Bulk-Out endpoint (as indicated by the Direction bit) during
+    // the execution of this command.  If this field is zero, the device and
+    // the host shall transfer no data between the CBW and the associated CSW,
+    // and the device shall ignore the value of the Direction bit in
+    // bmCBWFlags.
+    //
+    *pui32Size = SCSI_INQUIRY_DATA_SZ;
+
+    //
+    // This is an IN request.
+    //
+    sSCSICmd.bmCBWFlags = CBWFLAGS_DIR_IN;
+
+    //
+    // Only handle LUN 0.
+    //
+    sSCSICmd.bCBWLUN = 0;
+
+    //
+    // This is the length of the command itself.
+    //
+    sSCSICmd.bCBWCBLength = 6;
+
+    //
+    // Send Inquiry command with no request for vital product data.
+    //
+    pui32Data[0] = SCSI_INQUIRY_CMD;
+
+    //
+    // Allocation length.
+    //
+    pui32Data[1] = SCSI_INQUIRY_DATA_SZ;
+    pui32Data[2] = 0;
+    pui32Data[3] = 0;
+
+    //
+    // Send the command and get the results.
+    //
+    return(USBHSCSISendCommand(ui32InPipe, ui32OutPipe, &sSCSICmd, pui8Data,
+                               pui32Size));
+}
+
+//*****************************************************************************
+//
+//! This will issue the SCSI read capacity command to a device.
+//!
+//! \param ui32InPipe is the USB IN pipe to use for this command.
+//! \param ui32OutPipe is the USB OUT pipe to use for this command.
+//! \param pui8Data is the data buffer to return the results into.
+//! \param pui32Size is the size of buffer that was passed in on entry and the
+//! number of bytes returned.
+//!
+//! This function should be used to issue a SCSI Read Capacity command
+//! to a mass storage device that is connected.  To allow for multiple devices,
+//! the \e ui32InPipe and \e ui32OutPipe parameters indicate which USB pipes to
+//! use for this call.
+//!
+//! \note The \e pui8Data buffer pointer should have at least
+//! \b SCSI_READ_CAPACITY_SZ bytes of data or this function will overflow the
+//! buffer.
+//!
+//! \return This function returns the SCSI status from the command.  The value
+//! will be either \b SCSI_CMD_STATUS_PASS or \b SCSI_CMD_STATUS_FAIL.
+//
+//*****************************************************************************
+uint32_t
+USBHSCSIReadCapacity(uint32_t ui32InPipe, uint32_t ui32OutPipe,
+                     uint8_t *pui8Data, uint32_t *pui32Size)
+{
+    tMSCCBW sSCSICmd;
+    uint32_t *pui32Data;
+
+    //
+    // Create a local 32-bit pointer to the command.
+    //
+    pui32Data = (uint32_t *)sSCSICmd.CBWCB;
+
+    //
+    // Set the size of the command data.
+    //
+    *pui32Size = SCSI_READ_CAPACITY_SZ;
+
+    //
+    // This is an IN request.
+    //
+    sSCSICmd.bmCBWFlags = CBWFLAGS_DIR_IN;
+
+    //
+    // Only handle LUN 0.
+    //
+    sSCSICmd.bCBWLUN = 0;
+
+    //
+    // Set the length of the command itself.
+    //
+    sSCSICmd.bCBWCBLength = 12;
+
+    //
+    // Only use the first byte and set it to the Read Capacity command.  The
+    // rest are set to 0.
+    //
+    pui32Data[0] = SCSI_READ_CAPACITY;
+    pui32Data[1] = 0;
+    pui32Data[2] = 0;
+    pui32Data[3] = 0;
+
+    //
+    // Send the command and get the results.
+    //
+    return(USBHSCSISendCommand(ui32InPipe, ui32OutPipe, &sSCSICmd, pui8Data,
+                               pui32Size));
+}
+
+//*****************************************************************************
+//
+//! This will issue the SCSI read capacities command to a device.
+//!
+//! \param ui32InPipe is the USB IN pipe to use for this command.
+//! \param ui32OutPipe is the USB OUT pipe to use for this command.
+//! \param pui8Data is the data buffer to return the results into.
+//! \param pui32Size is the size of buffer that was passed in on entry and the
+//! number of bytes returned.
+//!
+//! This function should be used to issue a SCSI Read Capacities command
+//! to a mass storage device that is connected.  To allow for multiple devices,
+//! the \e ui32InPipe and \e ui32OutPipe parameters indicate which USB pipes to
+//! use for this call.
+//!
+//! \return This function returns the SCSI status from the command.  The value
+//! will be either \b SCSI_CMD_STATUS_PASS or \b SCSI_CMD_STATUS_FAIL.
+//
+//*****************************************************************************
+uint32_t
+USBHSCSIReadCapacities(uint32_t ui32InPipe, uint32_t ui32OutPipe,
+                       uint8_t *pui8Data, uint32_t *pui32Size)
+{
+    tMSCCBW sSCSICmd;
+    uint32_t *pui32Data;
+
+    //
+    // Create a local 32-bit pointer to the command.
+    //
+    pui32Data = (uint32_t *)sSCSICmd.CBWCB;
+
+    //
+    // This is an IN request.
+    //
+    sSCSICmd.bmCBWFlags = CBWFLAGS_DIR_IN;
+
+    //
+    // Only handle LUN 0.
+    //
+    sSCSICmd.bCBWLUN = 0;
+
+    //
+    // Set the length of the command itself.
+    //
+    sSCSICmd.bCBWCBLength = 12;
+
+    //
+    // Only use the first byte and set it to the Read Capacity command.  The
+    // rest are set to 0.
+    //
+    pui32Data[0] = SCSI_READ_CAPACITIES;
+    pui32Data[1] = 0;
+    pui32Data[2] = 0;
+    pui32Data[3] = 0;
+
+    //
+    // Send the command and get the results.
+    //
+    return(USBHSCSISendCommand(ui32InPipe, ui32OutPipe, &sSCSICmd, pui8Data,
+                               pui32Size));
+}
+
+//*****************************************************************************
+//
+//! This will issue the SCSI Mode Sense(6) command to a device.
+//!
+//! \param ui32InPipe is the USB IN pipe to use for this command.
+//! \param ui32OutPipe is the USB OUT pipe to use for this command.
+//! \param ui32Flags is a combination of flags defining the exact query that is
+//! to be made.
+//! \param pui8Data is the data buffer to return the results into.
+//! \param pui32Size is the size of the buffer on entry and number of bytes
+//! read on exit.
+//!
+//! This function should be used to issue a SCSI Mode Sense(6) command
+//! to a mass storage device.  To allow for multiple devices,the \e ui32InPipe
+//! and \e ui32OutPipe parameters indicate which USB pipes to use for this
+//! call. The call will return at most the number of bytes in the \e pui32Size
+//! parameter, however it can return less and change the \e pui32Size parameter
+//! to the number of valid bytes in the \e *pui32Size buffer.
+//!
+//! The \e ui32Flags parameter is a combination of the following three sets of
+//! definitions:
+//!
+//! One of the following values must be specified:
+//!
+//! - \b SCSI_MS_PC_CURRENT request for current settings.
+//! - \b SCSI_MS_PC_CHANGEABLE request for changeable settings.
+//! - \b SCSI_MS_PC_DEFAULT request for default settings.
+//! - \b SCSI_MS_PC_SAVED request for the saved values.
+//!
+//! One of these following values must also be specified to determine the page
+//! code for the request:
+//!
+//! - \b SCSI_MS_PC_VENDOR is the vendor specific page code.
+//! - \b SCSI_MS_PC_DISCO is the disconnect/reconnect page code.
+//! - \b SCSI_MS_PC_CONTROL is the control page code.
+//! - \b SCSI_MS_PC_LUN is the protocol specific LUN page code.
+//! - \b SCSI_MS_PC_PORT is the protocol specific port page code.
+//! - \b SCSI_MS_PC_POWER is the power condition page code.
+//! - \b SCSI_MS_PC_INFORM is the informational exceptions page code.
+//! - \b SCSI_MS_PC_ALL will request all pages codes supported by the device.
+//!
+//! The last value is optional and supports the following global flag:
+//! - \b SCSI_MS_DBD disables returning block descriptors.
+//!
+//! Example: Request for all current settings.
+//!
+//! \verbatim
+//! SCSIModeSense6(ui32InPipe, ui32OutPipe,
+//!                SCSI_MS_PC_CURRENT | SCSI_MS_PC_ALL,
+//!                pui8Data, pui32Size);
+//! \endverbatim
+//!
+//! \return This function returns the SCSI status from the command.  The value
+//! will be either \b SCSI_CMD_STATUS_PASS or \b SCSI_CMD_STATUS_FAIL.
+//
+//*****************************************************************************
+uint32_t
+USBHSCSIModeSense6(uint32_t ui32InPipe, uint32_t ui32OutPipe,
+                   uint32_t ui32Flags, uint8_t *pui8Data,
+                   uint32_t *pui32Size)
+{
+    tMSCCBW sSCSICmd;
+    uint32_t *pui32Data;
+
+    //
+    // Create a local 32-bit pointer to the command.
+    //
+    pui32Data = (uint32_t *)sSCSICmd.CBWCB;
+
+    //
+    // This is an IN request.
+    //
+    sSCSICmd.bmCBWFlags = CBWFLAGS_DIR_IN;
+
+    //
+    // Only handle LUN 0.
+    //
+    sSCSICmd.bCBWLUN = 0;
+
+    //
+    // Set the size of the command data.
+    //
+    sSCSICmd.bCBWCBLength = 6;
+
+    //
+    // Set the options for the Mode Sense Command (6).
+    //
+    pui32Data[0] = (SCSI_MODE_SENSE_6 | ui32Flags);
+    pui32Data[1] = (uint8_t)*pui32Size;
+    pui32Data[2] = 0;
+    pui32Data[3] = 0;
+
+    //
+    // Send the command and get the results.
+    //
+    return(USBHSCSISendCommand(ui32InPipe, ui32OutPipe, &sSCSICmd, pui8Data,
+                               pui32Size));
+}
+
+//*****************************************************************************
+//
+//! This function issues a SCSI Test Unit Ready command to a device.
+//!
+//! \param ui32InPipe is the USB IN pipe to use for this command.
+//! \param ui32OutPipe is the USB OUT pipe to use for this command.
+//!
+//! This function is used to issue a SCSI Test Unit Ready command to a device.
+//! This call will simply return the results of issuing this command.
+//!
+//! \return This function returns the results of the SCSI Test Unit Ready
+//! command.  The value will be either \b SCSI_CMD_STATUS_PASS or
+//! \b SCSI_CMD_STATUS_FAIL.
+//
+//*****************************************************************************
+uint32_t
+USBHSCSITestUnitReady(uint32_t ui32InPipe, uint32_t ui32OutPipe)
+{
+    tMSCCBW sSCSICmd;
+    uint32_t ui32Size;
+    uint32_t *pui32Data;
+
+    //
+    // Create a local 32-bit pointer to the command.
+    //
+    pui32Data = (uint32_t *)sSCSICmd.CBWCB;
+
+    //
+    // No data in this command.
+    //
+    ui32Size = 0;
+
+    //
+    // This is an IN request.
+    //
+    sSCSICmd.bmCBWFlags = CBWFLAGS_DIR_IN;
+
+    //
+    // Only handle LUN 0.
+    //
+    sSCSICmd.bCBWLUN = 0;
+
+    //
+    // Set the size of the command data.
+    //
+    sSCSICmd.bCBWCBLength = 6;
+
+    //
+    // Set the parameter options.
+    //
+    pui32Data[0] = SCSI_TEST_UNIT_READY;
+    pui32Data[1] = 0;
+    pui32Data[2] = 0;
+    pui32Data[3] = 0;
+
+    //
+    // Send the command and get the results.
+    //
+    return(USBHSCSISendCommand(ui32InPipe, ui32OutPipe, &sSCSICmd, 0,
+                               &ui32Size));
+}
+
+//*****************************************************************************
+//
+//! This function issues a SCSI Request Sense command to a device.
+//!
+//! \param ui32InPipe is the USB IN pipe to use for this command.
+//! \param ui32OutPipe is the USB OUT pipe to use for this command.
+//! \param pui8Data is the data buffer to return the results into.
+//! \param pui32Size is the size of the buffer on entry and number of bytes
+//! read on exit.
+//!
+//! This function is used to issue a SCSI Request Sense command to a device.
+//! It will return the data in the buffer pointed to by \e pui8Data.  The
+//! parameter \e pui32Size should have the allocation size in bytes of the
+//! buffer pointed to by \e pui8Data.
+//!
+//! \return This function returns the results of the SCSI Request Sense
+//! command.  The value will be either \b SCSI_CMD_STATUS_PASS or
+//! \b SCSI_CMD_STATUS_FAIL.
+//
+//*****************************************************************************
+uint32_t
+USBHSCSIRequestSense(uint32_t ui32InPipe, uint32_t ui32OutPipe,
+                     uint8_t *pui8Data, uint32_t *pui32Size)
+{
+    tMSCCBW sSCSICmd;
+    uint32_t *pui32Data;
+
+    //
+    // Create a local 32-bit pointer to the command.
+    //
+    pui32Data = (uint32_t *)sSCSICmd.CBWCB;
+
+    //
+    // This is an IN request.
+    //
+    sSCSICmd.bmCBWFlags = CBWFLAGS_DIR_IN;
+
+    //
+    // Only handle LUN 0.
+    //
+    sSCSICmd.bCBWLUN = 0;
+
+    //
+    // Set the size of the command data.
+    //
+    sSCSICmd.bCBWCBLength = 12;
+
+    //
+    // Set the parameter options.
+    //
+    pui32Data[0] = SCSI_REQUEST_SENSE;
+    pui32Data[1] = 18;
+    pui32Data[2] = 0;
+    pui32Data[3] = 0;
+
+    //
+    // Send the command and get the results.
+    //
+    return(USBHSCSISendCommand(ui32InPipe, ui32OutPipe, &sSCSICmd, pui8Data,
+                               pui32Size));
+}
+
+//*****************************************************************************
+//
+//! This function issues a SCSI Read(10) command to a device.
+//!
+//! \param ui32InPipe is the USB IN pipe to use for this command.
+//! \param ui32OutPipe is the USB OUT pipe to use for this command.
+//! \param ui32LBA is the logical block address to read.
+//! \param pui8Data is the data buffer to return the data.
+//! \param pui32Size is the size of the buffer on entry and number of bytes
+//! read on exit.
+//! \param ui32NumBlocks is the number of contiguous blocks to read from the
+//! device.
+//!
+//! This function is used to issue a SCSI Read(10) command to a device.  The
+//! \e ui32LBA parameter specifies the logical block address to read from the
+//! device.  The data from this block will be returned in the buffer pointed to
+//! by \e pui8Data.  The parameter \e pui32Size should indicate enough space to
+//! hold a full block size, or only the first \e pui32Size bytes of the LBA are
+//! returned.
+//!
+//! \return This function returns the results of the SCSI Read(10) command.
+//! The value will be either \b SCSI_CMD_STATUS_PASS or
+//! \b SCSI_CMD_STATUS_FAIL.
+//
+//*****************************************************************************
+uint32_t
+USBHSCSIRead10(uint32_t ui32InPipe, uint32_t ui32OutPipe,
+               uint32_t ui32LBA, uint8_t *pui8Data,
+               uint32_t *pui32Size, uint32_t ui32NumBlocks)
+{
+    tMSCCBW sSCSICmd;
+    int32_t i32Idx;
+
+    //
+    // Zero out the response data.
+    //
+    for(i32Idx = 0; i32Idx < sizeof(sSCSICmd.CBWCB); i32Idx++)
+    {
+        sSCSICmd.CBWCB[i32Idx] = 0;
+    }
+
+    //
+    // This is an IN request.
+    //
+    sSCSICmd.bmCBWFlags = CBWFLAGS_DIR_IN;
+
+    //
+    // Only handle LUN 0.
+    //
+    sSCSICmd.bCBWLUN = 0;
+
+    //
+    // Set the size of the command data.
+    //
+    sSCSICmd.bCBWCBLength = 10;
+
+    //
+    // Set the parameter options.
+    //
+    sSCSICmd.CBWCB[0] = SCSI_READ_10;
+
+    //
+    // LBA starts at offset 2.
+    //
+    sSCSICmd.CBWCB[2] = (uint8_t)(ui32LBA >> 24);
+    sSCSICmd.CBWCB[3] = (uint8_t)(ui32LBA >> 16);
+    sSCSICmd.CBWCB[4] = (uint8_t)(ui32LBA >> 8);
+    sSCSICmd.CBWCB[5] = (uint8_t)ui32LBA;
+
+    //
+    // Transfer length in blocks starts at offset 7.
+    //
+    sSCSICmd.CBWCB[7] = (uint8_t)(ui32NumBlocks >> 8);
+    sSCSICmd.CBWCB[8] = (uint8_t)ui32NumBlocks;
+
+    //
+    // Send the command and get the results.
+    //
+    return(USBHSCSISendCommand(ui32InPipe, ui32OutPipe, &sSCSICmd, pui8Data,
+                               pui32Size));
+}
+
+//*****************************************************************************
+//
+//! This function issues a SCSI Write(10) command to a device.
+//!
+//! This function is used to issue a SCSI Write(10) command to a device.  The
+//! \e ui32LBA parameter specifies the logical block address on the device.
+//! The data to write to this block should be in the buffer pointed to by
+//! \e pui8Data parameter.  The parameter \e pui32Size should indicate the
+//! amount of data to write to the specified LBA.
+//!
+//! \param ui32InPipe is the USB IN pipe to use for this command.
+//! \param ui32OutPipe is the USB OUT pipe to use for this command.
+//! \param ui32LBA is the logical block address to read.
+//! \param pui8Data is the data buffer to write out.
+//! \param pui32Size is the size of the buffer.
+//! \param ui32NumBlocks is the number of contiguous blocks to write to the
+//! device.
+//!
+//! \return This function returns the results of the SCSI Write(10) command.
+//! The value will be either \b SCSI_CMD_STATUS_PASS or
+//! \b SCSI_CMD_STATUS_FAIL.
+//
+//*****************************************************************************
+uint32_t
+USBHSCSIWrite10(uint32_t ui32InPipe, uint32_t ui32OutPipe,
+                uint32_t ui32LBA, uint8_t *pui8Data,
+                uint32_t *pui32Size, uint32_t ui32NumBlocks)
+{
+    tMSCCBW sSCSICmd;
+    uint32_t *pui32Data;
+
+    //
+    // Create a local 32-bit pointer to the command.
+    //
+    pui32Data = (uint32_t *)sSCSICmd.CBWCB;
+
+    //
+    // This is an IN request.
+    //
+    sSCSICmd.bmCBWFlags = CBWFLAGS_DIR_OUT;
+
+    //
+    // Only handle LUN 0.
+    //
+    sSCSICmd.bCBWLUN = 0;
+
+    //
+    // Set the size of the command data.
+    //
+    sSCSICmd.bCBWCBLength = 10;
+
+    //
+    // Set the parameter options.
+    //
+    sSCSICmd.CBWCB[0] = SCSI_WRITE_10;
+
+    //
+    // Clear the reserved field.
+    //
+    sSCSICmd.CBWCB[1] = 0;
+
+    //
+    // LBA starts at offset 2.
+    //
+    sSCSICmd.CBWCB[2] = (uint8_t)(ui32LBA >> 24);
+    sSCSICmd.CBWCB[3] = (uint8_t)(ui32LBA >> 16);
+    sSCSICmd.CBWCB[4] = (uint8_t)(ui32LBA >> 8);
+    sSCSICmd.CBWCB[5] = (uint8_t)ui32LBA;
+
+    //
+    // Clear the reserved field.
+    //
+    sSCSICmd.CBWCB[6] = 0;
+
+    //
+    // Set the transfer length in blocks.
+    // This also sets the Control value to 0 at offset 9.
+    //
+    sSCSICmd.CBWCB[7] = (ui32NumBlocks & 0xFF00) >> 8;
+
+    //
+    // The blocks go into is byte offset 8 or word address 2.
+    //
+    pui32Data[2] = (ui32NumBlocks & 0xFF);
+
+    //
+    // The blocks go into is byte offset 12 or word address 3.
+    //
+    pui32Data[3] = 0;
+
+    //
+    // Send the command and get the results.
+    //
+    return(USBHSCSISendCommand(ui32InPipe, ui32OutPipe, &sSCSICmd, pui8Data,
+                               pui32Size));
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
diff --git a/bsp/tm4c129x/libraries/usblib/host/usbhscsi.h b/bsp/tm4c129x/libraries/usblib/host/usbhscsi.h
new file mode 100755
index 0000000..cb5a9cc
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/host/usbhscsi.h
@@ -0,0 +1,87 @@
+//*****************************************************************************
+//
+// usbhscsi.h - Definitions for the USB host SCSI layer.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#ifndef __USBHSCSI_H__
+#define __USBHSCSI_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+//*****************************************************************************
+//
+//! \addtogroup usblib_host_class
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Prototypes for the APIs exported by the USB SCSI layer.
+//
+//*****************************************************************************
+extern uint32_t USBHSCSIInquiry(uint32_t ui32InPipe, uint32_t ui32OutPipe,
+                                uint8_t *pui8Buffer, uint32_t *pui32Size);
+extern uint32_t USBHSCSIReadCapacity(uint32_t ui32InPipe, uint32_t ui32OutPipe,
+                                     uint8_t *pui8Data, uint32_t *pui32Size);
+extern uint32_t USBHSCSIReadCapacities(uint32_t ui32InPipe,
+                                       uint32_t ui32OutPipe, uint8_t *pui8Data,
+                                       uint32_t *pui32Size);
+extern uint32_t USBHSCSIModeSense6(uint32_t ui32InPipe, uint32_t ui32OutPipe,
+                                   uint32_t ui32Flags, uint8_t *pui8Data,
+                                   uint32_t *pui32Size);
+extern uint32_t USBHSCSITestUnitReady(uint32_t ui32InPipe,
+                                      uint32_t ui32OutPipe);
+extern uint32_t USBHSCSIRequestSense(uint32_t ui32InPipe, uint32_t ui32OutPipe,
+                                     uint8_t *pui8Data, uint32_t *pui32Size);
+extern uint32_t USBHSCSIRead10(uint32_t ui32InPipe, uint32_t ui32OutPipe,
+                               uint32_t ui32LBA, uint8_t *pui8Data,
+                               uint32_t *pui32Size, uint32_t ui32NumBlocks);
+extern uint32_t USBHSCSIWrite10(uint32_t ui32InPipe, uint32_t ui32OutPipe,
+                                uint32_t ui32LBA, uint8_t *pui8Data,
+                                uint32_t *pui32Size, uint32_t ui32NumBlocks);
+
+//*****************************************************************************
+//
+//! @}
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __USBHSCSI_H__
diff --git a/bsp/tm4c129x/libraries/usblib/readme.txt b/bsp/tm4c129x/libraries/usblib/readme.txt
new file mode 100755
index 0000000..b7e280a
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/readme.txt
@@ -0,0 +1,21 @@
+This project will build the Tiva USB Library.
+
+-------------------------------------------------------------------------------
+
+Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+Software License Agreement
+
+Texas Instruments (TI) is supplying this software for use solely and
+exclusively on TI's microcontroller products. The software is owned by
+TI and/or its suppliers, and is protected under applicable copyright
+laws. You may not combine this software with "viral" open-source
+software in order to form a larger program.
+
+THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+DAMAGES, FOR ANY REASON WHATSOEVER.
+
+This is part of revision 2.1.0.12573 of the Tiva USB Library.
diff --git a/bsp/tm4c129x/libraries/usblib/usb-ids.h b/bsp/tm4c129x/libraries/usblib/usb-ids.h
new file mode 100755
index 0000000..b2adfda
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/usb-ids.h
@@ -0,0 +1,57 @@
+//*****************************************************************************
+//
+// usb-ids.h - Definitions of VIDs and PIDs used by USB library.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#ifndef __USBIDS_H__
+#define __USBIDS_H__
+
+//*****************************************************************************
+//
+// TI Vendor ID for devices that use VID as 0x1CBE.
+//
+//*****************************************************************************
+#define USB_VID_TI_1CBE         0x1cbe
+
+//*****************************************************************************
+//
+// Product IDs.
+//
+//*****************************************************************************
+#define USB_PID_MOUSE           0x0000
+#define USB_PID_KEYBOARD        0x0001
+#define USB_PID_SERIAL          0x0002
+#define USB_PID_BULK            0x0003
+#define USB_PID_SCOPE           0x0004
+#define USB_PID_MSC             0x0005
+#define USB_PID_AUDIO           0x0006
+#define USB_PID_COMP_SERIAL     0x0007
+#define USB_PID_COMP_AUDIO_HID  0x0008
+#define USB_PID_COMP_HID_SER    0x0009
+#define USB_PID_COMP_HID_DFU    0x000A
+#define USB_PID_DATA_LOGGER     0x000B
+#define USB_PID_COMP_HID_HID    0x000D
+#define USB_PID_GAMEPAD         0x000F
+#define USB_PID_LP_CGAMEPAD     0x0010
+#define USB_PID_DFU             0x00FF
+
+#endif /* __USBIDS_H__ */
diff --git a/bsp/tm4c129x/libraries/usblib/usbaudio.h b/bsp/tm4c129x/libraries/usblib/usbaudio.h
new file mode 100755
index 0000000..8f7ece8
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/usbaudio.h
@@ -0,0 +1,718 @@
+//*****************************************************************************
+//
+// usbaudio.h - Definitions used by Audio Class devices.
+//
+// Copyright (c) 2009-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#ifndef __USBAUDIO_H__
+#define __USBAUDIO_H__
+
+
+//*****************************************************************************
+//
+// Standard Audio descriptor sub types.
+//
+//*****************************************************************************
+#define USB_AI_UNDEFINED        0
+#define USB_AI_HEADER           1
+#define USB_AI_INPUT_TERMINAL   2
+#define USB_AI_OUTPUT_TERMINAL  3
+#define USB_AI_MIXER_UNIT       4
+#define USB_AI_SELECTOR_UNIT    5
+#define USB_AI_FEATURE_UNIT     6
+#define USB_AI_PROCESSING_UNIT  7
+#define USB_AI_EXTENSION_UNIT   8
+
+//*****************************************************************************
+//
+// Standard Audio Streaming Interface descriptor types.
+//
+//*****************************************************************************
+#define USB_AS_UNDEFINED        0
+#define USB_AS_GENERAL          1
+#define USB_AS_FORMAT_TYPE      2
+#define USB_AS_FORMAT_SPECIFIC  3
+
+//*****************************************************************************
+//
+// Standard USB terminal types used with audio terminal descriptors.  These
+// are defined in the "Universal Serial Bus Device Class Definition for
+// Terminal Types" version 1.0 released March 18, 1998.
+//
+//*****************************************************************************
+#define USB_TTYPE_UNDEFINED     0x0100
+#define USB_TTYPE_STREAMING     0x0101
+#define USB_TTYPE_VENDOR        0x01ff
+
+#define USB_TTYPE_OUT_UNDEF     0x0300
+#define USB_TTYPE_OUT_SPEAKER   0x0301
+#define USB_TTYPE_OUT_HEADPHONE 0x0302
+#define USB_TTYPE_OUT_DESK_SPKR 0x0304
+#define USB_TTYPE_OUT_ROOM_SPKR 0x0305
+#define USB_TTYPE_OUT_COMM_SPKR 0x0306
+#define USB_TTYPE_OUT_LFE       0x0307
+
+#define USB_TTYPE_EXT_UNDEF     0x0600
+#define USB_TTYPE_EXT_ANALOG    0x0601
+#define USB_TTYPE_EXT_DIGITAL   0x0602
+#define USB_TTYPE_EXT_LINE      0x0603
+#define USB_TTYPE_EXT_LEGACY    0x0604
+#define USB_TTYPE_EXT_SPDIF     0x0605
+#define USB_TTYPE_EXT_1394_DA   0x0606
+#define USB_TTYPE_EXT_1394_DV   0x0607
+
+//*****************************************************************************
+//
+// Audio Interface Subclass Codes
+//
+//*****************************************************************************
+#define USB_ASC_UNDEFINED       0x00
+#define USB_ASC_AUDIO_CONTROL   0x01
+#define USB_ASC_AUDIO_STREAMING 0x02
+#define USB_ASC_MIDI_STREAMING  0x03
+
+//*****************************************************************************
+//
+// Audio Class-Specific Descriptor Types
+// (Table A-4)
+//
+//*****************************************************************************
+#define USB_ACSDT_UNDEFINED     0x20
+#define USB_ACSDT_DEVICE        0x21
+#define USB_ACSDT_CONFIGURATION 0x22
+#define USB_ACSDT_STRING        0x23
+#define USB_ACSDT_INTERFACE     0x24
+#define USB_ACSDT_ENDPOINT      0x25
+
+//*****************************************************************************
+//
+// Audio Class-Specific AC Interface Descriptor Subtypes
+// (Table A-5)
+//
+//*****************************************************************************
+#define USB_ACDSTYPE_UNDEFINED       0x00
+#define USB_ACDSTYPE_HEADER          0x01
+#define USB_ACDSTYPE_IN_TERMINAL     0x02
+#define USB_ACDSTYPE_OUT_TERMINAL    0x03
+#define USB_ACDSTYPE_MIXER_UNIT      0x04
+#define USB_ACDSTYPE_SELECTOR_UNIT   0x05
+#define USB_ACDSTYPE_FEATURE_UNIT    0x06
+#define USB_ACDSTYPE_PROCESSING_UNIT 0x07
+#define USB_ACDSTYPE_EXTENSION_UNIT  0x08
+
+//*****************************************************************************
+//
+// Audio Class-Specific AS Interface Descriptor Subtypes
+// (Table A-6)
+//
+//*****************************************************************************
+#define USB_ASDSTYPE_UNDEFINED          0x00
+#define USB_ASDSTYPE_GENERAL            0x01
+#define USB_ASDSTYPE_FORMAT_TYPE        0x02
+#define USB_ASDSTYPE_FORMAT_SPECIFIC    0x03
+
+//*****************************************************************************
+//
+// Audio Data Format Type I Codes.
+//
+//*****************************************************************************
+#define USB_ADF_UNDEFINED       0x0000
+#define USB_ADF_PCM             0x0001
+#define USB_ADF_PCM8            0x0002
+#define USB_ADF_IEEE_FLOAT      0x0003
+#define USB_ADF_ALAW            0x0004
+#define USB_ADF_MULAW           0x0005
+
+//*****************************************************************************
+//
+// Audio Format Type Codes
+//
+//*****************************************************************************
+#define USB_AF_TYPE_UNDEFINED   0x00
+#define USB_AF_TYPE_TYPE_I      0x01
+#define USB_AF_TYPE_TYPE_II     0x02
+#define USB_AF_TYPE_TYPE_III    0x03
+
+//*****************************************************************************
+//
+// Audio Class-Specific controls used with bmaControls values.
+//
+//*****************************************************************************
+#define USB_ACONTROL_MUTE       0x0001  // Mute
+#define USB_ACONTROL_VOLUME     0x0002  // Volume
+#define USB_ACONTROL_BASS       0x0004  // Bass
+#define USB_ACONTROL_MID        0x0008  // Mid
+#define USB_ACONTROL_TREBLE     0x0010  // Treble
+#define USB_ACONTROL_EQ         0x0020  // Graphic Equalizer
+#define USB_ACONTROL_AGC        0x0040  // Automatic Gain
+#define USB_ACONTROL_DELAY      0x0080  // Delay
+#define USB_ACONTROL_BASS_BOOST 0x0100  // Bass Boost
+#define USB_ACONTROL_LOUD       0x0200  // Loudness
+
+//*****************************************************************************
+//
+// Audio Class-Specific Output terminal types.
+//
+//*****************************************************************************
+#define USB_ATTYPE_UNDEFINED    0x0300  // Output Terminal, undefined Type.
+#define USB_ATTYPE_SPEAKER      0x0301  // A generic speaker.
+#define USB_ATTYPE_HEADPHONES   0x0302  // A head-mounted audio output device.
+#define USB_ATTYPE_HMD          0x0303  // The audio part of a VR head mounted
+                                        // display.
+#define USB_ATTYPE_SPEAKER_DT   0x0304  // Desktop or Monitor speaker(s).
+#define USB_ATTYPE_SPEAKER_RM   0x0305  // Larger room speaker(s).
+#define USB_ATTYPE_SPEAKER_COM  0x0306  // Communications Speaker (phone).
+#define USB_ATTYPE_SPEAKER_LFE  0x0307  // Speaker designed for low
+                                        // frequencies.
+
+//*****************************************************************************
+//
+// USB Audio channel configuration bits for wChannelConfig values.
+// wChannelConfig: a bit field that indicates which spatial locations are
+// present in the cluster. The bit allocations are as follows:
+//
+//*****************************************************************************
+#define USB_CHANNEL_L           0x0001  // Left Front (L)
+#define USB_CHANNEL_R           0x0002  // Right Front (R)
+#define USB_CHANNEL_C           0x0004  // Center Front (C)
+#define USB_CHANNEL_LFE         0x0008  // Low Frequency Enhancement (LFE)
+#define USB_CHANNEL_LS          0x0010  // Left Surround (LS)
+#define USB_CHANNEL_RS          0x0020  // Right Surround (RS)
+#define USB_CHANNEL_LC          0x0040  // Left of Center (LC)
+#define USB_CHANNEL_RC          0x0080  // Right of Center (RC)
+#define USB_CHANNEL_S           0x0100  // Surround (S)
+#define USB_CHANNEL_SL          0x0200  // Side Left (SL)
+#define USB_CHANNEL_SR          0x0400  // Side Right (SR)
+#define USB_CHANNEL_T           0x0800  // Top (T)
+
+//*****************************************************************************
+//
+// Endpoint attributes for Audio Class General type.
+//
+//*****************************************************************************
+#define USB_EP_ATTR_ACG_SAMPLING    0x01    // Sampling Frequency
+#define USB_EP_ATTR_ACG_PITCH       0x02    // Pitch
+#define USB_EP_ATTR_ACG_MAXPACKET   0x80    // MaxPacketsOnly
+
+//*****************************************************************************
+//
+// Indicates the units used for the wLockDelay field for Audio Class General
+// type.
+//
+//*****************************************************************************
+#define USB_EP_LOCKDELAY_UNDEF  0x00    // Undefined
+#define USB_EP_LOCKDELAY_MS     0x01    // Milliseconds
+#define USB_EP_LOCKDELAY_PCM    0x02    // Decoded PCM samples
+
+//*****************************************************************************
+//
+// Audio Class-Specific Request Codes
+//
+//*****************************************************************************
+#define USB_AC_SET_CUR          0x01
+#define USB_AC_SET_MIN          0x02
+#define USB_AC_SET_MAX          0x03
+#define USB_AC_SET_RES          0x04
+#define USB_AC_SET_MEM          0x05
+#define USB_AC_GET_CUR          0x81
+#define USB_AC_GET_MIN          0x82
+#define USB_AC_GET_MAX          0x83
+#define USB_AC_GET_RES          0x84
+#define USB_AC_GET_MEM          0x85
+#define USB_AC_GET_STAT         0xff
+
+#define USB_CS_CONTROL_M        0xff00
+#define USB_CS_CHANNEL_M        0x00ff
+
+//*****************************************************************************
+//
+// Endpoint Control Selectors
+//
+//*****************************************************************************
+#define EP_CONTROL_UNDEFINED    0x0000
+#define SAMPLING_FREQ_CONTROL   0x0100
+#define PITCH_CONTROL           0x0200
+
+//*****************************************************************************
+//
+// Feature Unit Control Selectors
+//
+//*****************************************************************************
+#define FU_CONTROL_UNDEFINED    0x0000
+#define MUTE_CONTROL            0x0100
+#define VOLUME_CONTROL          0x0200
+#define BASS_CONTROL            0x0300
+#define MID_CONTROL             0x0400
+#define TREBLE_CONTROL          0x0500
+#define EQUALIZER_CONTROL       0x0600
+#define AUTOMATIC_GAIN_CONTROL  0x0700
+#define DELAY_CONTROL           0x0800
+#define BASS_BOOST_CONTROL      0x0900
+#define LOUDNESS_CONTROL        0x0A00
+
+//*****************************************************************************
+//
+// All structures defined in this section of the header require byte packing of
+// fields.  This is usually accomplished using the PACKED macro but, for IAR
+// Embedded Workbench, this requires a pragma.
+//
+//*****************************************************************************
+#ifdef ewarm
+#pragma pack(1)
+#endif
+
+//*****************************************************************************
+//
+//! This structure describes the Class-Specific Audio Class Interface Header
+//! Descriptor as defined in Universal Serial Bus Device Class Definition
+//! for Audio Devices Release 1.0.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The length of this descriptor in bytes.
+    //
+    uint8_t bLength;
+
+    //
+    //! The type of the descriptor.  For an interface descriptor, this will
+    //! be USB_DTYPE_CS_INTERFACE (36).
+    //
+    uint8_t bDescriptorType;
+
+    //
+    //! This will be USB_DSUBTYPE_HEADER for the header.
+    //
+    uint8_t bDescriptorSubtype;
+
+    //
+    //! Audio Device Class Specification Release Number in Binary-Coded
+    //! Decimal.
+    //
+    uint16_t bcdADC;
+
+    //
+    //! Total number of bytes returned for the class-specific AudioControl
+    //! interface descriptor. Includes the combined length of this descriptor
+    //! header and all Unit and Terminal descriptors.
+    //
+    uint16_t wTotai32Length;
+
+    //
+    //! The number of AudioStreaming and MIDIStreaming interfaces in the Audio
+    //! Interface Collection to which this AudioControl interface belongs.
+    //
+    uint8_t bInCollection;
+
+    //
+    //! Interface number of the first AudioStreaming or MIDIStreaming interface
+    //! in the Collection.
+    //
+    uint8_t baInterfaceNr;
+}
+PACKED tACHeader;
+
+//*****************************************************************************
+//
+// These are the possible bits set in the tACInputTerminal.wChannelConfig
+// value.
+//
+//*****************************************************************************
+#define USB_AC_CC_LEFT          0x0001
+#define USB_AC_CC_RIGHT         0x0002
+#define USB_AC_CC_CENTER        0x0004
+#define USB_AC_CC_LFE           0x0008
+#define USB_AC_CC_LEFTSURROUND  0x0010
+#define USB_AC_CC_RIGHTSURROUND 0x0020
+#define USB_AC_CC_LEFT_CENTER   0x0040
+#define USB_AC_CC_RIGHT_CENTER  0x0080
+#define USB_AC_CC_SURROUND      0x0100
+#define USB_AC_CC_SIDE_LEFT     0x0200
+#define USB_AC_CC_SIDE_RIGHT    0x0400
+#define USB_AC_CC_TOP           0x0800
+
+//*****************************************************************************
+//
+//! This structure describes the Feature Unit Descriptor as defined in
+//! Universal Serial Bus Device Class Definition for Audio Devices Release 1.0.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The length of this descriptor in bytes.
+    //
+    uint8_t bLength;
+
+    //
+    //! The type of the descriptor.  For an interface descriptor, this will
+    //! be USB_DTYPE_CS_INTERFACE (36).
+    //
+    uint8_t bDescriptorType;
+
+    //
+    //! This will be USB_DSUBTYPE_IN_TERM for the header.
+    //
+    uint8_t bDescriptorSubtype;
+
+    //
+    //! Constant uniquely identifying the Unit within the audio function. This
+    //! value is used in all requests to address this Unit.
+    //
+    uint8_t bUnitID;
+
+    //
+    //! ID of the Unit or Terminal to which this Feature Unit is connected.
+    //
+    uint8_t bSourceID;
+
+    //
+    //! ID of the Output Terminal to which this Input Terminal is associated.
+    //
+    uint8_t bControlSize;
+
+    //
+    //! A bit set to 1 indicates that the mentioned Control is supported for
+    //! a given channel.  See the USB_FU_* defines for the bit definitions.
+    //! This actually an array of elements of size bControlSize so be
+    //! careful when using this value directly.
+    //
+    uint16_t bmaControls;
+}
+PACKED tACFeatureUnit;
+
+//*****************************************************************************
+//
+//! This structure describes the Output Terminal Descriptor as defined in
+//! Universal Serial Bus Device Class Definition for Audio Devices Release 1.0.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The length of this descriptor in bytes.
+    //
+    uint8_t bLength;
+
+    //
+    //! The type of the descriptor.  For an interface descriptor, this will
+    //! be USB_DTYPE_CS_INTERFACE (36).
+    //
+    uint8_t bDescriptorType;
+
+    //
+    //! This will be USB_DSUBTYPE_OUT_TERM for the header.
+    //
+    uint8_t bDescriptorSubtype;
+
+    //
+    //! Constant uniquely identifying the Terminal within the audio function.
+    //! This value is used in all requests to address this Terminal.
+    //
+    uint8_t bTerminalID;
+
+    //
+    //! Constant characterizing the type of Terminal. See USB Audio Terminal
+    //! Types.
+    //
+    uint16_t wTerminalType;
+
+    //
+    //! Constant, identifying the Input Terminal to which this Output Terminal
+    //! is associated.
+    //
+    uint8_t bAssocTerminal;
+
+    //
+    //! ID of the Unit or Terminal to which this Terminal is connected.
+    //
+    uint8_t bSourceID;
+
+    //
+    //! Index of a string descriptor, describing the Output Terminal.
+    //
+    uint8_t iTerminal;
+}
+PACKED tACOutputTerminal;
+
+//*****************************************************************************
+//
+//! This structure describes the Input Terminal Descriptor as defined in
+//! Universal Serial Bus Device Class Definition for Audio Devices Release 1.0.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The length of this descriptor in bytes.
+    //
+    uint8_t bLength;
+
+    //
+    //! The type of the descriptor.  For an interface descriptor, this will
+    //! be USB_DTYPE_CS_INTERFACE (36).
+    //
+    uint8_t bDescriptorType;
+
+    //
+    //! This will be USB_DSUBTYPE_OUT_TERM for the header.
+    //
+    uint8_t bDescriptorSubtype;
+
+    //
+    //! Constant uniquely identifying the Terminal within the audio function.
+    //! This value is used in all requests to address this Terminal.
+    //
+    uint8_t bTerminalID;
+
+    //
+    //! Constant characterizing the type of Terminal. See USB Audio Terminal
+    //! Types.
+    //
+    uint16_t wTerminalType;
+
+    //
+    //! Constant, identifying the Input Terminal to which this Output Terminal
+    //! is associated.
+    //
+    uint8_t bAssocTerminal;
+
+    //
+    //! Number of logical output channels in the Terminal's output audio
+    //! channel cluster.
+    //
+    uint8_t bNrChannels;
+
+    //
+    //! Describes the spatial location of the logical channels.
+    //
+    uint16_t wChannelConfig;
+
+    //
+    //! Index of a string descriptor, describing the name of the first logical
+    //! channel.
+    //
+    uint8_t iChannelNames;
+
+    //
+    //! Index of a string descriptor, describing the Output Terminal.
+    //
+    uint8_t iTerminal;
+}
+PACKED tACInputTerminal;
+
+//*****************************************************************************
+//
+//! This structure describes the Mixer Descriptor as defined in Universal
+//! Serial Bus Device Class Definition for Audio Devices Release 1.0.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The length of this descriptor in bytes.
+    //
+    uint8_t bLength;
+
+    //
+    //! The type of the descriptor.  For an interface descriptor, this will
+    //! be USB_DTYPE_CS_INTERFACE (36).
+    //
+    uint8_t bDescriptorType;
+
+    //
+    //! This will be USB_AI_MIXER_UNIT for the header.
+    //
+    uint8_t bDescriptorSubtype;
+
+    //
+    //! Constant uniquely identifying the Unit within the audio function. This
+    //! value is used in all requests to address this Unit.
+    //
+    uint8_t bUnitID;
+
+    //
+    //! Number of Input Pins of this Unit.
+    //
+    uint8_t bNrInPins;
+
+    //
+    //! ID of the Unit or Terminal to which the first Input Pin of this Mixer
+    //! Unit is connected.
+    //
+    uint8_t baSourceID;
+}
+PACKED tACMixer;
+
+//*****************************************************************************
+//
+//! This structure describes the Selector Descriptor as defined in Universal
+//! Serial Bus Device Class Definition for Audio Devices Release 1.0.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The length of this descriptor in bytes.
+    //
+    uint8_t bLength;
+
+    //
+    //! The type of the descriptor.  For an interface descriptor, this will
+    //! be USB_DTYPE_CS_INTERFACE (36).
+    //
+    uint8_t bDescriptorType;
+
+    //
+    //! This will be USB_AI_MIXER_UNIT for the header.
+    //
+    uint8_t bDescriptorSubtype;
+
+    //
+    //! Constant uniquely identifying the Unit within the audio function. This
+    //! value is used in all requests to address this Unit.
+    //
+    uint8_t bUnitID;
+
+    //
+    //! Number of Input Pins of this Unit.
+    //
+    uint8_t bNrInPins;
+
+    //
+    //! ID of the Unit or Terminal to which the first Input Pin of this Mixer
+    //! Unit is connected.
+    //
+    uint8_t baSourceID;
+}
+PACKED tACSelector;
+
+//*****************************************************************************
+//
+//! This structure describes the Output Terminal Descriptor as defined in
+//! Universal Serial Bus Device Class Definition for Audio Devices Release 1.0.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The length of this descriptor in bytes.
+    //
+    uint8_t bLength;
+
+    //
+    //! The type of the descriptor.  For an interface descriptor, this will
+    //! be USB_DTYPE_CS_INTERFACE (36).
+    //
+    uint8_t bDescriptorType;
+
+    //
+    //! This will be USB_DSUBTYPE_GENERAL for the header.
+    //
+    uint8_t bDescriptorSubtype;
+
+    //
+    //! The Terminal ID of the Terminal to which the endpoint of this
+    //! interface is connected.
+    //
+    uint8_t bTerminalLink;
+
+    //
+    //! Delay introduced by the data path. Expressed in number of frames.
+    //
+    uint8_t bDelay;
+
+    //
+    //! The Audio Data Format that has to be used to communicate with this
+    //! interface.
+    //
+    uint16_t wFormatTag;
+}
+PACKED tACGeneral;
+
+//*****************************************************************************
+//
+//! This structure describes the Type I Audio format descriptors defined in
+//! USB Audio Devices Release 1.0.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The length of this descriptor in bytes.
+    //
+    uint8_t bLength;
+
+    //
+    //! The type of the descriptor.  For an interface descriptor, this will
+    //! be USB_DTYPE_CS_INTERFACE (36).
+    //
+    uint8_t bDescriptorType;
+
+    //
+    //! This will be USB_AS_FORMAT_TYPE.
+    //
+    uint8_t bDescriptorSubtype;
+
+    //
+    //! This will be USB_AS_FORMAT_TYPE_I.
+    //
+    uint8_t bFormatType;
+
+    //
+    //! Number of channels on this streaming interface.
+    //
+    uint8_t bNrChannels;
+
+    //
+    //! Number of bytes per audio sub-frame or channel.
+    //
+    uint8_t bSubFrameSize;
+
+    //
+    //! Number of bits per sample.
+    //
+    uint8_t bBitResolution;
+
+    //
+    //! Number of sample rates that are supported.
+    //
+    uint8_t bSamFreqType;
+
+    //
+    //! Number of bits per sample.
+    //
+    uint8_t tSamFreq;
+}
+PACKED tASFormat;
+
+//*****************************************************************************
+//
+// Return to default packing when using the IAR Embedded Workbench compiler.
+//
+//*****************************************************************************
+#ifdef ewarm
+#pragma pack()
+#endif
+
+#endif
+
diff --git a/bsp/tm4c129x/libraries/usblib/usbbuffer.c b/bsp/tm4c129x/libraries/usblib/usbbuffer.c
new file mode 100755
index 0000000..a9a49b4
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/usbbuffer.c
@@ -0,0 +1,1192 @@
+//*****************************************************************************
+//
+// usbbuffer.c - USB buffer object.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "inc/hw_types.h"
+#include "driverlib/debug.h"
+#include "usblib/usblib.h"
+#include "usblib/usblibpriv.h"
+
+//*****************************************************************************
+//
+//! \addtogroup usblib_buffer_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Workspace variables required by each buffer instance.  This structure is
+// overlaid on the pvWorkspace memory provided in the tUSBBuffer structure
+// passed to USBBufferInit().
+//
+//*****************************************************************************
+typedef struct
+{
+    tUSBRingBufObject sRingBuf;
+    uint32_t ui32LastSent;
+    uint32_t ui32Flags;
+}
+tUSBBufferVars;
+
+//*****************************************************************************
+//
+// Flags which may be set in the tUSBBufferVars ui32Flags field.
+//
+//*****************************************************************************
+#define USB_BUFFER_FLAG_SEND_ZLP 0x00000001
+
+//*****************************************************************************
+//
+// Schedule the next packet transmission to the host if data remains to be
+// sent.
+//
+// \param psBuffer points to the buffer from which a packet transmission is
+// to be scheduled.
+//
+// This function checks to determine whether the lower layer is capable of
+// accepting a new packet for transmission and, if so, schedules the next
+// packet transmission if data remains in the buffer.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+ScheduleNextTransmission(const tUSBBuffer *psBuffer)
+{
+    tUSBBufferVars *psBufVars;
+    uint32_t ui32Packet, ui32Space, ui32Total, ui32Sent;
+
+    //
+    // Get a pointer to our workspace variables.
+    //
+    psBufVars = psBuffer->pvWorkspace;
+
+    //
+    // Ask the lower layer if it has space to accept another packet of data.
+    //
+    ui32Packet = psBuffer->pfnAvailable(psBuffer->pvHandle);
+
+    //
+    // If we were returned something other than zero, we can write that number
+    // of bytes to the lower layer.
+    //
+    if(ui32Packet)
+    {
+        //
+        // How much contiguous data do we have in the buffer?
+        //
+        ui32Space = USBRingBufContigUsed(&psBufVars->sRingBuf);
+
+        //
+        // How much total data do we have in the buffer?
+        //
+        ui32Total = USBRingBufUsed(&psBufVars->sRingBuf);
+
+        //
+        // How much data will we be sending as a result of this call?
+        //
+        ui32Sent = (ui32Packet < ui32Total) ? ui32Packet : ui32Total;
+
+        //
+        // Write the contiguous bytes to the lower layer assuming there is
+        // something to send.
+        //
+        if(ui32Space)
+        {
+            //
+            // There is data available to send.  Update our state to indicate
+            // the amount we will be sending in this packet.
+            //
+            psBufVars->ui32LastSent = ui32Sent;
+
+            //
+            // Determine the maximum sized block we can send in this transfer.
+            //
+            ui32Space = (ui32Space < ui32Packet) ? ui32Space : ui32Packet;
+            //
+            // Call the lower layer to send the new packet.  If the current
+            // data spans the buffer wrap, tell the lower layer that it can
+            // expect a second call to fill the whole packet before it
+            // transmits it.
+            //
+            psBuffer->pfnTransfer(psBuffer->pvHandle,
+                                  (psBufVars->sRingBuf.pui8Buf +
+                                   psBufVars->sRingBuf.ui32ReadIndex),
+                                   ui32Space,
+                                  (((ui32Space < ui32Packet) &&
+                                    (ui32Space < ui32Total)) ? false : true));
+
+            //
+            // Do we need to send a second part to fill out the packet?  This
+            // will occur if the current packet spans the buffer wrap.
+            //
+            if((ui32Space < ui32Packet) && (ui32Space < ui32Total))
+            {
+                //
+                // The packet straddled the wrap.  How much space remains in
+                // the packet?
+                //
+                ui32Packet -= ui32Space;
+
+                //
+                // How much data can we actually send?
+                //
+                ui32Space = ui32Total - ui32Space;
+                ui32Space = (ui32Space > ui32Packet) ? ui32Packet : ui32Space;
+
+                psBuffer->pfnTransfer(psBuffer->pvHandle,
+                                      psBufVars->sRingBuf.pui8Buf, ui32Space,
+                                      true);
+            }
+        }
+        else
+        {
+            //
+            // There is no data to send.  Did we last send a full packet?
+            //
+            if(psBufVars->ui32LastSent == ui32Packet)
+            {
+                //
+                // Yes - if necessary, send a zero-length packet back to the
+                // host to complete the last transaction.
+                //
+                if(psBufVars->ui32Flags & USB_BUFFER_FLAG_SEND_ZLP)
+                {
+                    psBufVars->ui32LastSent = 0;
+                    psBuffer->pfnTransfer(psBuffer->pvHandle,
+                                          psBufVars->sRingBuf.pui8Buf, 0,
+                                          true);
+                }
+            }
+        }
+
+        //
+        // Don't update the ring buffer read index yet.  We do this once we are
+        // sure the packet was correctly transmitted.
+        //
+    }
+}
+
+//*****************************************************************************
+//
+// Handles USB_EVENT_RX_AVAILABLE for a receive buffer.
+//
+// \param psBuffer points to the buffer which is receiving the event.
+// \param ui32Size is the size reported in the event.
+// \param pui8Data is the pointer provided in the event.
+//
+// This function is responsible for reading data from the lower layer into
+// the buffer or, if we had previously passed a section of the buffer to the
+// lower layer for it to write into directly, updating the buffer write pointer
+// to add the new data to the buffer.
+//
+// If the pointer provided is NULL, we call the low level pfnTransfer function
+// to get the new data.  If the pointer is not NULL and not within the existing
+// ring buffer, we copy the data directly from the pointer to the buffer and
+// return the number of bytes read.
+//
+// \return Returns the number of bytes read from the lower layer.
+//
+//*****************************************************************************
+static uint32_t
+HandleRxAvailable(tUSBBuffer *psBuffer, uint32_t ui32Size, uint8_t *pui8Data)
+{
+    tUSBBufferVars *psBufVars;
+    uint32_t ui32Avail, ui32Read, ui32Packet, ui32RetCount;
+
+    //
+    // Get a pointer to our workspace variables.
+    //
+    psBufVars = psBuffer->pvWorkspace;
+
+    //
+    // Has the data already been read into memory?
+    //
+    if(pui8Data)
+    {
+        //
+        // Yes - is it already in our ring buffer?
+        //
+        if((pui8Data >= psBuffer->pui8Buffer) &&
+           (pui8Data < psBuffer->pui8Buffer + psBuffer->ui32BufferSize))
+        {
+            //
+            // The data is already in our ring buffer so merely update the
+            // write pointer to add the new data.
+            //
+            USBRingBufAdvanceWrite(&psBufVars->sRingBuf, ui32Size);
+
+            //
+            // In this case, we pass back 0 to indicate that the lower layer
+            // doesn't need to make any buffer pointer updates.
+            //
+            ui32RetCount = 0;
+        }
+        else
+        {
+            //
+            // The data is not within our buffer so we need to copy it into
+            // the buffer.
+            //
+            // How much space does the buffer have available?
+            //
+            ui32Avail = USBRingBufFree(&psBufVars->sRingBuf);
+
+            //
+            // How much should we copy?
+            //
+            ui32Read = (ui32Avail < ui32Size) ? ui32Avail : ui32Size;
+
+            //
+            // Copy the data into the buffer.
+            //
+            USBRingBufWrite(&psBufVars->sRingBuf, pui8Data, ui32Read);
+
+            //
+            // We need to return the number of bytes we read in this case
+            // since the buffer supplied to us was owned by the lower layer and
+            // it may need to update its read pointer.
+            //
+            ui32RetCount = ui32Read;
+        }
+    }
+    else
+    {
+        //
+        // We were passed a NULL pointer so the low level driver has not read
+        // the data into memory yet.  We need to call the transfer function to
+        // get the packet.
+        //
+        // How big is the packet that we need to receive?
+        //
+        ui32Packet = psBuffer->pfnAvailable(psBuffer->pvHandle);
+
+        //
+        // How much contiguous space do we have in the buffer?
+        //
+        ui32Avail = USBRingBufContigFree(&psBufVars->sRingBuf);
+
+        //
+        // Get as much of the packet as we can in the available space.
+        //
+        ui32Read = psBuffer->pfnTransfer(psBuffer->pvHandle,
+                                         (psBufVars->sRingBuf.pui8Buf +
+                                          psBufVars->sRingBuf.ui32WriteIndex),
+                                         ui32Avail, true);
+
+        //
+        // Advance the ring buffer write pointer to add our new data.
+        //
+        if(ui32Read)
+        {
+            USBRingBufAdvanceWrite(&psBufVars->sRingBuf, ui32Read);
+        }
+
+        //
+        // Did we get the whole packet?
+        //
+        if(ui32Read < ui32Packet)
+        {
+            //
+            // No - how much space do we have in the buffer?
+            //
+            ui32Avail = USBRingBufContigFree(&psBufVars->sRingBuf);
+
+            //
+            // If there is any space left, read as much of the remainder of
+            // the packet as we can.
+            //
+            if(ui32Avail)
+            {
+                ui32Packet =
+                    psBuffer->pfnTransfer(psBuffer->pvHandle,
+                                          (psBufVars->sRingBuf.pui8Buf +
+                                           psBufVars->sRingBuf.ui32WriteIndex),
+                                          ui32Avail, true);
+
+                //
+                // Update the write pointer after we read more data into the
+                // buffer.
+                //
+                if(ui32Packet)
+                {
+                    USBRingBufAdvanceWrite(&psBufVars->sRingBuf, ui32Packet);
+                }
+            }
+        }
+
+        //
+        // We need to return 0 in this case to indicate that the lower layer
+        // need not perform any buffer maintenance as a result of the callback.
+        //
+        ui32RetCount = 0;
+    }
+
+    //
+    // How much data do we have in the buffer?
+    //
+    ui32Avail = USBRingBufUsed(&psBufVars->sRingBuf);
+
+    //
+    // Pass the event on to the client with the current read pointer and
+    // available data size.  The client is expected to understand the ring
+    // structure and be able to deal with wrap if it wants to read the data
+    // directly from the buffer.
+    //
+    ui32Read = psBuffer->pfnCallback(psBuffer->pvCBData,
+                                     USB_EVENT_RX_AVAILABLE, ui32Avail,
+                                     (psBufVars->sRingBuf.pui8Buf +
+                                      psBufVars->sRingBuf.ui32ReadIndex));
+
+    //
+    // If the client read anything from the buffer, update the read pointer.
+    //
+    USBRingBufAdvanceRead(&psBufVars->sRingBuf, ui32Read);
+
+    //
+    // Return the correct value to the low level driver.
+    //
+    return(ui32RetCount);
+}
+
+//*****************************************************************************
+//
+// Handles USB_EVENT_DATA_REMAINING for a receive buffer.
+//
+// \param psBuffer points to the buffer which is receiving the event.
+//
+// This function determines the total number of bytes of data that remain
+// unprocessed in the client and buffer and reports this back to the caller.
+//
+// \return Returns the number of bytes remaining to be processed.
+//
+//*****************************************************************************
+static uint32_t
+HandleDataRemaining(tUSBBuffer *psBuffer)
+{
+    uint32_t ui32BufData, ui32ClientData;
+    tUSBBufferVars *psBufVars;
+
+    //
+    // Get a pointer to our workspace variables.
+    //
+    psBufVars = psBuffer->pvWorkspace;
+
+    //
+    // How much data does the client currently have buffered?
+    //
+    ui32ClientData = psBuffer->pfnCallback(psBuffer->pvCBData,
+                                           USB_EVENT_DATA_REMAINING, 0,
+                                           (void *)0);
+
+    //
+    // How much data do we have in the buffer?
+    //
+    ui32BufData = USBRingBufUsed(&psBufVars->sRingBuf);
+
+    //
+    // Return the total number of bytes of unprocessed data to the lower layer.
+    //
+    return(ui32BufData + ui32ClientData);
+}
+
+//*****************************************************************************
+//
+// Handles USB_EVENT_TX_COMPLETE for a transmit buffer.
+//
+// \param psBuffer points to the buffer which is receiving the event.
+// \param ui32Size is the number of bytes that have been transmitted and
+// acknowledged.
+//
+// This function informs us that data written to the lower layer from a
+// transmit buffer has been successfully transmitted.  We use this to update
+// the buffer read pointer and attempt to schedule the next transmission if
+// data remains in the buffer.
+//
+// \return Returns the number of bytes remaining to be processed.
+//
+//*****************************************************************************
+static uint32_t
+HandleTxComplete(tUSBBuffer *psBuffer, uint32_t ui32Size)
+{
+    tUSBBufferVars *psBufVars;
+
+    //
+    // Get a pointer to our workspace variables.
+    //
+    psBufVars = psBuffer->pvWorkspace;
+
+    //
+    // Update the transmit buffer read pointer to remove the data that has
+    // now been transmitted.
+    //
+    USBRingBufAdvanceRead(&psBufVars->sRingBuf, ui32Size);
+
+    //
+    // Try to schedule the next packet transmission if data remains to be
+    // sent.
+    //
+    ScheduleNextTransmission(psBuffer);
+
+    //
+    // The return code from this event is ignored.
+    //
+    return(0);
+}
+
+//*****************************************************************************
+//
+// Handles USB_EVENT_REQUEST_BUFFER for a receive buffer.
+//
+// \param psBuffer points to the buffer which is receiving the event.
+// \param ui32Size is the size of the buffer requested.
+// \param ppui8Buffer is a pointer which is to be written with a pointer to
+// the returned buffer.
+//
+// This function is called by a low level driver that wishes to receive data
+// automatically and write it directly to a memory buffer, either using
+// software or DMA prior to issuing USB_EVENT_RX_AVAILABLE.  The event is sent
+// in advance of receiving data to provide storage for whatever is received
+// next.
+//
+// If we have a contiguous block of space in the buffer of at least ui32Size
+// bytes immediately in front of the current write pointer, we pass this back
+// otherwise we send NULL indicating that the next packet should be notified
+// using a standard USB_EVENT_RX_AVAILABLE event without being received
+// automatically.  Note that the USB_EVENT_REQUEST_BUFFER protocol allows us to
+// return less than \e ui32Size bytes if we know how much data is expected next
+// but this is not possible here since the USBBuffer knows nothing about the
+// protocol whose data it is handling.
+//
+// \return Returns the number of bytes remaining to be processed.
+//
+//*****************************************************************************
+static uint32_t
+HandleRequestBuffer(tUSBBuffer *psBuffer, uint32_t ui32Size,
+                    uint8_t **ppui8Buffer)
+{
+    tUSBBufferVars *psBufVars;
+    uint32_t ui32Space;
+
+    //
+    // Get a pointer to our workspace variables.
+    //
+    psBufVars = psBuffer->pvWorkspace;
+
+    //
+    // How much contiguous space do we have available?
+    //
+    ui32Space = USBRingBufContigFree(&psBufVars->sRingBuf);
+
+    //
+    // Is there enough space available to satisfy the request?
+    //
+    if(ui32Space >= ui32Size)
+    {
+        //
+        // Yes - return the current write pointer
+        //
+        *ppui8Buffer = psBufVars->sRingBuf.pui8Buf +
+                       psBufVars->sRingBuf.ui32WriteIndex;
+        return(ui32Size);
+    }
+    else
+    {
+        //
+        // We do not have enough contiguous space following the current write
+        // pointer to satisfy the request so do not provide a buffer.
+        //
+        *ppui8Buffer = (uint8_t *)0;
+        return(0);
+    }
+}
+
+//*****************************************************************************
+//
+//! Initializes a USB buffer object to be used with a given USB controller and
+//! device or host class driver.
+//!
+//! \param psBuffer points to a structure containing information on the buffer
+//! memory to be used and the underlying device or host class driver whose data
+//! is to be buffered.  This structure must remain accessible for as long as
+//! the buffer is in use.
+//!
+//! This function is used to initialize a USB buffer object and insert it
+//! into the function and callback interfaces between an underlying driver
+//! and the application.  The caller supplies information on both the RAM
+//! to be used to buffer data, the type of buffer to be created (transmit or
+//! receive) and the functions to be called in the lower layer to transfer
+//! data to or from the USB controller.
+//!
+//! \return Returns the original buffer structure pointer if successful or
+//! NULL if an error is detected.
+//
+//*****************************************************************************
+const tUSBBuffer *
+USBBufferInit(const tUSBBuffer *psBuffer)
+{
+    tUSBBufferVars *psBufVars;
+
+    //
+    // Check parameter validity.
+    //
+    ASSERT(psBuffer && psBuffer->pvWorkspace && psBuffer->pui8Buffer &&
+           psBuffer->ui32BufferSize && psBuffer->pfnAvailable &&
+           psBuffer->pfnTransfer && psBuffer->pfnCallback);
+
+    //
+    // Get a pointer to the buffer workspace and initialize the variables it
+    // contains.
+    //
+    psBufVars = psBuffer->pvWorkspace;
+    psBufVars->ui32Flags = 0;
+    USBRingBufInit(&psBufVars->sRingBuf, psBuffer->pui8Buffer,
+                   psBuffer->ui32BufferSize);
+
+    //
+    // If all is well, return the same pointer we were originally passed.
+    //
+    return(psBuffer);
+}
+
+//*****************************************************************************
+//
+//! Enables or disables zero-length packet insertion.
+//!
+//! \param psBuffer is the pointer to the buffer instance whose information
+//! is being queried.
+//! \param bSendZLP is \b true to send zero-length packets or \b false to
+//! prevent them from being sent.
+//!
+//! This function allows the use of zero-length packets to be controlled by
+//! an application.  In cases where the USB buffer has sent a full (64 byte)
+//! packet and then discovers that the transmit buffer is empty, the default
+//! behavior is to do nothing.  Some protocols, however, require that a zero-
+//! length packet be inserted to signal the end of the data.  When using such
+//! a protocol, this function should be called with \e bSendZLP set to \b true
+//! to enable the desired behavior.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBBufferZeroLengthPacketInsert(const tUSBBuffer *psBuffer, bool bSendZLP)
+{
+    tUSBBufferVars *psBufVars;
+
+    //
+    // Check parameter validity.
+    //
+    ASSERT(psBuffer);
+
+    //
+    // Get our workspace variables.
+    //
+    psBufVars = psBuffer->pvWorkspace;
+
+    //
+    // Set the flag telling us whether or not to send a zero-length packet
+    // after sending a 64 bytes packet and finding no more data to send.
+    //
+    if(bSendZLP)
+    {
+        //
+        // Enable ZLP transmission.
+        //
+        psBufVars->ui32Flags |= USB_BUFFER_FLAG_SEND_ZLP;
+    }
+    else
+    {
+        //
+        // Disable ZLP transmission.
+        //
+        psBufVars->ui32Flags &= ~ USB_BUFFER_FLAG_SEND_ZLP;
+    }
+}
+
+//*****************************************************************************
+//
+//! Returns the current ring buffer indices for this USB buffer.
+//!
+//! \param psBuffer is the pointer to the buffer instance whose information
+//! is being queried.
+//! \param psRingBuf is a pointer to storage that will be written with the
+//! current ring buffer control structure for this USB buffer.
+//!
+//! This function is provided to aid a client wishing to write data directly
+//! into the USB buffer rather than using the USBBufferWrite() function.  This
+//! may be necessary to control when the USBBuffer starts transmission of a
+//! large block of data, for example.
+//!
+//! A transmit buffer will immediately send a new packet on any call to
+//! USBBufferWrite() if the underlying layer indicates that a transmission can
+//! be started.  In some cases this is not desirable and a client may wish to
+//! wishes to write more data to the buffer in advance of starting transmission
+//! to the lower layer.  In such cases, this function may be called to retrieve
+//! the current ring buffer indices and the buffer accessed directly.  Once the
+//! client has written all data it wishes to send, it should call function
+//! USBBufferDataWritten() to indicate that transmission may begin.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBBufferInfoGet(const tUSBBuffer *psBuffer, tUSBRingBufObject *psRingBuf)
+{
+    tUSBBufferVars *psBufVars;
+
+    //
+    // Check parameter validity.
+    //
+    ASSERT(psBuffer && psRingBuf);
+
+    //
+    // Get our workspace variables.
+    //
+    psBufVars = psBuffer->pvWorkspace;
+
+    //
+    // Copy the current ring buffer settings to the clients storage.
+    //
+    psRingBuf->pui8Buf = psBufVars->sRingBuf.pui8Buf;
+    psRingBuf->ui32ReadIndex = psBufVars->sRingBuf.ui32ReadIndex;
+    psRingBuf->ui32Size = psBufVars->sRingBuf.ui32ReadIndex;
+    psRingBuf->ui32WriteIndex = psBufVars->sRingBuf.ui32WriteIndex;
+}
+
+//*****************************************************************************
+//
+//! Indicates that a client has written data directly into the buffer and
+//! wishes to start transmission.
+//!
+//! \param psBuffer is the pointer to the buffer instance into which data has
+//! been written.
+//! \param ui32Length is the number of bytes of data that the client has
+//! written.
+//!
+//! This function updates the USB buffer write pointer and starts transmission
+//! of the data in the buffer assuming the lower layer is ready to receive a
+//! new packet.  The function is provided to aid a client wishing to write
+//! data directly into the USB buffer rather than using the USBBufferWrite()
+//! function.  This may be necessary to control when the USB buffer starts
+//! transmission of a large block of data, for example.
+//!
+//! A transmit buffer will immediately send a new packet on any call to
+//! USBBufferWrite() if the underlying layer indicates that a transmission can
+//! be started.  In some cases this is not desirable and a client may wish to
+//! write more data to the buffer in advance of starting transmission
+//! to the lower layer.  In such cases, USBBufferInfoGet() may be called to
+//! retrieve the current ring buffer indices and the buffer accessed directly.
+//! Once the client has written all data it wishes to send (taking care to
+//! handle the ring buffer wrap), it should call this function to indicate that
+//! transmission may begin.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBBufferDataWritten(const tUSBBuffer *psBuffer, uint32_t ui32Length)
+{
+    tUSBBufferVars *psBufVars;
+
+    //
+    // Check parameter validity.
+    //
+    ASSERT(psBuffer);
+
+    //
+    // Get our workspace variables.
+    //
+    psBufVars = psBuffer->pvWorkspace;
+
+    //
+    // Advance the ring buffer write pointer to include the newly written
+    // data.
+    //
+    if(ui32Length)
+    {
+        USBRingBufAdvanceWrite(&psBufVars->sRingBuf, ui32Length);
+    }
+
+    //
+    // Try to schedule a new packet transmission.
+    //
+    ScheduleNextTransmission(psBuffer);
+}
+
+//*****************************************************************************
+//
+//! Indicates that a client has read data directly out of the buffer.
+//!
+//! \param psBuffer is the pointer to the buffer instance from which data has
+//! been read.
+//! \param ui32Length is the number of bytes of data that the client has read.
+//!
+//! This function updates the USB buffer read pointer to remove data that
+//! the client has read directly rather than via a call to USBBufferRead().
+//! The function is provided to aid a client wishing to minimize data copying.
+//! To read directly from the buffer, a client must call USBBufferInfoGet() to
+//! retrieve the current buffer inpsBufVarsdices.  With this information, the
+//! data following the current read index can be read.  Once the client has
+//! processed much data as it needs, USBBufferDataRemoved() must be called to
+//! advance the read pointer past the data that has been read and free up that
+//! section of the buffer.  The client must take care to correctly handle the
+//! wrap point if accessing the buffer directly.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBBufferDataRemoved(const tUSBBuffer *psBuffer, uint32_t ui32Length)
+{
+    tUSBBufferVars *psBufVars;
+
+    //
+    // Check parameter validity.
+    //
+    ASSERT(psBuffer);
+
+    //
+    // Get our workspace variables.
+    //
+    psBufVars = psBuffer->pvWorkspace;
+
+    //
+    // Advance the ring buffer write pointer to include the newly written
+    // data.
+    //
+    if(ui32Length)
+    {
+        USBRingBufAdvanceRead(&psBufVars->sRingBuf, ui32Length);
+    }
+}
+
+//*****************************************************************************
+//
+//! Sets the callback pointer supplied to clients of this buffer.
+//!
+//! \param psBuffer is the pointer to the buffer instance whose callback data
+//! is to be changed.
+//! \param pvCBData is the pointer the client wishes to receive on all future
+//! callbacks from this buffer.
+//!
+//! This function sets the callback pointer which this buffer will supply
+//! to clients as the \e pvCBData parameter in all future calls to the
+//! event callback.
+//!
+//! \note If this function is to be used, the application must ensure that the
+//! tUSBBuffer structure used to describe this buffer is held in RAM rather
+//! than flash.  The \e pvCBData value passed is written directly into this
+//! structure.
+//!
+//! \return Returns the previous callback pointer set for the buffer.
+//
+//*****************************************************************************
+void *
+USBBufferCallbackDataSet(tUSBBuffer *psBuffer, void *pvCBData)
+{
+    void *pvOldData;
+
+    //
+    // Keep a copy of the old callback data.
+    //
+    pvOldData = psBuffer->pvCBData;
+
+    //
+    // Replace the callback data with the new value.
+    //
+    psBuffer->pvCBData = pvCBData;
+
+    //
+    // Give the caller the old value back.
+    //
+    return(pvOldData);
+}
+
+//*****************************************************************************
+//
+//! Writes a block of data to the transmit buffer and queues it for
+//! transmission to the USB controller.
+//!
+//! \param psBuffer points to the pointer instance into which data is to be
+//! written.
+//! \param pui8Data points to the first byte of data which is to be written.
+//! \param ui32Length is the number of bytes of data to write to the buffer.
+//!
+//! This function copies the supplied data into the transmit buffer.  The
+//! transmit buffer data will be packetized according to the constraints
+//! imposed by the lower layer in use and sent to the USB controller as soon as
+//! possible.  Once a packet is transmitted and acknowledged, a
+//! \b USB_EVENT_TX_COMPLETE event will be sent to the application callback
+//! indicating the number of bytes that have been sent from the buffer.
+//!
+//! Attempts to send more data than there is space for in the transmit buffer
+//! will result in fewer bytes than expected being written.  The value returned
+//! by the function indicates the actual number of bytes copied to the buffer.
+//!
+//! \return Returns the number of bytes actually written.
+//
+//*****************************************************************************
+uint32_t
+USBBufferWrite(const tUSBBuffer *psBuffer, const uint8_t *pui8Data,
+               uint32_t ui32Length)
+{
+    uint32_t ui32Space;
+    tUSBBufferVars *psBufVars;
+
+    //
+    // Check parameter validity.
+    //
+    ASSERT(psBuffer && pui8Data);
+    ASSERT(psBuffer->bTransmitBuffer == true);
+
+    //
+    // Get our workspace variables.
+    //
+    psBufVars = psBuffer->pvWorkspace;
+
+    //
+    // How much space is left in the buffer?
+    //
+    ui32Space = USBRingBufFree(&psBufVars->sRingBuf);
+
+    //
+    // How many bytes will we write?
+    //
+    ui32Length = (ui32Length > ui32Space) ? ui32Space : ui32Length;
+
+    //
+    // Write the data to the buffer.
+    //
+    if(ui32Length)
+    {
+        USBRingBufWrite(&psBufVars->sRingBuf, pui8Data, ui32Length);
+    }
+
+    //
+    // Try to transmit the next packet to the host.
+    //
+    ScheduleNextTransmission(psBuffer);
+
+    //
+    // Tell the caller how many bytes we wrote to the buffer.
+    //
+    return(ui32Length);
+}
+
+//*****************************************************************************
+//
+//! Flushes a USB buffer, discarding any data that it contains.
+//!
+//! \param psBuffer is the pointer to the buffer instance which is to be
+//! flushed.
+//!
+//! This function discards all data currently in the supplied buffer without
+//! processing (transmitting it via the USB controller or passing it to the
+//! client depending upon the buffer mode).
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBBufferFlush(const tUSBBuffer *psBuffer)
+{
+    tUSBBufferVars *psBufVars;
+
+    //
+    // Check parameter validity.
+    //
+    ASSERT(psBuffer);
+
+    //
+    // Get our workspace variables.
+    //
+    psBufVars = psBuffer->pvWorkspace;
+
+    //
+    // Flush the ring buffer.
+    //
+    USBRingBufFlush(&psBufVars->sRingBuf);
+}
+
+//*****************************************************************************
+//
+//! Reads a block of data from a USB receive buffer into storage supplied by
+//! the caller.
+//!
+//! \param psBuffer is the pointer to the buffer instance from which data is
+//! to be read.
+//! \param pui8Data points to a buffer into which the received data will be
+//! written.
+//! \param ui32Length is the size of the buffer pointed to by pui8Data.
+//!
+//! This function reads up to \e ui32Length bytes of data received from the USB
+//! host into the supplied application buffer.  If the receive buffer
+//! contains fewer than \e ui32Length bytes of data, the data that is present
+//! will be copied and the return code will indicate the actual number of bytes
+//! copied to \e pui8Data.
+//!
+//! \return Returns the number of bytes of data read.
+//
+//*****************************************************************************
+uint32_t
+USBBufferRead(const tUSBBuffer *psBuffer, uint8_t *pui8Data,
+              uint32_t ui32Length)
+{
+    tUSBBufferVars *psBufVars;
+    uint32_t ui32Avail, ui32Read;
+
+    //
+    // Check parameter validity.
+    //
+    ASSERT(psBuffer && pui8Data && ui32Length);
+
+    //
+    // Get our workspace variables.
+    //
+    psBufVars = psBuffer->pvWorkspace;
+
+    //
+    // How much data is in the buffer?
+    //
+    ui32Avail = USBRingBufUsed(&psBufVars->sRingBuf);
+
+    //
+    // Determine how many bytes we can actually read.
+    //
+    ui32Read = (ui32Avail < ui32Length) ? ui32Avail : ui32Length;
+
+    //
+    // Read the data from the buffer assuming there is some to read.
+    //
+    if(ui32Read)
+    {
+        USBRingBufRead(&psBufVars->sRingBuf, pui8Data, ui32Read);
+    }
+
+    //
+    // Tell the caller how many bytes we wrote to their buffer.
+    //
+    return(ui32Read);
+}
+
+//*****************************************************************************
+//
+//! Returns the number of bytes of data available in the buffer.
+//!
+//! \param psBuffer is the pointer to the buffer instance which is to be
+//! queried.
+//!
+//! This function may be used to determine the number of bytes of data in a
+//! buffer.  For a receive buffer, this indicates the number of bytes that the
+//! client can read from the buffer using USBBufferRead().  For a transmit
+//! buffer, this indicates the amount of data that remains to be sent to the
+//! USB controller.
+//!
+//! \return Returns the number of bytes of data in the buffer.
+//
+//*****************************************************************************
+uint32_t
+USBBufferDataAvailable(const tUSBBuffer *psBuffer)
+{
+    tUSBBufferVars *psBufVars;
+
+    //
+    // Check parameter validity.
+    //
+    ASSERT(psBuffer);
+
+    //
+    // Get our workspace variables.
+    //
+    psBufVars = psBuffer->pvWorkspace;
+
+    //
+    // Return the amount of data in the buffer.
+    //
+    return(USBRingBufUsed(&psBufVars->sRingBuf));
+}
+
+//*****************************************************************************
+//
+//! Returns the number of free bytes in the buffer.
+//!
+//! \param psBuffer is the pointer to the buffer instance which is to be
+//! queried.
+//!
+//! This function returns the number of free bytes in the buffer.  For a
+//! transmit buffer, this indicates the maximum number of bytes that can be
+//! passed on a call to USBBufferWrite() and accepted for transmission.  For a
+//! receive buffer, it indicates the number of bytes that can be read from the
+//! USB controller before the buffer will be full.
+//!
+//! \return Returns the number of free bytes in the buffer.
+//
+//*****************************************************************************
+uint32_t
+USBBufferSpaceAvailable(const tUSBBuffer *psBuffer)
+{
+    tUSBBufferVars *psBufVars;
+
+    //
+    // Check parameter validity.
+    //
+    ASSERT(psBuffer);
+
+    //
+    // Get our workspace variables.
+    //
+    psBufVars = psBuffer->pvWorkspace;
+
+    //
+    // Return the amount of space available in the buffer.
+    //
+    return(USBRingBufFree(&psBufVars->sRingBuf));
+}
+
+//*****************************************************************************
+//
+//! Called by the USB buffer to notify the client of asynchronous events.
+//!
+//! \param pvCBData is the client-supplied callback pointer associated with
+//! this buffer instance.
+//! \param ui32Event is the identifier of the event being sent.  This will be
+//! a general event identifier of the form \b USBD_EVENT_xxxx or a device
+//! class-dependent event of the form \b USBD_CDC_EVENT_xxx or
+//! \b USBD_HID_EVENT_xxx.
+//! \param ui32MsgValue is an event-specific parameter value.
+//! \param pvMsgData is an event-specific data pointer.
+//!
+//! This function is the USB buffer event handler that applications should
+//! register with the USB device class driver as the callback for the channel
+//! which is to be buffered using this buffer.
+//!
+//! \note This function will never be called by an application.  It is the
+//! handler that allows the USB buffer to be inserted above the device class
+//! driver or host pipe driver and below the application to offer buffering
+//! support.
+//!
+//! \return The return value is dependent upon the event being processed.
+//
+//*****************************************************************************
+uint32_t
+USBBufferEventCallback(void *pvCBData, uint32_t ui32Event,
+                       uint32_t ui32MsgValue, void *pvMsgData)
+{
+    tUSBBuffer *psBuffer;
+
+    //
+    // Get our instance data pointers from the callback data.
+    //
+    psBuffer = (tUSBBuffer *)pvCBData;
+    ASSERT(psBuffer);
+
+    //
+    // Which event have we been sent?
+    //
+    switch(ui32Event)
+    {
+        //
+        // Data is available from the lower layer.
+        //
+        case USB_EVENT_RX_AVAILABLE:
+        {
+            //
+            // This event is only relevant to us if we are a receive buffer.
+            //
+            if(!psBuffer->bTransmitBuffer)
+            {
+                return(HandleRxAvailable(psBuffer, ui32MsgValue, pvMsgData));
+            }
+            break;
+        }
+
+        //
+        // We are being asked how much data remains to be processed.
+        //
+        case USB_EVENT_DATA_REMAINING:
+        {
+            return(HandleDataRemaining(psBuffer));
+        }
+
+        //
+        // A previous transmission has completed.
+        //
+        case USB_EVENT_TX_COMPLETE:
+        {
+            //
+            // This event is only relevant to us if we are a transmit buffer.
+            //
+            if(psBuffer->bTransmitBuffer)
+            {
+                //
+                // Handle the message then drop out of the switch so that the
+                // event is echoed to the layer above.
+                //
+                HandleTxComplete(psBuffer, ui32MsgValue);
+            }
+            break;
+        }
+
+        //
+        // We are being asked to provide a buffer into which the next packet
+        // can be received.
+        //
+        case USB_EVENT_REQUEST_BUFFER:
+        {
+            //
+            // This event is only relevant to us if we are a receive buffer.
+            //
+            if(!psBuffer->bTransmitBuffer)
+            {
+                return(HandleRequestBuffer(psBuffer, ui32MsgValue, pvMsgData));
+            }
+            break;
+        }
+
+        //
+        // All other events are merely passed through to the client.
+        //
+        default:
+        {
+            break;
+        }
+    }
+
+    //
+    // If we drop out of the switch, we need to pass the event on to the client
+    // unmodified and return the relevant return code back to the lower layer.
+    //
+    return(psBuffer->pfnCallback(psBuffer->pvCBData, ui32Event, ui32MsgValue,
+                                 pvMsgData));
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
diff --git a/bsp/tm4c129x/libraries/usblib/usbcdc.h b/bsp/tm4c129x/libraries/usblib/usbcdc.h
new file mode 100755
index 0000000..8fd9c7f
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/usbcdc.h
@@ -0,0 +1,947 @@
+//*****************************************************************************
+//
+// usbhid.h - Definitions used by Communication Device Class devices.
+//
+// Copyright (c) 2007-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Note: This header contains definitions related to the USB Communication
+//       Device Class specification.  The header is complete for ACM model
+//       devices but request and notification definitions specific to other
+//       modem types, ISDN, ATM and Ethernet are currently incomplete or
+//       omitted.
+//
+//*****************************************************************************
+
+#ifndef __USBCDC_H__
+#define __USBCDC_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+//*****************************************************************************
+//
+//! \addtogroup cdc_device_class_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Generic macros to read an 8-bit, 16-bit or 32-bit value from a character
+// pointer.
+//
+//*****************************************************************************
+#define BYTE(pui8Data)          (*(uint8_t *)(pui8Data))
+#define SHORT(pui8Data)         (*(uint16_t *)(pui8Data))
+#define LONG(pui8Data)          (*(uint32_t *)(pui8Data))
+
+//*****************************************************************************
+//
+// USB CDC subclass codes.  Used in interface descriptor, bInterfaceClass
+//
+//*****************************************************************************
+#define USB_CDC_SUBCLASS_DIRECT_LINE_MODEL                                    \
+                                0x01
+#define USB_CDC_SUBCLASS_ABSTRACT_MODEL                                       \
+                                0x02
+#define USB_CDC_SUBCLASS_TELEPHONE_MODEL                                      \
+                                0x03
+#define USB_CDC_SUBCLASS_MULTI_CHANNEL_MODEL                                  \
+                                0x04
+#define USB_CDC_SUBCLASS_CAPI_MODEL                                           \
+                                0x05
+#define USB_CDC_SUBCLASS_ETHERNET_MODEL                                       \
+                                0x06
+#define USB_CDC_SUBCLASS_ATM_MODEL                                            \
+                                0x07
+
+//*****************************************************************************
+//
+// USB CDC control interface protocols.  Used in control interface descriptor,
+// bInterfaceProtocol
+//
+//*****************************************************************************
+#define USB_CDC_PROTOCOL_NONE   0x00
+#define USB_CDC_PROTOCOL_V25TER 0x01
+#define USB_CDC_PROTOCOL_VENDOR 0xFF
+
+//*****************************************************************************
+//
+// USB CDC data interface protocols.  Used in data interface descriptor,
+// bInterfaceProtocol
+//
+//*****************************************************************************
+#define USB_CDC_PROTOCOL_NONE   0x00
+#define USB_CDC_PROTOCOL_I420   0x30
+#define USB_CDC_PROTOCOL_TRANSPARENT                                          \
+                                0x32
+#define USB_CDC_PROTOCOL_Q921M  0x50
+#define USB_CDC_PROTOCOL_Q921   0x51
+#define USB_CDC_PROTOCOL_Q921TM 0x52
+#define USB_CDC_PROTOCOL_V42BIS 0x90
+#define USB_CDC_PROTOCOL_Q921EURO                                             \
+                                0x91
+#define USB_CDC_PROTOCOL_V120   0x92
+#define USB_CDC_PROTOCOL_CAPI20 0x93
+#define USB_CDC_PROTOCOL_HOST_DRIVER                                          \
+                                0xFD
+#define USB_CDC_PROTOCOL_CDC_SPEC                                             \
+                                0xFE
+#define USB_CDC_PROTOCOL_VENDOR 0xFF
+
+//*****************************************************************************
+//
+// Functional descriptor definitions
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Functional descriptor types
+//
+//*****************************************************************************
+#define USB_CDC_CS_INTERFACE    0x24
+#define USB_CDC_CS_ENDPOINT     0x25
+
+//*****************************************************************************
+//
+// Functional descriptor subtypes
+//
+//*****************************************************************************
+#define USB_CDC_FD_SUBTYPE_HEADER                                             \
+                                0x00
+#define USB_CDC_FD_SUBTYPE_CALL_MGMT                                          \
+                                0x01
+#define USB_CDC_FD_SUBTYPE_ABSTRACT_CTL_MGMT                                  \
+                                0x02
+#define USB_CDC_FD_SUBTYPE_DIRECT_LINE_MGMT                                   \
+                                0x03
+#define USB_CDC_FD_SUBTYPE_TELEPHONE_RINGER                                   \
+                                0x04
+#define USB_CDC_FD_SUBTYPE_LINE_STATE_CAPS                                    \
+                                0x05
+#define USB_CDC_FD_SUBTYPE_UNION                                              \
+                                0x06
+#define USB_CDC_FD_SUBTYPE_COUNTRY                                            \
+                                0x07
+#define USB_CDC_FD_SUBTYPE_TELEPHONE_MODES                                    \
+                                0x08
+#define USB_CDC_FD_SUBTYPE_USB_TERMINAL                                       \
+                                0x09
+#define USB_CDC_FD_SUBTYPE_NETWORK_TERMINAL                                   \
+                                0x0A
+#define USB_CDC_FD_SUBTYPE_PROTOCOL_UNIT                                      \
+                                0x0B
+#define USB_CDC_FD_SUBTYPE_EXTENSION_UNIT                                     \
+                                0x0C
+#define USB_CDC_FD_SUBTYPE_MULTI_CHANNEL_MGMT                                 \
+                                0x0D
+#define USB_CDC_FD_SUBTYPE_CAPI_MGMT                                          \
+                                0x0E
+#define USB_CDC_FD_SUBTYPE_ETHERNET                                           \
+                                0x0F
+#define USB_CDC_FD_SUBTYPE_ATM  0x10
+
+//*****************************************************************************
+//
+// USB_CDC_FD_SUBTYPE_CALL_MGMT, Header functional descriptor, bmCapabilities
+//
+//*****************************************************************************
+#define USB_CDC_CALL_MGMT_VIA_DATA                                            \
+                                0x02
+#define USB_CDC_CALL_MGMT_HANDLED                                             \
+                                0x01
+
+//*****************************************************************************
+//
+// USB_CDC_FD_SUBTYPE_ABSTRACT_CTL_MGMT, Abstract Control Management functional
+// descriptor, bmCapabilities
+//
+//*****************************************************************************
+#define USB_CDC_ACM_SUPPORTS_NETWORK_CONNECTION                               \
+                                0x08
+#define USB_CDC_ACM_SUPPORTS_SEND_BREAK                                       \
+                                0x04
+#define USB_CDC_ACM_SUPPORTS_LINE_PARAMS                                      \
+                                0x02
+#define USB_CDC_ACM_SUPPORTS_COMM_FEATURE                                     \
+                                0x01
+
+//*****************************************************************************
+//
+// USB_CDC_FD_SUBTYPE_DIRECT_LINE_MGMT, Direct Line Management functional
+// descriptor, bmCapabilities
+//
+//*****************************************************************************
+#define USB_CDC_DLM_NEEDS_EXTRA_PULSE_SETUP                                   \
+                                0x04
+#define USB_CDC_DLM_SUPPORTS_AUX                                              \
+                                0x02
+#define USB_CDC_DLM_SUPPORTS_PULSE                                            \
+                                0x01
+
+//*****************************************************************************
+//
+// USB_CDC_FD_SUBTYPE_TELEPHONE_MODES, Telephone Operational Modes functional
+// descriptor, bmCapabilities
+//
+//*****************************************************************************
+#define USB_CDC_TELEPHONE_SUPPORTS_COMPUTER                                   \
+                                0x04
+#define USB_CDC_TELEPHONE_SUPPORTS_STANDALONE                                 \
+                                0x02
+#define USB_CDC_TELEPHONE_SUPPORTS_SIMPLE                                     \
+                                0x01
+
+//*****************************************************************************
+//
+// USB_CDC_FD_SUBTYPE_LINE_STATE_CAPS, Telephone Call and Line State Reporting
+// Capabilities descriptor
+//
+//*****************************************************************************
+#define USB_CDC_LINE_STATE_CHANGES_NOTIFIED                                   \
+                                0x20
+#define USB_CDC_LINE_STATE_REPORTS_DTMF                                       \
+                                0x10
+#define USB_CDC_LINE_STATE_REPORTS_DIST_RING                                  \
+                                0x08
+#define USB_CDC_LINE_STATE_REPORTS_CALLERID                                   \
+                                0x04
+#define USB_CDC_LINE_STATE_REPORTS_BUSY                                       \
+                                0x02
+#define USB_CDC_LINE_STATE_REPORTS_INT_DIALTONE                               \
+                                0x01
+
+//*****************************************************************************
+//
+// USB_CDC_FD_SUBTYPE_USB_TERMINAL, USB Terminal functional descriptor,
+// bmOptions
+//
+//*****************************************************************************
+#define USB_CDC_TERMINAL_NO_WRAPPER_USED                                      \
+                                0x00
+#define USB_CDC_TERMINAL_WRAPPER_USED                                         \
+                                0x01
+
+//*****************************************************************************
+//
+// USB_CDC_FD_SUBTYPE_MULTI_CHANNEL_MGMT, Multi-Channel Management functional
+// descriptor, bmCapabilities
+//
+//*****************************************************************************
+#define USB_CDC_MCM_SUPPORTS_SET_UNIT_PARAM                                   \
+                                0x04
+#define USB_CDC_MCM_SUPPORTS_CLEAR_UNIT_PARAM                                 \
+                                0x02
+#define USB_CDC_MCM_UNIT_PARAMS_NON_VOLATILE                                  \
+                                0x01
+
+//*****************************************************************************
+//
+// USB_CDC_FD_SUBTYPE_CAPI_MGMT, CAPI Control Management functional descriptor,
+// bmCapabilities
+//
+//*****************************************************************************
+#define USB_CDC_CAPI_INTELLIGENT                                             \
+                                0x01
+#define USB_CDC_CAPI_SIMPLE     0x00
+
+//*****************************************************************************
+//
+// USB_CDC_FD_SUBTYPE_ETHERNET, Ethernet Networking functional descriptor,
+// bmEthernetStatistics
+//
+//*****************************************************************************
+#define USB_CDC_ETHERNET_XMIT_OK                                              \
+                                0x01000000
+#define USB_CDC_ETHERNET_RCV_OK 0x02000000
+#define USB_CDC_ETHERNET_XMIT_ERROR                                           \
+                                0x04000000
+#define USB_CDC_ETHERNET_RCV_ERROR                                            \
+                                0x08000000
+#define USB_CDC_ETHERNET_RCV_NO_BUFFER                                        \
+                                0x10000000
+#define USB_CDC_ETHERNET_DIRECTED_BYTES_XMIT                                  \
+                                0x20000000
+#define USB_CDC_ETHERNET_DIRECTED_FRAMES_XMIT                                 \
+                                0x40000000
+#define USB_CDC_ETHERNET_MULTICAST_BYTES_XMIT                                 \
+                                0x80000000
+#define USB_CDC_ETHERNET_MULTICAST_FRAMES_XMIT                                \
+                                0x00010000
+#define USB_CDC_ETHERNET_BROADCAST_BYTES_XMIT                                 \
+                                0x00020000
+#define USB_CDC_ETHERNET_BROADCAST_FRAMES_XMIT                                \
+                                0x00040000
+#define USB_CDC_ETHERNET_DIRECTED_BYTES_RCV                                   \
+                                0x00080000
+#define USB_CDC_ETHERNET_DIRECTED_FRAMES_RCV                                  \
+                                0x00100000
+#define USB_CDC_ETHERNET_MULTICAST_BYTES_RCV                                  \
+                                0x00200000
+#define USB_CDC_ETHERNET_MULTICAST_FRAMES_RCV                                 \
+                                0x00400000
+#define USB_CDC_ETHERNET_BROADCAST_BYTES_RCV                                  \
+                                0x00800000
+#define USB_CDC_ETHERNET_BROADCAST_FRAMES_RCV                                 \
+                                0x00000100
+#define USB_CDC_ETHERNET_RCV_CRC_ERROR                                        \
+                                0x00000200
+#define USB_CDC_ETHERNET_TRANSMIT_QUEUE_LENGTH                                \
+                                0x00000400
+#define USB_CDC_ETHERNET_RCV_ERROR_ALIGNMENT                                  \
+                                0x00000800
+#define USB_CDC_ETHERNET_XMIT_ONE_COLLISION                                   \
+                                0x00001000
+#define USB_CDC_ETHERNET_XMIT_MORE_COLLISIONS                                 \
+                                0x00002000
+#define USB_CDC_ETHERNET_XMIT_DEFERRED                                        \
+                                0x00004000
+#define USB_CDC_ETHERNET_XMIT_MAX_COLLISIONS                                  \
+                                0x00008000
+#define USB_CDC_ETHERNET_RCV_OVERRUN                                          \
+                                0x00000001
+#define USB_CDC_ETHERNET_XMIT_UNDERRUN                                        \
+                                0x00000002
+#define USB_CDC_ETHERNET_XMIT_HEARTBEAT_FAILURE                               \
+                                0x00000004
+#define USB_CDC_ETHERNET_XMIT_TIMES_CRS_LOST                                  \
+                                0x00000010
+
+//*****************************************************************************
+//
+// USB_CDC_FD_SUBTYPE_ATM, ATM Networking functional descriptor,
+// bmDataCapabilities
+//
+//*****************************************************************************
+#define USB_CDC_ATM_TYPE_3      0x08
+#define USB_CDC_ATM_TYPE_2      0x04
+#define USB_CDC_ATM_TYPE_1      0x02
+
+//*****************************************************************************
+//
+// bmATMDeviceStatistics
+//
+//*****************************************************************************
+#define USB_CDC_ATM_VC_US_CELLS_SENT                                          \
+                                0x10
+#define USB_CDC_ATM_VC_US_CELLS_RECEIVED                                      \
+                                0x08
+#define USB_CDC_ATM_DS_CELLS_HEC_ERR_CORRECTED                                \
+                                0x04
+#define USB_CDC_ATM_US_CELLS_SENT                                             \
+                                0x02
+#define USB_CDC_ATM_US_CELLS_RECEIVED                                         \
+                                0x01
+
+//*****************************************************************************
+//
+// Management Element Requests (provided in tUSBRequest.bRequest)
+//
+//*****************************************************************************
+#define USB_CDC_SEND_ENCAPSULATED_COMMAND                                     \
+                                0x00
+#define USB_CDC_GET_ENCAPSULATED_RESPONSE                                     \
+                                0x01
+#define USB_CDC_SET_COMM_FEATURE                                              \
+                                0x02
+#define USB_CDC_GET_COMM_FEATURE                                              \
+                                0x03
+#define USB_CDC_CLEAR_COMM_FEATURE                                            \
+                                0x04
+#define USB_CDC_SET_AUX_LINE_STATE                                            \
+                                0x10
+#define USB_CDC_SET_HOOK_STATE  0x11
+#define USB_CDC_PULSE_SETUP     0x12
+#define USB_CDC_SEND_PULSE      0x13
+#define USB_CDC_SET_PULSE_TIME  0x14
+#define USB_CDC_RING_AUX_JACK   0x15
+#define USB_CDC_SET_LINE_CODING 0x20
+#define USB_CDC_GET_LINE_CODING 0x21
+#define USB_CDC_SET_CONTROL_LINE_STATE                                        \
+                                0x22
+#define USB_CDC_SEND_BREAK      0x23
+#define USB_CDC_SET_RINGER_PARMS                                              \
+                                0x30
+#define USB_CDC_GET_RINGER_PARMS                                              \
+                                0x31
+#define USB_CDC_SET_OPERATION_PARMS                                           \
+                                0x32
+#define USB_CDC_GET_OPERATION_PARMS                                           \
+                                0x33
+#define USB_CDC_SET_LINE_PARMS  0x34
+#define USB_CDC_GET_LINE_PARMS  0x35
+#define USB_CDC_DIAL_DIGITS     0x36
+#define USB_CDC_SET_UNIT_PARAMETER                                            \
+                                0x37
+#define USB_CDC_GET_UNIT_PARAMETER                                            \
+                                0x38
+#define USB_CDC_CLEAR_UNIT_PARAMETER                                          \
+                                0x39
+#define USB_CDC_GET_PROFILE     0x3A
+#define USB_CDC_SET_ETHERNET_MULTICAST_FILTERS                                \
+                                0x40
+#define USB_CDC_SET_ETHERNET_POWER_MANAGEMENT_PATTERN_FILTER                  \
+                                0x41
+#define USB_CDC_GET_ETHERNET_POWER_MANAGEMENT_PATTERN_FILTER                  \
+                                0x42
+#define USB_CDC_SET_ETHERNET_PACKET_FILTER                                    \
+                                0x43
+#define USB_CDC_GET_ETHERNET_STATISTIC                                        \
+                                0x44
+#define USB_CDC_SET_ATM_DATA_FORMAT                                           \
+                                0x50
+#define USB_CDC_GET_ATM_DEVICE_STATISTICS                                     \
+                                0x51
+#define USB_CDC_SET_ATM_DEFAULT_VC                                            \
+                                0x52
+#define USB_CDC_GET_ATM_VC_STATISTICS                                         \
+                                0x53
+
+//*****************************************************************************
+//
+// In cases where a request defined above results in the return of a fixed size
+// data block, the following group of labels define the size of that block.  In
+// each of these cases, an access macro is also provided to write the response
+// data into an appropriately-sized array of 8-bit characters.
+//
+//*****************************************************************************
+#define USB_CDC_SIZE_COMM_FEATURE                                             \
+                                2
+#define USB_CDC_SIZE_LINE_CODING                                              \
+                                7
+#define USB_CDC_SIZE_RINGER_PARMS                                             \
+                                4
+#define USB_CDC_SIZE_OPERATION_PARMS                                          \
+                                2
+#define USB_CDC_SIZE_UNIT_PARAMETER                                           \
+                                2
+#define USB_CDC_SIZE_PROFILE    64
+#define USB_CDC_SIZE_ETHERNET_POWER_MANAGEMENT_PATTERN_FILTER                 \
+                                2
+#define USB_CDC_SIZE_ETHERNET_STATISTIC                                       \
+                                4
+#define USB_CDC_SIZE_ATM_DEVICE_STATISTICS                                    \
+                                4
+#define USB_CDC_SIZE_ATM_VC_STATISTICS                                        \
+                                4
+#define USB_CDC_SIZE_LINE_PARMS                                               \
+                                10
+
+//*****************************************************************************
+//
+// NB: USB_CDC_SIZE_LINE_PARAMS assumes only a single call.  For multiple
+// calls, add 4 bytes per additional call.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// USB_CDC_GET_COMM_FEATURE & USB_CDC_SET_COMM_FEATURE
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// wValue (Feature Selector)
+//
+//*****************************************************************************
+#define USB_CDC_ABSTRACT_STATE  0x0001
+#define USB_CDC_COUNTRY_SETTING 0x0002
+
+//*****************************************************************************
+//
+// Data when feature selector is USB_DCD_ABSTRACT_STATE
+//
+//*****************************************************************************
+#define USB_CDC_ABSTRACT_CALL_DATA_MULTIPLEXED                                \
+                                0x0002
+#define USB_CDC_ABSTRACT_ENDPOINTS_IDLE                                       \
+                                0x0001
+
+//*****************************************************************************
+//
+// Macros to populate the response data buffer (whose size in bytes is defined
+// by USB_CDC_SIZE_COMM_FEATURE).
+//
+//*****************************************************************************
+#define SetResponseCommFeature(pi8Buf, ui16Data)                              \
+        do                                                                    \
+        {                                                                     \
+            (*(uint16_t *)(pi8Buf)) = ui16Data;                               \
+        }                                                                     \
+        while(0)
+
+//*****************************************************************************
+//
+// USB_CDC_SET_AUX_LINE_STATE, wValue
+//
+//*****************************************************************************
+#define USB_CDC_AUX_DISCONNECT  0x0000
+#define USB_CDC_AUX_CONNECT     0x0001
+
+//*****************************************************************************
+//
+// USB_CDC_SET_HOOK_STATE, wValue
+//
+//*****************************************************************************
+#define USB_CDC_ON_HOOK         0x0000
+#define USB_CDC_OFF_HOOK        0x0001
+#define USB_CDC_SNOOPING        0x0002
+
+//*****************************************************************************
+//
+// USB_CDC_GET_LINE_CODING
+//
+//*****************************************************************************
+#define USB_CDC_STOP_BITS_1     0x00
+#define USB_CDC_STOP_BITS_1_5   0x01
+#define USB_CDC_STOP_BITS_2     0x02
+
+#define USB_CDC_PARITY_NONE     0x00
+#define USB_CDC_PARITY_ODD      0x01
+#define USB_CDC_PARITY_EVEN     0x02
+#define USB_CDC_PARITY_MARK     0x03
+#define USB_CDC_PARITY_SPACE    0x04
+
+//*****************************************************************************
+//
+// Macro to populate the response data buffer (whose size in bytes is defined
+// by USB_CDC_SIZE_LINE_CODING).
+//
+//*****************************************************************************
+#define SetResponseLineCoding(pi8Buf, ui8Rate, ui8Stop, ui8Parity,            \
+                              ui8Databits)                                    \
+        do                                                                    \
+        {                                                                     \
+            (*(uint32_t *)(pi8Buf)) = ui8Rate;                                \
+            (*((uint8_t *)(pi8Buf) + 4)) = ui8Stop;                           \
+            (*((uint8_t *)(pi8Buf) + 5)) = ui8Parity;                         \
+            (*((uint8_t *)(pi8Buf) + 6)) = ui8Databits;                       \
+        }                                                                     \
+        while(0)
+
+//*****************************************************************************
+//
+// USB_CDC_SET_CONTROL_LINE_STATE, wValue
+//
+//*****************************************************************************
+#define USB_CDC_DEACTIVATE_CARRIER                                            \
+                                0x00
+#define USB_CDC_ACTIVATE_CARRIER                                              \
+                                0x02
+#define USB_CDC_DTE_NOT_PRESENT 0x00
+#define USB_CDC_DTE_PRESENT     0x01
+
+//*****************************************************************************
+//
+// USB_CDC_SET_RINGER_PARMS, USB_CDC_GET_RINGER_PARMS and
+// USB_CDC_GET_LINE_PARMS (ui32RingerBmp)
+//
+//*****************************************************************************
+#define USB_CDC_RINGER_EXISTS   0x80000000
+#define USB_CDC_RINGER_DOES_NOT_EXIST                                         \
+                                0x00000000
+
+//*****************************************************************************
+//
+// Macro to populate the response data buffer to USB_CDC_GET_RINGER_PARMS.
+// Parameter buf points to a buffer of size USB_CDC_SIZE_RINGER_PARMS bytes.
+//
+//*****************************************************************************
+#define SetResponseRingerParms(pi8Buf, ui8Pattern, ui8Volume, ui32Exists)     \
+        do                                                                    \
+        {                                                                     \
+            *(uint32_t *)(pi8Buf) = ((ui8Pattern) +                           \
+                                     ((ui8Volume & 0xFF) << 8) +              \
+                                     (ui32Exists & USB_CDC_RINGER_EXISTS));   \
+        }                                                                     \
+        while(0)
+
+//*****************************************************************************
+//
+// Macros to extract fields from the USB_CDC_SET_RINGER_PARMS data
+//
+//*****************************************************************************
+#define GetRingerVolume(pi8Data)                                              \
+                                (BYTE((pi8Data) + 1))
+#define GetRingerPattern(pi8Data)                                             \
+                                (BYTE(pi8Data))
+#define GetRingerExists(pi8Data)                                              \
+                                ((LONG(pi8Data)) & USB_CDC_RINGER_EXISTS)
+
+//*****************************************************************************
+//
+// USB_CDC_SET_OPERATION_PARMS, wValue
+//
+//*****************************************************************************
+#define USB_CDC_SIMPLE_MODE     0x0000
+#define USB_CDC_STANDALONE_MODE 0x0001
+#define USB_CDC_HOST_CENTRIC_MODE                                             \
+                                0x0002
+
+//*****************************************************************************
+//
+// Macro to populate the response data buffer to USB_CDC_GET_OPERATION_PARMS.
+// Parameter buf points to a buffer of size USB_CDC_SIZE_OPERATION_PARMS
+// bytes.
+//
+//*****************************************************************************
+#define SetResponseOperationParms(pi8Bbuf, ui16Data)                          \
+        do                                                                    \
+        {                                                                     \
+            WORD(pi8Buf) = ui16Data;                                          \
+        }                                                                     \
+        while(0)
+
+//*****************************************************************************
+//
+// USB_CDC_SET_LINE_PARMS, wParam - Line State Change
+//
+//*****************************************************************************
+#define USB_CDC_DROP_ACTIVE_CALL                                              \
+                                0x0000
+#define USB_CDC_START_NEW_CALL  0x0001
+#define USB_CDC_APPLY_RINGING   0x0002
+#define USB_CDC_REMOVE_RINGING  0x0003
+#define USB_CDC_SWITCH_CALL     0x0004
+
+//*****************************************************************************
+//
+// Line state bitmap in USB_CDC_GET_LINE_PARMS response
+//
+//*****************************************************************************
+#define USB_CDC_LINE_IS_ACTIVE  0x80000000
+#define USB_CDC_LINE_IS_IDLE    0x00000000
+#define USB_CDC_LINE_NO_ACTIVE_CALL                                           \
+                                0x000000FF
+
+#define USB_CDC_CALL_ACTIVE     0x80000000
+
+//*****************************************************************************
+//
+// Call state value definitions
+//
+//*****************************************************************************
+#define USB_CDC_CALL_IDLE       0x00000000
+#define USB_CDC_CALL_TYPICAL_DIALTONE                                         \
+                                0x00000001
+#define USB_CDC_CALL_INTERRUPTED_DIALTONE                                     \
+                                0x00000002
+#define USB_CDC_CALL_DIALING    0x00000003
+#define USB_CDC_CALL_RINGBACK   0x00000004
+#define USB_CDC_CALL_CONNECTED  0x00000005
+#define USB_CDC_CALL_INCOMING   0x00000006
+
+//*****************************************************************************
+//
+// Call state change value definitions
+//
+//*****************************************************************************
+#define USB_CDC_CALL_STATE_IDLE 0x01
+#define USB_CDC_CALL_STATE_DIALING                                            \
+                                0x02
+#define USB_CDC_CALL_STATE_RINGBACK                                           \
+                                0x03
+#define USB_CDC_CALL_STATE_CONNECTED                                          \
+                                0x04
+#define USB_CDC_CALL_STATE_INCOMING                                           \
+                                0x05
+
+//*****************************************************************************
+//
+// Extra byte of data describing the connection type for
+// USB_CDC_CALL_STATE_CONNECTED.
+//
+//*****************************************************************************
+#define USB_CDC_VOICE           0x00
+#define USB_CDC_ANSWERING_MACHINE                                             \
+                                0x01
+#define USB_CDC_FAX             0x02
+#define USB_CDC_MODEM           0x03
+#define USB_CDC_UNKNOWN         0xFF
+
+//*****************************************************************************
+//
+// Macro to extract call index from request in cases where wParam is
+// USB_CDC_SWITCH_CALL.
+//
+//*****************************************************************************
+#define GetCallIndex(pi8Data)   (BYTE(pi8Data))
+
+//*****************************************************************************
+//
+// Macro to populate the CallState entries in response to request
+// USB_CDC_GET_LINE_PARMS.  The ui8Index parameter is a zero based index
+// indicating which call entry in the pi8Buf response buffer to fill in.  Note
+// that pi8Buf points to the first byte of the buffer (the wLength field).
+//
+//*****************************************************************************
+#define SetResponseCallState(pi8Buf, ui8Index, ui32Active, ui8StateChange,    \
+                             ui8State)                                        \
+        do                                                                    \
+        {                                                                     \
+            (LONG((uint8_t *)(pi8Buf) + (10 + (4 * (ui8Index))))) =           \
+                (((ui32Active) & USB_CDC_CALL_IS_ACTIVE) +                    \
+                 (((ui8StateChange) & 0xFF) << 8) +                           \
+                 ((ui8State) & 0xFF));                                        \
+        }                                                                     \
+        while(0)
+
+//*****************************************************************************
+//
+// Macro to populate the response data buffer (whose size in bytes is defined
+// by USB_CDC_SIZE_LINE_PARMS).  Note that this macro only populates fields for
+// a single call.  If multiple calls are being managed, additional 4 byte
+// fields must be appended to provide call state for each call after the first.
+// This may be done using the SetResponseCallState macro with the appropriate
+// call index supplied.
+//
+//*****************************************************************************
+#define SetResponseLineParms(pi8Buf, ui16Length,                              \
+                             ui8RingPattern, ui8RingVolume, ui32RingExists,   \
+                             ui32LineActive, ui8LineCallIndex,                \
+                             ui32CallActive, ui8CallStateChange,              \
+                             ui8CallState)                                    \
+        do                                                                    \
+        {                                                                     \
+            (WORD(pi8Buf)) = ui16Length;                                      \
+            SetResponseRingerParams(((uint8_t *)(pi8Buf) + 2),                \
+                                    ui8RingPattern, ui8RingVolume,            \
+                                    ui32RingExists);                          \
+            (LONG((uint8_t *)(pi8Buf) + 6)) =                                 \
+                (((ui32LineActive) & USB_CDC_LINE_IS_ACTIVE) +                \
+                 ((ui8LineCallIndex) & 0xFF)) ;                               \
+            SetResponseCallState(pi8Buf, 0, ui32CallActive,                   \
+                                 ui8CallStateChange, ui8CallState);           \
+        }                                                                     \
+        while(0)
+
+//*****************************************************************************
+//
+// Notification Element definitions
+//
+//*****************************************************************************
+#define USB_CDC_NOTIFY_NETWORK_CONNECTION                                     \
+                                0x00
+#define USB_CDC_NOTIFY_RESPONSE_AVAILABLE                                     \
+                                0x01
+#define USB_CDC_NOTIFY_AUX_JACK_HOOK_STATE                                    \
+                                0x08
+#define USB_CDC_NOTIFY_RING_DETECT                                            \
+                                0x09
+#define USB_CDC_NOTIFY_SERIAL_STATE                                           \
+                                0x20
+#define USB_CDC_NOTIFY_CALL_STATE_CHANGE                                      \
+                                0x28
+#define USB_CDC_NOTIFY_LINE_STATE_CHANGE                                      \
+                                0x29
+#define USB_CDC_NOTIFY_CONNECTION_SPEED_CHANGE                                \
+                                0x2A
+
+//*****************************************************************************
+//
+// USB_CDC_NOTIFY_NETWORK_CONNECTION, wValue
+//
+//*****************************************************************************
+#define USB_CDC_NETWORK_DISCONNECTED                                          \
+                                0x0000
+#define USB_CDC_NETWORK_CONNECTED                                             \
+                                0x0001
+
+//*****************************************************************************
+//
+// USB_CDC_NOTIFY_AUX_JACK_HOOK_STATE, wValue
+//
+//*****************************************************************************
+#define USB_CDC_AUX_JACK_ON_HOOK                                              \
+                                0x0000
+#define USB_CDC_AUX_JACK_OFF_HOOK                                             \
+                                0x0001
+
+//*****************************************************************************
+//
+// USB_CDC_NOTIFY_SERIAL_STATE, Data
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Number of bytes of data returned alongside this notification.
+//
+//*****************************************************************************
+#define USB_CDC_NOTIFY_SERIAL_STATE_SIZE                                      \
+                                2
+
+#define USB_CDC_SERIAL_STATE_OVERRUN                                          \
+                                0x0040
+#define USB_CDC_SERIAL_STATE_PARITY                                           \
+                                0x0020
+#define USB_CDC_SERIAL_STATE_FRAMING                                          \
+                                0x0010
+#define USB_CDC_SERIAL_STATE_RING_SIGNAL                                      \
+                                0x0008
+#define USB_CDC_SERIAL_STATE_BREAK                                            \
+                                0x0004
+#define USB_CDC_SERIAL_STATE_TXCARRIER                                        \
+                                0x0002
+#define USB_CDC_SERIAL_STATE_RXCARRIER                                        \
+                                0x0001
+
+//*****************************************************************************
+//
+// USB_CDC_NOTIFY_CALL_STATE_CHANGE, wValue
+//
+// Call state values are defined above in the group beginning
+// USB_CDC_CALL_STATE_IDLE.  Note that the data returned alongside this
+// notification are heavily dependent upon the call state being reported so no
+// specific lengths or access macros are provided here.
+//
+// Macro to construct the correct wValue for this notification given a state
+// and call index.
+//
+//*****************************************************************************
+#define SetNotifyCallStatewValue(pi16Result, ui8CallState, ui8Index)          \
+        do                                                                    \
+        {                                                                     \
+            (WORD(pi16Result)) = (((ui8CallState) & 0xFF) +                   \
+                                  (((ui8Index) & 0xFF) << 8));                \
+        }                                                                     \
+        while(0)
+
+//*****************************************************************************
+//
+// USB_CDC_NOTIFY_LINE_STATE_CHANGE, wValue
+//
+// Note that the data returned alongside this notification are heavily
+// dependent upon the call state being reported so no specific lengths or
+// access macros are provided here.
+//
+//*****************************************************************************
+#define USB_CDC_LINE_STATE_IDLE 0x0000
+#define USB_CDC_LINE_STATE_HOLD 0x0001
+#define USB_CDC_LINE_STATE_OFF_HOOK                                           \
+                                0x0002
+#define USB_CDC_LINE_STATE_ON_HOOK                                            \
+                                0x0003
+
+//*****************************************************************************
+//
+// USB_CDC_NOTIFY_CONNECTION_SPEED_CHANGE, Data
+//
+// Macro to populate the 8 byte data structure returned alongside this
+// notification.
+//
+//*****************************************************************************
+#define SetNotifyConnectionSpeedChange(pi8Buf, ui32USBitRate, ui32DSBitRate)  \
+        do                                                                    \
+        {                                                                     \
+            LONG(pi8Buf) = ui32USBitRate;                                     \
+            LONG((uint8_t *)(pi8Buf) + 4) = ui32DSBitRate;                    \
+        }                                                                     \
+        while(0)
+
+//*****************************************************************************
+//
+// Packed structure definitions for request/response data blocks
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// All structures defined in this section of the header require byte packing of
+// fields.  This is usually accomplished using the PACKED macro but, for IAR
+// Embedded Workbench, this requires a pragma.
+//
+//*****************************************************************************
+#ifdef ewarm
+#pragma pack(1)
+#endif
+
+//*****************************************************************************
+//
+//! USB_CDC_GET/SET_LINE_CODING request-specific data.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The data terminal rate in bits per second.
+    //
+    uint32_t ui32Rate;
+
+    //
+    //! The number of stop bits.  Valid values are USB_CDC_STOP_BITS_1,
+    //! USB_CDC_STOP_BITS_1_5 or USB_CDC_STOP_BITS_2
+    //
+    uint8_t ui8Stop;
+
+    //
+    //! The parity setting.  Valid values are USB_CDC_PARITY_NONE,
+    //! USB_CDC_PARITY_ODD, USB_CDC_PARITY_EVEN, USB_CDC_PARITY_MARK and
+    //! USB_CDC_PARITY_SPACE.
+    //
+    uint8_t ui8Parity;
+
+    //
+    //! The number of data bits per character.  Valid values are 5, 6, 7 and 8
+    //! in this implementation.
+    //
+    uint8_t ui8Databits;
+}
+PACKED tLineCoding;
+
+//*****************************************************************************
+//
+// Return to default packing when using the IAR Embedded Workbench compiler.
+//
+//*****************************************************************************
+#ifdef ewarm
+#pragma pack()
+#endif
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __USBCDC_H__
diff --git a/bsp/tm4c129x/libraries/usblib/usbdesc.c b/bsp/tm4c129x/libraries/usblib/usbdesc.c
new file mode 100755
index 0000000..32d3de1
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/usbdesc.c
@@ -0,0 +1,480 @@
+//*****************************************************************************
+//
+// usbdesc.c - USB descriptor parsing functions.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "inc/hw_types.h"
+#include "usblib/usblib.h"
+
+//*****************************************************************************
+//
+// Assumptions:
+// ------------
+//
+// The following assumptions are made in this module.  From reading chapter 9
+// of the USB 2.0 specification, these appear to be perfectly valid.
+//
+// 1.  The interface number, bInterfaceNumber in the interface descriptor, is
+//     a zero based index and takes values between 0 and
+//     (pConfigDescriptor->bNumInterfaces - 1) inclusive.
+// 2.  Similarly, the alternate setting number, bAlternateSetting in the
+//     interface descriptor, is a zero based index.
+// 3.  Interface descriptors are ordered by interface number in the
+//     configuration descriptor.
+// 4.  If alternate settings are available for an interface, the interface
+//     descriptors are ordered by alternate setting value bAlternateSetting.
+// 5.  Although the endpoints associated with a given interface must follow
+//     their associated interface descriptor, it is possible for other,
+//     device specific descriptors to be found between an interface descriptor
+//     and its endpoints or between endpoint descriptors for the same
+//     interface.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! \addtogroup general_usblib_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! Determines the number of individual descriptors of a particular type within
+//! a supplied buffer.
+//!
+//! \param psDesc points to the first byte of a block of standard USB
+//! descriptors.
+//! \param ui32Size is the number of bytes of descriptor data found at pointer
+//! \e psDesc.
+//! \param ui32Type identifies the type of descriptor that is to be counted.
+//! If the value is \b USB_DESC_ANY, the function returns the total number of
+//! descriptors regardless of type.
+//!
+//! This function can be used to count the number of descriptors of a
+//! particular type within a block of descriptors.  The caller can provide a
+//! specific type value which the function matches against the second byte of
+//! each descriptor or, alternatively, can specify \b USB_DESC_ANY to have the
+//! function count all descriptors regardless of their type.
+//!
+//! \return Returns the number of descriptors found in the supplied block of
+//! data.
+//
+//*****************************************************************************
+uint32_t
+USBDescGetNum(tDescriptorHeader *psDesc,  uint32_t ui32Size,
+              uint32_t ui32Type)
+{
+    tDescriptorHeader *psDescCheck;
+    uint32_t ui32TotLength;
+    uint32_t ui32Count;
+
+    //
+    // Set up for our descriptor counting loop.
+    //
+    psDescCheck = psDesc;
+    ui32TotLength = 0;
+    ui32Count = 0;
+
+    //
+    // Keep looking through the supplied data until we reach the end.
+    //
+    while(ui32TotLength < ui32Size)
+    {
+        //
+        // Does this descriptor match the type passed (if a specific type
+        // has been specified)?
+        //
+        if((ui32Type == USB_DESC_ANY) ||
+           (psDescCheck->bDescriptorType == (uint8_t)(ui32Type & 0xFF)))
+        {
+            ui32Count++;
+        }
+
+        //
+        // Move on to the next descriptor.
+        //
+        ui32TotLength += (uint32_t)psDescCheck->bLength;
+        psDescCheck = NEXT_USB_DESCRIPTOR(psDescCheck);
+    }
+
+    //
+    // Return the descriptor count to the caller.
+    //
+    return(ui32Count);
+}
+
+//*****************************************************************************
+//
+//! Determines the number of individual descriptors of a particular type within
+//! a supplied buffer.
+//!
+//! \param psDesc points to the first byte of a block of standard USB
+//! descriptors.
+//! \param ui32Size is the number of bytes of descriptor data found at pointer
+//! \e psDesc.
+//! \param ui32Type identifies the type of descriptor that is to be found.  If
+//! the value is \b USB_DESC_ANY, the function returns a pointer to the n-th
+//! descriptor regardless of type.
+//! \param ui32Index is the zero based index of the descriptor whose pointer is
+//! to be returned.  For example, passing value 1 in \e ui32Index returns the
+//! second matching descriptor.
+//!
+//! Return a pointer to the n-th descriptor of a particular type found in the
+//! block of \e ui32Size bytes starting at \e psDesc.
+//!
+//! \return Returns a pointer to the header of the required descriptor if
+//! found or NULL otherwise.
+//
+//*****************************************************************************
+tDescriptorHeader *
+USBDescGet(tDescriptorHeader *psDesc,  uint32_t ui32Size,
+           uint32_t ui32Type, uint32_t ui32Index)
+{
+    tDescriptorHeader *psDescCheck;
+    uint32_t ui32TotLength;
+    uint32_t ui32Count;
+
+    //
+    // Set up for our descriptor counting loop.
+    //
+    psDescCheck = psDesc;
+    ui32TotLength = 0;
+    ui32Count = 0;
+
+    //
+    // Keep looking through the supplied data until we reach the end.
+    //
+    while(ui32TotLength < ui32Size)
+    {
+        //
+        // Does this descriptor match the type passed (if a specific type
+        // has been specified)?
+        //
+        if((ui32Type == USB_DESC_ANY) ||
+           (psDescCheck->bDescriptorType == (uint8_t)(ui32Type & 0xFF)))
+        {
+            //
+            // We found a matching descriptor.  If our count matches the
+            // supplied index, we are done so return the pointer.
+            //
+            if(ui32Count == ui32Index)
+            {
+                return(psDescCheck);
+            }
+
+            //
+            // We have not found enough descriptors yet to satisfy the supplied
+            // index so increment our count and continue.
+            //
+            ui32Count++;
+        }
+
+        //
+        // Move on to the next descriptor.
+        //
+        ui32TotLength += (uint32_t)psDescCheck->bLength;
+        psDescCheck = NEXT_USB_DESCRIPTOR(psDescCheck);
+    }
+
+    //
+    // If we get here, we reached the end of the data without finding the
+    // required descriptor.  Return NULL.
+    //
+    return((tDescriptorHeader *)0);
+}
+
+//*****************************************************************************
+//
+//! Determines the number of different alternate configurations for a given
+//! interface within a configuration descriptor.
+//!
+//! \param psConfig points to the first byte of a standard USB configuration
+//! descriptor.
+//! \param ui8InterfaceNumber is the interface number for which the number of
+//! alternate configurations is to be counted.
+//!
+//! This function can be used to count the number of alternate settings for a
+//! specific interface within a configuration.
+//!
+//! \return Returns the number of alternate versions of the specified interface
+//! or 0 if the interface number supplied cannot be found in the config
+//! descriptor.
+//
+//*****************************************************************************
+uint32_t
+USBDescGetNumAlternateInterfaces(tConfigDescriptor *psConfig,
+                                 uint8_t ui8InterfaceNumber)
+{
+    tDescriptorHeader *psDescCheck;
+    uint32_t ui32TotLength;
+    uint32_t ui32Count;
+
+    //
+    // Set up for our descriptor counting loop.
+    //
+    psDescCheck = (tDescriptorHeader *)psConfig;
+    ui32TotLength = 0;
+    ui32Count = 0;
+
+    //
+    // Keep looking through the supplied data until we reach the end.
+    //
+    while(ui32TotLength < (uint32_t)psConfig->wTotalLength)
+    {
+        //
+        // Is this an interface descriptor with the required interface number?
+        //
+        if((psDescCheck->bDescriptorType == USB_DTYPE_INTERFACE) &&
+            (((tInterfaceDescriptor *)psDescCheck)->bInterfaceNumber ==
+             ui8InterfaceNumber))
+        {
+            //
+            // Yes - increment our count.
+            //
+            ui32Count++;
+        }
+
+        //
+        // Move on to the next descriptor.
+        //
+        ui32TotLength += (uint32_t)psDescCheck->bLength;
+        psDescCheck = NEXT_USB_DESCRIPTOR(psDescCheck);
+    }
+
+    //
+    // Return the descriptor count to the caller.
+    //
+    return(ui32Count);
+}
+
+//*****************************************************************************
+//
+//! Returns a pointer to the n-th interface descriptor in a config descriptor
+//! with the supplied interface number.
+//!
+//! \param psConfig points to the first byte of a standard USB configuration
+//! descriptor.
+//! \param ui8InterfaceNumber is the interface number of the descriptor that is
+//! being queried.
+//! \param ui32Index is the zero based index of the descriptor to return.
+//!
+//! This function returns a pointer to the n-th interface descriptor in the
+//! supplied configuration which has the requested interface number.  It may be
+//! used by a client to retrieve the descriptors for each alternate setting
+//! of a given interface within the configuration passed.
+//!
+//! \return Returns a pointer to the n-th interface descriptor with interface
+//! number as specified or NULL of this descriptor does not exist.
+//
+//*****************************************************************************
+static tInterfaceDescriptor *
+USBDescGetAlternateInterface(tConfigDescriptor *psConfig,
+                             uint8_t ui8InterfaceNumber,
+                             uint32_t ui32Index)
+{
+    tDescriptorHeader *psDescCheck;
+    uint32_t ui32TotLength;
+    uint32_t ui32Count;
+
+    //
+    // Set up for our descriptor counting loop.
+    //
+    psDescCheck = (tDescriptorHeader *)psConfig;
+    ui32TotLength = 0;
+    ui32Count = 0;
+
+    //
+    // Keep looking through the supplied data until we reach the end.
+    //
+    while(ui32TotLength < (uint32_t)psConfig->wTotalLength)
+    {
+        //
+        // Does this descriptor match the type passed (if a specific type
+        // has been specified)?
+        //
+        if((psDescCheck->bDescriptorType == USB_DTYPE_INTERFACE) &&
+            (((tInterfaceDescriptor *)psDescCheck)->bInterfaceNumber ==
+             ui8InterfaceNumber))
+        {
+            //
+            // This is an interface descriptor for interface
+            // ui8InterfaceNumber.  Determine if this is the n-th one we have
+            // found and, if so, return its pointer.
+            //
+            if(ui32Count == ui32Index)
+            {
+                //
+                // Found it - return the pointer.
+                //
+                return((tInterfaceDescriptor *)psDescCheck);
+            }
+
+            //
+            // Increment our count of matching descriptors found and go back
+            // to look for another since we have not yet reached the n-th
+            // match.
+            //
+            ui32Count++;
+        }
+
+        //
+        // Move on to the next descriptor.
+        //
+        ui32TotLength += (uint32_t)psDescCheck->bLength;
+        psDescCheck = NEXT_USB_DESCRIPTOR(psDescCheck);
+    }
+
+    //
+    // If we drop out the end of the loop, we did not find the requested
+    // descriptor so return NULL.
+    //
+    return((tInterfaceDescriptor *)0);
+}
+
+//*****************************************************************************
+//
+//! Returns a pointer to the n-th interface descriptor in a configuration
+//! descriptor that applies to the supplied alternate setting number.
+//!
+//! \param psConfig points to the first byte of a standard USB configuration
+//! descriptor.
+//! \param ui32Index is the zero based index of the interface that is to be
+//! found.  If \e ui32Alt is set to a value other than \b USB_DESC_ANY, this
+//! will be equivalent to the interface number being searched for.
+//! \param ui32Alt is the alternate setting number which is to be
+//! searched for.  If this value is \b USB_DESC_ANY, the alternate setting
+//! is ignored and all interface descriptors are considered in the search.
+//!
+//! Return a pointer to the n-th interface descriptor found in the supplied
+//! configuration descriptor.  If \e ui32Alt is not \b USB_DESC_ANY, only
+//! interface descriptors which are part of the supplied alternate setting are
+//! considered in the search otherwise all interface descriptors are
+//! considered.
+//!
+//! Note that, although alternate settings can be applied on an interface-by-
+//! interface basis, the number of interfaces offered is fixed for a given
+//! config descriptor.  Hence, this function will correctly find the unique
+//! interface descriptor for that interface's alternate setting number
+//! \e ui32Alt if \e ui32Index is set to the required interface number and
+//! \e ui32Alt is set to a valid alternate setting number for that interface.
+//!
+//! \return Returns a pointer to the required interface descriptor if
+//! found or NULL otherwise.
+//
+//*****************************************************************************
+tInterfaceDescriptor *
+USBDescGetInterface(tConfigDescriptor *psConfig, uint32_t ui32Index,
+                    uint32_t ui32Alt)
+{
+    //
+    // If we are being told to ignore the alternate configuration, this boils
+    // down to a very simple query.
+    //
+    if(ui32Alt == USB_DESC_ANY)
+    {
+        //
+        // Return the ui32Index-th interface descriptor we find in the
+        // configuration descriptor.
+        //
+        return((tInterfaceDescriptor *)USBDescGet(
+                          (tDescriptorHeader *)psConfig,
+                          (uint32_t)psConfig->wTotalLength,
+                          USB_DTYPE_INTERFACE, ui32Index));
+    }
+    else
+    {
+        //
+        // In this case, a specific alternate setting number is required.
+        // Given that interface numbers are zero based indices, we can
+        // pass the supplied ui32Index parameter directly as the interface
+        // number to USBDescGetAlternateInterface to retrieve the requested
+        // interface descriptor pointer.
+        //
+        return(USBDescGetAlternateInterface(psConfig, ui32Index, ui32Alt));
+    }
+}
+
+//*****************************************************************************
+//
+//! Return a pointer to the n-th endpoint descriptor in the supplied
+//! interface descriptor.
+//!
+//! \param psInterface points to the first byte of a standard USB interface
+//! descriptor.
+//! \param ui32Index is the zero based index of the endpoint that is to be
+//! found.
+//! \param ui32Size contains the maximum number of bytes that the function may
+//! search beyond \e psInterface while looking for the requested endpoint
+//! descriptor.
+//!
+//! Return a pointer to the n-th endpoint descriptor found in the supplied
+//! interface descriptor.  If the \e ui32Index parameter is invalid (greater
+//! than or equal to the bNumEndpoints field of the interface descriptor) or
+//! the endpoint cannot be found within \e ui32Size bytes of the interface
+//! descriptor pointer, the function will return NULL.
+//!
+//! Note that, although the USB 2.0 specification states that endpoint
+//! descriptors must follow the interface descriptor that they relate to, it
+//! also states that device specific descriptors should follow any standard
+//! descriptor that they relate to.  As a result, we cannot assume that each
+//! interface descriptor will be followed by nothing but an ordered list of
+//! its own endpoints and, hence, the function needs to be provided \e ui32Size
+//! to limit the search range.
+//!
+//! \return Returns a pointer to the requested endpoint descriptor if
+//! found or NULL otherwise.
+//
+//*****************************************************************************
+tEndpointDescriptor *
+USBDescGetInterfaceEndpoint(tInterfaceDescriptor *psInterface,
+                            uint32_t ui32Index, uint32_t ui32Size)
+{
+    //
+    // Is the index passed valid?
+    //
+    if(ui32Index >= psInterface->bNumEndpoints)
+    {
+        //
+        // It's out of bounds so return a NULL.
+        //
+        return((tEndpointDescriptor *)0);
+    }
+    else
+    {
+        //
+        // Endpoint index is valid so find the descriptor.
+        //
+        return((tEndpointDescriptor *)USBDescGet(
+                         (tDescriptorHeader *)psInterface,
+                          ui32Size, USB_DTYPE_ENDPOINT, ui32Index));
+    }
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
diff --git a/bsp/tm4c129x/libraries/usblib/usbdfu.h b/bsp/tm4c129x/libraries/usblib/usbdfu.h
new file mode 100755
index 0000000..31f15f2
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/usbdfu.h
@@ -0,0 +1,504 @@
+//*****************************************************************************
+//
+// usbdfu.h - Definitions related to the USB Device Firmware Upgrade class.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#ifndef __USBDFU_H__
+#define __USBDFU_H__
+
+//*****************************************************************************
+//
+// DFU attributes as published in the functional descriptor.
+//
+//*****************************************************************************
+#define DFU_ATTR_WILL_DETACH    0x08
+#define DFU_ATTR_MANIFEST_TOLERANT                                            \
+                                0x04
+#define DFU_ATTR_CAN_UPLOAD     0x02
+#define DFU_ATTR_CAN_DOWNLOAD   0x01
+
+//*****************************************************************************
+//
+// The states that the DFU device can be in.  These values are reported to
+// the host in response to a USBD_DFU_REQUEST_GETSTATE request.
+//
+//*****************************************************************************
+typedef enum
+{
+   eDFUStateAppIdle = 0,
+   eDFUStateAppDetach,
+   eDFUStateIdle,
+   eDFUStateDnloadSync,
+   eDFUStateDnBusy,
+   eDFUStateDnloadIdle,
+   eDFUStateManifestSync,
+   eDFUStateManifest,
+   eDFUStateManifestWaitReset,
+   eDFUStateUploadIdle,
+   eDFUStateError
+}
+tDFUState;
+
+//*****************************************************************************
+//
+// The current error status of the DFU device.  These values are reported to
+// the host in response to a USBD_DFU_REQUEST_GETSTATUS request.
+//
+//*****************************************************************************
+typedef enum
+{
+   eDFUStatusOk = 0,
+   eDFUStatusErrTarget,
+   eDFUStatusErrFile,
+   eDFUStatusErrWrite,
+   eDFUStatusErrErase,
+   eDFUStatusErrCheckErased,
+   eDFUStatusErrProg,
+   eDFUStatusErrVerify,
+   eDFUStatusErrAddress,
+   eDFUStatusErrNotDone,
+   eDFUStatusErrFirmware,
+   eDFUStatusErrVendor,
+   eDFUStatusErrUSBR,
+   eDFUStatusErrPOR,
+   eDFUStatusErrUnknown,
+   eDFUStatusErrStalledPkt
+}
+tDFUStatus;
+
+//*****************************************************************************
+//
+// The descriptor type for the DFU functional descriptor.
+//
+//*****************************************************************************
+#define USB_DFU_FUNC_DESCRIPTOR_TYPE                                          \
+                                0x21
+
+//*****************************************************************************
+//
+// The subclass identifier for DFU as reported to the host in the
+// bInterfaceSubClass field of the DFU interface descriptor.
+//
+//*****************************************************************************
+#define USB_DFU_SUBCLASS        0x01
+
+//*****************************************************************************
+//
+// The protocol identifier for DFU as reported to the host in the
+// bInterfaceProtocol field of the DFU interface descriptor.
+//
+//*****************************************************************************
+#define USB_DFU_PROTOCOL        0x02
+#define USB_DFU_RUNTIME_PROTOCOL                                              \
+                                0x01
+
+//*****************************************************************************
+//
+// DFU class-specific request identifiers.
+//
+//*****************************************************************************
+#define USBD_DFU_REQUEST_DETACH 0
+#define USBD_DFU_REQUEST_DNLOAD 1
+#define USBD_DFU_REQUEST_UPLOAD 2
+#define USBD_DFU_REQUEST_GETSTATUS                                            \
+                                3
+#define USBD_DFU_REQUEST_CLRSTATUS                                            \
+                                4
+#define USBD_DFU_REQUEST_GETSTATE                                             \
+                                5
+#define USBD_DFU_REQUEST_ABORT  6
+
+//*****************************************************************************
+//
+// Request 1KB blocks from the host.  This value is published in the USB
+// functional descriptor.
+//
+//*****************************************************************************
+#define DFU_TRANSFER_SIZE       1024
+
+//*****************************************************************************
+//
+// USBLib-specific request identifier.  This is used to determine whether
+// the target device supports our DFU command protocol.  It is expected that
+// a device not supporting our extensions will stall this request.  This
+// request is only supported while the DFU device is in eDFUStateIdle.
+//
+// An IN request containing the following parameters will result in the device
+// sending back a tDFUQueryTivaProtocol structure indicating that
+// USBLib extensions are supported.  The actual values in wValue and wIndex
+// have no meaning other than to act as markers in the unlikely event that
+// another DFU device also chooses to use request ID 0x42 for some other
+// purpose.
+//
+// wValue        - 0x23(REQUEST_TIVA_VALUE)
+// wIndex        - Interface number
+// wLength       - sizeof(tDFUQueryTivaProtocol)
+//
+//*****************************************************************************
+#define USBD_DFU_REQUEST_TIVA 0x42
+#define REQUEST_TIVA_VALUE    0x23
+
+#define DFU_PROTOCOL_TIVA_MARKER                                            \
+                                0x4C4D
+#define DFU_PROTOCOL_TIVA_VERSION_1                                         \
+                                0x0001
+
+#ifdef ewarm
+#pragma pack(1)
+#endif
+
+//*****************************************************************************
+//
+// The structure sent to the host when a valid USBD_DFU_REQUEST_TIVA is
+// received while the DFU device is in idle state.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    // The protocol marker(DFU_PROTOCOL_TIVA_MARKER)
+    //
+    uint16_t ui16Marker;
+
+    //
+    // The protocol version(DFU_PROTOCOL_TIVA_VERSION_1)
+    //
+    uint16_t ui16Version;
+}
+PACKED tDFUQueryTivaProtocol;
+
+//*****************************************************************************
+//
+// Structure sent to the host in response to USBD_DFU_REQUEST_GETSTATUS.
+//
+//*****************************************************************************
+typedef struct
+{
+    uint8_t bStatus;
+    uint8_t bwPollTimeout[3];
+    uint8_t bState;
+    uint8_t iString;
+}
+PACKED tDFUGetStatusResponse;
+
+//*****************************************************************************
+//
+// Firmware Download Commands
+//
+// The data passed on a USBD_DFU_REQUEST_DNLOAD request is comprised of a
+// header which instructs the boot loader how to interpret the block and
+// block-specific data.  The following definitions relate to the download
+// block headers.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Supported command identifiers
+//
+//*****************************************************************************
+#define DFU_CMD_PROG            0x01
+#define DFU_CMD_READ            0x02
+#define DFU_CMD_CHECK           0x03
+#define DFU_CMD_ERASE           0x04
+#define DFU_CMD_INFO            0x05
+#define DFU_CMD_BIN             0x06
+#define DFU_CMD_RESET           0x07
+
+//*****************************************************************************
+//
+// Generic download command header.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    // Command identifier.
+    //
+    uint8_t ui8Command;
+
+    //
+    // Command-specific data elements.
+    //
+    uint8_t pui8Data[7];
+}
+PACKED tDFUDownloadHeader;
+
+//*****************************************************************************
+//
+// Header for the DFU_CMD_PROG command.
+//
+// This command is used to program a section of the flash with the binary data
+// which immediately follows the header. The start address of the data is
+// expressed as a 1KB block number so 0 would represent the bottom of flash
+// (which, incidentally, the USB boot loader will not let you program) and 0x10
+// would represent address 16KB or 16384 (0x4000).  The ui32Length field
+// contains the total number of bytes of data in the following programming
+// operation.  The DFU device will not look for any command header on following
+// USBD_DFU_REQUEST_DNLOAD requests until the operation is completed or
+// aborted.
+//
+// By using this protocol, the DFU_CMD_PROG command header may be used as a
+// simple header on the binary files to be sent to the DFU device for
+// programming.  If we enforce the requirement that the DFU_CMD_PROG header is
+// applied to each USBD_DFU_REQUEST_DNLOAD (one per block), this means that the
+// host-side DFU application must be aware of the underlying protocol and
+// insert these headers dynamically during programming operations.  This could
+// be handled by post processing the binary to insert the headers at the
+// appropriate points but this would then tie the binary structure to the
+// chosen transfer size and break the operation if the transfer size were to
+// change in the future.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    // DFU_CMD_PROG
+    //
+    uint8_t  ui8Command;
+
+    //
+    // Reserved - set to 0x00.
+    //
+    uint8_t  ui8Reserved;
+
+    //
+    // Block start address / 1024
+    //
+    uint16_t ui16StartAddr;
+
+    //
+    // Total length, in bytes, of following data for the complete download
+    // operation.
+    //
+    uint32_t  ui32Length;
+}
+PACKED tDFUDownloadProgHeader;
+
+//*****************************************************************************
+//
+// Header for the DFU_CMD_READ and DFU_CMD_CHECK commands.
+//
+// This command may be used to set the address range whose content will be
+// returned on subsequent USBD_DFU_REQUEST_UPLOAD requests from the host.
+//
+// To read back a the contents of a region of flash, the host should send
+// USBD_DFU_REQUEST_DNLOAD with ui8Command DFU_CMD_READ, ui16StartAddr set to
+// the 1KB block start address and ui32Length set to the number of bytes to
+// read.  The host should then send one or more USBD_DFU_REQUEST_UPLOAD
+// requests to receive the current flash contents from the configured
+// addresses.  Data returned will include an 8 byte DFU_CMD_PROG prefix
+// structure unless the prefix has been disabled by sending a DFU_CMD_BIN
+// command with the bBinary parameter set to 1.
+//
+// To check that a region of flash is erased, the DFU_CMD_CHECK command should
+// be sent with ui16StartAddr and ui32Length set to describe the region to
+// check.  The host should then send a USBD_DFU_REQUEST_GETSTATUS.  If the
+// erase check was successful, the returned bStatus value will be STATUS_OK,
+// otherwise it will be STATUS_ERR_CHECK_ERASED. Note that ui32Length passed
+// must be a multiple of 4.  If this is not the case, the value will be
+// truncated before the check is performed.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    // DFU_CMD_READ or DFU_CMD_CHECK
+    //
+    uint8_t  ui8Command;
+
+    //
+    // Reserved - write to 0
+    //
+    uint8_t  ui8Reserved;
+
+    //
+    // Block start address / 1024
+    //
+    uint16_t ui16StartAddr;
+
+    //
+    // The number of bytes of data to read back or check.
+    //
+    uint32_t  ui32Length;
+}
+PACKED tDFUDownloadReadCheckHeader;
+
+//*****************************************************************************
+//
+// Header for the DFU_CMD_ERASE command.
+//
+// This command may be used to erase a number of flash blocks.  The address of
+// the first block to be erased is passed in ui16StartAddr with ui16NumBlocks
+// containing the number of blocks to be erased from this address.  The block
+// size of the device may be determined using the DFU_CMD_INFO command.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    // DFU_CMD_ERASE
+    //
+    uint8_t  ui8Command;
+
+    //
+    // Reserved - set to 0.
+    //
+    uint8_t  ui8Reserved;
+
+    //
+    // Block start address / 1024
+    //
+    uint16_t ui16StartAddr;
+
+    //
+    // The number of blocks to erase.
+    //
+    uint16_t ui16NumBlocks;
+
+    //
+    // Reserved - set to 0.
+    //
+    uint8_t  pui8Reserved2[2];
+}
+PACKED tDFUDownloadEraseHeader;
+
+//*****************************************************************************
+//
+// Header for the DFU_CMD_INFO command.
+//
+// This command may be used to query information about the connected device.
+// After sending the command, the information is returned on the next
+// USBD_DFU_REQUEST_UPLOAD request.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    // DFU_CMD_INFO
+    //
+    uint8_t ui8Command;
+
+    //
+    // Reserved - set to 0.
+    //
+    uint8_t pui8Reserved[7];
+}
+PACKED tDFUDownloadInfoHeader;
+
+//*****************************************************************************
+//
+// Header for the DFU_CMD_BIN command.
+//
+// This command may be used to set the format of uploaded data.  By default,
+// images read using USBD_DFU_REQUEST_UPLOAD are formatted with the appropriate
+// header to allow the same image to be flashed back to the device and have it
+// located at the address from which it originated.  This is a requirement of
+// the DFU class specification (section 6.2 "the uploaded image must be
+// usable in a subsequent download") but may not be helpful in some cases where
+// the application wishes to receive only the binary image from flash.  To
+// instruct the DFU device to omit the position and size header, send this
+// command with the bBinary field set to \b true prior to issuing a
+// USBD_DFU_REQUEST_UPLOAD for image data.  The format choice remains in effect
+// until the command is sent once again with bBinary set to \b false.
+//
+// Note that the format choice affects only image data sent and not responses
+// read via USBD_DFU_REQUEST_UPLOAD following USBLib-specific commands such
+// as DFU_CMD_INFO.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    // DFU_CMD_BIN
+    //
+    uint8_t ui8Command;
+
+    //
+    // Set to true to omit image header or false to include it (the default).
+    //
+    uint8_t ui8Binary;
+
+    //
+    // Reserved - set to 0.
+    //
+    uint8_t pui8Reserved[6];
+}
+PACKED tDFUDownloadBinHeader;
+
+//*****************************************************************************
+//
+// The DFU_CMD_RESET command uses a tDFUDownloadHeader structure since
+// only the ui8Command field is important.  This command causes an immediate
+// reset of the the target board.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! Payload returned in response to the DFU_CMD_INFO command.
+//!
+//! This is structure is returned in response to the first
+//! USBD_DFU_REQUEST_UPLOAD request following a DFU_CMD_INFO command.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The size of a flash block in bytes.
+    //
+    uint16_t ui16FlashBlockSize;
+
+    //
+    //! The number of blocks of flash in the  device.  Total flash size is
+    //! ui16NumFlashBlocks * ui16FlashBlockSize.
+    //
+    uint16_t ui16NumFlashBlocks;
+
+    //
+    //! Information on the part number, family, version and package as
+    //! read from SYSCTL register DID1.
+    //
+    uint32_t ui32PartInfo;
+
+    //
+    //! Information on the part class and revision as read from SYSCTL DID0.
+    //
+    uint32_t ui32ClassInfo;
+
+    //
+    //! Address 1 byte above the highest location the boot loader can access.
+    //
+    uint32_t ui32FlashTop;
+
+    //
+    //! Lowest address the boot loader can write or erase.
+    //
+    uint32_t ui32AppStartAddr;
+}
+PACKED tDFUDeviceInfo;
+
+#ifdef ewarm
+#pragma pack()
+#endif
+
+#endif // __USBDFU_H__
diff --git a/bsp/tm4c129x/libraries/usblib/usbdma.c b/bsp/tm4c129x/libraries/usblib/usbdma.c
new file mode 100755
index 0000000..b6f7c96
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/usbdma.c
@@ -0,0 +1,1453 @@
+//*****************************************************************************
+//
+// usbdma.c - USB Library DMA handling functions.
+//
+// Copyright (c) 2012-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "inc/hw_memmap.h"
+#include "inc/hw_types.h"
+#include "inc/hw_ints.h"
+#include "inc/hw_sysctl.h"
+#include "inc/hw_udma.h"
+#include "driverlib/debug.h"
+#include "driverlib/interrupt.h"
+#include "driverlib/rtos_bindings.h"
+#include "driverlib/usb.h"
+#include "driverlib/rom.h"
+#include "driverlib/rom_map.h"
+#include "driverlib/udma.h"
+#include "usblib/usblib.h"
+#include "usblib/usblibpriv.h"
+
+//*****************************************************************************
+//
+//! \addtogroup usblib_dma_api Internal USB DMA functions
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// There are two sets of functions in this file, one is used with uDMA while
+// the other is used with USB controllers with an integrated DMA controller.
+// The functions with the IDMA prefix are for the integrated DMA controller and
+// the functions that are specific to the uDMA controller are prefixed with
+// uDMA.  Any common functions are have just the DMA prefix.
+//
+//*****************************************************************************
+static tUSBDMAInstance g_psUSBDMAInst[1];
+
+//*****************************************************************************
+//
+// Macros used to determine if a uDMA endpoint configuration is used for
+// receive or transmit.
+//
+//*****************************************************************************
+#define UDMAConfigIsRx(ui32Config)                                            \
+        ((ui32Config & UDMA_SRC_INC_NONE) == UDMA_SRC_INC_NONE)
+#define UDMAConfigIsTx(ui32Config)                                            \
+        ((ui32Config & UDMA_DEST_INC_NONE) == UDMA_DEST_INC_NONE)
+
+//*****************************************************************************
+//
+// USBLibDMAChannelStatus() for USB controllers that use the uDMA for DMA.
+//
+//*****************************************************************************
+static uint32_t
+uDMAUSBChannelStatus(tUSBDMAInstance *psUSBDMAInst, uint32_t ui32Channel)
+{
+    uint32_t ui32Status;
+
+    //
+    // Initialize the current status to no events.
+    //
+    ui32Status = USBLIBSTATUS_DMA_IDLE;
+
+    //
+    // Check if there is a pending DMA transfer.
+    //
+    if(psUSBDMAInst->ui32Complete & (1 << (ui32Channel - 1)))
+    {
+        //
+        // Return that the DMA transfer has completed and clear the
+        // DMA pending flag.
+        //
+        ui32Status = USBLIBSTATUS_DMA_COMPLETE;
+    }
+    else if(psUSBDMAInst->ui32Pending & (1 << (ui32Channel - 1)))
+    {
+        //
+        // DMA transfer is still pending.
+        //
+        ui32Status = USBLIBSTATUS_DMA_PENDING;
+    }
+    else
+    {
+        //
+        // DMA transfer is still pending.
+        //
+        ui32Status = USBLIBSTATUS_DMA_IDLE;
+    }
+
+    return(ui32Status);
+}
+
+//*****************************************************************************
+//
+// USBLibDMAChannelStatus() for USB controllers with an integrated DMA
+// controller.
+//
+//*****************************************************************************
+static uint32_t
+iDMAUSBChannelStatus(tUSBDMAInstance *psUSBDMAInst, uint32_t ui32Channel)
+{
+    uint32_t ui32Status;
+
+    //
+    // Initialize the current status to no events.
+    //
+    ui32Status = USBLIBSTATUS_DMA_IDLE;
+
+    //
+    // Check if an error has occurred.
+    //
+    if(USBDMAChannelStatus(psUSBDMAInst->ui32Base, ui32Channel) ==
+       USB_DMA_STATUS_ERROR)
+    {
+        ui32Status = USBLIBSTATUS_DMA_ERROR;
+    }
+    //
+    // Otherwise check if there a pending DMA transfer has completed.
+    //
+    else if(psUSBDMAInst->ui32Complete & (1 << (ui32Channel - 1)))
+    {
+        //
+        // Return that the DMA transfer has completed and clear the
+        // DMA pending flag.
+        //
+        ui32Status = USBLIBSTATUS_DMA_COMPLETE;
+    }
+    else if(psUSBDMAInst->ui32Pending & (1 << (ui32Channel - 1)))
+    {
+        //
+        // DMA transfer is still pending.
+        //
+        ui32Status = USBLIBSTATUS_DMA_PENDING;
+    }
+    else
+    {
+        //
+        // DMA Channel is idle.
+        //
+        ui32Status = USBLIBSTATUS_DMA_IDLE;
+    }
+
+    return(ui32Status);
+}
+
+//*****************************************************************************
+//
+// USBLibDMAIntStatus() for USB controllers that use uDMA.
+//
+//*****************************************************************************
+static uint32_t
+uDMAUSBIntStatus(tUSBDMAInstance *psUSBDMAInst)
+{
+    uint32_t ui32Status, ui32Pending;
+    int32_t i32Channel;
+
+    //
+    // Initialize the current status to no events.
+    //
+    ui32Status = 0;
+
+    //
+    // No pending interrupts by default.
+    //
+    ui32Status = 0;
+
+    //
+    // Save the pending channels.
+    //
+    ui32Pending = psUSBDMAInst->ui32Pending;
+
+    //
+    // Loop through channels to find out if any pending DMA transfers have
+    // completed.
+    //
+    for(i32Channel = 0; i32Channel < USB_MAX_DMA_CHANNELS; i32Channel++)
+    {
+        //
+        // If pending and stopped then the DMA completed.
+        //
+        if((ui32Pending & 1) &&
+           (MAP_uDMAChannelModeGet(i32Channel) == UDMA_MODE_STOP))
+        {
+            ui32Status |= (1 << i32Channel);
+        }
+        ui32Pending >>= 1;
+
+        //
+        // Done if this is zero.
+        //
+        if(ui32Pending == 0)
+        {
+            break;
+        }
+    }
+
+    return(ui32Status);
+}
+
+//*****************************************************************************
+//
+// USBLibDMAIntStatus() for USB controllers with an integrated DMA controller.
+//
+//*****************************************************************************
+static uint32_t
+iDMAUSBIntStatus(tUSBDMAInstance *psUSBDMAInst)
+{
+    //
+    // Read the current DMA status, unfortunately this clears the
+    // pending interrupt status.
+    //
+    return(USBDMAChannelIntStatus(psUSBDMAInst->ui32Base));
+}
+
+//*****************************************************************************
+//
+// USBLibDMAIntStatusClear() for USB controllers that use uDMA for DMA or have
+// an integrated DMA controller.
+//
+//*****************************************************************************
+static void
+DMAUSBIntStatusClear(tUSBDMAInstance *psUSBDMAInst, uint32_t ui32Status)
+{
+    //
+    // Clear out the requested interrupts.  Since the USB interface does not
+    // have a true interrupt clear, this clears the current completed
+    // status for the requested channels.
+    //
+    psUSBDMAInst->ui32Complete &= ~ui32Status;
+
+    return;
+}
+
+//*****************************************************************************
+//
+// USBLibDMAIntHandler() for USB controllers that use uDMA for DMA or have an
+// integrated DMA controller.
+//
+//*****************************************************************************
+static void
+DMAUSBIntHandler(tUSBDMAInstance *psUSBDMAInst, uint32_t ui32DMAIntStatus)
+{
+    uint32_t ui32Channel;
+
+    if(ui32DMAIntStatus == 0)
+    {
+        return;
+    }
+
+    //
+    // Determine if the uDMA is used or the USB DMA controller.
+    //
+    for(ui32Channel = 0; ui32Channel < USB_MAX_DMA_CHANNELS; ui32Channel++)
+    {
+        //
+        // Mark any pending interrupts as completed.
+        //
+        if(ui32DMAIntStatus & 1)
+        {
+            psUSBDMAInst->ui32Pending &= ~(1 << ui32Channel);
+            psUSBDMAInst->ui32Complete |= (1 << ui32Channel);
+        }
+
+        //
+        // Check the next channel.
+        //
+        ui32DMAIntStatus >>= 1;
+
+        //
+        // Break if there are no more pending DMA interrupts.
+        //
+        if(ui32DMAIntStatus == 0)
+        {
+            break;
+        }
+    }
+}
+
+//*****************************************************************************
+//
+// USBLibDMAChannelEnable() for USB controllers that use uDMA.
+//
+//*****************************************************************************
+static void
+uDMAUSBChannelEnable(tUSBDMAInstance *psUSBDMAInst, uint32_t ui32Channel)
+{
+    uint32_t ui32IntEnabled;
+
+    //
+    // Save if the interrupt was enabled or not.
+    //
+    ui32IntEnabled = IntIsEnabled(psUSBDMAInst->ui32IntNum);
+
+    //
+    // Disable the USB interrupt if it was enabled.
+    //
+    if(ui32IntEnabled)
+    {
+        OS_INT_DISABLE(psUSBDMAInst->ui32IntNum);
+    }
+
+    //
+    // Mark this channel as pending and not complete.
+    //
+    psUSBDMAInst->ui32Pending |= (1 << (ui32Channel - 1));
+    psUSBDMAInst->ui32Complete &= ~(1 << (ui32Channel - 1));
+
+    //
+    // Enable DMA for the endpoint.
+    //
+    if(UDMAConfigIsRx(psUSBDMAInst->pui32Config[ui32Channel - 1]))
+    {
+        MAP_USBEndpointDMAEnable(psUSBDMAInst->ui32Base,
+                                 psUSBDMAInst->pui8Endpoint[ui32Channel - 1],
+                                 USB_EP_DEV_OUT | USB_EP_HOST_IN);
+    }
+    else
+    {
+        MAP_USBEndpointDMAEnable(psUSBDMAInst->ui32Base,
+                                 psUSBDMAInst->pui8Endpoint[ui32Channel - 1],
+                                 USB_EP_DEV_IN | USB_EP_HOST_OUT);
+    }
+
+    //
+    // Enable the DMA in the uDMA controller.
+    //
+    MAP_uDMAChannelEnable(ui32Channel - 1);
+
+    //
+    // Enable the USB interrupt if it was enabled before.
+    //
+    if(ui32IntEnabled)
+    {
+        OS_INT_ENABLE(psUSBDMAInst->ui32IntNum);
+    }
+}
+
+//*****************************************************************************
+//
+// USBLibDMAChannelEnable() for USB controllers with an integrated DMA
+// controller.
+//
+//*****************************************************************************
+static void
+iDMAUSBChannelEnable(tUSBDMAInstance *psUSBDMAInst, uint32_t ui32Channel)
+{
+    uint32_t ui32IntEnabled;
+
+    //
+    // Save if the interrupt was enabled or not.
+    //
+    ui32IntEnabled = IntIsEnabled(psUSBDMAInst->ui32IntNum);
+
+    //
+    // Disable the USB interrupt if it was enabled.
+    //
+    if(ui32IntEnabled)
+    {
+        OS_INT_DISABLE(psUSBDMAInst->ui32IntNum);
+    }
+
+    //
+    // Mark this channel as pending and not complete.
+    //
+    psUSBDMAInst->ui32Pending |= (1 << (ui32Channel - 1));
+    psUSBDMAInst->ui32Complete &= ~(1 << (ui32Channel - 1));
+
+    //
+    // Enable the interrupt for this DMA channel.
+    //
+    USBDMAChannelIntEnable(psUSBDMAInst->ui32Base, ui32Channel - 1);
+
+    //
+    // Enable the DMA channel.
+    //
+    USBDMAChannelEnable(psUSBDMAInst->ui32Base, ui32Channel - 1);
+
+    //
+    // Enable the USB interrupt if it was enabled before.
+    //
+    if(ui32IntEnabled)
+    {
+        OS_INT_ENABLE(psUSBDMAInst->ui32IntNum);
+    }
+}
+
+//*****************************************************************************
+//
+// USBLibDMAChannelDisable() for USB controllers that use uDMA.
+//
+//*****************************************************************************
+static void
+uDMAUSBChannelDisable(tUSBDMAInstance *psUSBDMAInst, uint32_t ui32Channel)
+{
+    //
+    // Disable DMA for the endpoint.
+    //
+    if(UDMAConfigIsRx(psUSBDMAInst->pui32Config[ui32Channel - 1]))
+    {
+        MAP_USBEndpointDMADisable(psUSBDMAInst->ui32Base,
+                                  psUSBDMAInst->pui8Endpoint[ui32Channel - 1],
+                                  USB_EP_DEV_OUT);
+    }
+    else
+    {
+        MAP_USBEndpointDMADisable(psUSBDMAInst->ui32Base,
+                                  psUSBDMAInst->pui8Endpoint[ui32Channel - 1],
+                                  USB_EP_DEV_IN);
+    }
+
+    //
+    // Disable the DMA channel in the uDMA controller.
+    //
+    MAP_uDMAChannelDisable(ui32Channel - 1);
+
+    //
+    // Clear out any pending or complete flag set for this DMA channel.
+    //
+    psUSBDMAInst->ui32Pending &= ~(1 << (ui32Channel - 1));
+    psUSBDMAInst->ui32Complete &= ~(1 << (ui32Channel - 1));
+}
+
+//*****************************************************************************
+//
+// USBLibDMAChannelDisable() for USB controllers with an integrated DMA
+// controller.
+//
+//*****************************************************************************
+static void
+iDMAUSBChannelDisable(tUSBDMAInstance *psUSBDMAInst, uint32_t ui32Channel)
+{
+    //
+    // Disable the DMA channel.
+    //
+    USBDMAChannelDisable(psUSBDMAInst->ui32Base, ui32Channel - 1);
+
+    //
+    // Disable the interrupt for this DMA channel.
+    //
+    USBDMAChannelIntDisable(psUSBDMAInst->ui32Base, ui32Channel - 1);
+
+    //
+    // Clear out any pending or complete flag set for this DMA channel.
+    //
+    psUSBDMAInst->ui32Pending &= ~(1 << (ui32Channel - 1));
+    psUSBDMAInst->ui32Complete &= ~(1 << (ui32Channel - 1));
+}
+
+//*****************************************************************************
+//
+// USBLibDMAChannelIntEnable() for USB controllers that use uDMA.
+//
+//*****************************************************************************
+static void
+uDMAUSBChannelIntEnable(tUSBDMAInstance *psUSBDMAInst, uint32_t ui32Channel)
+{
+    //
+    // There is no way to Enable channel interrupts when using uDMA.
+    //
+}
+
+//*****************************************************************************
+//
+// USBLibDMAChannelIntEnable() for USB controllers with an integrated DMA
+// controller.
+//
+//*****************************************************************************
+static void
+iDMAUSBChannelIntEnable(tUSBDMAInstance *psUSBDMAInst, uint32_t ui32Channel)
+{
+    //
+    // Enable the interrupt for this DMA channel.
+    //
+    USBDMAChannelIntEnable(psUSBDMAInst->ui32Base, ui32Channel - 1);
+}
+
+//*****************************************************************************
+//
+// USBLibDMAChannelIntDisable() for USB controllers that use uDMA.
+//
+//*****************************************************************************
+static void
+uDMAUSBChannelIntDisable(tUSBDMAInstance *psUSBDMAInst, uint32_t ui32Channel)
+{
+    //
+    // There is no way to Disable channel interrupts when using uDMA.
+    //
+}
+
+//*****************************************************************************
+//
+// USBLibDMAChannelIntDisable() for USB controllers with an integrated DMA
+// controller.
+//
+//*****************************************************************************
+static void
+iDMAUSBChannelIntDisable(tUSBDMAInstance *psUSBDMAInst, uint32_t ui32Channel)
+{
+    //
+    // Disable the interrupt for this DMA channel.
+    //
+    USBDMAChannelIntDisable(psUSBDMAInst->ui32Base, ui32Channel - 1);
+}
+
+//*****************************************************************************
+//
+// USBLibDMATransfer() for USB controllers that use the uDMA controller.
+//
+//*****************************************************************************
+static uint32_t
+uDMAUSBTransfer(tUSBDMAInstance *psUSBDMAInst, uint32_t ui32Channel,
+                void *pvBuffer, uint32_t ui32Size)
+{
+    void *pvFIFO;
+    uint32_t uluDMAChannel;
+    uint32_t ui32PacketCount;
+    uint32_t ui32TransferCount;
+
+    if((ui32Size < 64) || ((uint32_t)pvBuffer & 0x3))
+    {
+        return(0);
+    }
+
+    //
+    // Mark this channel as pending and not complete.
+    //
+    psUSBDMAInst->ui32Pending |= (1 << (ui32Channel - 1));
+    psUSBDMAInst->ui32Complete &= ~(1 << (ui32Channel - 1));
+
+    //
+    // Save the pointer to the data and the byte count.
+    //
+    psUSBDMAInst->ppui32Data[ui32Channel - 1] = pvBuffer;
+    psUSBDMAInst->pui32Count[ui32Channel - 1] = ui32Size;
+
+    //
+    // Need the address of the FIFO.
+    //
+    pvFIFO = (void *)USBFIFOAddrGet(psUSBDMAInst->ui32Base,
+                                psUSBDMAInst->pui8Endpoint[ui32Channel - 1]);
+
+    //
+    // Calculate the uDMA channel for this RX channel.
+    //
+    uluDMAChannel = UDMA_CHANNEL_USBEP1RX + ui32Channel - 1;
+
+    ui32TransferCount = ui32Size;
+
+    if((psUSBDMAInst->pui32Config[ui32Channel - 1] & UDMA_SIZE_32) ==
+       UDMA_SIZE_32)
+    {
+        ui32TransferCount >>= 2;
+    }
+    else if((psUSBDMAInst->pui32Config[ui32Channel - 1] & UDMA_SIZE_32) ==
+            UDMA_SIZE_32)
+    {
+        ui32TransferCount >>= 1;
+    }
+
+    //
+    // If source increment is none this is an RX transfer.
+    //
+    if(UDMAConfigIsRx(psUSBDMAInst->pui32Config[ui32Channel - 1]))
+    {
+        MAP_uDMAChannelTransferSet(uluDMAChannel, UDMA_MODE_BASIC, pvFIFO,
+                                   pvBuffer, ui32TransferCount);
+    }
+    else
+    {
+        MAP_uDMAChannelTransferSet(uluDMAChannel, UDMA_MODE_BASIC, pvBuffer,
+                                   pvFIFO, ui32TransferCount);
+    }
+
+    //
+    // Set the mode based on the size of the transfer.  More than one
+    // packet requires mode 1.
+    //
+    if(ui32Size > psUSBDMAInst->pui32MaxPacketSize[ui32Channel - 1])
+    {
+        //
+        // Calculate the number of packets required for this transfer.
+        //
+        ui32PacketCount = ((ui32Size /
+                           psUSBDMAInst->pui32MaxPacketSize[ui32Channel - 1]));
+
+        //
+        // Set the packet count so that the last packet does not generate
+        // another IN request.
+        //
+        USBEndpointPacketCountSet(psUSBDMAInst->ui32Base,
+                                  psUSBDMAInst->pui8Endpoint[ui32Channel - 1],
+                                  ui32PacketCount);
+
+        //
+        // Configure the USB endpoint in mode 1 for this DMA transfer.
+        //
+        USBEndpointDMAConfigSet(psUSBDMAInst->ui32Base,
+                                psUSBDMAInst->pui8Endpoint[ui32Channel - 1],
+                                psUSBDMAInst->pui32EPDMAMode1[ui32Channel - 1]);
+    }
+    else
+    {
+        //
+        // Configure the USB endpoint in mode 0 for this DMA transfer.
+        //
+        USBEndpointDMAConfigSet(psUSBDMAInst->ui32Base,
+                                psUSBDMAInst->pui8Endpoint[ui32Channel - 1],
+                                psUSBDMAInst->pui32EPDMAMode0[ui32Channel -1]);
+    }
+
+    //
+    // Enable the uDMA channel to start the transfer
+    //
+    uDMAUSBChannelEnable(psUSBDMAInst, ui32Channel);
+
+    return(ui32Size);
+}
+
+//*****************************************************************************
+//
+// USBLibDMATransfer() for USB controllers with an integrated DMA controller.
+//
+//*****************************************************************************
+static uint32_t
+iDMAUSBTransfer(tUSBDMAInstance *psUSBDMAInst, uint32_t ui32Channel,
+                void *pvBuffer, uint32_t ui32Size)
+{
+    uint32_t ui32PacketCount;
+
+    if((uint32_t)pvBuffer & 0x3)
+    {
+        return(0);
+    }
+
+    //
+    // Mark this channel as pending and not complete.
+    //
+    psUSBDMAInst->ui32Pending |= (1 << (ui32Channel - 1));
+    psUSBDMAInst->ui32Complete &= ~(1 << (ui32Channel - 1));
+
+    //
+    // Save the pointer to the data and the byte count.
+    //
+    psUSBDMAInst->ppui32Data[ui32Channel - 1] = pvBuffer;
+    psUSBDMAInst->pui32Count[ui32Channel - 1] = ui32Size;
+
+    //
+    // Set the address.
+    //
+    USBDMAChannelAddressSet(psUSBDMAInst->ui32Base, ui32Channel - 1, pvBuffer);
+
+    //
+    // Set the number of transfers.
+    //
+    USBDMAChannelCountSet(psUSBDMAInst->ui32Base, ui32Channel - 1, ui32Size);
+
+    //
+    // Set the mode based on the size of the transfer.  More than one
+    // packet requires mode 1.
+    //
+    if(ui32Size > psUSBDMAInst->pui32MaxPacketSize[ui32Channel - 1])
+    {
+        //
+        // Calculate the number of packets required for this transfer.
+        //
+        ui32PacketCount = ui32Size /
+                          psUSBDMAInst->pui32MaxPacketSize[ui32Channel - 1];
+
+        if(ui32Size % psUSBDMAInst->pui32MaxPacketSize[ui32Channel - 1])
+        {
+            ui32PacketCount += 1;
+        }
+
+        USBEndpointPacketCountSet(psUSBDMAInst->ui32Base,
+                                  psUSBDMAInst->pui8Endpoint[ui32Channel - 1],
+                                  ui32PacketCount);
+
+        //
+        // Configure the USB DMA controller for mode 1.
+        //
+        USBEndpointDMAConfigSet(psUSBDMAInst->ui32Base,
+                                psUSBDMAInst->pui8Endpoint[ui32Channel - 1],
+                                psUSBDMAInst->pui32EPDMAMode1[ui32Channel - 1]);
+
+        USBDMAChannelConfigSet(psUSBDMAInst->ui32Base, ui32Channel - 1,
+                               psUSBDMAInst->pui8Endpoint[ui32Channel - 1],
+                               psUSBDMAInst->pui32Config[ui32Channel - 1] |
+                               USB_DMA_CFG_MODE_1);
+
+        //
+        // Enable DMA on the endpoint.
+        //
+        if(psUSBDMAInst->pui32Config[ui32Channel - 1] & USB_DMA_CFG_DIR_TX)
+        {
+            //
+            // Make sure that DMA is enabled on the endpoint.
+            //
+            MAP_USBEndpointDMAEnable(
+                                psUSBDMAInst->ui32Base,
+                                psUSBDMAInst->pui8Endpoint[ui32Channel - 1],
+                                USB_EP_HOST_OUT);
+        }
+        else
+        {
+            //
+            // Make sure that DMA is enabled on the endpoint.
+            //
+            MAP_USBEndpointDMAEnable(
+                                   psUSBDMAInst->ui32Base,
+                                   psUSBDMAInst->pui8Endpoint[ui32Channel - 1],
+                                   USB_EP_HOST_IN);
+        }
+
+        //
+        // Enable the DMA channel.
+        //
+        USBDMAChannelEnable(psUSBDMAInst->ui32Base, ui32Channel - 1);
+    }
+    else
+    {
+        //
+        // Configure the USB DMA controller for mode 0.
+        //
+        USBEndpointDMAConfigSet(psUSBDMAInst->ui32Base,
+                                psUSBDMAInst->pui8Endpoint[ui32Channel - 1],
+                                psUSBDMAInst->pui32EPDMAMode0[ui32Channel -1]);
+
+        USBDMAChannelConfigSet(psUSBDMAInst->ui32Base, ui32Channel -1,
+                               psUSBDMAInst->pui8Endpoint[ui32Channel - 1],
+                               psUSBDMAInst->pui32Config[ui32Channel - 1] |
+                               USB_DMA_CFG_MODE_0);
+
+        //
+        // In mode 0 only enable DMA transfer for mode 0.
+        //
+        if(psUSBDMAInst->pui32Config[ui32Channel - 1] & USB_DMA_CFG_DIR_TX)
+        {
+            //
+            // Make sure that DMA is enabled on the endpoint.
+            //
+            MAP_USBEndpointDMAEnable(
+                                psUSBDMAInst->ui32Base,
+                                psUSBDMAInst->pui8Endpoint[ui32Channel - 1],
+                                USB_EP_HOST_OUT);
+            //
+            // Enable the DMA channel.
+            //
+            USBDMAChannelEnable(psUSBDMAInst->ui32Base, ui32Channel - 1);
+        }
+        else
+        {
+            //
+            // Make sure that DMA is disabled on the endpoint, it will
+            // be enabled when the endpoint interrupt occurs.
+            //
+            MAP_USBEndpointDMADisable(
+                                   psUSBDMAInst->ui32Base,
+                                   psUSBDMAInst->pui8Endpoint[ui32Channel - 1],
+                                   USB_EP_HOST_IN);
+
+        }
+    }
+
+    return(ui32Size);
+}
+
+//*****************************************************************************
+//
+// USBLibDMAChannelAllocate() for USB controllers that use uDMA for DMA.
+//
+//*****************************************************************************
+static uint32_t
+uDMAUSBChannelAllocate(tUSBDMAInstance *psUSBDMAInst, uint8_t ui8Endpoint,
+                       uint32_t ui32MaxPacketSize, uint32_t ui32Config)
+{
+    uint32_t ui32Channel;
+
+    //
+    // The DMA channels are organized in pairs on this controller and the
+    // transmit channels are 1, 3, and 5 while receive are 0, 2, and 4.
+    //
+    if(ui32Config & USB_DMA_EP_RX)
+    {
+        ui32Channel = 0;
+    }
+    else
+    {
+        ui32Channel = 1;
+    }
+
+    //
+    // Search for an available DMA channel to use.
+    //
+    for(; ui32Channel < USB_MAX_DMA_CHANNELS_0; ui32Channel += 2)
+    {
+        //
+        // If the current endpoint value is zero then this channel is
+        // available.
+        //
+        if(psUSBDMAInst->pui8Endpoint[ui32Channel] == 0)
+        {
+            //
+            // Save the endpoint for this DMA channel.
+            //
+            psUSBDMAInst->pui8Endpoint[ui32Channel] = ui8Endpoint;
+
+            //
+            // Save the maximum packet size for the endpoint.
+            //
+            psUSBDMAInst->pui32MaxPacketSize[ui32Channel] = ui32MaxPacketSize;
+
+            //
+            // Set the channel configuration based on the direction.
+            //
+            if(ui32Config & USB_DMA_EP_RX)
+            {
+                psUSBDMAInst->pui32Config[ui32Channel] =
+                        UDMA_SIZE_8 | UDMA_SRC_INC_NONE | UDMA_DST_INC_8 |
+                        UDMA_ARB_64;
+
+                //
+                // If in device mode and Isochronous.
+                //
+                if(((ui32Config & USB_DMA_EP_HOST) == 0) &&
+                   ((ui32Config & USB_DMA_EP_TYPE_M) == USB_DMA_EP_TYPE_ISOC))
+                {
+                    //
+                    // USB_EP_AUTO_REQUEST is required for device
+                    // Isochronous endpoints.
+                    //
+                    psUSBDMAInst->pui32EPDMAMode0[ui32Channel] =
+                                                    USB_EP_DMA_MODE_0 |
+                                                    USB_EP_AUTO_REQUEST |
+                                                    USB_EP_HOST_IN;
+                }
+                else
+                {
+                    psUSBDMAInst->pui32EPDMAMode0[ui32Channel] =
+                                                    USB_EP_DMA_MODE_0 |
+                                                    USB_EP_AUTO_CLEAR |
+                                                    USB_EP_HOST_IN;
+                }
+
+                //
+                // Do not set auto request in device mode unless it is an
+                // isochronous endpoint.
+                //
+                if(((ui32Config & USB_DMA_EP_HOST) == 0) &&
+                   ((ui32Config & USB_DMA_EP_TYPE_M) != USB_DMA_EP_TYPE_ISOC))
+                {
+                    psUSBDMAInst->pui32EPDMAMode1[ui32Channel] =
+                                                USB_EP_DMA_MODE_1 |
+                                                USB_EP_HOST_IN |
+                                                USB_EP_AUTO_CLEAR;
+                }
+                else
+                {
+                    psUSBDMAInst->pui32EPDMAMode1[ui32Channel] =
+                                                USB_EP_DMA_MODE_1 |
+                                                USB_EP_HOST_IN |
+                                                USB_EP_AUTO_REQUEST |
+                                                USB_EP_AUTO_CLEAR;
+                }
+            }
+            else
+            {
+                psUSBDMAInst->pui32Config[ui32Channel] =
+                        UDMA_SIZE_8 | UDMA_SRC_INC_8 | UDMA_DST_INC_NONE |
+                        UDMA_ARB_64;
+
+                psUSBDMAInst->pui32EPDMAMode0[ui32Channel] = USB_EP_DMA_MODE_0 |
+                                                             USB_EP_HOST_OUT;
+                psUSBDMAInst->pui32EPDMAMode1[ui32Channel] = USB_EP_DMA_MODE_1 |
+                                                             USB_EP_HOST_OUT |
+                                                             USB_EP_AUTO_SET;
+            }
+
+            //
+            // Map the uDMA channel to the given endpoint.
+            //
+            MAP_USBEndpointDMAChannel(psUSBDMAInst->ui32Base, ui8Endpoint,
+                                      ui32Channel);
+
+            //
+            // Clear out the attributes on this channel.
+            //
+            MAP_uDMAChannelAttributeDisable(ui32Channel, UDMA_ATTR_ALL);
+
+            //
+            // Configure the uDMA channel for the pipe
+            //
+            MAP_uDMAChannelControlSet(ui32Channel,
+                                      psUSBDMAInst->pui32Config[ui32Channel]);
+
+            if(ui32Config & USB_DMA_EP_RX)
+            {
+                MAP_USBEndpointDMADisable(psUSBDMAInst->ui32Base, ui8Endpoint,
+                                          USB_EP_DEV_OUT);
+            }
+            else
+            {
+                MAP_USBEndpointDMADisable(psUSBDMAInst->ui32Base, ui8Endpoint,
+                                          USB_EP_DEV_IN);
+            }
+
+            //
+            // Outside of this function all channels are 1 based as
+            // zero is not a valid channel.
+            //
+            return(ui32Channel + 1);
+        }
+    }
+    return(0);
+}
+
+//*****************************************************************************
+//
+// USBLibDMAChannelAllocate() for USB controllers with an integrated DMA
+// controller.
+//
+//*****************************************************************************
+static uint32_t
+iDMAUSBChannelAllocate(tUSBDMAInstance *psUSBDMAInst, uint8_t ui8Endpoint,
+                       uint32_t ui32MaxPacketSize, uint32_t ui32Config)
+{
+    uint32_t ui32Channel;
+
+    //
+    // Search for an available DMA channel to use.
+    //
+    for(ui32Channel = 0; ui32Channel < USB_MAX_DMA_CHANNELS_0; ui32Channel++)
+    {
+        //
+        // If the current endpoint value is zero then this channel is
+        // available.
+        //
+        if(psUSBDMAInst->pui8Endpoint[ui32Channel] == 0)
+        {
+            //
+            // Clear out the attributes on this channel.
+            //
+            USBDMAChannelDisable(psUSBDMAInst->ui32Base, ui32Channel);
+
+            //
+            // Save the endpoint for this DMA channel.
+            //
+            psUSBDMAInst->pui8Endpoint[ui32Channel] = ui8Endpoint;
+
+            //
+            // Save the maximum packet size for the endpoint.
+            //
+            psUSBDMAInst->pui32MaxPacketSize[ui32Channel] = ui32MaxPacketSize;
+
+            //
+            // Assign the endpoint to the channel and set the direction.
+            //
+            if(ui32Config & USB_DMA_EP_RX)
+            {
+                psUSBDMAInst->pui32Config[ui32Channel] =
+                                        USB_DMA_CFG_DIR_RX |
+                                        USB_DMA_CFG_BURST_NONE |
+                                        USB_DMA_CFG_INT_EN;
+
+                //
+                // If in device mode and Isochronous.
+                //
+                if(((ui32Config & USB_DMA_EP_HOST) == 0) &&
+                   ((ui32Config & USB_DMA_EP_TYPE_M) == USB_DMA_EP_TYPE_ISOC))
+                {
+                    //
+                    // USB_EP_AUTO_REQUEST is required for device
+                    // Isochronous endpoints.
+                    //
+                    psUSBDMAInst->pui32EPDMAMode0[ui32Channel] =
+                                                    USB_EP_DMA_MODE_0 |
+                                                    USB_EP_AUTO_REQUEST |
+                                                    USB_EP_HOST_IN;
+                }
+                else
+                {
+                    psUSBDMAInst->pui32EPDMAMode0[ui32Channel] =
+                                                    USB_EP_DMA_MODE_0 |
+                                                    USB_EP_AUTO_CLEAR |
+                                                    USB_EP_HOST_IN;
+                }
+
+                //
+                // Do not set auto request in device mode unless it is an
+                // isochronous endpoint.
+                //
+                if(((ui32Config & USB_DMA_EP_HOST) == 0) &&
+                   ((ui32Config & USB_DMA_EP_TYPE_M) != USB_DMA_EP_TYPE_ISOC))
+                {
+                    psUSBDMAInst->pui32EPDMAMode1[ui32Channel] =
+                                                USB_EP_DMA_MODE_1 |
+                                                USB_EP_HOST_IN |
+                                                USB_EP_AUTO_CLEAR;
+                }
+                else
+                {
+                    psUSBDMAInst->pui32EPDMAMode1[ui32Channel] =
+                                                USB_EP_DMA_MODE_1 |
+                                                USB_EP_HOST_IN |
+                                                USB_EP_AUTO_REQUEST |
+                                                USB_EP_AUTO_CLEAR;
+                }
+            }
+            else
+            {
+                psUSBDMAInst->pui32Config[ui32Channel] =
+                                                USB_DMA_CFG_DIR_TX |
+                                                USB_DMA_CFG_BURST_NONE |
+                                                USB_DMA_CFG_INT_EN;
+
+                psUSBDMAInst->pui32EPDMAMode0[ui32Channel] =
+                                                USB_EP_DMA_MODE_0 |
+                                                USB_EP_HOST_OUT;
+                psUSBDMAInst->pui32EPDMAMode1[ui32Channel] =
+                                                USB_EP_DMA_MODE_1 |
+                                                USB_EP_HOST_OUT |
+                                                USB_EP_AUTO_SET;
+            }
+
+            //
+            // Outside of this function all channels are 1 based as
+            // zero is not a valid channel.
+            //
+            return(ui32Channel + 1);
+        }
+    }
+    return(0);
+}
+
+//*****************************************************************************
+//
+// USBLibDMAChannelRelease() for USB controllers that use uDMA for DMA.
+//
+//*****************************************************************************
+static void
+uDMAUSBChannelRelease(tUSBDMAInstance *psUSBDMAInst, uint8_t ui32Channel)
+{
+    ASSERT(ui32Channel < USB_MAX_DMA_CHANNELS_0);
+
+    //
+    // Clear out the attributes on this channel.
+    //
+    MAP_uDMAChannelAttributeDisable(ui32Channel - 1, UDMA_ATTR_ALL);
+
+    if(psUSBDMAInst->pui8Endpoint[ui32Channel] & USB_DMA_EP_RX)
+    {
+        MAP_USBEndpointDMADisable(psUSBDMAInst->ui32Base,
+                (psUSBDMAInst->pui8Endpoint[ui32Channel] & ~USB_DMA_EP_RX),
+                USB_EP_DEV_OUT);
+    }
+    else
+    {
+        MAP_USBEndpointDMADisable(psUSBDMAInst->ui32Base,
+                (psUSBDMAInst->pui8Endpoint[ui32Channel] & ~USB_DMA_EP_RX),
+                USB_EP_DEV_IN);
+    }
+
+    //
+    // Clear out the state for this endpoint.
+    //
+    psUSBDMAInst->pui8Endpoint[ui32Channel - 1] = 0;
+    psUSBDMAInst->pui32Config[ui32Channel - 1] = 0;
+    psUSBDMAInst->ui32Pending &= ~(1 << (ui32Channel - 1));
+    psUSBDMAInst->ui32Complete &= ~(1 << (ui32Channel - 1));
+    psUSBDMAInst->pui32MaxPacketSize[ui32Channel - 1] = 0;
+}
+
+//*****************************************************************************
+//
+// DMAChannelRelease() for USB controllers with an integrated DMA controller.
+//
+//*****************************************************************************
+static void
+iDMAUSBChannelRelease(tUSBDMAInstance *psUSBDMAInst, uint8_t ui32Channel)
+{
+    ASSERT(ui32Channel < USB_MAX_DMA_CHANNELS);
+
+    //
+    // Clear out the attributes on this channel.
+    //
+    USBDMAChannelDisable(psUSBDMAInst->ui32Base, ui32Channel);
+
+    //
+    // Clear out the state for this endpoint.
+    //
+    psUSBDMAInst->pui8Endpoint[ui32Channel - 1] = 0;
+    psUSBDMAInst->pui32Config[ui32Channel - 1] = 0;
+    psUSBDMAInst->ui32Pending &= ~(1 << (ui32Channel - 1));
+    psUSBDMAInst->ui32Complete &= ~(1 << (ui32Channel - 1));
+    psUSBDMAInst->pui32MaxPacketSize[ui32Channel - 1] = 0;
+}
+
+//*****************************************************************************
+//
+// USBLibDMAUnitSizeSet() for USB controllers that use uDMA for DMA.
+//
+//*****************************************************************************
+static void
+uDMAUSBUnitSizeSet(tUSBDMAInstance *psUSBDMAInst, uint32_t ui32Channel,
+                   uint32_t ui32BitSize)
+{
+    uint32_t ui32Value;
+
+    ASSERT((ui32BitSize == 8) || (ui32BitSize == 16) || (ui32BitSize == 32));
+
+    ASSERT(ui32Channel < USB_MAX_DMA_CHANNELS_0);
+
+    if(ui32BitSize == 8)
+    {
+        ui32Value = UDMA_SIZE_8;
+
+        if(UDMAConfigIsRx(psUSBDMAInst->pui32Config[ui32Channel - 1]))
+        {
+            //
+            // Receive increments destination and not source.
+            //
+            ui32Value |= UDMA_DST_INC_8 | UDMA_SRC_INC_NONE;
+        }
+        else
+        {
+            //
+            // Transmit increments source and not destination.
+            //
+            ui32Value |= UDMA_SRC_INC_8 | UDMA_DST_INC_NONE;
+        }
+    }
+    else if(ui32BitSize == 16)
+    {
+        ui32Value = UDMA_SIZE_16;
+
+        if(UDMAConfigIsRx(psUSBDMAInst->pui32Config[ui32Channel - 1]))
+        {
+            //
+            // Receive increments destination and not source.
+            //
+            ui32Value |= UDMA_DST_INC_16 | UDMA_SRC_INC_NONE;
+        }
+        else
+        {
+            //
+            // Transmit increments source and not destination.
+            //
+            ui32Value |= UDMA_SRC_INC_16 | UDMA_DST_INC_NONE;
+        }
+    }
+    else
+    {
+        ui32Value = UDMA_SIZE_32;
+
+        if(UDMAConfigIsRx(psUSBDMAInst->pui32Config[ui32Channel - 1]))
+        {
+            //
+            // Receive increments destination and not source.
+            //
+            ui32Value |= (UDMA_DST_INC_32 | UDMA_SRC_INC_NONE);
+        }
+        else
+        {
+            //
+            // Transmit increments source and not destination.
+            //
+            ui32Value |= (UDMA_SRC_INC_32 | UDMA_DST_INC_NONE);
+        }
+    }
+
+    //
+    // Keep the current arbitration size and or in the size.
+    //
+    psUSBDMAInst->pui32Config[ui32Channel - 1] &= 0x00ffffff;
+    psUSBDMAInst->pui32Config[ui32Channel - 1] |= ui32Value;
+    MAP_uDMAChannelControlSet(ui32Channel - 1,
+                              psUSBDMAInst->pui32Config[ui32Channel - 1]);
+}
+
+//*****************************************************************************
+//
+// USBLibDMAUnitSizeSet() for USB controllers that have an integrated DMA
+// controller.
+//
+//*****************************************************************************
+static void
+iDMAUSBUnitSizeSet(tUSBDMAInstance *psUSBDMAInst, uint32_t ui32Channel,
+                   uint32_t ui32BitSize)
+{
+}
+
+//*****************************************************************************
+//
+// USBLibDMAArbSizeSet() for USB controllers that use uDMA for DMA.
+//
+//*****************************************************************************
+static void
+uDMAUSBArbSizeSet(tUSBDMAInstance *psUSBDMAInst, uint32_t ui32Channel,
+                  uint32_t ui32ArbSize)
+{
+    uint32_t ui32Value;
+
+    ASSERT(ui32Channel < USB_MAX_DMA_CHANNELS_0);
+
+    //
+    // Get the arbitration size value.
+    //
+    if(ui32ArbSize == 2)
+    {
+        ui32Value = UDMA_ARB_2;
+    }
+    else if(ui32ArbSize == 4)
+    {
+        ui32Value = UDMA_ARB_4;
+    }
+    else if(ui32ArbSize == 8)
+    {
+        ui32Value = UDMA_ARB_8;
+    }
+    else if(ui32ArbSize == 16)
+    {
+        ui32Value = UDMA_ARB_16;
+    }
+    else if(ui32ArbSize == 32)
+    {
+        ui32Value = UDMA_ARB_32;
+    }
+    else if(ui32ArbSize == 64)
+    {
+        ui32Value = UDMA_ARB_64;
+    }
+    else if(ui32ArbSize == 128)
+    {
+        ui32Value = UDMA_ARB_128;
+    }
+    else if(ui32ArbSize == 256)
+    {
+        ui32Value = UDMA_ARB_256;
+    }
+    else
+    {
+        //
+        // Default to arbitration size of 1.
+        //
+        ui32Value = UDMA_ARB_1;
+    }
+
+    //
+    // Keep the current size and or in the new arbitration size.
+    //
+    psUSBDMAInst->pui32Config[ui32Channel - 1] &= 0xff000000;
+    psUSBDMAInst->pui32Config[ui32Channel - 1] |= ui32Value;
+
+    //
+    // Set the uDMA channel control, remember its channel starts at 0 and
+    // not 1.
+    //
+    MAP_uDMAChannelControlSet(ui32Channel - 1,
+                              psUSBDMAInst->pui32Config[ui32Channel - 1]);
+}
+
+//*****************************************************************************
+//
+// USBLibDMAArbSizeSet() for USB controllers that have an integrated DMA
+// controller.
+//
+//*****************************************************************************
+static void
+iDMAUSBArbSizeSet(tUSBDMAInstance *psUSBDMAInst, uint32_t ui32Channel,
+                  uint32_t ui32ArbSize)
+{
+}
+
+//*****************************************************************************
+//
+// USBLibDMAStatus() for USB controllers that use uDMA for DMA or have an
+// integrated DMA controller.
+//
+//*****************************************************************************
+static uint32_t
+DMAUSBStatus(tUSBDMAInstance *psUSBDMAInst)
+{
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! This function is used to return the current DMA pointer for a given
+//! DMA channel.
+//!
+//! \param psUSBDMAInst is a generic instance pointer that can be used to
+//! distinguish between different hardware instances.
+//! \param ui32Channel is the DMA channel number for this request.
+//!
+//! This function returns the address that is in use by the DMA channel passed
+//! in via the \e ui32Channel parameter.  This is not the real-time pointer,
+//! but the starting address of the DMA transfer for this DMA channel.
+//!
+//! \return The current DMA address for the given DMA channel.
+//
+//*****************************************************************************
+void *
+USBLibDMAAddrGet(tUSBDMAInstance *psUSBDMAInst, uint32_t ui32Channel)
+{
+    return(psUSBDMAInst->ppui32Data[ui32Channel - 1]);
+}
+
+//*****************************************************************************
+//
+//! This function is used to return the current DMA transfer size for a given
+//! DMA channel.
+//!
+//! \param psUSBDMAInst is a generic instance pointer that can be used to
+//! distinguish between different hardware instances.
+//! \param ui32Channel is the DMA channel number for this request.
+//!
+//! This function returns the DMA transfer size that is in use by the DMA
+//! channel passed in via the \e ui32Channel parameter.
+//!
+//! \return The current DMA transfer size for the given DMA channel.
+//
+//*****************************************************************************
+uint32_t
+USBLibDMASizeGet(tUSBDMAInstance *psUSBDMAInst, uint32_t ui32Channel)
+{
+    return(psUSBDMAInst->pui32Count[ui32Channel - 1]);
+}
+
+//*****************************************************************************
+//
+//! This function is used to initialize the DMA interface for a USB instance.
+//!
+//! \param ui32Index is the index of the USB controller for this instance.
+//!
+//! This function performs any initialization and configuration of the DMA
+//! portions of the USB controller.  This function returns a pointer that
+//! is used with the remaining USBLibDMA APIs or the function returns zero
+//! if the requested controller cannot support DMA.  If this function is called
+//! when already initialized it will not reinitialize the DMA controller and
+//! will instead return the previously initialized DMA instance.
+//!
+//! \return A pointer to use with USBLibDMA APIs.
+//
+//*****************************************************************************
+tUSBDMAInstance *
+USBLibDMAInit(uint32_t ui32Index)
+{
+    uint32_t ui32Channel;
+
+    ASSERT(ui32Index == 0);
+
+    //
+    // Make sure that the DMA has not already been initialized.
+    //
+    if(g_psUSBDMAInst[0].ui32Base == USB0_BASE)
+    {
+        return(&g_psUSBDMAInst[0]);
+    }
+
+    //
+    // Save the base address of the USB controller.
+    //
+    g_psUSBDMAInst[0].ui32Base = USB0_BASE;
+
+    //
+    // Save the interrupt number for the USB controller.
+    //
+    g_psUSBDMAInst[0].ui32IntNum = INT_USB0_TM4C123;
+
+    //
+    // Initialize the function pointers.
+    //
+    g_psUSBDMAInst[0].pfnArbSizeSet = uDMAUSBArbSizeSet;
+    g_psUSBDMAInst[0].pfnChannelAllocate = uDMAUSBChannelAllocate;
+    g_psUSBDMAInst[0].pfnChannelDisable = uDMAUSBChannelDisable;
+    g_psUSBDMAInst[0].pfnChannelEnable = uDMAUSBChannelEnable;
+    g_psUSBDMAInst[0].pfnChannelIntEnable = uDMAUSBChannelIntEnable;
+    g_psUSBDMAInst[0].pfnChannelIntDisable = uDMAUSBChannelIntDisable;
+    g_psUSBDMAInst[0].pfnChannelRelease = uDMAUSBChannelRelease;
+    g_psUSBDMAInst[0].pfnChannelStatus = uDMAUSBChannelStatus;
+    g_psUSBDMAInst[0].pfnIntHandler = DMAUSBIntHandler;
+    g_psUSBDMAInst[0].pfnIntStatus = uDMAUSBIntStatus;
+    g_psUSBDMAInst[0].pfnIntStatusClear = DMAUSBIntStatusClear;
+    g_psUSBDMAInst[0].pfnStatus = DMAUSBStatus;
+    g_psUSBDMAInst[0].pfnTransfer = uDMAUSBTransfer;
+    g_psUSBDMAInst[0].pfnUnitSizeSet = uDMAUSBUnitSizeSet;
+
+    //
+    // These devices have a different USB interrupt number.
+    //
+    if(CLASS_IS_TM4C129)
+    {
+        g_psUSBDMAInst[0].ui32IntNum = INT_USB0_TM4C129;
+    }
+
+    //
+    // Initialize the function pointers for the integrated USB DMA controller.
+    //
+    if(USBControllerVersion(g_psUSBDMAInst[0].ui32Base) == USB_CONTROLLER_VER_1)
+    {
+        g_psUSBDMAInst[0].pfnArbSizeSet = iDMAUSBArbSizeSet;
+        g_psUSBDMAInst[0].pfnChannelAllocate = iDMAUSBChannelAllocate;
+        g_psUSBDMAInst[0].pfnChannelStatus = iDMAUSBChannelStatus;
+        g_psUSBDMAInst[0].pfnIntStatus = iDMAUSBIntStatus;
+        g_psUSBDMAInst[0].pfnChannelIntEnable = iDMAUSBChannelIntEnable;
+        g_psUSBDMAInst[0].pfnChannelIntDisable = iDMAUSBChannelIntDisable;
+        g_psUSBDMAInst[0].pfnTransfer = iDMAUSBTransfer;
+        g_psUSBDMAInst[0].pfnChannelRelease = iDMAUSBChannelRelease;
+        g_psUSBDMAInst[0].pfnChannelEnable = iDMAUSBChannelEnable;
+        g_psUSBDMAInst[0].pfnChannelDisable = iDMAUSBChannelDisable;
+        g_psUSBDMAInst[0].pfnUnitSizeSet = iDMAUSBUnitSizeSet;
+    }
+
+    //
+    // Clear out the endpoint and the current configuration.
+    //
+    for(ui32Channel = 0; ui32Channel < USB_MAX_DMA_CHANNELS; ui32Channel++)
+    {
+        g_psUSBDMAInst[0].pui8Endpoint[ui32Channel] = 0;
+        g_psUSBDMAInst[0].pui32Config[ui32Channel] = 0;
+        g_psUSBDMAInst[0].ui32Pending = 0;
+        g_psUSBDMAInst[0].ui32Complete = 0;
+    }
+    return(&g_psUSBDMAInst[0]);
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
diff --git a/bsp/tm4c129x/libraries/usblib/usbhid.h b/bsp/tm4c129x/libraries/usblib/usbhid.h
new file mode 100755
index 0000000..d491d16
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/usbhid.h
@@ -0,0 +1,667 @@
+//*****************************************************************************
+//
+// usbhid.h - Definitions used by HID class devices and hosts.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#ifndef __USBHID_H__
+#define __USBHID_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+//*****************************************************************************
+//
+//! \addtogroup hid_device_class_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// HID Interface descriptor Subclasses.
+//
+//*****************************************************************************
+#define USB_HID_SCLASS_NONE     0x00
+#define USB_HID_SCLASS_BOOT     0x01
+
+//*****************************************************************************
+//
+// USB Interface descriptor HID protocols.
+//
+//*****************************************************************************
+#define USB_HID_PROTOCOL_NONE   0
+#define USB_HID_PROTOCOL_KEYB   1
+#define USB_HID_PROTOCOL_MOUSE  2
+
+//*****************************************************************************
+//
+// HID Class descriptor types.
+//
+//*****************************************************************************
+#define USB_HID_DTYPE_HID       0x21
+#define USB_HID_DTYPE_REPORT    0x22
+#define USB_HID_DTYPE_PHYSICAL  0x23
+
+//*****************************************************************************
+//
+// HID USB requests.
+//
+//*****************************************************************************
+#define USBREQ_GET_REPORT       0x01
+#define USBREQ_GET_IDLE         0x02
+#define USBREQ_GET_PROTOCOL     0x03
+#define USBREQ_SET_REPORT       0x09
+#define USBREQ_SET_IDLE         0x0a
+#define USBREQ_SET_PROTOCOL     0x0b
+
+//*****************************************************************************
+//
+// GET_REPORT or SET_REPORT Definitions.
+//
+//*****************************************************************************
+#define USB_HID_REPORT_IN       0x01
+#define USB_HID_REPORT_OUTPUT   0x02
+#define USB_HID_REPORT_FEATURE  0x03
+
+//*****************************************************************************
+//
+// GET_PROTOCOL or SET_PROTOCOL Definitions.
+//
+//*****************************************************************************
+#define USB_HID_PROTOCOL_BOOT   0
+#define USB_HID_PROTOCOL_REPORT 1
+
+//*****************************************************************************
+//
+// Report Values used with the Report macros.
+//
+//*****************************************************************************
+#define USB_HID_GENERIC_DESKTOP 0x01
+#define USB_HID_BUTTONS         0x09
+#define USB_HID_X               0x30
+#define USB_HID_Y               0x31
+#define USB_HID_Z               0x32
+#define USB_HID_RX              0x33
+#define USB_HID_RY              0x34
+#define USB_HID_RZ              0x35
+
+#define USB_HID_POINTER         0x01
+#define USB_HID_MOUSE           0x02
+#define USB_HID_JOYSTICK        0x04
+#define USB_HID_GAME_PAD        0x05
+#define USB_HID_KEYBOARD        0x06
+
+#define USB_HID_PHYSICAL        0x00
+#define USB_HID_APPLICATION     0x01
+#define USB_HID_LOGICAL         0x02
+
+#define USB_HID_USAGE_POINTER   0x0109
+#define USB_HID_USAGE_BUTTONS   0x0509
+#define USB_HID_USAGE_LEDS      0x0508
+#define USB_HID_USAGE_KEYCODES  0x0507
+
+//*****************************************************************************
+//
+// HID mouse button definitions as used in the first byte of the output report
+// used in the BIOS mouse protocol.
+//
+//*****************************************************************************
+#define HID_MOUSE_BUTTON_1      0x01
+#define HID_MOUSE_BUTTON_2      0x02
+#define HID_MOUSE_BUTTON_3      0x04
+
+//*****************************************************************************
+//
+// HID Keyboard LED definitions as used in the first byte of the output report
+// used in the BIOS keyboard protocol.
+//
+//*****************************************************************************
+#define HID_KEYB_NUM_LOCK       0x01
+#define HID_KEYB_CAPS_LOCK      0x02
+#define HID_KEYB_SCROLL_LOCK    0x04
+#define HID_KEYB_COMPOSE        0x08
+#define HID_KEYB_KANA           0x10
+
+//*****************************************************************************
+//
+// HID Keyboard key modifiers as provided in the first byte of the input report
+// used in the BIOS keyboard protocol.
+//
+//*****************************************************************************
+#define HID_KEYB_LEFT_CTRL      0x01
+#define HID_KEYB_LEFT_SHIFT     0x02
+#define HID_KEYB_LEFT_ALT       0x04
+#define HID_KEYB_LEFT_GUI       0x08
+#define HID_KEYB_RIGHT_CTRL     0x10
+#define HID_KEYB_RIGHT_SHIFT    0x20
+#define HID_KEYB_RIGHT_ALT      0x40
+#define HID_KEYB_RIGHT_GUI      0x80
+
+//*****************************************************************************
+//
+// A subset of the HID keyboard usage IDs.
+//
+//*****************************************************************************
+#define HID_KEYB_USAGE_RESERVED 0x00
+#define HID_KEYB_USAGE_ROLLOVER 0x01
+#define HID_KEYB_USAGE_A        0x04
+#define HID_KEYB_USAGE_B        0x05
+#define HID_KEYB_USAGE_C        0x06
+#define HID_KEYB_USAGE_D        0x07
+#define HID_KEYB_USAGE_E        0x08
+#define HID_KEYB_USAGE_F        0x09
+#define HID_KEYB_USAGE_G        0x0A
+#define HID_KEYB_USAGE_H        0x0B
+#define HID_KEYB_USAGE_I        0x0C
+#define HID_KEYB_USAGE_J        0x0D
+#define HID_KEYB_USAGE_K        0x0E
+#define HID_KEYB_USAGE_L        0x0F
+#define HID_KEYB_USAGE_M        0x10
+#define HID_KEYB_USAGE_N        0x11
+#define HID_KEYB_USAGE_O        0x12
+#define HID_KEYB_USAGE_P        0x13
+#define HID_KEYB_USAGE_Q        0x14
+#define HID_KEYB_USAGE_R        0x15
+#define HID_KEYB_USAGE_S        0x16
+#define HID_KEYB_USAGE_T        0x17
+#define HID_KEYB_USAGE_U        0x18
+#define HID_KEYB_USAGE_V        0x19
+#define HID_KEYB_USAGE_W        0x1A
+#define HID_KEYB_USAGE_X        0x1B
+#define HID_KEYB_USAGE_Y        0x1C
+#define HID_KEYB_USAGE_Z        0x1D
+#define HID_KEYB_USAGE_1        0x1E
+#define HID_KEYB_USAGE_2        0x1F
+#define HID_KEYB_USAGE_3        0x20
+#define HID_KEYB_USAGE_4        0x21
+#define HID_KEYB_USAGE_5        0x22
+#define HID_KEYB_USAGE_6        0x23
+#define HID_KEYB_USAGE_7        0x24
+#define HID_KEYB_USAGE_8        0x25
+#define HID_KEYB_USAGE_9        0x26
+#define HID_KEYB_USAGE_0        0x27
+#define HID_KEYB_USAGE_ENTER    0x28
+#define HID_KEYB_USAGE_ESCAPE   0x29
+#define HID_KEYB_USAGE_BACKSPACE \
+                                0x2A
+#define HID_KEYB_USAGE_TAB      0x2B
+#define HID_KEYB_USAGE_SPACE    0x2C
+#define HID_KEYB_USAGE_MINUS    0x2D
+#define HID_KEYB_USAGE_EQUAL    0x2E
+#define HID_KEYB_USAGE_LBRACKET 0x2F
+#define HID_KEYB_USAGE_RBRACKET 0x30
+#define HID_KEYB_USAGE_BSLASH   0x31
+#define HID_KEYB_USAGE_SEMICOLON \
+                                0x33
+#define HID_KEYB_USAGE_FQUOTE   0x34
+#define HID_KEYB_USAGE_BQUOTE   0x35
+#define HID_KEYB_USAGE_COMMA    0x36
+#define HID_KEYB_USAGE_PERIOD   0x37
+#define HID_KEYB_USAGE_FSLASH   0x38
+#define HID_KEYB_USAGE_CAPSLOCK 0x39
+#define HID_KEYB_USAGE_F1       0x3A
+#define HID_KEYB_USAGE_F2       0x3B
+#define HID_KEYB_USAGE_F3       0x3C
+#define HID_KEYB_USAGE_F4       0x3D
+#define HID_KEYB_USAGE_F5       0x3E
+#define HID_KEYB_USAGE_F6       0x3F
+#define HID_KEYB_USAGE_F7       0x40
+#define HID_KEYB_USAGE_F8       0x41
+#define HID_KEYB_USAGE_F9       0x42
+#define HID_KEYB_USAGE_F10      0x43
+#define HID_KEYB_USAGE_F11      0x44
+#define HID_KEYB_USAGE_F12      0x45
+#define HID_KEYB_USAGE_SCROLLOCK   \
+                                0x47
+#define HID_KEYB_USAGE_PAGE_UP  0x4B
+#define HID_KEYB_USAGE_PAGE_DOWN   \
+                                0x4E
+#define HID_KEYB_USAGE_RIGHT_ARROW \
+                                0x4F
+#define HID_KEYB_USAGE_LEFT_ARROW \
+                                0x50
+#define HID_KEYB_USAGE_DOWN_ARROW \
+                                0x51
+#define HID_KEYB_USAGE_UP_ARROW 0x52
+#define HID_KEYB_USAGE_NUMLOCK  0x53
+#define HID_KEYB_USAGE_KEYPAD_SLASH \
+                                0x54
+#define HID_KEYB_USAGE_KEYPAD_STAR \
+                                0x55
+#define HID_KEYB_USAGE_KEYPAD_MINUS \
+                                0x56
+#define HID_KEYB_USAGE_KEYPAD_PLUS \
+                                0x57
+#define HID_KEYB_USAGE_KEPAD_ENTER \
+                                0x58
+#define HID_KEYB_USAGE_KEYPAD_1 0x59
+#define HID_KEYB_USAGE_KEYPAD_2 0x5A
+#define HID_KEYB_USAGE_KEYPAD_3 0x5B
+#define HID_KEYB_USAGE_KEYPAD_4 0x5C
+#define HID_KEYB_USAGE_KEYPAD_5 0x5D
+#define HID_KEYB_USAGE_KEYPAD_6 0x5E
+#define HID_KEYB_USAGE_KEYPAD_7 0x5F
+#define HID_KEYB_USAGE_KEYPAD_8 0x60
+#define HID_KEYB_USAGE_KEYPAD_9 0x61
+#define HID_KEYB_USAGE_KEYPAD_0 0x62
+#define HID_KEYB_USAGE_KEPAD_PERIOD \
+                                0x63
+
+//*****************************************************************************
+//
+// HID descriptor country codes (most of these are described as "countries" in
+// the HID specification even though they are really languages).
+//
+//*****************************************************************************
+#define USB_HID_COUNTRY_NONE    0x00
+#define USB_HID_COUNTRY_ARABIC  0x01
+#define USB_HID_COUNTRY_BELGIAN 0x02
+#define USB_HID_COUNTRY_CANADA_BI \
+                                0x03
+#define USB_HID_COUNTRY_CANADA_FR \
+                                0x04
+#define USB_HID_COUNTRY_CZECH_REPUBLIC \
+                                0x05
+#define USB_HID_COUNTRY_DANISH  0x06
+#define USB_HID_COUNTRY_FINNISH 0x07
+#define USB_HID_COUNTRY_FRENCH  0x08
+#define USB_HID_COUNTRY_GERMAN  0x09
+#define USB_HID_COUNTRY_GREEK   0x0A
+#define USB_HID_COUNTRY_HEBREW  0x0B
+#define USB_HID_COUNTRY_HUNGARY 0x0C
+#define USB_HID_COUNTRY_INTERNATIONAL_ISO \
+                                0x0D
+#define USB_HID_COUNTRY_ITALIAN 0x0E
+#define USB_HID_COUNTRY_JAPAN_KATAKANA \
+                                0x0F
+#define USB_HID_COUNTRY_KOREAN  0x10
+#define USB_HID_COUNTRY_LATIN_AMERICAN \
+                                0x11
+#define USB_HID_COUNTRY_NETHERLANDS \
+                                0x12
+#define USB_HID_COUNTRY_NORWEGIAN \
+                                0x13
+#define USB_HID_COUNTRY_PERSIAN 0x14
+#define USB_HID_COUNTRY_POLAND  0x15
+#define USB_HID_COUNTRY_PORTUGUESE \
+                                0x16
+#define USB_HID_COUNTRY_RUSSIA  0x17
+#define USB_HID_COUNTRY_SLOVAKIA \
+                                0x18
+#define USB_HID_COUNTRY_SPANISH 0x19
+#define USB_HID_COUNTRY_SWEDISH 0x1A
+#define USB_HID_COUNTRY_SWISS_FRENCH \
+                                0x1B
+#define USB_HID_COUNTRY_SWISS_GERMAN \
+                                0x1C
+#define USB_HID_COUNTRY_SWITZERLAND \
+                                0x1D
+#define USB_HID_COUNTRY_TAIWAN  0x1E
+#define USB_HID_COUNTRY_TURKISH_Q \
+                                0x1F
+#define USB_HID_COUNTRY_UK      0x20
+#define USB_HID_COUNTRY_US      0x21
+#define USB_HID_COUNTRY_YUGOSLAVIA \
+                                0x22
+#define USB_HID_COUNTRY_TURKISH_F \
+                                0x23
+
+//*****************************************************************************
+//
+// Data flags used in Input item tags within report descriptors.
+//
+//*****************************************************************************
+#define USB_HID_INPUT_DATA      0x0000
+#define USB_HID_INPUT_CONSTANT  0x0001
+#define USB_HID_INPUT_ARRAY     0x0000
+#define USB_HID_INPUT_VARIABLE  0x0002
+#define USB_HID_INPUT_ABS       0x0000
+#define USB_HID_INPUT_RELATIVE  0x0004
+#define USB_HID_INPUT_NOWRAP    0x0000
+#define USB_HID_INPUT_WRAP      0x0008
+#define USB_HID_INPUT_LINEAR    0x0000
+#define USB_HID_INPUT_NONLINEAR 0x0010
+#define USB_HID_INPUT_PREFER    0x0000
+#define USB_HID_INPUT_NONPREFER 0x0020
+#define USB_HID_INPUT_NONULL    0x0000
+#define USB_HID_INPUT_NULL      0x0040
+#define USB_HID_INPUT_BITF      0x0100
+#define USB_HID_INPUT_BYTES     0x0000
+
+//*****************************************************************************
+//
+// Data flags used in Feature item tags within report descriptors.
+//
+//*****************************************************************************
+#define USB_HID_FEATURE_DATA    0x0000
+#define USB_HID_FEATURE_CONSTANT \
+                                0x0001
+#define USB_HID_FEATURE_ARRAY   0x0000
+#define USB_HID_FEATURE_VARIABLE \
+                                0x0002
+#define USB_HID_FEATURE_ABS     0x0000
+#define USB_HID_FEATURE_RELATIVE \
+                                0x0004
+#define USB_HID_FEATURE_NOWRAP  0x0000
+#define USB_HID_FEATURE_WRAP    0x0008
+#define USB_HID_FEATURE_LINEAR  0x0000
+#define USB_HID_FEATURE_NONLINEAR \
+                                0x0010
+#define USB_HID_FEATURE_PREFER  0x0000
+#define USB_HID_FEATURE_NONPREFER \
+                                0x0020
+#define USB_HID_FEATURE_NONULL  0x0000
+#define USB_HID_FEATURE_NULL    0x0040
+#define USB_HID_FEATURE_BITF    0x0100
+#define USB_HID_FEATURE_BYTES   0x0000
+
+//*****************************************************************************
+//
+// Data flags used in Output item tags within report descriptors.
+//
+//*****************************************************************************
+#define USB_HID_OUTPUT_DATA     0x0000
+#define USB_HID_OUTPUT_CONSTANT 0x0001
+#define USB_HID_OUTPUT_ARRAY    0x0000
+#define USB_HID_OUTPUT_VARIABLE 0x0002
+#define USB_HID_OUTPUT_ABS      0x0000
+#define USB_HID_OUTPUT_RELATIVE 0x0004
+#define USB_HID_OUTPUT_NOWRAP   0x0000
+#define USB_HID_OUTPUT_WRAP     0x0008
+#define USB_HID_OUTPUT_LINEAR   0x0000
+#define USB_HID_OUTPUT_NONLINEAR \
+                                0x0010
+#define USB_HID_OUTPUT_PREFER   0x0000
+#define USB_HID_OUTPUT_NONPREFER \
+                                0x0020
+#define USB_HID_OUTPUT_NONULL   0x0000
+#define USB_HID_OUTPUT_NULL     0x0040
+#define USB_HID_OUTPUT_BITF     0x0100
+#define USB_HID_OUTPUT_BYTES    0x0000
+
+//*****************************************************************************
+//
+// Physical descriptor bias values.
+//
+//*****************************************************************************
+#define USB_HID_BIAS_NOT_APPLICABLE \
+                                0x00
+#define USB_HID_BIAS_RIGHT_HAND 0x01
+#define USB_HID_BIAS_LEFT_HAND  0x02
+#define USB_HID_BIAS_BOTH_HANDS 0x03
+#define USB_HID_BIAS_EITHER_HAND \
+                                0x04
+
+//*****************************************************************************
+//
+// Physical descriptor designator values.
+//
+//*****************************************************************************
+#define USB_HID_DESIGNATOR_NONE 0x00
+#define USB_HID_DESIGNATOR_HAND 0x01
+#define USB_HID_DESIGNATOR_EYEBALL \
+                                0x02
+#define USB_HID_DESIGNATOR_EYEBROW \
+                                0x03
+#define USB_HID_DESIGNATOR_EYELID \
+                                0x04
+#define USB_HID_DESIGNATOR_EAR  0x05
+#define USB_HID_DESIGNATOR_NOSE 0x06
+#define USB_HID_DESIGNATOR_MOUTH \
+                                0x07
+#define USB_HID_DESIGNATOR_UPPER_LIP \
+                                0x08
+#define USB_HID_DESIGNATOR_LOWER_LIP \
+                                0x09
+#define USB_HID_DESIGNATOR_JAW  0x0A
+#define USB_HID_DESIGNATOR_NECK 0x0B
+#define USB_HID_DESIGNATOR_UPPER_ARM \
+                                0x0C
+#define USB_HID_DESIGNATOR_ELBOW \
+                                0x0D
+#define USB_HID_DESIGNATOR_FOREARM \
+                                0x0E
+#define USB_HID_DESIGNATOR_WRIST \
+                                0x0F
+#define USB_HID_DESIGNATOR_PALM 0x10
+#define USB_HID_DESIGNATOR_THUMB \
+                                0x11
+#define USB_HID_DESIGNATOR_INDEX_FINGER \
+                                0x12
+#define USB_HID_DESIGNATOR_MIDDLE_FINGER \
+                                0x13
+#define USB_HID_DESIGNATOR_RING_FINGER \
+                                0x14
+#define USB_HID_DESIGNATOR_LITTLE_FINGER \
+                                0x15
+#define USB_HID_DESIGNATOR_HEAD 0x16
+#define USB_HID_DESIGNATOR_SHOULDER \
+                                0x17
+#define USB_HID_DESIGNATOR_HIP  0x18
+#define USB_HID_DESIGNATOR_WAIST \
+                                0x19
+#define USB_HID_DESIGNATOR_THIGH \
+                                0x1A
+#define USB_HID_DESIGNATOR_KNEE 0x1B
+#define USB_HID_DESIGNATOR_CALF 0x1C
+#define USB_HID_DESIGNATOR_ANKLE \
+                                0x1D
+#define USB_HID_DESIGNATOR_FOOT 0x1E
+#define USB_HID_DESIGNATOR_HEEL 0x1F
+#define USB_HID_DESIGNATOR_BALL_OF_FOOT \
+                                0x20
+#define USB_HID_DESIGNATOR_BIG_TOE \
+                                0x21
+#define USB_HID_DESIGNATOR_SECOND_TOE \
+                                0x22
+#define USB_HID_DESIGNATOR_THIRD_TOE \
+                                0x23
+#define USB_HID_DESIGNATOR_FOURTH_TOE \
+                                0x24
+#define USB_HID_DESIGNATOR_LITTLE_TOE \
+                                0x25
+#define USB_HID_DESIGNATOR_BROW 0x26
+#define USB_HID_DESIGNATOR_CHEEK \
+                                0x27
+
+//*****************************************************************************
+//
+// Physical descriptor qualifier values.
+//
+//*****************************************************************************
+#define USB_HID_QUALIFIER_NOT_APPLICABLE    \
+                                (0x00 << 5)
+#define USB_HID_QUALIFIER_RIGHT (0x01 << 5)
+#define USB_HID_QUALIFIER_LEFT  (0x02 << 5)
+#define USB_HID_QUALIFIER_BOTH  (0x03 << 5)
+#define USB_HID_QUALIFIER_EITHER \
+                                (0x04 << 5)
+#define USB_HID_QUALIFIER_CENTER \
+                                (0x05 << 5)
+
+//*****************************************************************************
+//
+// This is the maximum value for a usage code.
+//
+//*****************************************************************************
+#define USBH_HID_MAX_USAGE      256
+#define USBH_HID_CAPS_ARRAY_SZ  (USBH_HID_MAX_USAGE/sizeof(uint32_t))
+
+//*****************************************************************************
+//
+// All structures defined in this section of the header require byte packing of
+// fields.  This is usually accomplished using the PACKED macro but, for IAR
+// Embedded Workbench, this requires a pragma.
+//
+//*****************************************************************************
+#ifdef ewarm
+#pragma pack(1)
+#endif
+
+//*****************************************************************************
+//
+//! The class descriptor information structure is used to announce the presence
+//! of HID-specific class descriptors within the HID descriptor.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The type of HID class descriptor.  This will be \b USB_HID_DTYPE_REPORT
+    //!  or \b USB_HID_DTYPE_PHYSICAL.
+    //
+    uint8_t bDescriptorType;
+
+    //
+    //! The total length of the HID class descriptor.
+    //
+    uint16_t wDescriptorLength;
+}
+PACKED tHIDClassDescriptorInfo;
+
+//*****************************************************************************
+//
+//! The HID descriptor is inserted following the interface descriptor and
+//! before the endpoint descriptors for a HID class device.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The length of this descriptor in bytes.
+    //
+    uint8_t bLength;
+
+    //
+    //! The type of the descriptor.  For a HID descriptor, this will be
+    //! \b USB_HID_DTYPE_HID.
+    //
+    uint8_t bDescriptorType;
+
+    //
+    //! A BCD value identifying the HID Class specification release supported
+    //! by the device.  For version 1.11, for example, this value would be
+    //! 0x0111.
+    //
+    uint16_t bcdHID;
+
+    //
+    //! The country code for which this hardware is localized or 0 if no
+    //! localization has been performed.  Valid country (or language) codes are
+    //! in labels of the form \b USB_HID_COUNTRY_xxx.
+    uint8_t bCountryCode;
+
+    //
+    //! The number of class-specific descriptors that exist for this device.
+    //! This indicates the number of class descriptor information structures
+    //! that are appended to this structure and must be at least 1 (since all
+    //! HID devices must publish at least 1 report descriptor).
+    //
+    uint8_t bNumDescriptors;
+
+    //
+    //! A table announcing each of the class-specific descriptors that this
+    //! device publishes.  The actual number of entries in the array is given
+    //! by the bNumDescriptors field.
+    //
+    tHIDClassDescriptorInfo sClassDescriptor[1];
+}
+PACKED tHIDDescriptor;
+
+//*****************************************************************************
+//
+// Return to default packing when using the IAR Embedded Workbench compiler.
+//
+//*****************************************************************************
+#ifdef ewarm
+#pragma pack()
+#endif
+
+//*****************************************************************************
+//
+//! This structure defines the mapping of USB usage identifiers to printable
+//! characters.  The structure has three members that hold this information.
+//! The ui8BytesPerChar, indicates the number of bytes per character in
+//! the table.  The pui32CapsLock array holds a packed bit array of usage
+//! identifiers that can be modified by the Caps Lock key.  The pCharMapping
+//! array is treated as a double indexed array with two "columns".  In the case
+//! of a single byte character it is treated as pairs of 8 bit values for
+//! unshifted and shifted values.  In the case of a double byte characters it
+//! is treated as pairs of 16 bit values.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! Number of bytes per character in the pCharMapping table of this
+    //! structure.
+    //
+    uint8_t ui8BytesPerChar;
+
+    //
+    //! This is a packed bitmasked structure with a one bit flags that
+    //! indicates if the corresponding Usage ID is affected by the Caps Lock
+    //! key.
+    //
+    uint32_t pui32CapsLock[USBH_HID_CAPS_ARRAY_SZ];
+
+    //
+    //! This is the indexed table of Usage ID to character value.  It must be
+    //! at least ui8BytesPerChar * 2 * \b USBH_HID_MAX_USAGE bytes in size as
+    //! it is treated as a double indexed array.
+    //
+    void *pvCharMapping;
+}
+tHIDKeyboardUsageTable;
+
+//*****************************************************************************
+//
+// The US Keyboard mapping used by USB keyboard usage ID to character mapping.
+//
+//*****************************************************************************
+extern const tHIDKeyboardUsageTable g_sUSKeyboardMap;
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __USBHID_H__
diff --git a/bsp/tm4c129x/libraries/usblib/usbkeyboardmap.c b/bsp/tm4c129x/libraries/usblib/usbkeyboardmap.c
new file mode 100755
index 0000000..d592cc8
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/usbkeyboardmap.c
@@ -0,0 +1,145 @@
+//*****************************************************************************
+//
+// usbkeyboardmap.c - This file holds the table to enable USB keyboard usage
+// identifiers to be mapped to printable characters.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "inc/hw_types.h"
+#include "usblib/usblib.h"
+#include "usblib/usbhid.h"
+
+//*****************************************************************************
+//
+// This is the array that hold the unshifted and shifted ASCII character for
+// each usage ID.
+//
+//*****************************************************************************
+const uint8_t g_pui8KeyBoardMap[USBH_HID_MAX_USAGE][2] =
+{
+//
+//  Usage ID to character mapping                      Usage ID     CAPS Lock
+//
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 0 - 3        0
+    {'a', 'A'}, {'b', 'B'}, {'c', 'C'}, {'d', 'D'}, // 4 - 7        f
+    {'e', 'E'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, // 8 - 11       f
+    {'i', 'I'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, // 12 - 15      f
+    {'m', 'M'}, {'n', 'N'}, {'o', 'O'}, {'p', 'P'}, // 16 - 19      f
+    {'q', 'Q'}, {'r', 'R'}, {'s', 'S'}, {'t', 'T'}, // 20 - 23      f
+    {'u', 'U'}, {'v', 'V'}, {'w', 'W'}, {'x', 'X'}, // 24 - 27      f
+    {'y', 'Y'}, {'z', 'Z'}, {'1', '!'}, {'2', '@'}, // 28 - 31      3
+
+    {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'}, // 32 - 35      0
+    {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, // 36 - 39      0
+    {'\n', '\n'}, {0, 0},   {0, 0},   {'\t', '\t'}, // 40 - 43      0
+    {' ', ' '}, {'-', '_'}, {'=', '+'}, {'[', '{'}, // 44 - 47      0
+    {']', '}'}, {'\\', '|'},{'`', '~'}, {';', ':'}, // 48 - 51      0
+    {'\'', '"'}, {'`', '~'}, {',', '<'}, {'.', '>'},// 52 - 55      0
+    {'/', '?'}, {0, 0},     {0, 0},     {0, 0},     // 56 - 59      0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 60 - 63      0
+
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 64 - 67      0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 68 - 71      0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 72 - 75      0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 76 - 79      0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 80 - 83      0
+    {'/', '/'}, {'*', '*'}, {'-', '-'}, {'+', '+'}, // 84 - 87      0
+    {'\n', '\n'}, {'1', 0}, {'2', 0},   {'3', 0},   // 88 - 91      0
+    {'4', 0},   {'5', 0},   {'6', 0},   {'7', 0},   // 92 - 95      0
+
+    {'8', 0},   {'9', 0},   {'0', 0},   {'.', 0},   // 96 - 99      0
+    {'\\', '|'},{0, 0},     {0, 0},     {'=', '+'}, // 100 - 103    0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 104 - 107    0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 108 - 111    0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 112 - 115    0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 116 - 119    0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 120 - 123    0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 124 - 127    0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 128 - 131    0
+
+    {0, 0},     {',', ','}, {'=', '='}, {0, 0},     // 132 - 135    0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 136 - 139    0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 140 - 143    0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 144 - 147    0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 148 - 151    0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 152 - 155    0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 156 - 159    0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 160 - 163    0
+
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 164 - 167    0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 168 - 171    0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 172 - 175    0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 174 - 179    0
+    {0, 0},     {0, 0},     {'(', '('}, {')', ')'}, // 180 - 183    0
+    {'{', '{'}, {'}', '}'}, {'\t', '\t'}, {0, 0},   // 184 - 187    0
+    {'A', 'A'}, {'B', 'B'}, {'C', 'C'}, {'D', 'D'}, // 188 - 191    0
+    {'E', 'E'}, {'F', 'F'}, {0, 0},     {'^', '^'}, // 192 - 195    0
+
+    {'%', '%'}, {'<', '<'}, {'>', '>'}, {'&', '&'}, // 196 - 199    0
+    {'&', '&'}, {'|', '|'}, {'|', '|'}, {':', ':'}, // 200 - 203    0
+    {'#', '#'}, {' ', ' '}, {'@', '@'}, {'!', '!'}, // 204 - 207    0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 208 - 211    0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 212 - 215    0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 216 - 219    0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 220 - 223    0
+
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 224 - 227    0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 228 - 231    0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 232 - 235    0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 236 - 239    0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 240 - 243    0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 244 - 247    0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 248 - 251    0
+    {0, 0},     {0, 0},     {0, 0},     {0, 0},     // 252 - 255    0
+};
+
+//*****************************************************************************
+//
+// This is the structure that defines the mapping of USB usage IDs to ASCII
+// values for printing.
+//
+//*****************************************************************************
+const tHIDKeyboardUsageTable g_sUSKeyboardMap =
+{
+    //
+    // One byte per character.
+    //
+    1,
+    //
+    // Packed bit array of usages codes that are effected by Caps Lock state.
+    //
+    {
+        0x3ffffff0,     // Alpha characters are only one affected by CAPS LOCK
+        0x00000000,
+        0x00000000,
+        0x00000000,
+        0x00000000,
+        0x00000000,
+        0x00000000,
+        0x00000000,
+    },
+    //
+    // The large table of the direct mapping of usage id's to ascii characters.
+    //
+    (void *)g_pui8KeyBoardMap
+};
diff --git a/bsp/tm4c129x/libraries/usblib/usblib.ewp b/bsp/tm4c129x/libraries/usblib/usblib.ewp
new file mode 100755
index 0000000..70afea7
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/usblib.ewp
@@ -0,0 +1,860 @@
+<?xml version="1.0" encoding="iso-8859-1"?>
+
+<project>
+  <fileVersion>1</fileVersion>
+  <configuration>
+    <name>Debug</name>
+    <toolchain>
+      <name>ARM</name>
+    </toolchain>
+    <debug>1</debug>
+    <settings>
+      <name>General</name>
+      <archiveVersion>3</archiveVersion>
+      <data>
+        <version>14</version>
+        <wantNonLocal>1</wantNonLocal>
+        <debug>1</debug>
+        <option>
+          <name>ExePath</name>
+          <state>ewarm\Exe</state>
+        </option>
+        <option>
+          <name>ObjPath</name>
+          <state>ewarm\Obj</state>
+        </option>
+        <option>
+          <name>ListPath</name>
+          <state>ewarm\List</state>
+        </option>
+        <option>
+          <name>Variant</name>
+          <version>19</version>
+          <state>39</state>
+        </option>
+        <option>
+          <name>GEndianMode</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>Input variant</name>
+          <version>1</version>
+          <state>0</state>
+        </option>
+        <option>
+          <name>Input description</name>
+          <state>Full formatting.</state>
+        </option>
+        <option>
+          <name>Output variant</name>
+          <version>0</version>
+          <state>0</state>
+        </option>
+        <option>
+          <name>Output description</name>
+          <state>Full formatting.</state>
+        </option>
+        <option>
+          <name>GOutputBinary</name>
+          <state>1</state>
+        </option>
+        <option>
+          <name>FPU</name>
+          <version>2</version>
+          <state>5</state>
+        </option>
+        <option>
+          <name>OGCoreOrChip</name>
+          <state>1</state>
+        </option>
+        <option>
+          <name>GRuntimeLibSelect</name>
+          <version>0</version>
+          <state>1</state>
+        </option>
+        <option>
+          <name>GRuntimeLibSelectSlave</name>
+          <version>0</version>
+          <state>1</state>
+        </option>
+        <option>
+          <name>RTDescription</name>
+          <state>To be used with the normal configuration of the C/C++ runtime library. No locale interface, C locale, no file descriptor support, no multibytes in printf and scanf, and no hex floats in strtod.</state>
+        </option>
+        <option>
+          <name>RTConfigPath</name>
+          <state>$TOOLKIT_DIR$\INC\DLib_Config_Normal.h</state>
+        </option>
+        <option>
+          <name>OGProductVersion</name>
+          <state>5.11.0.50579</state>
+        </option>
+        <option>
+          <name>OGLastSavedByProductVersion</name>
+          <state>5.11.0.50579</state>
+        </option>
+        <option>
+          <name>GeneralMisraRules</name>
+          <version>0</version>
+          <state>1000111110110101101110011100111111101110011011000101110111101101100111111111111100110011111001110111001111111111111111111111111</state>
+        </option>
+        <option>
+          <name>GeneralEnableMisra</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>GeneralMisraVerbose</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>OGChipSelectEditMenu</name>
+          <state>TM4C1230C3PM	TexasInstruments TM4C1230C3PM</state>
+        </option>
+        <option>
+          <name>GenLowLevelInterface</name>
+          <state>1</state>
+        </option>
+        <option>
+          <name>GEndianModeBE</name>
+          <state>1</state>
+        </option>
+        <option>
+          <name>OGBufferedTerminalOutput</name>
+          <state>0</state>
+        </option>
+      </data>
+    </settings>
+    <settings>
+      <name>ICCARM</name>
+      <archiveVersion>2</archiveVersion>
+      <data>
+        <version>19</version>
+        <wantNonLocal>1</wantNonLocal>
+        <debug>1</debug>
+        <option>
+          <name>CCDefines</name>
+          <state>ewarm</state>
+        </option>
+        <option>
+          <name>CCPreprocFile</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>CCPreprocComments</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>CCPreprocLine</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>CCListCFile</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>CCListCMnemonics</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>CCListCMessages</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>CCListAssFile</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>CCListAssSource</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>CCEnableRemarks</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>CCDiagSuppress</name>
+          <state>Pa050</state>
+        </option>
+        <option>
+          <name>CCDiagRemark</name>
+          <state></state>
+        </option>
+        <option>
+          <name>CCDiagWarning</name>
+          <state></state>
+        </option>
+        <option>
+          <name>CCDiagError</name>
+          <state></state>
+        </option>
+        <option>
+          <name>CCObjPrefix</name>
+          <state>1</state>
+        </option>
+        <option>
+          <name>CCAllowList</name>
+          <version>1</version>
+          <state>1111111</state>
+        </option>
+        <option>
+          <name>CCDebugInfo</name>
+          <state>1</state>
+        </option>
+        <option>
+          <name>IEndianMode</name>
+          <state>1</state>
+        </option>
+        <option>
+          <name>IProcessor</name>
+          <state>1</state>
+        </option>
+        <option>
+          <name>IExtraOptionsCheck</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>IExtraOptions</name>
+          <state></state>
+        </option>
+        <option>
+          <name>CCLangConformance</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>CCSignedPlainChar</name>
+          <state>1</state>
+        </option>
+        <option>
+          <name>CCRequirePrototypes</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>CCMultibyteSupport</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>CCDiagWarnAreErr</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>CCCompilerRuntimeInfo</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>IFpuProcessor</name>
+          <state>1</state>
+        </option>
+        <option>
+          <name>OutputFile</name>
+          <state>$FILE_BNAME$.o</state>
+        </option>
+        <option>
+          <name>CCLangSelect</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>CCLibConfigHeader</name>
+          <state>1</state>
+        </option>
+        <option>
+          <name>PreInclude</name>
+          <state></state>
+        </option>
+        <option>
+          <name>CompilerMisraRules</name>
+          <version>0</version>
+          <state>1000111110110101101110011100111111101110011011000101110111101101100111111111111100110011111001110111001111111111111111111111111</state>
+        </option>
+        <option>
+          <name>CompilerMisraOverride</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>CCIncludePath2</name>
+          <state>$PROJ_DIR$\..</state>
+        </option>
+        <option>
+          <name>CCStdIncCheck</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>CCStdIncludePath</name>
+          <state>$TOOLKIT_DIR$\INC\</state>
+        </option>
+        <option>
+          <name>CCCodeSection</name>
+          <state>.text</state>
+        </option>
+        <option>
+          <name>IInterwork2</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>IProcessorMode2</name>
+          <state>1</state>
+        </option>
+        <option>
+          <name>CCOptLevel</name>
+          <state>3</state>
+        </option>
+        <option>
+          <name>CCOptStrategy</name>
+          <version>0</version>
+          <state>1</state>
+        </option>
+        <option>
+          <name>CCOptLevelSlave</name>
+          <state>3</state>
+        </option>
+      </data>
+    </settings>
+    <settings>
+      <name>AARM</name>
+      <archiveVersion>2</archiveVersion>
+      <data>
+        <version>7</version>
+        <wantNonLocal>1</wantNonLocal>
+        <debug>1</debug>
+        <option>
+          <name>AObjPrefix</name>
+          <state>1</state>
+        </option>
+        <option>
+          <name>AEndian</name>
+          <state>1</state>
+        </option>
+        <option>
+          <name>ACaseSensitivity</name>
+          <state>1</state>
+        </option>
+        <option>
+          <name>MacroChars</name>
+          <version>0</version>
+          <state>0</state>
+        </option>
+        <option>
+          <name>AWarnEnable</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>AWarnWhat</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>AWarnOne</name>
+          <state></state>
+        </option>
+        <option>
+          <name>AWarnRange1</name>
+          <state></state>
+        </option>
+        <option>
+          <name>AWarnRange2</name>
+          <state></state>
+        </option>
+        <option>
+          <name>ADebug</name>
+          <state>1</state>
+        </option>
+        <option>
+          <name>AltRegisterNames</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>ADefines</name>
+          <state>ewarm</state>
+        </option>
+        <option>
+          <name>AList</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>AListHeader</name>
+          <state>1</state>
+        </option>
+        <option>
+          <name>AListing</name>
+          <state>1</state>
+        </option>
+        <option>
+          <name>Includes</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>MacDefs</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>MacExps</name>
+          <state>1</state>
+        </option>
+        <option>
+          <name>MacExec</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>OnlyAssed</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>MultiLine</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>PageLengthCheck</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>PageLength</name>
+          <state>80</state>
+        </option>
+        <option>
+          <name>TabSpacing</name>
+          <state>8</state>
+        </option>
+        <option>
+          <name>AXRef</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>AXRefDefines</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>AXRefInternal</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>AXRefDual</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>AProcessor</name>
+          <state>1</state>
+        </option>
+        <option>
+          <name>AFpuProcessor</name>
+          <state>1</state>
+        </option>
+        <option>
+          <name>AOutputFile</name>
+          <state>$FILE_BNAME$.o</state>
+        </option>
+        <option>
+          <name>AMultibyteSupport</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>ALimitErrorsCheck</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>ALimitErrorsEdit</name>
+          <state>100</state>
+        </option>
+        <option>
+          <name>AIgnoreStdInclude</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>AStdIncludes</name>
+          <state>$TOOLKIT_DIR$\INC\</state>
+        </option>
+        <option>
+          <name>AUserIncludes</name>
+          <state></state>
+        </option>
+        <option>
+          <name>AExtraOptionsCheckV2</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>AExtraOptionsV2</name>
+          <state></state>
+        </option>
+      </data>
+    </settings>
+    <settings>
+      <name>OBJCOPY</name>
+      <archiveVersion>0</archiveVersion>
+      <data>
+        <version>1</version>
+        <wantNonLocal>1</wantNonLocal>
+        <debug>1</debug>
+        <option>
+          <name>OOCOutputFormat</name>
+          <version>1</version>
+          <state>0</state>
+        </option>
+        <option>
+          <name>OCOutputOverride</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>OOCOutputFile</name>
+          <state>usblib.srec</state>
+        </option>
+        <option>
+          <name>OOCCommandLineProducer</name>
+          <state>1</state>
+        </option>
+        <option>
+          <name>OOCObjCopyEnable</name>
+          <state>0</state>
+        </option>
+      </data>
+    </settings>
+    <settings>
+      <name>CUSTOM</name>
+      <archiveVersion>3</archiveVersion>
+      <data>
+        <extensions></extensions>
+        <cmdline></cmdline>
+      </data>
+    </settings>
+    <settings>
+      <name>BICOMP</name>
+      <archiveVersion>0</archiveVersion>
+      <data/>
+    </settings>
+    <settings>
+      <name>BUILDACTION</name>
+      <archiveVersion>1</archiveVersion>
+      <data>
+        <prebuild></prebuild>
+        <postbuild></postbuild>
+      </data>
+    </settings>
+    <settings>
+      <name>ILINK</name>
+      <archiveVersion>0</archiveVersion>
+      <data>
+        <version>5</version>
+        <wantNonLocal>1</wantNonLocal>
+        <debug>1</debug>
+        <option>
+          <name>IlinkLibIOConfig</name>
+          <state>1</state>
+        </option>
+        <option>
+          <name>XLinkMisraHandler</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>IlinkInputFileSlave</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>IlinkOutputFile</name>
+          <state>usblib.out</state>
+        </option>
+        <option>
+          <name>IlinkDebugInfoEnable</name>
+          <state>1</state>
+        </option>
+        <option>
+          <name>IlinkKeepSymbols</name>
+          <state></state>
+        </option>
+        <option>
+          <name>IlinkRawBinaryFile</name>
+          <state></state>
+        </option>
+        <option>
+          <name>IlinkRawBinarySymbol</name>
+          <state></state>
+        </option>
+        <option>
+          <name>IlinkRawBinarySegment</name>
+          <state></state>
+        </option>
+        <option>
+          <name>IlinkRawBinaryAlign</name>
+          <state></state>
+        </option>
+        <option>
+          <name>IlinkDefines</name>
+          <state></state>
+        </option>
+        <option>
+          <name>IlinkConfigDefines</name>
+          <state></state>
+        </option>
+        <option>
+          <name>IlinkMapFile</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>IlinkLogFile</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>IlinkLogInitialization</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>IlinkLogModule</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>IlinkLogSection</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>IlinkLogVeneer</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>IlinkIcfOverride</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>IlinkIcfFile</name>
+          <state>lnk0t.icf</state>
+        </option>
+        <option>
+          <name>IlinkIcfFileSlave</name>
+          <state></state>
+        </option>
+        <option>
+          <name>IlinkEnableRemarks</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>IlinkSuppressDiags</name>
+          <state></state>
+        </option>
+        <option>
+          <name>IlinkTreatAsRem</name>
+          <state></state>
+        </option>
+        <option>
+          <name>IlinkTreatAsWarn</name>
+          <state></state>
+        </option>
+        <option>
+          <name>IlinkTreatAsErr</name>
+          <state></state>
+        </option>
+        <option>
+          <name>IlinkWarningsAreErrors</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>IlinkUseExtraOptions</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>IlinkExtraOptions</name>
+          <state></state>
+        </option>
+        <option>
+          <name>IlinkLowLevelInterfaceSlave</name>
+          <state>1</state>
+        </option>
+        <option>
+          <name>IlinkAutoLibEnable</name>
+          <state>1</state>
+        </option>
+        <option>
+          <name>IlinkAdditionalLibs</name>
+          <state></state>
+        </option>
+        <option>
+          <name>IlinkOverrideProgramEntryLabel</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>IlinkProgramEntryLabelSelect</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>IlinkProgramEntryLabel</name>
+          <state></state>
+        </option>
+        <option>
+          <name>IlinkNXPLPCChecksum</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>DoFill</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>FillerByte</name>
+          <state>0xFF</state>
+        </option>
+        <option>
+          <name>FillerStart</name>
+          <state>0x0</state>
+        </option>
+        <option>
+          <name>FillerEnd</name>
+          <state>0x0</state>
+        </option>
+        <option>
+          <name>CrcSize</name>
+          <version>0</version>
+          <state>1</state>
+        </option>
+        <option>
+          <name>CrcAlign</name>
+          <state>1</state>
+        </option>
+        <option>
+          <name>CrcAlgo</name>
+          <state>1</state>
+        </option>
+        <option>
+          <name>CrcPoly</name>
+          <state>0x11021</state>
+        </option>
+        <option>
+          <name>CrcCompl</name>
+          <version>0</version>
+          <state>0</state>
+        </option>
+        <option>
+          <name>CrcBitOrder</name>
+          <version>0</version>
+          <state>0</state>
+        </option>
+        <option>
+          <name>CrcInitialValue</name>
+          <state>0x0</state>
+        </option>
+        <option>
+          <name>DoCrc</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>IlinkBE8Slave</name>
+          <state>1</state>
+        </option>
+        <option>
+          <name>IlinkBufferedTerminalOutput</name>
+          <state>1</state>
+        </option>
+      </data>
+    </settings>
+    <settings>
+      <name>IARCHIVE</name>
+      <archiveVersion>0</archiveVersion>
+      <data>
+        <version>0</version>
+        <wantNonLocal>1</wantNonLocal>
+        <debug>1</debug>
+        <option>
+          <name>IarchiveInputs</name>
+          <state></state>
+        </option>
+        <option>
+          <name>IarchiveOverride</name>
+          <state>0</state>
+        </option>
+        <option>
+          <name>IarchiveOutput</name>
+          <state>$PROJ_DIR$\ewarm\Exe\usblib.a</state>
+        </option>
+      </data>
+    </settings>
+    <settings>
+      <name>BILINK</name>
+      <archiveVersion>0</archiveVersion>
+      <data/>
+    </settings>
+  </configuration>
+  <group>
+    <name>Source</name>
+    <file>
+      <name>$PROJ_DIR$\usbbuffer.c</name>
+    </file>
+    <file>
+      <name>$PROJ_DIR$\device\usbdaudio.c</name>
+    </file>
+    <file>
+      <name>$PROJ_DIR$\device\usbdbulk.c</name>
+    </file>
+    <file>
+      <name>$PROJ_DIR$\device\usbdcdc.c</name>
+    </file>
+    <file>
+      <name>$PROJ_DIR$\device\usbdcdesc.c</name>
+    </file>
+    <file>
+      <name>$PROJ_DIR$\device\usbdcomp.c</name>
+    </file>
+    <file>
+      <name>$PROJ_DIR$\device\usbdconfig.c</name>
+    </file>
+    <file>
+      <name>$PROJ_DIR$\device\usbddfu-rt.c</name>
+    </file>
+    <file>
+      <name>$PROJ_DIR$\device\usbdenum.c</name>
+    </file>
+    <file>
+      <name>$PROJ_DIR$\usbdesc.c</name>
+    </file>
+    <file>
+      <name>$PROJ_DIR$\device\usbdhandler.c</name>
+    </file>
+    <file>
+      <name>$PROJ_DIR$\device\usbdhid.c</name>
+    </file>
+    <file>
+      <name>$PROJ_DIR$\device\usbdhidgamepad.c</name>
+    </file>
+    <file>
+      <name>$PROJ_DIR$\device\usbdhidkeyb.c</name>
+    </file>
+    <file>
+      <name>$PROJ_DIR$\device\usbdhidmouse.c</name>
+    </file>
+    <file>
+      <name>$PROJ_DIR$\usbdma.c</name>
+    </file>
+    <file>
+      <name>$PROJ_DIR$\device\usbdmsc.c</name>
+    </file>
+    <file>
+      <name>$PROJ_DIR$\host\usbhaudio.c</name>
+    </file>
+    <file>
+      <name>$PROJ_DIR$\host\usbhhid.c</name>
+    </file>
+    <file>
+      <name>$PROJ_DIR$\host\usbhhidkeyboard.c</name>
+    </file>
+    <file>
+      <name>$PROJ_DIR$\host\usbhhidmouse.c</name>
+    </file>
+    <file>
+      <name>$PROJ_DIR$\host\usbhhub.c</name>
+    </file>
+    <file>
+      <name>$PROJ_DIR$\host\usbhmsc.c</name>
+    </file>
+    <file>
+      <name>$PROJ_DIR$\host\usbhostenum.c</name>
+    </file>
+    <file>
+      <name>$PROJ_DIR$\host\usbhscsi.c</name>
+    </file>
+    <file>
+      <name>$PROJ_DIR$\usbkeyboardmap.c</name>
+    </file>
+    <file>
+      <name>$PROJ_DIR$\usbmode.c</name>
+    </file>
+    <file>
+      <name>$PROJ_DIR$\usbringbuf.c</name>
+    </file>
+    <file>
+      <name>$PROJ_DIR$\usbtick.c</name>
+    </file>
+    <file>
+      <name>$PROJ_DIR$\usbulpi.c</name>
+    </file>
+  </group>
+</project>
diff --git a/bsp/tm4c129x/libraries/usblib/usblib.h b/bsp/tm4c129x/libraries/usblib/usblib.h
new file mode 100755
index 0000000..27fa60d
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/usblib.h
@@ -0,0 +1,1951 @@
+//*****************************************************************************
+//
+// usblib.h - Main header file for the USB Library.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#ifndef __USBLIB_H__
+#define __USBLIB_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+//*****************************************************************************
+//
+// This is the maximum number of devices we can support when in host mode and
+// using a hub.  By default, we support up to 4 devices (plus 1 internally for
+// the hub itself).
+//
+//*****************************************************************************
+#ifndef MAX_USB_DEVICES
+#define MAX_USB_DEVICES         5
+#endif
+
+//*****************************************************************************
+//
+// This is the maximum number of endpoints supported by the usblib.
+//
+//*****************************************************************************
+#ifndef USBLIB_NUM_EP
+#define USBLIB_NUM_EP           8       // Number of supported endpoints.
+#endif
+
+//*****************************************************************************
+//
+// The following macro allows compiler-independent syntax to be used to
+// define packed structures.  A typical structure definition using these
+// macros will look similar to the following example:
+//
+//   #ifdef ewarm
+//   #pragma pack(1)
+//   #endif
+//
+//   typedef struct _PackedStructName
+//   {
+//      uint32_t ui32FirstField;
+//      int8_t i8CharMember;
+//      uint16_t ui16Short;
+//   }
+//   PACKED tPackedStructName;
+//
+//   #ifdef ewarm
+//   #pragma pack()
+//   #endif
+//
+// The conditional blocks related to ewarm include the #pragma pack() lines
+// only if the IAR Embedded Workbench compiler is being used.  Unfortunately,
+// it is not possible to emit a #pragma from within a macro definition so this
+// must be done explicitly.
+//
+//*****************************************************************************
+#if defined(ccs) ||                                                           \
+    defined(codered) ||                                                       \
+    defined(gcc) ||                                                           \
+    defined(rvmdk) ||                                                         \
+    defined(__ARMCC_VERSION) ||                                               \
+    defined(sourcerygxx)
+#define PACKED __attribute__ ((packed))
+#elif defined(ewarm)
+#define PACKED
+#else
+#error Unrecognized COMPILER!
+#endif
+//*****************************************************************************
+//
+// Assorted language IDs from the document "USB_LANGIDs.pdf" provided by the
+// USB Implementers' Forum (Version 1.0).
+//
+//*****************************************************************************
+#define USB_LANG_CHINESE_PRC    0x0804      // Chinese (PRC)
+#define USB_LANG_CHINESE_TAIWAN 0x0404      // Chinese (Taiwan)
+#define USB_LANG_EN_US          0x0409      // English (United States)
+#define USB_LANG_EN_UK          0x0809      // English (United Kingdom)
+#define USB_LANG_EN_AUS         0x0C09      // English (Australia)
+#define USB_LANG_EN_CA          0x1009      // English (Canada)
+#define USB_LANG_EN_NZ          0x1409      // English (New Zealand)
+#define USB_LANG_FRENCH         0x040C      // French (Standard)
+#define USB_LANG_GERMAN         0x0407      // German (Standard)
+#define USB_LANG_HINDI          0x0439      // Hindi
+#define USB_LANG_ITALIAN        0x0410      // Italian (Standard)
+#define USB_LANG_JAPANESE       0x0411      // Japanese
+#define USB_LANG_KOREAN         0x0412      // Korean
+#define USB_LANG_ES_TRAD        0x040A      // Spanish (Traditional)
+#define USB_LANG_ES_MODERN      0x0C0A      // Spanish (Modern)
+#define USB_LANG_SWAHILI        0x0441      // Swahili (Kenya)
+#define USB_LANG_URDU_IN        0x0820      // Urdu (India)
+#define USB_LANG_URDU_PK        0x0420      // Urdu (Pakistan)
+
+//*****************************************************************************
+//
+//! \addtogroup usbchap9_src
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Note:
+//
+// Structure definitions which are derived directly from the USB specification
+// use field names from the specification.  Since a somewhat different version
+// of Hungarian prefix notation is used from the standard, beware of making
+// assumptions about field sizes based on the field prefix when using
+// these structures.  Of particular note is the difference in the meaning of
+// the 'i' prefix.  In USB structures, this indicates a single byte index
+// whereas in other code, this is an integer or enumeration variable.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// All structures defined in this section of the header require byte packing of
+// fields.  This is usually accomplished using the PACKED macro but, for IAR
+// Embedded Workbench, this requires a pragma.
+//
+//*****************************************************************************
+#ifdef ewarm
+#pragma pack(1)
+#endif
+
+//*****************************************************************************
+//
+// Definitions related to standard USB device requests (sections 9.3 & 9.4)
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! The standard USB request header as defined in section 9.3 of the USB 2.0
+//! specification.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! Determines the type and direction of the request.
+    //
+    uint8_t bmRequestType;
+
+    //
+    //! Identifies the specific request being made.
+    //
+    uint8_t bRequest;
+
+    //
+    //! Word-sized field that varies according to the request.
+    //
+    uint16_t wValue;
+
+    //
+    //! Word-sized field that varies according to the request; typically used
+    //! to pass an index or offset.
+    //
+    uint16_t wIndex;
+
+    //
+    //! The number of bytes to transfer if there is a data stage to the
+    //! request.
+    //
+    uint16_t wLength;
+
+}
+PACKED tUSBRequest;
+
+//*****************************************************************************
+//
+// The following defines are used with the bmRequestType member of tUSBRequest.
+//
+// Request types have 3 bit fields:
+// 4:0 - Is the recipient type.
+// 6:5 - Is the request type.
+// 7 - Is the direction of the request.
+//
+//*****************************************************************************
+#define USB_RTYPE_DIR_IN        0x80
+#define USB_RTYPE_DIR_OUT       0x00
+
+#define USB_RTYPE_TYPE_M        0x60
+#define USB_RTYPE_VENDOR        0x40
+#define USB_RTYPE_CLASS         0x20
+#define USB_RTYPE_STANDARD      0x00
+
+#define USB_RTYPE_RECIPIENT_M   0x1f
+#define USB_RTYPE_OTHER         0x03
+#define USB_RTYPE_ENDPOINT      0x02
+#define USB_RTYPE_INTERFACE     0x01
+#define USB_RTYPE_DEVICE        0x00
+
+//*****************************************************************************
+//
+// Standard USB requests IDs used in the bRequest field of tUSBRequest.
+//
+//*****************************************************************************
+#define USBREQ_GET_STATUS       0x00
+#define USBREQ_CLEAR_FEATURE    0x01
+#define USBREQ_SET_FEATURE      0x03
+#define USBREQ_SET_ADDRESS      0x05
+#define USBREQ_GET_DESCRIPTOR   0x06
+#define USBREQ_SET_DESCRIPTOR   0x07
+#define USBREQ_GET_CONFIG       0x08
+#define USBREQ_SET_CONFIG       0x09
+#define USBREQ_GET_INTERFACE    0x0a
+#define USBREQ_SET_INTERFACE    0x0b
+#define USBREQ_SYNC_FRAME       0x0c
+
+//*****************************************************************************
+//
+// Data returned from a USBREQ_GET_STATUS request to a device.
+//
+//*****************************************************************************
+#define USB_STATUS_SELF_PWR     0x0001  // Currently self powered.
+#define USB_STATUS_BUS_PWR      0x0000  // Currently bus-powered.
+#define USB_STATUS_PWR_M        0x0001  // Mask for power mode.
+#define USB_STATUS_REMOTE_WAKE  0x0002  // Remote wake-up is currently enabled.
+
+//*****************************************************************************
+//
+// Feature Selectors (tUSBRequest.wValue) passed on USBREQ_CLEAR_FEATURE and
+// USBREQ_SET_FEATURE.
+//
+//*****************************************************************************
+#define USB_FEATURE_EP_HALT     0x0000  // Endpoint halt feature.
+#define USB_FEATURE_REMOTE_WAKE 0x0001  // Remote wake feature, device only.
+#define USB_FEATURE_TEST_MODE   0x0002  // Test mode
+
+//*****************************************************************************
+//
+// Endpoint Selectors (tUSBRequest.wIndex) passed on USBREQ_CLEAR_FEATURE,
+// USBREQ_SET_FEATURE and USBREQ_GET_STATUS.
+//
+//*****************************************************************************
+#define USB_REQ_EP_NUM_M        0x007F
+#define USB_REQ_EP_DIR_M        0x0080
+#define USB_REQ_EP_DIR_IN       0x0080
+#define USB_REQ_EP_DIR_OUT      0x0000
+
+//*****************************************************************************
+//
+// Standard USB descriptor types.  These values are passed in the upper bytes
+// of tUSBRequest.wValue on USBREQ_GET_DESCRIPTOR and also appear in the
+// bDescriptorType field of standard USB descriptors.
+//
+//*****************************************************************************
+#define USB_DTYPE_DEVICE        1
+#define USB_DTYPE_CONFIGURATION 2
+#define USB_DTYPE_STRING        3
+#define USB_DTYPE_INTERFACE     4
+#define USB_DTYPE_ENDPOINT      5
+#define USB_DTYPE_DEVICE_QUAL   6
+#define USB_DTYPE_OSPEED_CONF   7
+#define USB_DTYPE_INTERFACE_PWR 8
+#define USB_DTYPE_OTG           9
+#define USB_DTYPE_INTERFACE_ASC 11
+#define USB_DTYPE_CS_INTERFACE  36
+#define USB_DTYPE_HUB           41
+
+//*****************************************************************************
+//
+// Definitions related to USB descriptors (sections 9.5 & 9.6)
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! This structure describes a generic descriptor header.  These fields are to
+//! be found at the beginning of all valid USB descriptors.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The length of this descriptor (including this length byte) expressed
+    //! in bytes.
+    //
+    uint8_t bLength;
+
+    //
+    //! The type identifier of the descriptor whose information follows.  For
+    //! standard descriptors, this field could contain, for example,
+    //! USB_DTYPE_DEVICE to identify a device descriptor or USB_DTYPE_ENDPOINT
+    //! to identify an endpoint descriptor.
+    //
+    uint8_t bDescriptorType;
+}
+PACKED tDescriptorHeader;
+
+//*****************************************************************************
+//
+//! This structure describes the USB device descriptor as defined in USB
+//! 2.0 specification section 9.6.1.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The length of this descriptor in bytes.  All device descriptors are
+    //! 18 bytes long.
+    //
+    uint8_t bLength;
+
+    //
+    //! The type of the descriptor.  For a device descriptor, this will be
+    //! USB_DTYPE_DEVICE (1).
+    //
+    uint8_t bDescriptorType;
+
+    //
+    //! The USB Specification Release Number in BCD format.  For USB 2.0, this
+    //! will be 0x0200.
+    //
+    uint16_t bcdUSB;
+
+    //
+    //! The device class code.
+    //
+    uint8_t bDeviceClass;
+
+    //
+    //! The device subclass code.  This value qualifies the value found in the
+    //! bDeviceClass field.
+    //
+    uint8_t bDeviceSubClass;
+
+    //
+    //! The device protocol code.  This value is qualified by the values of
+    //! bDeviceClass and bDeviceSubClass.
+    //
+    uint8_t bDeviceProtocol;
+
+    //
+    //! The maximum packet size for endpoint zero.  Valid values are 8, 16, 32
+    //! and 64.
+    //
+    uint8_t bMaxPacketSize0;
+
+    //
+    //! The device Vendor ID (VID) as assigned by the USB-IF.
+    //
+    uint16_t idVendor;
+
+    //
+    //! The device Product ID (PID) as assigned by the manufacturer.
+    //
+    uint16_t idProduct;
+
+    //
+    //! The device release number in BCD format.
+    //
+    uint16_t bcdDevice;
+
+    //
+    //! The index of a string descriptor describing the manufacturer.
+    //
+    uint8_t iManufacturer;
+
+    //
+    //! The index of a string descriptor describing the product.
+    //
+    uint8_t iProduct;
+
+    //
+    //! The index of a string descriptor describing the device's serial
+    //! number.
+    //
+    uint8_t iSerialNumber;
+
+    //
+    //! The number of possible configurations offered by the device.  This
+    //! field indicates the number of distinct configuration descriptors that
+    //! the device offers.
+    //
+    uint8_t bNumConfigurations;
+}
+PACKED tDeviceDescriptor;
+
+//*****************************************************************************
+//
+// USB Device Class codes used in the tDeviceDescriptor.bDeviceClass field.
+// Definitions for the bDeviceSubClass and bDeviceProtocol fields are device
+// specific and can be found in the appropriate device class header files.
+//
+//*****************************************************************************
+#define USB_CLASS_DEVICE        0x00
+#define USB_CLASS_AUDIO         0x01
+#define USB_CLASS_CDC           0x02
+#define USB_CLASS_HID           0x03
+#define USB_CLASS_PHYSICAL      0x05
+#define USB_CLASS_IMAGE         0x06
+#define USB_CLASS_PRINTER       0x07
+#define USB_CLASS_MASS_STORAGE  0x08
+#define USB_CLASS_HUB           0x09
+#define USB_CLASS_CDC_DATA      0x0a
+#define USB_CLASS_SMART_CARD    0x0b
+#define USB_CLASS_SECURITY      0x0d
+#define USB_CLASS_VIDEO         0x0e
+#define USB_CLASS_HEALTHCARE    0x0f
+#define USB_CLASS_DIAG_DEVICE   0xdc
+#define USB_CLASS_WIRELESS      0xe0
+#define USB_CLASS_MISC          0xef
+#define USB_CLASS_APP_SPECIFIC  0xfe
+#define USB_CLASS_VEND_SPECIFIC 0xff
+#define USB_CLASS_EVENTS        0xffffffff
+
+//*****************************************************************************
+//
+// Generic values for undefined subclass and protocol.
+//
+//*****************************************************************************
+#define USB_SUBCLASS_UNDEFINED  0x00
+#define USB_PROTOCOL_UNDEFINED  0x00
+
+//*****************************************************************************
+//
+// The following are the miscellaneous subclass values.
+//
+//*****************************************************************************
+#define USB_MISC_SUBCLASS_SYNC  0x01
+#define USB_MISC_SUBCLASS_COMMON                                              \
+                                0x02
+
+//*****************************************************************************
+//
+// These following are miscellaneous protocol values.
+//
+//*****************************************************************************
+#define USB_MISC_PROTOCOL_IAD   0x01
+
+//*****************************************************************************
+//
+// These following are hub protocol values.
+//
+//*****************************************************************************
+#define USB_HUB_PROTOCOL_FS     0x00
+#define USB_HUB_PROTOCOL_SINGLE 0x01
+#define USB_HUB_PROTOCOL_MULTI  0x02
+
+//*****************************************************************************
+//
+//! This structure describes the USB device qualifier descriptor as defined in
+//! the USB 2.0 specification, section 9.6.2.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The length of this descriptor in bytes.  All device qualifier
+    //! descriptors are 10 bytes long.
+    //
+    uint8_t bLength;
+
+    //
+    //! The type of the descriptor.  For a device descriptor, this will be
+    //! USB_DTYPE_DEVICE_QUAL (6).
+    //
+    uint8_t bDescriptorType;
+
+    //
+    //! The USB Specification Release Number in BCD format.  For USB 2.0, this
+    //! will be 0x0200.
+    //
+    uint16_t bcdUSB;
+
+    //
+    //! The device class code.
+    //
+    uint8_t bDeviceClass;
+
+    //
+    //! The device subclass code.  This value qualifies the value found in the
+    //! bDeviceClass field.
+    //
+    uint8_t bDeviceSubClass;
+
+    //
+    //! The device protocol code.  This value is qualified by the values of
+    //! bDeviceClass and bDeviceSubClass.
+    //
+    uint8_t bDeviceProtocol;
+
+    //
+    //! The maximum packet size for endpoint zero when operating at a speed
+    //! other than high speed.
+    //
+    uint8_t bMaxPacketSize0;
+
+    //
+    //! The number of other-speed configurations supported.
+    //
+    uint8_t bNumConfigurations;
+
+    //
+    //! Reserved for future use.  Must be set to zero.
+    //
+    uint8_t bReserved;
+}
+PACKED tDeviceQualifierDescriptor;
+
+//*****************************************************************************
+//
+//! This structure describes the USB configuration descriptor as defined in
+//! USB 2.0 specification section 9.6.3.  This structure also applies to the
+//! USB other speed configuration descriptor defined in section 9.6.4.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The length of this descriptor in bytes.  All configuration descriptors
+    //! are 9 bytes long.
+    //
+    uint8_t bLength;
+
+    //
+    //! The type of the descriptor.  For a configuration descriptor, this will
+    //! be USB_DTYPE_CONFIGURATION (2).
+    //
+    uint8_t bDescriptorType;
+
+    //
+    //! The total length of data returned for this configuration.  This
+    //! includes the combined length of all descriptors (configuration,
+    //! interface, endpoint and class- or vendor-specific) returned for this
+    //! configuration.
+    //
+    uint16_t wTotalLength;
+
+    //
+    //! The number of interface supported by this configuration.
+    //
+    uint8_t bNumInterfaces;
+
+    //
+    //! The value used as an argument to the SetConfiguration standard request
+    //! to select this configuration.
+    //
+    uint8_t bConfigurationValue;
+
+    //
+    //! The index of a string descriptor describing this configuration.
+    //
+    uint8_t iConfiguration;
+
+    //
+    //! Attributes of this configuration.
+    //
+    uint8_t bmAttributes;
+
+    //
+    //! The maximum power consumption of the USB device from the bus in this
+    //! configuration when the device is fully operational.  This is expressed
+    //! in units of 2mA so, for example, 100 represents 200mA.
+    //
+    uint8_t bMaxPower;
+}
+PACKED tConfigDescriptor;
+
+//*****************************************************************************
+//
+// Flags used in constructing the value assigned to the field
+// tConfigDescriptor.bmAttributes.  Note that bit 7 is reserved and must be set
+// to 1.
+//
+//*****************************************************************************
+#define USB_CONF_ATTR_PWR_M     0xC0
+
+#define USB_CONF_ATTR_SELF_PWR  0xC0
+#define USB_CONF_ATTR_BUS_PWR   0x80
+#define USB_CONF_ATTR_RWAKE     0xA0
+
+//*****************************************************************************
+//
+//! This structure describes the USB interface descriptor as defined in USB
+//! 2.0 specification section 9.6.5.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The length of this descriptor in bytes.  All interface descriptors
+    //! are 9 bytes long.
+    //
+    uint8_t bLength;
+
+    //
+    //! The type of the descriptor.  For an interface descriptor, this will
+    //! be USB_DTYPE_INTERFACE (4).
+    //
+    uint8_t bDescriptorType;
+
+    //
+    //! The number of this interface.  This is a zero based index into the
+    //! array of concurrent interfaces supported by this configuration.
+    //
+    uint8_t bInterfaceNumber;
+
+    //
+    //! The value used to select this alternate setting for the interface
+    //! defined in bInterfaceNumber.
+    //
+    uint8_t bAlternateSetting;
+
+    //
+    //! The number of endpoints used by this interface (excluding endpoint
+    //! zero).
+    //
+    uint8_t bNumEndpoints;
+
+    //
+    //! The interface class code as assigned by the USB-IF.
+    //
+    uint8_t bInterfaceClass;
+
+    //
+    //! The interface subclass code as assigned by the USB-IF.
+    //
+    uint8_t bInterfaceSubClass;
+
+    //
+    //! The interface protocol code as assigned by the USB-IF.
+    //
+    uint8_t bInterfaceProtocol;
+
+    //
+    //! The index of a string descriptor describing this interface.
+    //
+    uint8_t iInterface;
+}
+PACKED tInterfaceDescriptor;
+
+//*****************************************************************************
+//
+//! This structure describes the USB endpoint descriptor as defined in USB
+//! 2.0 specification section 9.6.6.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The length of this descriptor in bytes.  All endpoint descriptors
+    //! are 7 bytes long.
+    //
+    uint8_t bLength;
+
+    //
+    //! The type of the descriptor.  For an endpoint descriptor, this will
+    //! be USB_DTYPE_ENDPOINT (5).
+    //
+    uint8_t bDescriptorType;
+
+    //
+    //! The address of the endpoint.  This field contains the endpoint number
+    //! ORed with flag USB_EP_DESC_OUT or USB_EP_DESC_IN to indicate the
+    //! endpoint direction.
+    //
+    uint8_t bEndpointAddress;
+
+    //
+    //! The endpoint transfer type, USB_EP_ATTR_CONTROL, USB_EP_ATTR_ISOC,
+    //! USB_EP_ATTR_BULK or USB_EP_ATTR_INT and, if isochronous, additional
+    //! flags indicating usage type and synchronization method.
+    //
+    uint8_t bmAttributes;
+
+    //
+    //! The maximum packet size this endpoint is capable of sending or
+    //! receiving when this configuration is selected.  For high speed
+    //! isochronous or interrupt endpoints, bits 11 and 12 are used to
+    //! pass additional information.
+    //
+    uint16_t wMaxPacketSize;
+
+    //
+    //! The polling interval for data transfers expressed in frames or
+    //! micro frames depending upon the operating speed.
+    //
+    uint8_t bInterval;
+}
+PACKED tEndpointDescriptor;
+
+//*****************************************************************************
+//
+// Flags used in constructing the value assigned to the field
+// tEndpointDescriptor.bEndpointAddress.
+//
+//*****************************************************************************
+#define USB_EP_DESC_OUT         0x00
+#define USB_EP_DESC_IN          0x80
+#define USB_EP_DESC_NUM_M       0x0f
+
+//*****************************************************************************
+//
+// Mask used to extract the maximum packet size (in bytes) from the
+// wMaxPacketSize field of the endpoint descriptor.
+//
+//*****************************************************************************
+#define USB_EP_MAX_PACKET_COUNT_M                                             \
+                                0x07FF
+
+//*****************************************************************************
+//
+// Endpoint attributes used in tEndpointDescriptor.bmAttributes.
+//
+//*****************************************************************************
+#define USB_EP_ATTR_CONTROL     0x00
+#define USB_EP_ATTR_ISOC        0x01
+#define USB_EP_ATTR_BULK        0x02
+#define USB_EP_ATTR_INT         0x03
+#define USB_EP_ATTR_TYPE_M      0x03
+
+#define USB_EP_ATTR_ISOC_M      0x0c
+#define USB_EP_ATTR_ISOC_NOSYNC 0x00
+#define USB_EP_ATTR_ISOC_ASYNC  0x04
+#define USB_EP_ATTR_ISOC_ADAPT  0x08
+#define USB_EP_ATTR_ISOC_SYNC   0x0c
+#define USB_EP_ATTR_USAGE_M     0x30
+#define USB_EP_ATTR_USAGE_DATA  0x00
+#define USB_EP_ATTR_USAGE_FEEDBACK                                            \
+                                0x10
+#define USB_EP_ATTR_USAGE_IMPFEEDBACK                                         \
+                                0x20
+
+//*****************************************************************************
+//
+//! This structure describes the USB string descriptor for index 0 as defined
+//! in USB 2.0 specification section 9.6.7.  Note that the number of language
+//! IDs is variable and can be determined by examining bLength.  The number of
+//! language IDs present in the descriptor is given by ((bLength - 2) / 2).
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The length of this descriptor in bytes.  This value will vary
+    //! depending upon the number of language codes provided in the descriptor.
+    //
+    uint8_t bLength;
+
+    //
+    //! The type of the descriptor.  For a string descriptor, this will be
+    //! USB_DTYPE_STRING (3).
+    //
+    uint8_t bDescriptorType;
+
+    //
+    //! The language code (LANGID) for the first supported language.  Note that
+    //! this descriptor may support multiple languages, in which case, the
+    //! number of elements in the wLANGID array will increase and bLength will
+    //! be updated accordingly.
+    //
+    uint16_t wLANGID[1];
+}
+PACKED tString0Descriptor;
+
+//*****************************************************************************
+//
+//! This structure describes the USB string descriptor for all string indexes
+//! other than 0 as defined in USB 2.0 specification section 9.6.7.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The length of this descriptor in bytes.  This value will be 2 greater
+    //! than the number of bytes comprising the UNICODE string that the
+    //! descriptor contains.
+    //
+    uint8_t bLength;
+
+    //
+    //! The type of the descriptor.  For a string descriptor, this will be
+    //! USB_DTYPE_STRING (3).
+    //
+    uint8_t bDescriptorType;
+
+    //
+    //! The first byte of the UNICODE string.  This string is not NULL
+    //! terminated.  Its length (in bytes) can be computed by subtracting 2
+    //! from the value in the bLength field.
+    //
+    uint8_t bString;
+}
+PACKED tStringDescriptor;
+
+//*****************************************************************************
+//
+//! Write a 16-bit value to a USB descriptor block.
+//!
+//! \param ui16Value is the 16-bit value to write to the descriptor.
+//!
+//! This helper macro is used in descriptor definitions to write two-byte
+//! values.  Since the configuration descriptor contains all interface and
+//! endpoint descriptors in a contiguous block of memory, these descriptors are
+//! typically defined using an array of bytes rather than as packed structures.
+//!
+//! \return Not a function.
+//
+//*****************************************************************************
+#define USBShort(ui16Value)     (ui16Value & 0xff), (ui16Value >> 8)
+
+//*****************************************************************************
+//
+//! Write a 24-bit value to a USB descriptor block.
+//!
+//! \param ui32Value is the 24-bit value that to write to the descriptor.
+//!
+//! This helper macro is used in descriptor definitions to write three-byte
+//! values.  Since the configuration descriptor contains all interface and
+//! endpoint descriptors in a contiguous block of memory, these descriptors are
+//! typically defined using an array of bytes rather than as packed structures.
+//!
+//! \return Not a function.
+//
+//*****************************************************************************
+#define USB3Byte(ui32Value)     (ui32Value & 0xff),                           \
+                                ((ui32Value >> 8) & 0xff),                    \
+                                ((ui32Value >> 16) & 0xff)
+
+//*****************************************************************************
+//
+//! Write a 32-bit value to a USB descriptor block.
+//!
+//! \param ui32Value is the 32-bit value that to write to the descriptor.
+//!
+//! This helper macro is used in descriptor definitions to write four-byte
+//! values.  Since the configuration descriptor contains all interface and
+//! endpoint descriptors in a contiguous block of memory, these descriptors are
+//! typically defined using an array of bytes rather than as packed structures.
+//!
+//! \return Not a function.
+//
+//*****************************************************************************
+#define USBLong(ui32Value)      (ui32Value & 0xff),                           \
+                                ((ui32Value >> 8) & 0xff),                    \
+                                ((ui32Value >> 16) & 0xff),                   \
+                                ((ui32Value >> 24) & 0xff)
+
+//*****************************************************************************
+//
+//! Traverse to the next USB descriptor in a block.
+//!
+//! \param ptr points to the first byte of a descriptor in a block of
+//! USB descriptors.
+//!
+//! This macro aids in traversing lists of descriptors by returning a pointer
+//! to the next descriptor in the list given a pointer to the current one.
+//!
+//! \return Returns a pointer to the next descriptor in the block following
+//! \e ptr.
+//!
+//*****************************************************************************
+#define NEXT_USB_DESCRIPTOR(ptr)                                              \
+                                (tDescriptorHeader *)(((uint8_t *)(ptr)) +    \
+                                                      *((uint8_t *)(ptr)))
+
+//*****************************************************************************
+//
+// Return to default packing when using the IAR Embedded Workbench compiler.
+//
+//*****************************************************************************
+#ifdef ewarm
+#pragma pack()
+#endif
+
+//*****************************************************************************
+//
+// Close the usbchap9_src Doxygen group.
+//! @}
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! \addtogroup device_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Function prototype for any standard USB request.
+//
+//*****************************************************************************
+typedef void (* tStdRequest)(void *pvInstance, tUSBRequest *pUSBRequest);
+
+//*****************************************************************************
+//
+// Data callback for receiving data from an endpoint.
+//
+//*****************************************************************************
+typedef void (* tInfoCallback)(void *pvInstance, uint32_t ui32Info);
+
+//*****************************************************************************
+//
+// Callback made to indicate that an interface alternate setting change has
+// occurred.
+//
+//*****************************************************************************
+typedef void (* tInterfaceCallback)(void *pvInstance, uint8_t ui8InterfaceNum,
+                                    uint8_t ui8AlternateSetting);
+
+//*****************************************************************************
+//
+// Generic interrupt handler callbacks.
+//
+//*****************************************************************************
+typedef void (* tUSBIntHandler)(void *pvInstance);
+
+//*****************************************************************************
+//
+// Interrupt handler callbacks that have status information.
+//
+//*****************************************************************************
+typedef void (* tUSBEPIntHandler)(void *pvInstance, uint32_t ui32Status);
+
+//*****************************************************************************
+//
+//! Generic handler callbacks that are used when the callers needs to call into
+//! an instance of class.
+//
+//*****************************************************************************
+typedef void (* tUSBDeviceHandler)(void *pvInstance, uint32_t ui32Request,
+                                   void *pvRequestData);
+
+//*****************************************************************************
+//
+//! USB event handler functions used during enumeration and operation of the
+//! device stack.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! This callback is made whenever the USB host requests a non-standard
+    //! descriptor from the device.
+    //
+    tStdRequest pfnGetDescriptor;
+
+    //
+    //! This callback is made whenever the USB host makes a non-standard
+    //! request.
+    //
+    tStdRequest pfnRequestHandler;
+
+    //
+    //! This callback is made in response to a SetInterface request from the
+    //! host.
+    //
+    tInterfaceCallback pfnInterfaceChange;
+
+    //
+    //! This callback is made in response to a SetConfiguration request from
+    //! the host.
+    //
+    tInfoCallback pfnConfigChange;
+
+    //
+    //! This callback is made when data has been received following to a call
+    //! to USBDCDRequestDataEP0.
+    //
+    tInfoCallback pfnDataReceived;
+
+    //
+    //! This callback is made when data has been transmitted following a call
+    //! to USBDCDSendDataEP0.
+    //
+    tInfoCallback pfnDataSent;
+
+    //
+    //! This callback is made when a USB reset is detected.
+    //
+    tUSBIntHandler pfnResetHandler;
+
+    //
+    //! This callback is made when the bus has been inactive long enough to
+    //! trigger a suspend condition.
+    //
+    tUSBIntHandler pfnSuspendHandler;
+
+    //
+    //! This is called when resume signaling is detected.
+    //
+    tUSBIntHandler pfnResumeHandler;
+
+    //
+    //! This callback is made when the device is disconnected from the USB bus.
+    //
+    tUSBIntHandler pfnDisconnectHandler;
+
+    //
+    //! This callback is made to inform the device of activity on all endpoints
+    //! other than endpoint zero.
+    //
+    tUSBEPIntHandler pfnEndpointHandler;
+
+    //
+    //! This generic handler is provided to allow requests based on
+    //! a given instance to be passed into a device.  This is commonly used
+    //! by a top level composite device that is using multiple instances of
+    //! a class.
+    //
+    tUSBDeviceHandler pfnDeviceHandler;
+}
+tCustomHandlers;
+
+//*****************************************************************************
+//
+//! This structure defines a contiguous block of data which contains a group
+//! of descriptors that form part of a configuration descriptor for a device.
+//! It is assumed that a config section contains only whole descriptors.  It is
+//! not valid to split a single descriptor across multiple sections.
+//!
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The number of bytes of descriptor data pointed to by pui8Data.
+    //
+    uint16_t ui16Size;
+
+    //
+    //! A pointer to a block of data containing an integral number of
+    //! USB descriptors which form part of a larger configuration descriptor.
+    //
+    const uint8_t *pui8Data;
+}
+tConfigSection;
+
+//*****************************************************************************
+//
+//! This is the top level structure defining a USB device configuration
+//! descriptor.  A configuration descriptor contains a collection of device-
+//! specific descriptors in addition to the basic config, interface and
+//! endpoint descriptors.  To allow flexibility in constructing the
+//! configuration, the descriptor is described in terms of a list of data
+//! blocks.  The first block must contain the configuration descriptor itself
+//! and the following blocks are appended to this in order to produce the
+//! full descriptor sent to the host in response to a GetDescriptor request
+//! for the configuration descriptor.
+//!
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The number of sections comprising the full descriptor for this
+    //! configuration.
+    //
+    uint8_t ui8NumSections;
+
+    //
+    //! A pointer to an array of ui8NumSections section pointers which must
+    //! be concatenated to form the configuration descriptor.
+    //
+    const tConfigSection * const *psSections;
+}
+tConfigHeader;
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! \addtogroup general_usblib_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Predeclare of the DMA instance structure.
+//
+//*****************************************************************************
+typedef struct tUSBDMAInstance tUSBDMAInstance;
+
+//*****************************************************************************
+//
+// USB descriptor parsing functions found in usbdesc.c
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! The USB_DESC_ANY label is used as a wild card in several of the descriptor
+//! parsing APIs to determine whether or not particular search criteria should
+//! be ignored.
+//
+//*****************************************************************************
+#define USB_DESC_ANY 0xFFFFFFFF
+
+extern uint32_t USBDescGetNum(tDescriptorHeader *psDesc, uint32_t ui32Size,
+                              uint32_t ui32Type);
+extern tDescriptorHeader *USBDescGet(tDescriptorHeader *psDesc,
+                                     uint32_t ui32Size, uint32_t ui32Type,
+                                     uint32_t ui32Index);
+extern uint32_t
+       USBDescGetNumAlternateInterfaces(tConfigDescriptor *psConfig,
+                                        uint8_t ui8InterfaceNumber);
+extern tInterfaceDescriptor *USBDescGetInterface(tConfigDescriptor *psConfig,
+                                                 uint32_t ui32Index,
+                                                 uint32_t ui32AltCfg);
+extern tEndpointDescriptor *
+       USBDescGetInterfaceEndpoint(tInterfaceDescriptor *psInterface,
+                                   uint32_t ui32Index, uint32_t ui32Size);
+
+//*****************************************************************************
+//
+//! The operating mode required by the USB library client.  This type is used
+//! by applications which wish to be able to switch between host and device
+//! modes by calling the USBStackModeSet() API.
+//
+//*****************************************************************************
+typedef enum
+{
+    //
+    //! Operate in USB device mode with active monitoring of VBUS and the
+    //! ID pin must be pulled to a logic high value.
+    //
+    eUSBModeDevice = 0,
+
+    //
+    //! Operate in USB host mode with active monitoring of VBUS and the ID pin
+    //! must be pulled to a logic low value.
+    //
+    eUSBModeHost,
+
+    //
+    //! Operate as an On-The-Go device which requires both VBUS and ID to be
+    //! connected directly to the USB controller from the USB connector.
+    //
+    eUSBModeOTG,
+
+    //
+    //! A marker indicating that no USB mode has yet been set by the
+    //! application.
+    //
+    eUSBModeNone,
+
+    //
+    //! Force host mode so that the VBUS and ID pins are not used or monitored
+    //! by the USB controller.
+    //
+    eUSBModeForceHost,
+
+    //
+    //! Forcing device mode so that the VBUS and ID pins are not used or
+    //! monitored by the USB controller.
+    //
+    eUSBModeForceDevice,
+}
+tUSBMode;
+
+//*****************************************************************************
+//
+// A pointer to a USB mode callback function.  This function is called by the
+// USB library to indicate to the application which operating mode it should
+// use, host or device.
+//
+//*****************************************************************************
+typedef void (*tUSBModeCallback)(uint32_t ui32Index, tUSBMode iMode);
+
+//*****************************************************************************
+//
+//! USB callback function.
+//!
+//! \param pvCBData is the callback pointer associated with the instance
+//! generating the callback.  This is a value provided by the client during
+//! initialization of the instance making the callback.
+//! \param ui32Event is the identifier of the asynchronous event which is being
+//! notified to the client.
+//! \param ui32MsgParam is an event-specific parameter.
+//! \param pvMsgData is an event-specific data pointer.
+//!
+//! A function pointer provided to the USB layer by the application
+//! which will be called to notify it of all asynchronous events relating to
+//! data transmission or reception.  This callback is used by device class
+//! drivers and host pipe functions.
+//!
+//! \return Returns an event-dependent value.
+//
+//*****************************************************************************
+typedef uint32_t (* tUSBCallback)(void *pvCBData, uint32_t ui32Event,
+                                  uint32_t ui32MsgParam, void *pvMsgData);
+
+//*****************************************************************************
+//
+// Error sources reported via USB_EVENT_ERROR.
+//
+//*****************************************************************************
+
+//
+//! The host received an invalid PID in a transaction.
+//
+#define USBERR_HOST_IN_PID_ERROR                                              \
+                                0x01000000
+
+//
+//! The host did not receive a response from a device.
+//
+#define USBERR_HOST_IN_NOT_COMP 0x00100000
+
+//
+//! The host received a stall on an IN endpoint.
+//
+#define USBERR_HOST_IN_STALL    0x00400000
+
+//
+//! The host detected a CRC or bit-stuffing error (isochronous mode).
+//
+#define USBERR_HOST_IN_DATA_ERROR                                             \
+                                0x00080000
+
+//
+//! The host received NAK on an IN endpoint for longer than the specified
+//! timeout period (interrupt, bulk and control modes).
+//
+#define USBERR_HOST_IN_NAK_TO   0x00080000
+
+//
+//! The host failed to communicate with a device via an IN endpoint.
+//
+#define USBERR_HOST_IN_ERROR    0x00040000
+
+//
+//! The host receive FIFO is full.
+//
+#define USBERR_HOST_IN_FIFO_FULL                                              \
+                                0x00020000
+//
+//! The host received NAK on an OUT endpoint for longer than the specified
+//! timeout period (bulk, interrupt and control modes).
+//
+#define USBERR_HOST_OUT_NAK_TO  0x00000080
+
+//
+//! The host did not receive a response from a device (isochronous mode).
+//
+#define USBERR_HOST_OUT_NOT_COMP                                              \
+                                0x00000080
+
+//
+//! The host received a stall on an OUT endpoint.
+//
+#define USBERR_HOST_OUT_STALL   0x00000020
+
+//
+//! The host failed to communicate with a device via an OUT endpoint.
+//
+#define USBERR_HOST_OUT_ERROR   0x00000004
+
+//
+//! The host received NAK on endpoint 0 for longer than the configured
+//! timeout.
+//
+#define USBERR_HOST_EP0_NAK_TO  0x00000080
+
+//
+//! The host failed to communicate with a device via an endpoint zero.
+//
+#define USBERR_HOST_EP0_ERROR   0x00000010
+
+//
+//! The device detected a CRC error in received data.
+//
+#define USBERR_DEV_RX_DATA_ERROR                                              \
+                                0x00080000
+
+//
+//! The device was unable to receive a packet from the host since the receive
+//! FIFO is full.
+//
+#define USBERR_DEV_RX_OVERRUN   0x00040000
+
+//
+//! The device receive FIFO is full.
+//
+#define USBERR_DEV_RX_FIFO_FULL 0x00020000
+
+//*****************************************************************************
+//
+// Close the general_usblib_api Doxygen group.
+//! @}
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! \addtogroup usblib_events
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! This structure is used to return generic event based information to an
+//! application.  The following events are currently supported:
+//! USB_EVENT_CONNECTED, USB_EVENT_DISCONNECTED, USB_EVENT_POWER_FAULT,
+//! USB_EVENT_POWER_FAULT, USB_EVENT_POWER_ENABLE,
+//! USB_EVENT_POWER_DISABLE and USB_EVENT_SOF.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! One of the USB_EVENT_ values.
+    //
+    uint32_t ui32Event;
+
+    //
+    //! The caller supplied instance value that is passed to event handlers.
+    //
+    uint32_t ui32Instance;
+}
+tEventInfo;
+
+//*****************************************************************************
+//
+// Base identifiers for groups of USB events.  These are used by both the
+// device class drivers and host layer.
+//
+// USB_CLASS_EVENT_BASE is the lowest identifier that should be used for
+// a class-specific event.  Individual event bases are defined for each
+// of the supported device class drivers.  Events with IDs between
+// USB_EVENT_BASE and USB_CLASS_EVENT_BASE are reserved for stack use.
+//
+//*****************************************************************************
+#define USB_EVENT_BASE          0x0000
+#define USB_CLASS_EVENT_BASE    0x8000
+
+//*****************************************************************************
+//
+// Event base identifiers for the various device classes supported in host
+// and device modes.
+// The first 0x800 values of a range are reserved for the device specific
+// messages and the second 0x800 values of a range are used for the host
+// specific messages for a given class.
+//
+//*****************************************************************************
+#define USBD_CDC_EVENT_BASE     (USB_CLASS_EVENT_BASE + 0)
+#define USBD_HID_EVENT_BASE     (USB_CLASS_EVENT_BASE + 0x1000)
+#define USBD_HID_KEYB_EVENT_BASE                                              \
+                                (USBD_HID_EVENT_BASE + 0x100)
+#define USBD_BULK_EVENT_BASE    (USB_CLASS_EVENT_BASE + 0x2000)
+#define USBD_MSC_EVENT_BASE     (USB_CLASS_EVENT_BASE + 0x3000)
+#define USBD_AUDIO_EVENT_BASE   (USB_CLASS_EVENT_BASE + 0x4000)
+#define USBD_DFU_EVENT_BASE     (USB_CLASS_EVENT_BASE + 0x5000)
+
+#define USBH_CDC_EVENT_BASE     (USBD_CDC_EVENT_BASE  + 0x800)
+#define USBH_HID_EVENT_BASE     (USBD_HID_EVENT_BASE  + 0x800)
+#define USBH_BULK_EVENT_BASE    (USBD_BULK_EVENT_BASE + 0x800)
+#define USBH_MSC_EVENT_BASE     (USBD_MSC_EVENT_BASE  + 0x800)
+#define USBH_AUDIO_EVENT_BASE   (USBD_AUDIO_EVENT_BASE  + 0x800)
+
+//*****************************************************************************
+//
+// General events supported by device classes and host pipes.
+//
+//*****************************************************************************
+
+//
+//! The device is now attached to a USB host and ready to begin sending
+//! and receiving data (used by device classes only).
+//
+#define USB_EVENT_CONNECTED     (USB_EVENT_BASE + 0)
+
+//
+//! The device has been disconnected from the USB host (used by device classes
+//! only).
+//!
+//! \note In device mode, the USB_EVENT_DISCONNECTED will not be reported if
+//! the MCU's PB1/USB0VBUS pin is connected to a fixed +5 Volts rather than
+//! directly to the VBUS pin on the USB connector.
+//
+#define USB_EVENT_DISCONNECTED  (USB_EVENT_BASE + 1)
+
+//
+//! Data has been received and is in the buffer provided or is ready to be
+//! read from the FIFO.  If the \e pvMsgData value is 0 then the
+//! \e ui32MsgParam value contains the amount of data in bytes ready to be read
+//! from the device.  If the \e pvMsgData value is not 0 then \e pvMsgData is
+//! a pointer to the data that was read and \e ui32MsgParam is the number of
+//! valid bytes in the array pointed to by \e pvMsgData.
+//
+#define USB_EVENT_RX_AVAILABLE  (USB_EVENT_BASE + 2)
+
+//
+//! This event is sent by a lower layer to inquire about the amount of
+//! unprocessed data buffered in the layers above.  It is used in cases
+//! where a low level driver needs to ensure that all preceding data has
+//! been processed prior to performing some action or making some notification.
+//! Clients receiving this event should return the number of bytes of data
+//! that are unprocessed or 0 if no outstanding data remains.
+//
+#define USB_EVENT_DATA_REMAINING                                              \
+                                (USB_EVENT_BASE + 3)
+
+//
+//! This event is sent by a lower layer supporting DMA to request a buffer in
+//! which the next received packet may be stored.  The \e ui32MsgValue
+//! parameter indicates the maximum size of packet that can be received in this
+//! channel and \e pvMsgData points to storage which should be written with the
+//! returned buffer pointer.  The return value from the callback should be the
+//! size of the buffer allocated (which may be less than the maximum size
+//! passed in \e ui32MsgValue if the client knows that fewer bytes are expected
+//! to be received) or 0 if no buffer is being returned.
+//
+#define USB_EVENT_REQUEST_BUFFER                                              \
+                                (USB_EVENT_BASE + 4)
+
+//
+//! Data has been sent and acknowledged.  If this event is received via the
+//! USB buffer callback, the \e ui32MsgValue parameter indicates the number of
+//! bytes from the transmit buffer that have been successfully transmitted
+//! and acknowledged.
+//
+#define USB_EVENT_TX_COMPLETE   (USB_EVENT_BASE + 5)
+
+//
+//! An error has been reported on the channel or pipe.  The \e ui32MsgValue
+//! parameter indicates the source(s) of the error and is the logical OR
+//! combination of "USBERR_" flags defined below.
+//
+#define USB_EVENT_ERROR         (USB_EVENT_BASE + 6)
+
+//
+//! The bus has entered suspend state.
+//
+#define USB_EVENT_SUSPEND       (USB_EVENT_BASE + 7)
+
+//
+//! The bus has left suspend state.
+//
+#define USB_EVENT_RESUME        (USB_EVENT_BASE + 8)
+
+//
+//! A scheduler event has occurred.
+//
+#define USB_EVENT_SCHEDULER     (USB_EVENT_BASE + 9)
+//
+//! A device or host has detected a stall condition.
+//
+#define USB_EVENT_STALL         (USB_EVENT_BASE + 10)
+
+//
+//! The host detected a power fault condition.
+//
+#define USB_EVENT_POWER_FAULT   (USB_EVENT_BASE + 11)
+
+//
+//! The controller has detected a A-Side cable and needs power applied  This is
+//! only generated on OTG parts if automatic power control is disabled.
+//
+#define USB_EVENT_POWER_ENABLE  (USB_EVENT_BASE + 12)
+
+//
+//! The controller needs power removed,  This is only generated on OTG parts
+//! if automatic power control is disabled.
+//
+#define USB_EVENT_POWER_DISABLE (USB_EVENT_BASE + 13)
+
+//
+//! This define is used with a device class's pfnDeviceHandler handler function
+//! to indicate that the USB library has changed the interface number.  This
+//! event is typically due to the class being included in a composite device.
+//!
+//! The \e pvInstance is a pointer to an instance of the device being accessed.
+//!
+//! The \e ui32Request is USB_EVENT_COMP_IFACE_CHANGE.
+//!
+//! The \e pvRequestData is a pointer to a two byte array where the first value
+//! is the old interface number and the second is the new interface number.
+//
+#define USB_EVENT_COMP_IFACE_CHANGE                                           \
+                                (USB_EVENT_BASE + 14)
+
+//
+//! This define is used with a device class's pfnDeviceHandler handler function
+//! to indicate that the USB library has changed the endpoint number.  This
+//! event is typically due to the class being included in a composite device.
+//!
+//! The \e pvInstance is a pointer to an instance of the device being accessed.
+//!
+//! The \e ui32Request is USB_EVENT_COMP_EP_CHANGE.
+//!
+//! The \e pvRequestData is a pointer to a two byte array where the first value
+//! is the old endpoint number and the second is the new endpoint number.  The
+//! endpoint numbers should be exactly as USB specification defines them and
+//! bit 7 set indicates an IN endpoint and bit 7 clear indicates an OUT
+//! endpoint.
+//
+#define USB_EVENT_COMP_EP_CHANGE                                              \
+                                (USB_EVENT_BASE + 15)
+
+//
+//! This define is used with a device class's pfnDeviceHandler handler function
+//! to indicate that the USB library has changed the string index number for a
+//! string.  This event is typically due to the class being included in a
+//! composite device.
+//!
+//! The \e pvInstance is a pointer to an instance of the device being accessed.
+//!
+//! The \e ui32Request is USB_EVENT_COMP_STR_CHANGE.
+//!
+//! The \e pvRequestData is a pointer to a two byte array where the first value
+//! is the old string index and the second is the new string index.
+//
+#define USB_EVENT_COMP_STR_CHANGE                                             \
+                                (USB_EVENT_BASE + 16)
+
+//
+//! This define is used with a device class's pfnDeviceHandler handler function
+//! to indicate that the USB library has changed the configuration descriptor.
+//! This allows the class to make final adjustments to the configuration
+//! descriptor.  This event is typically due to the class being included in a
+//! composite device.
+//!
+//! The \e pvInstance is a pointer to an instance of the device being accessed.
+//!
+//! The \e ui32Request is USB_EVENT_COMP_CONFIG.
+//!
+//! The \e pvRequestData is a pointer to the beginning of the configuration
+//! descriptor for the device instance.
+//
+#define USB_EVENT_COMP_CONFIG   (USB_EVENT_BASE + 17)
+
+//
+//! An unknown device is now attached to a USB host.  This value is only valid
+//! for the generic event handler and not other device handlers.  It is
+//! useful for applications that want to know when an unknown device is
+//! connected and what the class is of the unknown device.
+//!
+//! The \e ui32Instance is the device instance for the unknown device.
+//
+#define USB_EVENT_UNKNOWN_CONNECTED                                           \
+                                (USB_EVENT_BASE + 18)
+
+//
+//! A start of frame event has occurred.  This event is disabled by default
+//! and must be enabled via a call from the application to USBHCDEventEnable().
+//
+#define USB_EVENT_SOF           (USB_EVENT_BASE + 19)
+
+//
+//! This event occurs when a device enters LPM sleep mode.
+//
+#define USB_EVENT_LPM_SLEEP     (USB_EVENT_BASE + 20)
+
+//
+//! This event occurs when a device is resumed from LPM sleep mode.
+//
+#define USB_EVENT_LPM_RESUME    (USB_EVENT_BASE + 21)
+
+//
+//! This event occurs when a device has responded with a NYET to an LPM request
+//! because LPM responses were disabled.
+//
+#define USB_EVENT_LPM_ERROR     (USB_EVENT_BASE + 22)
+
+//*****************************************************************************
+//
+// Close the usblib_events Doxygen group.
+//! @}
+//
+//*****************************************************************************
+//*****************************************************************************
+//
+//! \addtogroup usblib_buffer_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! A function pointer type which describes either a class driver packet read
+//! or packet write function (both have the same prototype) to the USB
+//! buffer object.
+//
+//*****************************************************************************
+typedef uint32_t (* tUSBPacketTransfer)(void *pvHandle, uint8_t *pi8Data,
+                                        uint32_t ui32Length, bool bLast);
+
+//*****************************************************************************
+//
+//! A function pointer type which describes either a class driver transmit
+//! or receive packet available function (both have the same prototype) to the
+//! USB buffer object.
+//!
+//! \param pvHandle is the handle of the device.
+//!
+//! \return None.
+//
+//*****************************************************************************
+typedef uint32_t (* tUSBPacketAvailable)(void *pvHandle);
+
+//*****************************************************************************
+//
+//! The number of bytes of workspace that each USB buffer object requires.
+//! This workspace memory is provided to the buffer on USBBufferInit() in
+//! the \e pvWorkspace field of the \e tUSBBuffer structure.
+//
+//*****************************************************************************
+#define USB_BUFFER_WORKSPACE_SIZE                                             \
+                                24
+//*****************************************************************************
+//
+// The defines used with the USBDCDFeatureSet() or USBHCDFeatureSet() calls.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! This feature setting enables or disables LPM support in the USB library in
+//! either host or device mode depending on if the USBHCDFeatureSet() or
+//! USBDCDFeatureSet() is called.  If no action is taken the default behavior of
+//! USB library is to not support LPM transactions.  The \e pvFeature value
+//! is a pointer to a 32-bit value containing the a logical OR of the following
+//! values:
+//!
+//! - \b USBLIB_FEATURE_LPM_EN is used to enable LPM support in host or device
+//!      mode.
+//! - \b USBLIB_FEATURE_LPM_DIS(default) is used to disable LPM support in host
+//!      or device mode.
+//! - \b USBLIB_FEATURE_LPM_RMT_WAKE is used to enable remote wake from an
+//!      LPM suspended state.
+//!
+//
+//*****************************************************************************
+#define USBLIB_FEATURE_LPM      0x00000001
+
+//*****************************************************************************
+//
+// The defines used with the USBDCDFeatureSet() or USBHCDFeatureSet() calls
+// for \b USBLIB_FEATURE_LPM feature requests.
+//
+//*****************************************************************************
+#define USBLIB_FEATURE_LPM_RMT_WAKE                                           \
+                                0x00000002
+#define USBLIB_FEATURE_LPM_EN   0x00000001
+#define USBLIB_FEATURE_LPM_DIS  0x00000000
+
+//*****************************************************************************
+//
+//! This feature setting allows an application to inform the USB library of the
+//! current processor speed that is can use for internal timing when the frame
+//! counter is not yet running.  The \e pvFeature is a pointer to a 32-bit
+//! value that holds the processor frequency in Hz.
+//
+//*****************************************************************************
+#define USBLIB_FEATURE_CPUCLK   0x00000002
+
+//*****************************************************************************
+//
+//! This feature setting allows an application to inform the USB library of the
+//! current USB PLL rate in cases where the USB library needs this information
+//! for internal configuration.  If this feature is not set, then default rate
+//! for the USB PLL is 480MHz.  The \e pvFeature is a pointer to an 32-bit
+//! value that holds the USB PLL speed in Hz.  If the application needs to use
+//! an external USB clock the PLL value should be set to zero.  This is used
+//! when connecting to an external USB phy which is providing the 60-MHz clock.
+//!
+//
+//*****************************************************************************
+#define USBLIB_FEATURE_USBPLL   0x00000003
+
+//*****************************************************************************
+//!
+//! This feature setting allows an application to disable or configure and
+//! enable the ULPI features in the USB library.  If this feature is not set,
+//! the default behavior is to not support ULPI operation.  The \e pvFeature is
+//! a pointer to an 32-bit value that holds the USB ULPI configuration.  The
+//! following are the valid settings for this feature:
+//!
+//! - USBLIB_FEATURE_ULPI_NONE disables all ULPI support.
+//! - USBLIB_FEATURE_ULPI_HS enable ULPI with high speed support.
+//! - USBLIB_FEATURE_ULPI_FS enable ULPI with full speed support.
+//
+//*****************************************************************************
+#define USBLIB_FEATURE_USBULPI  0x00000004
+
+//*****************************************************************************
+//
+// The defines used with the USBDCDFeatureSet() or USBHCDFeatureSet() calls
+// for \b USBLIB_FEATURE_USBULPI feature requests.
+//
+//*****************************************************************************
+#define USBLIB_FEATURE_ULPI_NONE                                              \
+                                0x00000000
+#define USBLIB_FEATURE_ULPI_HS  0x00000010
+#define USBLIB_FEATURE_ULPI_FS  0x00000020
+
+//*****************************************************************************
+//
+//! This feature setting enables or disables various power settings in the USB
+//! library in either host or device mode depending on if the
+//! USBHCDFeatureSet() or USBDCDFeatureSet() is called.  The \e pvFeature value
+//! is a pointer to a 32-bit value containing the a logical OR of the following
+//! values:
+//!
+//! - \b USBLIB_FEATURE_POWER_BUS - USB device mode is bus powered(default).
+//! - \b USBLIB_FEATURE_POWER_SELF - USB device mode is self powered.
+//! - \b USBLIB_FEATURE_REMOTE_WAKE - Enable USB remote wake feature.
+//
+//*****************************************************************************
+#define USBLIB_FEATURE_POWER    0x00000005
+
+//*****************************************************************************
+//
+// The defines used with the USBDCDFeatureSet() or USBHCDFeatureSet() calls
+// for \b USBLIB_FEATURE_POWER feature requests.
+//
+//*****************************************************************************
+#define USBLIB_FEATURE_POWER_SELF                                             \
+                                0x00000001
+#define USBLIB_FEATURE_POWER_BUS                                              \
+                                0x00000000
+#define USBLIB_FEATURE_REMOTE_WAKE                                            \
+                                0x00000002
+
+//*****************************************************************************
+//
+// The structure used with the USBDCDFeatureSet() or USBHCDFeatureSet() calls
+// to set feature enables and resume timing parameter.
+//
+//*****************************************************************************
+typedef struct
+{
+    uint32_t ui32HIRD;
+    uint32_t ui32Features;
+}
+tLPMFeature;
+
+//*****************************************************************************
+//
+//! The structure used by the application to initialize a buffer object that
+//! will provide buffered access to either a transmit or receive channel.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! This field sets the mode of the buffer.  If true, the buffer
+    //! operates as a transmit buffer and supports calls to USBBufferWrite
+    //! by the client.  If false, the buffer operates as a receive buffer
+    //! and supports calls to USBBufferRead.
+    //
+    bool bTransmitBuffer;
+
+    //
+    //! A pointer to the callback function which will be called to notify
+    //! the application of all asynchronous events related to the operation
+    //! of the buffer.
+    //
+    tUSBCallback pfnCallback;
+
+    //
+    //! A pointer that the buffer will pass back to the client in the
+    //! first parameter of all callbacks related to this instance.
+    //
+    void *pvCBData;
+
+    //
+    //! The function which should be called to transmit a packet of data
+    //! in transmit mode or receive a packet in receive mode.
+    //
+    tUSBPacketTransfer pfnTransfer;
+
+    //
+    //! The function which should be called to determine if the endpoint is
+    //! ready to accept a new packet for transmission in transmit mode or
+    //! to determine the size of the buffer required to read a packet in
+    //! receive mode.
+    //
+    tUSBPacketAvailable pfnAvailable;
+
+    //
+    //! The handle to pass to the low level function pointers
+    //! provided in the pfnTransfer and pfnAvailable members.  For USB device
+    //! use, this is the psDevice parameter required by the relevant device
+    //! class driver APIs.  For USB host use, this is the pipe identifier
+    //! returned by USBHCDPipeAlloc.
+    //
+    void *pvHandle;
+
+    //
+    //! A pointer to memory to be used as the ring buffer for this
+    //! instance.
+    //
+    uint8_t *pui8Buffer;
+
+    //
+    //! The size, in bytes, of the buffer pointed to by pi8Buffer.
+    //
+    uint32_t ui32BufferSize;
+
+    //
+    //! A pointer to USB_BUFFER_WORKSPACE_SIZE bytes of RAM that the buffer
+    //! object can use for workspace.
+    //
+    void *pvWorkspace;
+}
+tUSBBuffer;
+
+//*****************************************************************************
+//
+//! The structure used for encapsulating all the items associated with a
+//! ring buffer.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The ring buffer size.
+    //
+    uint32_t ui32Size;
+
+    //
+    //! The ring buffer write index.
+    //
+    volatile uint32_t ui32WriteIndex;
+
+    //
+    //! The ring buffer read index.
+    //
+    volatile uint32_t ui32ReadIndex;
+
+    //
+    //! The ring buffer.
+    //
+    uint8_t *pui8Buf;
+}
+tUSBRingBufObject;
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// USB buffer API function prototypes.
+//
+//*****************************************************************************
+extern const tUSBBuffer *USBBufferInit(const tUSBBuffer *psBuffer);
+extern void USBBufferZeroLengthPacketInsert(const tUSBBuffer *psBuffer,
+                                            bool bSendZLP);
+extern void USBBufferInfoGet(const tUSBBuffer *psBuffer,
+                             tUSBRingBufObject *psRingBuf);
+extern void *USBBufferCallbackDataSet(tUSBBuffer *psBuffer, void *pvCBData);
+extern uint32_t USBBufferWrite(const tUSBBuffer *psBuffer,
+                               const uint8_t *pui8Data, uint32_t ui32Length);
+extern void USBBufferDataWritten(const tUSBBuffer *psBuffer,
+                                 uint32_t ui32Length);
+extern void USBBufferDataRemoved(const tUSBBuffer *psBuffer,
+                                 uint32_t ui32Length);
+extern void USBBufferFlush(const tUSBBuffer *psBuffer);
+extern uint32_t USBBufferRead(const tUSBBuffer *psBuffer, uint8_t *pui8Data,
+                              uint32_t ui32Length);
+extern uint32_t USBBufferDataAvailable(const tUSBBuffer *psBuffer);
+extern uint32_t USBBufferSpaceAvailable(const tUSBBuffer *psBuffer);
+extern uint32_t USBBufferEventCallback(void *pvCBData, uint32_t ui32Event,
+                                       uint32_t ui32MsgValue, void *pvMsgData);
+extern bool USBRingBufFull(tUSBRingBufObject *psUSBRingBuf);
+extern bool USBRingBufEmpty(tUSBRingBufObject *psUSBRingBuf);
+extern void USBRingBufFlush(tUSBRingBufObject *psUSBRingBuf);
+extern uint32_t USBRingBufUsed(tUSBRingBufObject *psUSBRingBuf);
+extern uint32_t USBRingBufFree(tUSBRingBufObject *psUSBRingBuf);
+extern uint32_t USBRingBufContigUsed(tUSBRingBufObject *psUSBRingBuf);
+extern uint32_t USBRingBufContigFree(tUSBRingBufObject *psUSBRingBuf);
+extern uint32_t USBRingBufSize(tUSBRingBufObject *psUSBRingBuf);
+extern uint8_t USBRingBufReadOne(tUSBRingBufObject *psUSBRingBuf);
+extern void USBRingBufRead(tUSBRingBufObject *psUSBRingBuf,
+                           uint8_t *pui8Data, uint32_t ui32Length);
+extern void USBRingBufWriteOne(tUSBRingBufObject *psUSBRingBuf,
+                               uint8_t ui8Data);
+extern void USBRingBufWrite(tUSBRingBufObject *psUSBRingBuf,
+                            const uint8_t *pui8Data, uint32_t ui32Length);
+extern void USBRingBufAdvanceWrite(tUSBRingBufObject *psUSBRingBuf,
+                                   uint32_t ui32NumBytes);
+extern void USBRingBufAdvanceRead(tUSBRingBufObject *psUSBRingBuf,
+                                  uint32_t ui32NumBytes);
+extern void USBRingBufInit(tUSBRingBufObject *psUSBRingBuf,
+                           uint8_t *pui8Buf, uint32_t ui32Size);
+
+//*****************************************************************************
+//
+// Mode selection and dual mode interrupt steering functions.
+//
+//*****************************************************************************
+extern void USBStackModeSet(uint32_t ui32Index, tUSBMode iUSBMode,
+                            tUSBModeCallback pfnCallback);
+extern void USBDualModeInit(uint32_t ui32Index);
+extern void USBDualModeTerm(uint32_t ui32Index);
+extern void USBOTGMain(uint32_t ui32MsTicks);
+extern void USBOTGPollRate(uint32_t ui32Index, uint32_t ui32PollRate);
+extern void USBOTGModeInit(uint32_t ui32Index, uint32_t ui32PollRate,
+                           void *pHostData, uint32_t ui32HostDataSize);
+extern void USBOTGModeTerm(uint32_t ui32Index);
+extern void USB0OTGModeIntHandler(void);
+extern bool USBOTGFeatureSet(uint32_t ui32Index, uint32_t ui32Feature,
+                             void *pvFeature);
+extern void USB0DualModeIntHandler(void);
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __USBLIB_H__
diff --git a/bsp/tm4c129x/libraries/usblib/usblib.uvopt b/bsp/tm4c129x/libraries/usblib/usblib.uvopt
new file mode 100755
index 0000000..38fb6ab
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/usblib.uvopt
@@ -0,0 +1,650 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
+<ProjectOpt xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="project_opt.xsd">
+
+  <SchemaVersion>1.0</SchemaVersion>
+
+  <Header>### uVision Project, (C) Keil Software</Header>
+
+  <Extensions>
+    <cExt>*.c</cExt>
+    <aExt>*.s*; *.src; *.a*</aExt>
+    <oExt>*.obj</oExt>
+    <lExt>*.lib</lExt>
+    <tExt>*.txt; *.h; *.inc</tExt>
+    <pExt>*.plm</pExt>
+    <CppX>*.cpp</CppX>
+  </Extensions>
+
+  <DaveTm>
+    <dwLowDateTime>0</dwLowDateTime>
+    <dwHighDateTime>0</dwHighDateTime>
+  </DaveTm>
+
+  <Target>
+    <TargetName>usblib</TargetName>
+    <ToolsetNumber>0x4</ToolsetNumber>
+    <ToolsetName>ARM-ADS</ToolsetName>
+    <TargetOption>
+      <CLKADS>8000000</CLKADS>
+      <OPTTT>
+        <gFlags>1</gFlags>
+        <BeepAtEnd>1</BeepAtEnd>
+        <RunSim>1</RunSim>
+        <RunTarget>0</RunTarget>
+      </OPTTT>
+      <OPTHX>
+        <HexSelection>1</HexSelection>
+        <FlashByte>65535</FlashByte>
+        <HexRangeLowAddress>0</HexRangeLowAddress>
+        <HexRangeHighAddress>0</HexRangeHighAddress>
+        <HexOffset>0</HexOffset>
+      </OPTHX>
+      <OPTLEX>
+        <PageWidth>79</PageWidth>
+        <PageLength>66</PageLength>
+        <TabStop>8</TabStop>
+        <ListingPath>.\rvmdk\</ListingPath>
+      </OPTLEX>
+      <ListingPage>
+        <CreateCListing>1</CreateCListing>
+        <CreateAListing>1</CreateAListing>
+        <CreateLListing>1</CreateLListing>
+        <CreateIListing>0</CreateIListing>
+        <AsmCond>1</AsmCond>
+        <AsmSymb>1</AsmSymb>
+        <AsmXref>0</AsmXref>
+        <CCond>1</CCond>
+        <CCode>0</CCode>
+        <CListInc>0</CListInc>
+        <CSymb>0</CSymb>
+        <LinkerCodeListing>0</LinkerCodeListing>
+      </ListingPage>
+      <OPTXL>
+        <LMap>1</LMap>
+        <LComments>1</LComments>
+        <LGenerateSymbols>1</LGenerateSymbols>
+        <LLibSym>1</LLibSym>
+        <LLines>1</LLines>
+        <LLocSym>1</LLocSym>
+        <LPubSym>1</LPubSym>
+        <LXref>0</LXref>
+        <LExpSel>0</LExpSel>
+      </OPTXL>
+      <OPTFL>
+        <tvExp>1</tvExp>
+        <tvExpOptDlg>0</tvExpOptDlg>
+        <IsCurrentTarget>1</IsCurrentTarget>
+      </OPTFL>
+      <CpuCode>255</CpuCode>
+      <Books>
+        <Book>
+          <Number>0</Number>
+          <Title>Data Sheet</Title>
+          <Path>DATASHTS\Luminary\TM4C1230C3PM.PDF</Path>
+        </Book>
+      </Books>
+      <DllOpt>
+        <SimDllName>SARMCM3.DLL</SimDllName>
+        <SimDllArguments>-MPU</SimDllArguments>
+        <SimDlgDllName>DCM.DLL</SimDlgDllName>
+        <SimDlgDllArguments>-pCM4</SimDlgDllArguments>
+        <TargetDllName>SARMCM3.DLL</TargetDllName>
+        <TargetDllArguments>-MPU</TargetDllArguments>
+        <TargetDlgDllName>TCM.DLL</TargetDlgDllName>
+        <TargetDlgDllArguments>-pCM4</TargetDlgDllArguments>
+      </DllOpt>
+      <DebugOpt>
+        <uSim>1</uSim>
+        <uTrg>0</uTrg>
+        <sLdApp>1</sLdApp>
+        <sGomain>1</sGomain>
+        <sRbreak>1</sRbreak>
+        <sRwatch>1</sRwatch>
+        <sRmem>1</sRmem>
+        <sRfunc>1</sRfunc>
+        <sRbox>1</sRbox>
+        <tLdApp>1</tLdApp>
+        <tGomain>0</tGomain>
+        <tRbreak>1</tRbreak>
+        <tRwatch>1</tRwatch>
+        <tRmem>1</tRmem>
+        <tRfunc>0</tRfunc>
+        <tRbox>1</tRbox>
+        <sRunDeb>0</sRunDeb>
+        <sLrtime>0</sLrtime>
+        <nTsel>3</nTsel>
+        <sDll></sDll>
+        <sDllPa></sDllPa>
+        <sDlgDll></sDlgDll>
+        <sDlgPa></sDlgPa>
+        <sIfile></sIfile>
+        <tDll></tDll>
+        <tDllPa></tDllPa>
+        <tDlgDll></tDlgDll>
+        <tDlgPa></tDlgPa>
+        <tIfile></tIfile>
+        <pMon>BIN\lmidk-agdi.dll</pMon>
+      </DebugOpt>
+      <TargetDriverDllRegistry>
+        <SetRegEntry>
+          <Number>0</Number>
+          <Key>lmidk-agdi</Key>
+          <Name>-O4622 -S3 -FO29</Name>
+        </SetRegEntry>
+      </TargetDriverDllRegistry>
+      <DebugFlag>
+        <trace>0</trace>
+        <periodic>1</periodic>
+        <aLwin>0</aLwin>
+        <aCover>0</aCover>
+        <aSer1>0</aSer1>
+        <aSer2>0</aSer2>
+        <aPa>0</aPa>
+        <viewmode>0</viewmode>
+        <vrSel>0</vrSel>
+        <aSym>0</aSym>
+        <aTbox>0</aTbox>
+        <AscS1>0</AscS1>
+        <AscS2>0</AscS2>
+        <AscS3>0</AscS3>
+        <aSer3>0</aSer3>
+        <eProf>0</eProf>
+        <aLa>0</aLa>
+        <aPa1>0</aPa1>
+        <AscS4>0</AscS4>
+        <aSer4>0</aSer4>
+        <StkLoc>0</StkLoc>
+        <TrcWin>0</TrcWin>
+        <newCpu>0</newCpu>
+        <uProt>0</uProt>
+      </DebugFlag>
+      <LintExecutable></LintExecutable>
+      <LintConfigFile></LintConfigFile>
+    </TargetOption>
+  </Target>
+
+  <Group>
+    <GroupName>Source</GroupName>
+    <tvExp>1</tvExp>
+    <tvExpOptDlg>0</tvExpOptDlg>
+    <cbSel>0</cbSel>
+    <File>
+      <GroupNumber>1</GroupNumber>
+      <FileNumber>1</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>.\usbbuffer.c</PathWithFileName>
+      <FilenameWithoutPath>usbbuffer.c</FilenameWithoutPath>
+    </File>
+    <File>
+      <GroupNumber>1</GroupNumber>
+      <FileNumber>2</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>.\device\usbdaudio.c</PathWithFileName>
+      <FilenameWithoutPath>usbdaudio.c</FilenameWithoutPath>
+    </File>
+    <File>
+      <GroupNumber>1</GroupNumber>
+      <FileNumber>3</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>.\device\usbdbulk.c</PathWithFileName>
+      <FilenameWithoutPath>usbdbulk.c</FilenameWithoutPath>
+    </File>
+    <File>
+      <GroupNumber>1</GroupNumber>
+      <FileNumber>4</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>.\device\usbdcdc.c</PathWithFileName>
+      <FilenameWithoutPath>usbdcdc.c</FilenameWithoutPath>
+    </File>
+    <File>
+      <GroupNumber>1</GroupNumber>
+      <FileNumber>5</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>.\device\usbdcdesc.c</PathWithFileName>
+      <FilenameWithoutPath>usbdcdesc.c</FilenameWithoutPath>
+    </File>
+    <File>
+      <GroupNumber>1</GroupNumber>
+      <FileNumber>6</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>.\device\usbdcomp.c</PathWithFileName>
+      <FilenameWithoutPath>usbdcomp.c</FilenameWithoutPath>
+    </File>
+    <File>
+      <GroupNumber>1</GroupNumber>
+      <FileNumber>7</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>.\device\usbdconfig.c</PathWithFileName>
+      <FilenameWithoutPath>usbdconfig.c</FilenameWithoutPath>
+    </File>
+    <File>
+      <GroupNumber>1</GroupNumber>
+      <FileNumber>8</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>.\device\usbddfu-rt.c</PathWithFileName>
+      <FilenameWithoutPath>usbddfu-rt.c</FilenameWithoutPath>
+    </File>
+    <File>
+      <GroupNumber>1</GroupNumber>
+      <FileNumber>9</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>.\device\usbdenum.c</PathWithFileName>
+      <FilenameWithoutPath>usbdenum.c</FilenameWithoutPath>
+    </File>
+    <File>
+      <GroupNumber>1</GroupNumber>
+      <FileNumber>10</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>.\usbdesc.c</PathWithFileName>
+      <FilenameWithoutPath>usbdesc.c</FilenameWithoutPath>
+    </File>
+    <File>
+      <GroupNumber>1</GroupNumber>
+      <FileNumber>11</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>.\device\usbdhandler.c</PathWithFileName>
+      <FilenameWithoutPath>usbdhandler.c</FilenameWithoutPath>
+    </File>
+    <File>
+      <GroupNumber>1</GroupNumber>
+      <FileNumber>12</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>.\device\usbdhid.c</PathWithFileName>
+      <FilenameWithoutPath>usbdhid.c</FilenameWithoutPath>
+    </File>
+    <File>
+      <GroupNumber>1</GroupNumber>
+      <FileNumber>13</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>.\device\usbdhidgamepad.c</PathWithFileName>
+      <FilenameWithoutPath>usbdhidgamepad.c</FilenameWithoutPath>
+    </File>
+    <File>
+      <GroupNumber>1</GroupNumber>
+      <FileNumber>14</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>.\device\usbdhidkeyb.c</PathWithFileName>
+      <FilenameWithoutPath>usbdhidkeyb.c</FilenameWithoutPath>
+    </File>
+    <File>
+      <GroupNumber>1</GroupNumber>
+      <FileNumber>15</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>.\device\usbdhidmouse.c</PathWithFileName>
+      <FilenameWithoutPath>usbdhidmouse.c</FilenameWithoutPath>
+    </File>
+    <File>
+      <GroupNumber>1</GroupNumber>
+      <FileNumber>16</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>.\usbdma.c</PathWithFileName>
+      <FilenameWithoutPath>usbdma.c</FilenameWithoutPath>
+    </File>
+    <File>
+      <GroupNumber>1</GroupNumber>
+      <FileNumber>17</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>.\device\usbdmsc.c</PathWithFileName>
+      <FilenameWithoutPath>usbdmsc.c</FilenameWithoutPath>
+    </File>
+    <File>
+      <GroupNumber>1</GroupNumber>
+      <FileNumber>18</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>.\host\usbhaudio.c</PathWithFileName>
+      <FilenameWithoutPath>usbhaudio.c</FilenameWithoutPath>
+    </File>
+    <File>
+      <GroupNumber>1</GroupNumber>
+      <FileNumber>19</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>.\host\usbhhid.c</PathWithFileName>
+      <FilenameWithoutPath>usbhhid.c</FilenameWithoutPath>
+    </File>
+    <File>
+      <GroupNumber>1</GroupNumber>
+      <FileNumber>20</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>.\host\usbhhidkeyboard.c</PathWithFileName>
+      <FilenameWithoutPath>usbhhidkeyboard.c</FilenameWithoutPath>
+    </File>
+    <File>
+      <GroupNumber>1</GroupNumber>
+      <FileNumber>21</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>.\host\usbhhidmouse.c</PathWithFileName>
+      <FilenameWithoutPath>usbhhidmouse.c</FilenameWithoutPath>
+    </File>
+    <File>
+      <GroupNumber>1</GroupNumber>
+      <FileNumber>22</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>.\host\usbhhub.c</PathWithFileName>
+      <FilenameWithoutPath>usbhhub.c</FilenameWithoutPath>
+    </File>
+    <File>
+      <GroupNumber>1</GroupNumber>
+      <FileNumber>23</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>.\host\usbhmsc.c</PathWithFileName>
+      <FilenameWithoutPath>usbhmsc.c</FilenameWithoutPath>
+    </File>
+    <File>
+      <GroupNumber>1</GroupNumber>
+      <FileNumber>24</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>.\host\usbhostenum.c</PathWithFileName>
+      <FilenameWithoutPath>usbhostenum.c</FilenameWithoutPath>
+    </File>
+    <File>
+      <GroupNumber>1</GroupNumber>
+      <FileNumber>25</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>.\host\usbhscsi.c</PathWithFileName>
+      <FilenameWithoutPath>usbhscsi.c</FilenameWithoutPath>
+    </File>
+    <File>
+      <GroupNumber>1</GroupNumber>
+      <FileNumber>26</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>.\usbkeyboardmap.c</PathWithFileName>
+      <FilenameWithoutPath>usbkeyboardmap.c</FilenameWithoutPath>
+    </File>
+    <File>
+      <GroupNumber>1</GroupNumber>
+      <FileNumber>27</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>.\usbmode.c</PathWithFileName>
+      <FilenameWithoutPath>usbmode.c</FilenameWithoutPath>
+    </File>
+    <File>
+      <GroupNumber>1</GroupNumber>
+      <FileNumber>28</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>.\usbringbuf.c</PathWithFileName>
+      <FilenameWithoutPath>usbringbuf.c</FilenameWithoutPath>
+    </File>
+    <File>
+      <GroupNumber>1</GroupNumber>
+      <FileNumber>29</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>.\usbtick.c</PathWithFileName>
+      <FilenameWithoutPath>usbtick.c</FilenameWithoutPath>
+    </File>
+    <File>
+      <GroupNumber>1</GroupNumber>
+      <FileNumber>30</FileNumber>
+      <FileType>1</FileType>
+      <tvExp>0</tvExp>
+      <Focus>0</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>0</TopLine>
+      <CurrentLine>0</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>.\usbulpi.c</PathWithFileName>
+      <FilenameWithoutPath>usbulpi.c</FilenameWithoutPath>
+    </File>
+  </Group>
+
+  <Group>
+    <GroupName>Documentation</GroupName>
+    <tvExp>1</tvExp>
+    <tvExpOptDlg>0</tvExpOptDlg>
+    <cbSel>0</cbSel>
+    <File>
+      <GroupNumber>2</GroupNumber>
+      <FileNumber>31</FileNumber>
+      <FileType>5</FileType>
+      <tvExp>0</tvExp>
+      <Focus>1</Focus>
+      <ColumnNumber>0</ColumnNumber>
+      <tvExpOptDlg>0</tvExpOptDlg>
+      <TopLine>1</TopLine>
+      <CurrentLine>1</CurrentLine>
+      <bDave2>0</bDave2>
+      <PathWithFileName>.\readme.txt</PathWithFileName>
+      <FilenameWithoutPath>readme.txt</FilenameWithoutPath>
+      <WindowPosition>
+        <length>44</length>
+        <flags>0</flags>
+        <showCmd>1</showCmd>
+        <MinPosition>
+          <xPos>-1</xPos>
+          <yPos>-1</yPos>
+        </MinPosition>
+        <MaxPosition>
+          <xPos>-1</xPos>
+          <yPos>-1</yPos>
+        </MaxPosition>
+        <NormalPosition>
+          <Top>0</Top>
+          <Left>0</Left>
+          <Right>729</Right>
+          <Bottom>300</Bottom>
+        </NormalPosition>
+      </WindowPosition>
+    </File>
+  </Group>
+
+  <MDIGroups>
+    <Orientation>1</Orientation>
+    <ActiveMDIGroup>0</ActiveMDIGroup>
+    <MDIGroup>
+      <Size>100</Size>
+      <ActiveTab>0</ActiveTab>
+      <Documents>
+        <Doc>
+          <Name>.\readme.txt</Name>
+          <ColumnNumber>0</ColumnNumber>
+          <TopLine>1</TopLine>
+          <CurrentLine>1</CurrentLine>
+        </Doc>
+      </Documents>
+    </MDIGroup>
+  </MDIGroups>
+
+</ProjectOpt>
diff --git a/bsp/tm4c129x/libraries/usblib/usblib.uvproj b/bsp/tm4c129x/libraries/usblib/usblib.uvproj
new file mode 100755
index 0000000..76c4ac8
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/usblib.uvproj
@@ -0,0 +1,555 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
+<Project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="project_proj.xsd">
+
+  <SchemaVersion>1.1</SchemaVersion>
+
+  <Header>### uVision Project, (C) Keil Software</Header>
+
+  <Targets>
+    <Target>
+      <TargetName>usblib</TargetName>
+      <ToolsetNumber>0x4</ToolsetNumber>
+      <ToolsetName>ARM-ADS</ToolsetName>
+      <TargetOption>
+        <TargetCommonOption>
+          <Device>TM4C1230C3PM</Device>
+          <Vendor>Texas Instruments</Vendor>
+          <Cpu>IRAM(0x20000000-0x20002FFF) IROM(0-0x7FFF) CLOCK(8000000) CPUTYPE("Cortex-M4") FPU2</Cpu>
+          <FlashUtilSpec></FlashUtilSpec>
+          <StartupFile>"STARTUP\Luminary\Startup.s" ("Luminary Startup Code")</StartupFile>
+          <FlashDriverDll>UL2CM3(-O207 -S0 -C0 -FO7 -FD20000000 -FC800 -FN1 -FF0LM4F_32 -FS00 -FL08000)</FlashDriverDll>
+          <DeviceId>5919</DeviceId>
+          <RegisterFile>LM4Fxxxx.H</RegisterFile>
+          <MemoryEnv></MemoryEnv>
+          <Cmp></Cmp>
+          <Asm></Asm>
+          <Linker></Linker>
+          <OHString></OHString>
+          <InfinionOptionDll></InfinionOptionDll>
+          <SLE66CMisc></SLE66CMisc>
+          <SLE66AMisc></SLE66AMisc>
+          <SLE66LinkerMisc></SLE66LinkerMisc>
+          <SFDFile>SFD\Luminary\TM4C1230C3PM.SFR</SFDFile>
+          <UseEnv>0</UseEnv>
+          <BinPath></BinPath>
+          <IncludePath></IncludePath>
+          <LibPath></LibPath>
+          <RegisterFilePath>Luminary\</RegisterFilePath>
+          <DBRegisterFilePath>Luminary\</DBRegisterFilePath>
+          <TargetStatus>
+            <Error>0</Error>
+            <ExitCodeStop>0</ExitCodeStop>
+            <ButtonStop>0</ButtonStop>
+            <NotGenerated>0</NotGenerated>
+            <InvalidFlash>1</InvalidFlash>
+          </TargetStatus>
+          <OutputDirectory>.\rvmdk\</OutputDirectory>
+          <OutputName>usblib</OutputName>
+          <CreateExecutable>0</CreateExecutable>
+          <CreateLib>1</CreateLib>
+          <CreateHexFile>0</CreateHexFile>
+          <DebugInformation>1</DebugInformation>
+          <BrowseInformation>1</BrowseInformation>
+          <ListingPath>.\rvmdk\</ListingPath>
+          <HexFormatSelection>1</HexFormatSelection>
+          <Merge32K>0</Merge32K>
+          <CreateBatchFile>0</CreateBatchFile>
+          <BeforeCompile>
+            <RunUserProg1>0</RunUserProg1>
+            <RunUserProg2>0</RunUserProg2>
+            <UserProg1Name></UserProg1Name>
+            <UserProg2Name></UserProg2Name>
+            <UserProg1Dos16Mode>0</UserProg1Dos16Mode>
+            <UserProg2Dos16Mode>0</UserProg2Dos16Mode>
+          </BeforeCompile>
+          <BeforeMake>
+            <RunUserProg1>0</RunUserProg1>
+            <RunUserProg2>0</RunUserProg2>
+            <UserProg1Name></UserProg1Name>
+            <UserProg2Name></UserProg2Name>
+            <UserProg1Dos16Mode>0</UserProg1Dos16Mode>
+            <UserProg2Dos16Mode>0</UserProg2Dos16Mode>
+          </BeforeMake>
+          <AfterMake>
+            <RunUserProg1>0</RunUserProg1>
+            <RunUserProg2>0</RunUserProg2>
+            <UserProg1Name></UserProg1Name>
+            <UserProg2Name></UserProg2Name>
+            <UserProg1Dos16Mode>0</UserProg1Dos16Mode>
+            <UserProg2Dos16Mode>0</UserProg2Dos16Mode>
+          </AfterMake>
+          <SelectedForBatchBuild>0</SelectedForBatchBuild>
+          <SVCSIdString></SVCSIdString>
+        </TargetCommonOption>
+        <CommonProperty>
+          <UseCPPCompiler>0</UseCPPCompiler>
+          <RVCTCodeConst>0</RVCTCodeConst>
+          <RVCTZI>0</RVCTZI>
+          <RVCTOtherData>0</RVCTOtherData>
+          <ModuleSelection>0</ModuleSelection>
+          <IncludeInBuild>1</IncludeInBuild>
+          <AlwaysBuild>0</AlwaysBuild>
+          <GenerateAssemblyFile>0</GenerateAssemblyFile>
+          <AssembleAssemblyFile>0</AssembleAssemblyFile>
+          <PublicsOnly>0</PublicsOnly>
+          <StopOnExitCode>3</StopOnExitCode>
+          <CustomArgument></CustomArgument>
+          <IncludeLibraryModules></IncludeLibraryModules>
+        </CommonProperty>
+        <DllOption>
+          <SimDllName>SARMCM3.DLL</SimDllName>
+          <SimDllArguments>-MPU</SimDllArguments>
+          <SimDlgDll>DCM.DLL</SimDlgDll>
+          <SimDlgDllArguments>-pCM4</SimDlgDllArguments>
+          <TargetDllName>SARMCM3.DLL</TargetDllName>
+          <TargetDllArguments>-MPU</TargetDllArguments>
+          <TargetDlgDll>TCM.DLL</TargetDlgDll>
+          <TargetDlgDllArguments>-pCM4</TargetDlgDllArguments>
+        </DllOption>
+        <DebugOption>
+          <OPTHX>
+            <HexSelection>1</HexSelection>
+            <HexRangeLowAddress>0</HexRangeLowAddress>
+            <HexRangeHighAddress>0</HexRangeHighAddress>
+            <HexOffset>0</HexOffset>
+            <Oh166RecLen>16</Oh166RecLen>
+          </OPTHX>
+          <Simulator>
+            <UseSimulator>1</UseSimulator>
+            <LoadApplicationAtStartup>1</LoadApplicationAtStartup>
+            <RunToMain>1</RunToMain>
+            <RestoreBreakpoints>1</RestoreBreakpoints>
+            <RestoreWatchpoints>1</RestoreWatchpoints>
+            <RestoreMemoryDisplay>1</RestoreMemoryDisplay>
+            <RestoreFunctions>1</RestoreFunctions>
+            <RestoreToolbox>1</RestoreToolbox>
+            <LimitSpeedToRealTime>0</LimitSpeedToRealTime>
+          </Simulator>
+          <Target>
+            <UseTarget>0</UseTarget>
+            <LoadApplicationAtStartup>1</LoadApplicationAtStartup>
+            <RunToMain>0</RunToMain>
+            <RestoreBreakpoints>1</RestoreBreakpoints>
+            <RestoreWatchpoints>1</RestoreWatchpoints>
+            <RestoreMemoryDisplay>1</RestoreMemoryDisplay>
+            <RestoreFunctions>0</RestoreFunctions>
+            <RestoreToolbox>1</RestoreToolbox>
+          </Target>
+          <RunDebugAfterBuild>0</RunDebugAfterBuild>
+          <TargetSelection>3</TargetSelection>
+          <SimDlls>
+            <CpuDll></CpuDll>
+            <CpuDllArguments></CpuDllArguments>
+            <PeripheralDll></PeripheralDll>
+            <PeripheralDllArguments></PeripheralDllArguments>
+            <InitializationFile></InitializationFile>
+          </SimDlls>
+          <TargetDlls>
+            <CpuDll></CpuDll>
+            <CpuDllArguments></CpuDllArguments>
+            <PeripheralDll></PeripheralDll>
+            <PeripheralDllArguments></PeripheralDllArguments>
+            <InitializationFile></InitializationFile>
+            <Driver>BIN\lmidk-agdi.dll</Driver>
+          </TargetDlls>
+        </DebugOption>
+        <Utilities>
+          <Flash1>
+            <UseTargetDll>1</UseTargetDll>
+            <UseExternalTool>0</UseExternalTool>
+            <RunIndependent>0</RunIndependent>
+            <UpdateFlashBeforeDebugging>0</UpdateFlashBeforeDebugging>
+            <Capability>1</Capability>
+            <DriverSelection>4097</DriverSelection>
+          </Flash1>
+          <Flash2>BIN\lmidk-agdi.dll</Flash2>
+          <Flash3></Flash3>
+          <Flash4></Flash4>
+        </Utilities>
+        <TargetArmAds>
+          <ArmAdsMisc>
+            <GenerateListings>0</GenerateListings>
+            <asHll>1</asHll>
+            <asAsm>1</asAsm>
+            <asMacX>1</asMacX>
+            <asSyms>1</asSyms>
+            <asFals>1</asFals>
+            <asDbgD>1</asDbgD>
+            <asForm>1</asForm>
+            <ldLst>0</ldLst>
+            <ldmm>1</ldmm>
+            <ldXref>1</ldXref>
+            <BigEnd>0</BigEnd>
+            <AdsALst>0</AdsALst>
+            <AdsACrf>0</AdsACrf>
+            <AdsANop>0</AdsANop>
+            <AdsANot>0</AdsANot>
+            <AdsLLst>0</AdsLLst>
+            <AdsLmap>0</AdsLmap>
+            <AdsLcgr>0</AdsLcgr>
+            <AdsLsym>0</AdsLsym>
+            <AdsLszi>0</AdsLszi>
+            <AdsLtoi>0</AdsLtoi>
+            <AdsLsun>0</AdsLsun>
+            <AdsLven>0</AdsLven>
+            <AdsLsxf>0</AdsLsxf>
+            <RvctClst>0</RvctClst>
+            <GenPPlst>0</GenPPlst>
+            <AdsCpuType>"Cortex-M4"</AdsCpuType>
+            <RvctDeviceName></RvctDeviceName>
+            <mOS>0</mOS>
+            <uocRom>0</uocRom>
+            <uocRam>0</uocRam>
+            <hadIROM>1</hadIROM>
+            <hadIRAM>1</hadIRAM>
+            <hadXRAM>0</hadXRAM>
+            <uocXRam>0</uocXRam>
+            <RvdsVP>2</RvdsVP>
+            <hadIRAM2>0</hadIRAM2>
+            <hadIROM2>0</hadIROM2>
+            <StupSel>8</StupSel>
+            <useUlib>1</useUlib>
+            <EndSel>0</EndSel>
+            <uLtcg>0</uLtcg>
+            <RoSelD>3</RoSelD>
+            <RwSelD>3</RwSelD>
+            <CodeSel>0</CodeSel>
+            <OptFeed>0</OptFeed>
+            <NoZi1>0</NoZi1>
+            <NoZi2>0</NoZi2>
+            <NoZi3>0</NoZi3>
+            <NoZi4>0</NoZi4>
+            <NoZi5>0</NoZi5>
+            <Ro1Chk>0</Ro1Chk>
+            <Ro2Chk>0</Ro2Chk>
+            <Ro3Chk>0</Ro3Chk>
+            <Ir1Chk>1</Ir1Chk>
+            <Ir2Chk>0</Ir2Chk>
+            <Ra1Chk>0</Ra1Chk>
+            <Ra2Chk>0</Ra2Chk>
+            <Ra3Chk>0</Ra3Chk>
+            <Im1Chk>1</Im1Chk>
+            <Im2Chk>0</Im2Chk>
+            <OnChipMemories>
+              <Ocm1>
+                <Type>0</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </Ocm1>
+              <Ocm2>
+                <Type>0</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </Ocm2>
+              <Ocm3>
+                <Type>0</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </Ocm3>
+              <Ocm4>
+                <Type>0</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </Ocm4>
+              <Ocm5>
+                <Type>0</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </Ocm5>
+              <Ocm6>
+                <Type>0</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </Ocm6>
+              <IRAM>
+                <Type>0</Type>
+                <StartAddress>0x20000000</StartAddress>
+                <Size>0x3000</Size>
+              </IRAM>
+              <IROM>
+                <Type>1</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x8000</Size>
+              </IROM>
+              <XRAM>
+                <Type>0</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </XRAM>
+              <OCR_RVCT1>
+                <Type>1</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </OCR_RVCT1>
+              <OCR_RVCT2>
+                <Type>1</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </OCR_RVCT2>
+              <OCR_RVCT3>
+                <Type>1</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </OCR_RVCT3>
+              <OCR_RVCT4>
+                <Type>1</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x8000</Size>
+              </OCR_RVCT4>
+              <OCR_RVCT5>
+                <Type>1</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </OCR_RVCT5>
+              <OCR_RVCT6>
+                <Type>0</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </OCR_RVCT6>
+              <OCR_RVCT7>
+                <Type>0</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </OCR_RVCT7>
+              <OCR_RVCT8>
+                <Type>0</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </OCR_RVCT8>
+              <OCR_RVCT9>
+                <Type>0</Type>
+                <StartAddress>0x20000000</StartAddress>
+                <Size>0x3000</Size>
+              </OCR_RVCT9>
+              <OCR_RVCT10>
+                <Type>0</Type>
+                <StartAddress>0x0</StartAddress>
+                <Size>0x0</Size>
+              </OCR_RVCT10>
+            </OnChipMemories>
+            <RvctStartVector></RvctStartVector>
+          </ArmAdsMisc>
+          <Cads>
+            <interw>0</interw>
+            <Optim>3</Optim>
+            <oTime>1</oTime>
+            <SplitLS>0</SplitLS>
+            <OneElfS>1</OneElfS>
+            <Strict>0</Strict>
+            <EnumInt>0</EnumInt>
+            <PlainCh>0</PlainCh>
+            <Ropi>0</Ropi>
+            <Rwpi>0</Rwpi>
+            <wLevel>2</wLevel>
+            <uThumb>0</uThumb>
+            <VariousControls>
+              <MiscControls>--c99</MiscControls>
+              <Define>rvmdk </Define>
+              <Undefine></Undefine>
+              <IncludePath>..;</IncludePath>
+            </VariousControls>
+          </Cads>
+          <Aads>
+            <interw>1</interw>
+            <Ropi>0</Ropi>
+            <Rwpi>0</Rwpi>
+            <thumb>0</thumb>
+            <SplitLS>0</SplitLS>
+            <SwStkChk>0</SwStkChk>
+            <NoWarn>0</NoWarn>
+            <VariousControls>
+              <MiscControls></MiscControls>
+              <Define></Define>
+              <Undefine></Undefine>
+              <IncludePath></IncludePath>
+            </VariousControls>
+          </Aads>
+          <LDads>
+            <umfTarg>0</umfTarg>
+            <Ropi>0</Ropi>
+            <Rwpi>0</Rwpi>
+            <noStLib>0</noStLib>
+            <RepFail>1</RepFail>
+            <useFile>0</useFile>
+            <TextAddressRange>0x00000000</TextAddressRange>
+            <DataAddressRange>0x20000000</DataAddressRange>
+            <ScatterFile></ScatterFile>
+            <IncludeLibs></IncludeLibs>
+            <IncludeLibsPath></IncludeLibsPath>
+            <Misc></Misc>
+            <LinkerInputFile></LinkerInputFile>
+            <DisabledWarnings></DisabledWarnings>
+          </LDads>
+        </TargetArmAds>
+      </TargetOption>
+      <Groups>
+        <Group>
+          <GroupName>Source</GroupName>
+          <Files>
+            <File>
+              <FileName>usbbuffer.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>.\usbbuffer.c</FilePath>
+            </File>
+            <File>
+              <FileName>usbdaudio.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>.\device\usbdaudio.c</FilePath>
+            </File>
+            <File>
+              <FileName>usbdbulk.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>.\device\usbdbulk.c</FilePath>
+            </File>
+            <File>
+              <FileName>usbdcdc.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>.\device\usbdcdc.c</FilePath>
+            </File>
+            <File>
+              <FileName>usbdcdesc.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>.\device\usbdcdesc.c</FilePath>
+            </File>
+            <File>
+              <FileName>usbdcomp.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>.\device\usbdcomp.c</FilePath>
+            </File>
+            <File>
+              <FileName>usbdconfig.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>.\device\usbdconfig.c</FilePath>
+            </File>
+            <File>
+              <FileName>usbddfu-rt.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>.\device\usbddfu-rt.c</FilePath>
+            </File>
+            <File>
+              <FileName>usbdenum.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>.\device\usbdenum.c</FilePath>
+            </File>
+            <File>
+              <FileName>usbdesc.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>.\usbdesc.c</FilePath>
+            </File>
+            <File>
+              <FileName>usbdhandler.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>.\device\usbdhandler.c</FilePath>
+            </File>
+            <File>
+              <FileName>usbdhid.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>.\device\usbdhid.c</FilePath>
+            </File>
+            <File>
+              <FileName>usbdhidgamepad.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>.\device\usbdhidgamepad.c</FilePath>
+            </File>
+            <File>
+              <FileName>usbdhidkeyb.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>.\device\usbdhidkeyb.c</FilePath>
+            </File>
+            <File>
+              <FileName>usbdhidmouse.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>.\device\usbdhidmouse.c</FilePath>
+            </File>
+            <File>
+              <FileName>usbdma.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>.\usbdma.c</FilePath>
+            </File>
+            <File>
+              <FileName>usbdmsc.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>.\device\usbdmsc.c</FilePath>
+            </File>
+            <File>
+              <FileName>usbhaudio.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>.\host\usbhaudio.c</FilePath>
+            </File>
+            <File>
+              <FileName>usbhhid.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>.\host\usbhhid.c</FilePath>
+            </File>
+            <File>
+              <FileName>usbhhidkeyboard.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>.\host\usbhhidkeyboard.c</FilePath>
+            </File>
+            <File>
+              <FileName>usbhhidmouse.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>.\host\usbhhidmouse.c</FilePath>
+            </File>
+            <File>
+              <FileName>usbhhub.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>.\host\usbhhub.c</FilePath>
+            </File>
+            <File>
+              <FileName>usbhmsc.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>.\host\usbhmsc.c</FilePath>
+            </File>
+            <File>
+              <FileName>usbhostenum.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>.\host\usbhostenum.c</FilePath>
+            </File>
+            <File>
+              <FileName>usbhscsi.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>.\host\usbhscsi.c</FilePath>
+            </File>
+            <File>
+              <FileName>usbkeyboardmap.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>.\usbkeyboardmap.c</FilePath>
+            </File>
+            <File>
+              <FileName>usbmode.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>.\usbmode.c</FilePath>
+            </File>
+            <File>
+              <FileName>usbringbuf.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>.\usbringbuf.c</FilePath>
+            </File>
+            <File>
+              <FileName>usbtick.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>.\usbtick.c</FilePath>
+            </File>
+            <File>
+              <FileName>usbulpi.c</FileName>
+              <FileType>1</FileType>
+              <FilePath>.\usbulpi.c</FilePath>
+            </File>
+          </Files>
+        </Group>
+        <Group>
+          <GroupName>Documentation</GroupName>
+          <Files>
+            <File>
+              <FileName>readme.txt</FileName>
+              <FileType>5</FileType>
+              <FilePath>.\readme.txt</FilePath>
+            </File>
+          </Files>
+        </Group>
+      </Groups>
+    </Target>
+  </Targets>
+
+</Project>
diff --git a/bsp/tm4c129x/libraries/usblib/usblibpriv.h b/bsp/tm4c129x/libraries/usblib/usblibpriv.h
new file mode 100755
index 0000000..8eee718
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/usblibpriv.h
@@ -0,0 +1,529 @@
+//*****************************************************************************
+//
+// usblibpriv.h - Private header file used to share internal variables and
+//                function prototypes between the various modules in the USB
+//                library.  This header MUST NOT be used by application code.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#ifndef __USBLIBPRIV_H__
+#define __USBLIBPRIV_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+//*****************************************************************************
+//
+//! \addtogroup usblib_dma_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Internal interrupt handlers called from the main vectors in device and
+// host mode.
+//
+//*****************************************************************************
+extern void USBDeviceIntHandlerInternal(uint32_t ui32Index,
+                                        uint32_t ui32Status);
+extern void USBHostIntHandlerInternal(uint32_t ui32Index, uint32_t ui32Status);
+
+//*****************************************************************************
+//
+// The maximum number of tick handlers that can be registered in a system.
+//
+//*****************************************************************************
+#define MAX_USB_TICK_HANDLERS       6
+
+//*****************************************************************************
+//
+// This value defines the number of SOF ticks that must pass before a call
+// is made to InternalUSBStartOfFrameTick.  The value 5 ensures that the
+// function is called every 5 milliseconds assuming that SOF interrupts are
+// enabled and SOF is present.
+//
+//*****************************************************************************
+#define USB_SOF_TICK_DIVIDE 5
+
+//*****************************************************************************
+//
+// Tick handler function pointer type.
+//
+//*****************************************************************************
+typedef void(* tUSBTickHandler)(void *pvInstance, uint32_t ui32TicksmS);
+
+//*****************************************************************************
+//
+// Internal functions use to initialize the tick handler and register tick
+// callbacks.
+//
+//*****************************************************************************
+extern void InternalUSBTickInit(void);
+extern void InternalUSBTickReset(void);
+extern int32_t InternalUSBRegisterTickHandler(tUSBTickHandler pfnHandler,
+                                              void *pvInstance);
+extern void InternalUSBStartOfFrameTick(uint32_t ui32TicksmS);
+extern void InternalUSBHCDSendEvent(uint32_t ui32Index, tEventInfo *psEvent,
+                                    uint32_t ui32EvFlag);
+
+//*****************************************************************************
+//
+// g_ui32CurrentUSBTick holds the elapsed time in milliseconds since the
+// tick module was first initialized based on calls to the function
+// InternalUSBStartOfFrameTick.  The granularity is USB_SOF_TICK_DIVIDE
+// milliseconds.
+//
+//*****************************************************************************
+extern uint32_t g_ui32CurrentUSBTick;
+
+//*****************************************************************************
+//
+// g_ui32USBSOFCount is a global counter for Start of Frame interrupts.  It is
+// incremented by the low level device- or host-mode interrupt handlers.
+//
+//*****************************************************************************
+extern uint32_t g_ui32USBSOFCount;
+
+//*****************************************************************************
+//
+// InternalUSBGetTime is a macro which will return the system time in
+// milliseconds as calculated based on calls to the function
+// InternalUSBStartOfFrameTick.  The granularity is USB_SOF_TICK_DIVIDE
+// milliseconds.
+//
+// Currently, this merely returns the value of a global variable.
+//
+//*****************************************************************************
+#define InternalUSBGetTime()    g_ui32CurrentUSBTick
+
+//*****************************************************************************
+//
+// Macros to convert between USB controller base address and an index.  These
+// are currently trivial but are included to allow for the possibility of
+// supporting more than one controller in the future.
+//
+//*****************************************************************************
+#define USBBaseToIndex(BaseAddr)(0)
+#define USBIndexToBase(Index)   (USB0_BASE)
+
+//
+// Maximum number of channels for Type 0 USB controllers.
+//
+#define USB_MAX_DMA_CHANNELS_0  6
+
+//
+// Maximum number of channels for all other USB controllers.
+//
+#define USB_MAX_DMA_CHANNELS    8
+
+//*****************************************************************************
+//
+// Values returned by the USBLibDMAChannelStatus() function.
+//
+//*****************************************************************************
+#define USBLIBSTATUS_DMA_IDLE   0x00000000
+#define USBLIBSTATUS_DMA_COMPLETE                                             \
+                                0x00000001
+#define USBLIBSTATUS_DMA_ERROR  0x00000002
+#define USBLIBSTATUS_DMA_PENDING                                              \
+                                0x00000004
+
+//*****************************************************************************
+//
+// DMA endpoint types used with the USBLibDMAChannelAllocate() function.
+//
+//*****************************************************************************
+#define USB_DMA_EP_RX           0x00000080
+#define USB_DMA_EP_TX           0x00000000
+#define USB_DMA_EP_HOST         0x00000040
+#define USB_DMA_EP_DEVICE       0x00000000
+#define USB_DMA_EP_TYPE_CTRL    0x00000000
+#define USB_DMA_EP_TYPE_ISOC    0x00000001
+#define USB_DMA_EP_TYPE_BULK    0x00000002
+#define USB_DMA_EP_TYPE_INT     0x00000003
+#define USB_DMA_EP_TYPE_M       0x00000003
+
+//*****************************************************************************
+//
+// This is the internal instance data for the DMA functions and should not
+// be modified outside the usbdma.c file.
+//
+//*****************************************************************************
+struct tUSBDMAInstance
+{
+    uint32_t ui32Base;
+
+    uint32_t ui32IntNum;
+
+    uint32_t pui32Config[USB_MAX_DMA_CHANNELS];
+
+    uint32_t pui32MaxPacketSize[USB_MAX_DMA_CHANNELS];
+
+    uint32_t *ppui32Data[USB_MAX_DMA_CHANNELS];
+
+    uint32_t pui32Count[USB_MAX_DMA_CHANNELS];
+
+    uint8_t pui8Endpoint[USB_MAX_DMA_CHANNELS];
+
+    uint32_t pui32EPDMAMode0[USB_MAX_DMA_CHANNELS];
+
+    uint32_t pui32EPDMAMode1[USB_MAX_DMA_CHANNELS];
+
+    uint32_t ui32Pending;
+
+    uint32_t ui32Complete;
+
+    void (* pfnArbSizeSet)(tUSBDMAInstance *psUSBDMAInst, uint32_t ui32Channel,
+                           uint32_t ui32ArbSize);
+    uint32_t (* pfnChannelAllocate)(tUSBDMAInstance *psUSBDMAInst,
+                                    uint8_t ui8Endpoint,
+                                    uint32_t ui32MaxPacketSize,
+                                    uint32_t ui32Config);
+    void (* pfnChannelEnable)(tUSBDMAInstance *psUSBDMAInst,
+                              uint32_t ui32Channel);
+    void (* pfnChannelDisable)(tUSBDMAInstance *psUSBDMAInst,
+                               uint32_t ui32Channel);
+    void (* pfnChannelRelease)(tUSBDMAInstance *psUSBDMAInst,
+                               uint8_t ui8Endpoint);
+    uint32_t (* pfnChannelStatus)(tUSBDMAInstance *psUSBDMAInst,
+                                  uint32_t ui32Channel);
+    void (* pfnChannelIntDisable)(tUSBDMAInstance *psUSBDMAInst,
+                                  uint32_t ui32Channel);
+    void (* pfnChannelIntEnable)(tUSBDMAInstance *psUSBDMAInst,
+                                 uint32_t ui32Channel);
+    void (* pfnIntHandler)(tUSBDMAInstance *psUSBDMAInst,
+                           uint32_t ui32Status);
+    uint32_t (* pfnIntStatus)(tUSBDMAInstance *psUSBDMAInst);
+    void (* pfnIntStatusClear)(tUSBDMAInstance *psUSBDMAInst,
+                               uint32_t ui32Status);
+    uint32_t (* pfnStatus)(tUSBDMAInstance *psUSBDMAInst);
+    uint32_t (* pfnTransfer)(tUSBDMAInstance *psUSBDMAInst,
+                             uint32_t ui32Channel, void *pvBuffer,
+                             uint32_t ui32Size);
+    void (* pfnUnitSizeSet)(tUSBDMAInstance *psUSBDMAInst,
+                            uint32_t ui32Channel,
+                            uint32_t ui32BitSize);
+};
+
+//*****************************************************************************
+//
+// These are the USB libraries DMA functions.
+//
+//*****************************************************************************
+extern tUSBDMAInstance * USBLibDMAInit(uint32_t ui32Index);
+extern void * USBLibDMAAddrGet(tUSBDMAInstance *psUSBDMAInst,
+                               uint32_t ui32Channel);
+extern uint32_t USBLibDMASizeGet(tUSBDMAInstance *psUSBDMAInst,
+                                 uint32_t ui32Channel);
+
+//*****************************************************************************
+//
+//! This function returns the current DMA status for a given DMA channel.
+//!
+//! \param psUSBDMAInst is the DMA structure pointer for this instance.
+//! \param ui32Channel is the DMA channel number used to retrieve the DMA
+//! status.
+//!
+//! This function returns the current status of a DMA transfer on a given
+//! DMA channel.  The DMA channel is specified by the \e ui32Channel parameter.
+//!
+//! \return This function returns one of the \b USBLIBSTATUS_DMA_* values.
+//
+//*****************************************************************************
+#define USBLibDMAChannelStatus(psUSBDMAInst, ui32Channel)                     \
+          psUSBDMAInst->pfnChannelStatus(psUSBDMAInst, ui32Channel)
+
+//*****************************************************************************
+//
+//! This function is used to return any global status information for USB DMA.
+//!
+//! \param psUSBDMAInst is a generic instance pointer that can be used to
+//! distinguish between different hardware instances.
+//!
+//! This function performs returns the global status for the USB DMA
+//! interface.
+//!
+//! \return Always returns 0.
+//
+//*****************************************************************************
+#define USBLibDMAStatus(psUSBDMAInst)    psUSBDMAInst->pfnStatus(psUSBDMAInst)
+
+//*****************************************************************************
+//
+//! This function returns the current DMA interrupt status.
+//!
+//! \param psUSBDMAInst is the DMA structure pointer for this instance.
+//!
+//! This function returns the interrupt status for all DMA channels.  The value
+//! returned is a per channel interrupt mapping with the DMA channels mapped
+//! into bits 0-31 by channel number with channel 1 starting at bit 0.
+//!
+//! \note This function does not return an endpoint interrupt status, but the
+//! interrupt status for the DMA interface used with the USB controller.
+//!
+//! \return This function returns the pending DMA interrupts.
+//
+//*****************************************************************************
+#define USBLibDMAIntStatus(psUSBDMAInst)                                      \
+                psUSBDMAInst->pfnIntStatus(psUSBDMAInst)
+
+//*****************************************************************************
+//
+//! This function clears the requested DMA interrupt status.
+//!
+//! \param psUSBDMAInst is the DMA structure pointer for this instance.
+//! \param ui32Status contains the interrupts to clear.
+//!
+//! This function clears the current DMA interrupt status for the
+//! controller specified by the \e ui32Instance parameter.  The \e ui32Status
+//! value has the same format as the value returned from the
+//! USBLibDMAIntStatus() function which is a per channel interrupt mapping.
+//! The DMA channels are mapped into bits 0-31 by channel number with channel 1
+//!starting at bit 0.
+//!
+//! \return None.
+//
+//*****************************************************************************
+#define USBLibDMAIntStatusClear(psUSBDMAInst, ui32Status)                     \
+          psUSBDMAInst->pfnIntStatusClear(psUSBDMAInst, ui32Status)
+
+//*****************************************************************************
+//
+//! This function enables DMA for a given channel.
+//!
+//! \param psUSBDMAInst is the DMA structure pointer for this instance.
+//! \param ui32Channel is the DMA channel to enable.
+//!
+//! This function enables DMA on the channel number passed in the
+//! \e ui32Channel parameter.
+//!
+//! \return None.
+//
+//*****************************************************************************
+#define USBLibDMAChannelEnable(psUSBDMAInst, ui32Channel)                     \
+          psUSBDMAInst->pfnChannelEnable(psUSBDMAInst, ui32Channel)
+
+//*****************************************************************************
+//
+//! This function disables DMA for a given DMA channel.
+//!
+//! \param psUSBDMAInst is the DMA structure pointer for this instance.
+//! \param ui32Channel is the DMA channel to disable.
+//!
+//! This function disables DMA on the channel number passed in the
+//!\e ui32Channel parameter.
+//!
+//! \return None.
+//
+//*****************************************************************************
+#define USBLibDMAChannelDisable(psUSBDMAInst, ui32Channel)                    \
+          psUSBDMAInst->pfnChannelDisable(psUSBDMAInst, ui32Channel)
+
+//*****************************************************************************
+//
+//! This function is configures a USB transfer on a given DMA channel.
+//!
+//! \param psUSBDMAInst is the DMA structure pointer for this instance.
+//! \param ui32Channel is the DMA channel to use.
+//! \param pvBuffer is a pointer to the buffer to use for the transfer.
+//! \param ui32Size is the size of the data to be transferred in bytes.
+//!
+//! This function is called to configure a transfer using the USB
+//! controller depending on the parameters.  The \e ui32Channel parameter
+//! holds the channel number to use for this transfer which must have already
+//! been allocated with a call to the USBLibDMAChannelAllocate() function.  The
+//! transaction is configured to transfer \e ui32Size bytes to/from the buffer
+//! held in the \e pvBuffer pointer.
+//!
+//! \return This function returns the number of bytes scheduled to be
+//! transferred.
+//
+//*****************************************************************************
+#define USBLibDMATransfer(psUSBDMAInst, ui32Channel, pvBuffer, ui32Size)      \
+                    psUSBDMAInst->pfnTransfer(psUSBDMAInst, ui32Channel,      \
+                                              pvBuffer, ui32Size)
+
+//*****************************************************************************
+//
+//! This function is called by the USB interrupt handler.
+//!
+//! \param psUSBDMAInst is the DMA structure pointer for this instance.
+//! \param ui32Status is the DMA interrupt status.
+//!
+//! This function is called by the USB interrupt handler to allow the DMA
+//! interface to handle interrupts outside of the context of the normal USB
+//! interrupt handler.  The \e ui32Status is the current DMA interrupt status
+//! at the time of the USB interrupt.  Since some DMA controller interrupts are
+//! cleared automatically when read, this value must be retrieved by calling
+//! the USBLibDMAIntStatus() function and passed into this function.
+//!
+//! \return None.
+//
+//*****************************************************************************
+#define USBLibDMAIntHandler(psUSBDMAInst, ui32Status)                         \
+            psUSBDMAInst->pfnIntHandler(psUSBDMAInst, ui32Status)
+
+//*****************************************************************************
+//
+//! This function is used to assign a DMA channel to an endpoint.
+//!
+//! \param psUSBDMAInst is the DMA instance data for a USB controller.
+//! \param ui8Endpoint is the endpoint number to assign a DMA channel.
+//! \param ui32MaxPacketSize is the maximum packet size for the endpoint
+//! assigned that is being assigned to the DMA channel.
+//! \param ui32Config are the basic configuration options for the DMA channel.
+//!
+//! This function assigns a DMA channel to a given endpoint.  The
+//! \e ui8Endpoint parameter is the zero based endpoint number that is assigned
+//! a DMA channel.  The \e ui32Config parameter contains any configuration
+//! options for the DMA channel.  The current options include the following:
+//! - \b USB_DMA_EP_TX - this request is for a transmit DMA channel.
+//! - \b USB_DMA_EP_RX - this request is for a receive DMA channel.
+//!
+//! \note The maximum number of available DMA channels to endpoints varies
+//! between devices.
+//!
+//! \return Zero or the DMA channel assigned to the endpoint.
+//
+//*****************************************************************************
+#define USBLibDMAChannelAllocate(psUSBDMAInst, ui8Endpoint, ui32MaxPacketSize,\
+                                 ui32Config)                                  \
+                     psUSBDMAInst->pfnChannelAllocate(psUSBDMAInst,           \
+                                                      ui8Endpoint,            \
+                                                      ui32MaxPacketSize,      \
+                                                      ui32Config)
+
+//*****************************************************************************
+//
+//! This function is used to free a DMA channel that was assigned to an
+//! endpoint.
+//!
+//! \param psUSBDMAInst is the DMA instance data for a USB controller.
+//! \param ui8Endpoint is the DMA channel number to free up.
+//!
+//! This function frees up a DMA channel that was allocated to an endpoint
+//! by the USBLibDMAChannelAllocate() function.
+//!
+//! \return None.
+//
+//*****************************************************************************
+#define USBLibDMAChannelRelease(psUSBDMAInst, ui8Endpoint)                    \
+                  psUSBDMAInst->pfnChannelRelease(psUSBDMAInst, ui8Endpoint)
+
+//*****************************************************************************
+//
+//! This function is used to set the individual transfer size of a DMA channel.
+//!
+//! \param psUSBDMAInst is the DMA instance data for a USB controller.
+//! \param ui32Channel is the DMA channel number to modify.
+//! \param ui32BitSize is the individual transfer size in bits(8, 16 or 32).
+//!
+//! This function configures the individual transfer size of the DMA channel
+//! provided in the \e ui32Channel parameter.  The \e ui32Channel must already
+//! be allocated to an endpoint by calling the USBLibDMAChannelAllocate()
+//! function.  The \e ui32BitSize parameter should be on of the following
+//! values: 8, 16 or 32.
+//!
+//! \return None.
+//
+//*****************************************************************************
+#define USBLibDMAUnitSizeSet(psUSBDMAInst, ui32Channel, ui32BitSize)          \
+                      psUSBDMAInst->pfnUnitSizeSet(psUSBDMAInst, ui32Channel, \
+                                                   ui32BitSize);
+
+//*****************************************************************************
+//
+//! This function is used to set the arbitration size for a DMA channel.
+//!
+//! \param psUSBDMAInst is the DMA instance data for a USB controller.
+//! \param ui32Channel is the DMA channel number to modify.
+//! \param ui32ArbSize is the transfer arbitration size in bytes.
+//!
+//! This function configures the individual transfer size of the DMA channel
+//! provided in the \e ui32Channel parameter.  The \e ui32Channel must already
+//! be allocated to an endpoint by calling the USBLibDMAChannelAllocate()
+//! function.
+//!
+//! \return None.
+//
+//*****************************************************************************
+#define USBLibDMAArbSizeSet(psUSBDMAInst, ui32Channel, ui32ArbSize)           \
+                psUSBDMAInst->pfnArbSizeSet(psUSBDMAInst, ui32Channel,        \
+                                            ui32ArbSize);
+
+//*****************************************************************************
+//
+//! This function enables the DMA interrupt for a given channel.
+//!
+//! \param psUSBDMAInst is the DMA structure pointer for this instance.
+//! \param ui32Channel is the DMA channel interrupt to enable.
+//!
+//! This function enables DMA interrupt on the channel number passed in the
+//! \e ui32Channel parameter.
+//!
+//! \return None.
+//
+//*****************************************************************************
+#define USBLibDMAChannelIntEnable(psUSBDMAInst, ui32Channel)                  \
+                psUSBDMAInst->pfnChannelIntEnable(psUSBDMAInst, ui32Channel)
+
+//*****************************************************************************
+//
+//! This function disables DMA interrupt for a given DMA channel.
+//!
+//! \param psUSBDMAInst is the DMA structure pointer for this instance.
+//! \param ui32Channel is the DMA channel interrupt to disable.
+//!
+//! This function disables the DMA interrupt on the channel number passed in
+//! the \e ui32Channel parameter.
+//!
+//! \return None.
+//
+//*****************************************************************************
+#define USBLibDMAChannelIntDisable(psUSBDMAInst, ui32Channel)                 \
+        psUSBDMAInst->pfnChannelIntDisable(psUSBDMAInst, ui32Channel)
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
+
+#endif // __USBLIBPRIV_H__
diff --git a/bsp/tm4c129x/libraries/usblib/usbmode.c b/bsp/tm4c129x/libraries/usblib/usbmode.c
new file mode 100755
index 0000000..b3c9212
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/usbmode.c
@@ -0,0 +1,1180 @@
+//*****************************************************************************
+//
+// usbmode.c - Functions related to dual mode USB device/host operation.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "inc/hw_ints.h"
+#include "inc/hw_memmap.h"
+#include "inc/hw_types.h"
+#include "inc/hw_sysctl.h"
+#include "inc/hw_usb.h"
+#include "driverlib/debug.h"
+#include "driverlib/interrupt.h"
+#include "driverlib/rom.h"
+#include "driverlib/rom_map.h"
+#include "driverlib/sysctl.h"
+#include "driverlib/usb.h"
+#include "driverlib/rtos_bindings.h"
+#include "usblib/usblib.h"
+#include "usblib/usblibpriv.h"
+#include "usblib/device/usbdevice.h"
+#include "usblib/host/usbhost.h"
+#include "usblib/host/usbhostpriv.h"
+#include "usblib/usblibpriv.h"
+
+//*****************************************************************************
+//
+//! \addtogroup general_usblib_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// The following label defines interrupts that we will always pass to the host
+// interrupt handler even if we are in dual mode and not yet sure of which
+// mode we are operating in.
+//
+//*****************************************************************************
+#define USB_HOST_INTS           (USB_INTCTRL_VBUS_ERR)
+
+//*****************************************************************************
+//
+// Global variable indicating which mode of operation the application has
+// requested.
+//
+//*****************************************************************************
+volatile tUSBMode g_iUSBMode = eUSBModeNone;
+
+//*****************************************************************************
+//
+// The default and the current polling rate for the USB OTG library.
+//
+//*****************************************************************************
+volatile uint32_t g_ui32PollRate;
+
+//*****************************************************************************
+//
+// The current time remaining in milliseconds before checking the cable
+// connection.
+//
+//*****************************************************************************
+volatile uint32_t g_ui32WaitTicks = 0;
+
+//*****************************************************************************
+//
+// This enum holds the various states that we can be in while performing
+// USB mode checking. This involves use of the OTG session request to poll
+// the USB ID pin to determine whether a device or a host is connected.
+//
+//*****************************************************************************
+typedef enum
+{
+    //
+    // No checking is currently pending.
+    //
+    eUSBOTGModeIdle,
+
+    //
+    // Waiting on ID mode detection.
+    //
+    eUSBOTGModeWaitID,
+
+    //
+    // Waiting for next poll interval.
+    //
+    eUSBOTGModeWait,
+
+    //
+    // Now in B-side wait for connect.
+    //
+    eUSBOTGModeBWaitCon,
+
+    //
+    // Now in A-side device mode.
+    //
+    eUSBOTGModeBDevice,
+
+    //
+    // Now in A-side host mode.
+    //
+    eUSBOTGModeAHost,
+}
+tUSBOTGState;
+
+volatile tUSBOTGState g_eOTGModeState;
+
+//*****************************************************************************
+//
+// Global variable indicating whether we are currently operating in host or
+// device mode if the user has requested Dual mode operation.
+//
+//*****************************************************************************
+static volatile tUSBMode g_iDualMode = eUSBModeNone;
+
+static void USBOTGRemovePower(uint32_t ui32Index);
+
+//*****************************************************************************
+//
+// Global variable holding a pointer to the callback function which will be
+// called when the USB mode changes between device and host.
+//
+//*****************************************************************************
+static tUSBModeCallback g_pfnUSBModeCallback;
+
+//*****************************************************************************
+//
+// This function is used to handle switching between host, device and
+// unconfigured modes.
+//
+// \param iUSBMode is one of eUSBModeHost, eUSBModeDevice, or eUSBModeNone.
+//
+// Based on the current state held in g_iDualMode variable this function will
+// handle the transition of the mode of operation in OTG mode and calling
+// the callback function if it is present.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+USBOTGSetMode(tUSBMode iUSBMode)
+{
+    if((g_iDualMode != iUSBMode) || (g_iDualMode == eUSBModeNone))
+    {
+        //
+        // If going from host mode to unconfigured mode then remove power.
+        //
+        if((g_iDualMode == eUSBModeHost) && (iUSBMode == eUSBModeNone))
+        {
+            //
+            // Take the steps to remove power in the of host mode OTG.
+            //
+            USBOTGRemovePower(0);
+        }
+
+        //
+        // If going from device mode to unconfigured mode then end the current
+        // session.
+        //
+        if((g_iDualMode == eUSBModeDevice) && (iUSBMode == eUSBModeNone))
+        {
+            //
+            // End the current session.
+            //
+            USBOTGSessionRequest(USB0_BASE, false);
+        }
+
+        //
+        // Reset the delay whenever returning to eUSBModeNone.
+        //
+        if(iUSBMode == eUSBModeNone)
+        {
+            g_ui32WaitTicks = g_ui32PollRate;
+        }
+
+        //
+        // Do we have a mode change callback installed?
+        //
+        if((g_pfnUSBModeCallback) && (g_iDualMode != iUSBMode))
+        {
+            //
+            // Inform the callback of the new operating mode.
+            //
+            g_pfnUSBModeCallback(0, iUSBMode);
+        }
+
+        //
+        // Save the new mode.
+        //
+        g_iDualMode = iUSBMode;
+    }
+}
+
+//*****************************************************************************
+//
+//! Allows dual mode application to switch between USB device and host modes
+//! and provides a method to force the controller into the desired mode.
+//!
+//! \param ui32Index specifies the USB controller whose mode of operation is to
+//! be set.  This parameter must be set to 0.
+//! \param iUSBMode indicates the mode that the application wishes to operate
+//! in.  Valid values are \b eUSBModeDevice to operate as a USB device and
+//! \b eUSBModeHost to operate as a USB host.
+//! \param pfnCallback is a pointer to a function which the USB library will
+//! call each time the mode is changed to indicate the new operating mode.  In
+//! cases where \e iUSBMode is set to either \b eUSBModeDevice or
+//! \b eUSBModeHost, the callback will be made immediately to allow the
+//! application to perform any host or device specific initialization.
+//!
+//! This function allows a USB application that can operate in host
+//! or device mode to indicate to the USB stack the mode that it wishes to
+//! use.  The caller is responsible for cleaning up the interface and removing
+//! itself from the bus prior to making this call and reconfiguring afterwards.
+//! The \e pfnCallback function can be a NULL(0) value to indicate that no
+//! notification is required.
+//!
+//! For successful dual mode mode operation, an application must register
+//! USB0DualModeIntHandler() as the interrupt handler for the USB0 interrupt.
+//! This handler is responsible for steering interrupts to the device or host
+//! stack depending upon the chosen mode.  Devices which do not require dual
+//! mode capability should register either \e USB0DeviceIntHandler() or
+//! \e USB0HostIntHandler() instead.  Registering \e USB0DualModeIntHandler()
+//! for a single mode application will result in an application binary larger
+//! than required since library functions for both USB operating modes will be
+//! included even though only one mode is required.
+//!
+//! Single mode applications (those offering exclusively USB device or USB
+//! host functionality) are only required to call this function if they need to
+//! force the mode of the controller to Host or Device mode.  This is usually
+//! in the event that the application needs to reused the USBVBUS and/or USBID
+//! pins as GPIOs.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBStackModeSet(uint32_t ui32Index, tUSBMode iUSBMode,
+                tUSBModeCallback pfnCallback)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ui32Index == 0);
+
+    //
+    // Remember the mode so that we can steer the interrupts appropriately.
+    //
+    g_iUSBMode = iUSBMode;
+
+    //
+    // Remember the callback pointer.
+    //
+    g_pfnUSBModeCallback = pfnCallback;
+
+    //
+    // If we are being asked to be either a host or device, we will not be
+    // trying to auto-detect the mode so make the callback immediately.
+    //
+    if((iUSBMode == eUSBModeDevice) || (iUSBMode == eUSBModeHost))
+    {
+        //
+        // Make sure that a callback was provided.
+        //
+        if(g_pfnUSBModeCallback)
+        {
+            g_pfnUSBModeCallback(0, iUSBMode);
+        }
+    }
+}
+
+//*****************************************************************************
+//
+//! Steers USB interrupts from controller to the correct handler in the USB
+//! stack.
+//!
+//! This interrupt handler is used in applications which require to operate
+//! in both host and device mode.  It steers the USB hardware interrupt to the
+//! correct handler in the USB stack depending upon the current operating mode
+//! of the application, USB device or host.
+//!
+//! For successful dual mode operation, an application must register
+//! USB0DualModeIntHandler() in the CPU vector table as the interrupt handler
+//! for the USB0 interrupt.  This handler is responsible for steering
+//! interrupts to the device or host stack depending upon the chosen mode.
+//!
+//! \note Devices which do not require dual mode capability should register
+//! either USB0DeviceIntHandler() or USB0HostIntHandler() instead.  Registering
+//! USB0DualModeIntHandler() for a single mode application will result in an
+//! application binary larger than required since library functions for both
+//! USB operating modes will be included even though only one mode is actually
+//! required.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USB0DualModeIntHandler(void)
+{
+    uint32_t ui32Status;
+
+    //
+    // Read the USB interrupt status.
+    //
+    ui32Status = USBIntStatusControl(USB0_BASE);
+
+    //
+    // Pass through the subset of interrupts that we always want
+    // the host stack to see regardless of whether or not we
+    // are actually in host mode at this point.
+    //
+    if(ui32Status & USB_HOST_INTS)
+    {
+        //
+        // Call the host's interrupt handler.
+        //
+        USBHostIntHandlerInternal(0, ui32Status & USB_HOST_INTS);
+
+        //
+        // We have already processed these interrupts so clear them
+        // from the status.
+        //
+        ui32Status &= ~USB_HOST_INTS;
+    }
+
+    //
+    // Steer the interrupt to the appropriate handler within the stack
+    // depending upon our current operating mode.  Note that we need to pass
+    // the ui32Status parameter since the USB interrupt register is
+    // clear-on-read.
+    //
+    switch(g_iUSBMode)
+    {
+        case eUSBModeNone:
+        {
+            //
+            // No mode is set yet so we have no idea what to do.  Just ignore
+            // the interrupt.
+            //
+            break;
+        }
+
+        //
+        // Operating in pure host mode.
+        //
+        case eUSBModeHost:
+        {
+            //
+            // Call the host interrupt handler if there is anything still to
+            // process.
+            //
+            USBHostIntHandlerInternal(0, ui32Status);
+
+            break;
+        }
+
+        //
+        // Operating in pure device mode.
+        //
+        case eUSBModeDevice:
+        {
+            //
+            // Call the device interrupt handler.
+            //
+            USBDeviceIntHandlerInternal(0, ui32Status);
+
+            break;
+        }
+
+        default:
+        {
+            break;
+        }
+    }
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group general_usblib_api.
+//! @}
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! \addtogroup dualmode_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! Initializes the USB controller for dual mode operation.
+//!
+//! \param ui32Index specifies the USB controller that is to be initialized for
+//! dual mode operation.  This parameter must be set to 0.
+//!
+//! This function initializes the USB controller hardware into a state
+//! suitable for dual mode operation.  Applications may use this function to
+//! ensure that the controller is in a neutral state and able to receive
+//! appropriate interrupts before host or device mode is chosen using a call
+//! to USBStackModeSet().
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBDualModeInit(uint32_t ui32Index)
+{
+    //
+    // We only support a single USB controller.
+    //
+    ASSERT(ui32Index == 0);
+
+    //
+    // Configure the End point 0.
+    //
+    USBHostEndpointConfig(USB0_BASE, USB_EP_0, 64, 0, 0,
+                          (USB_EP_MODE_CTRL | USB_EP_SPEED_FULL |
+                           USB_EP_HOST_OUT));
+
+    //
+    // Enable USB Interrupts.
+    //
+    MAP_USBIntEnableControl(USB0_BASE, USB_INTCTRL_RESET |
+                                       USB_INTCTRL_DISCONNECT |
+                                       USB_INTCTRL_SESSION |
+                                       USB_INTCTRL_BABBLE |
+                                       USB_INTCTRL_CONNECT |
+                                       USB_INTCTRL_RESUME |
+                                       USB_INTCTRL_SUSPEND |
+                                       USB_INTCTRL_VBUS_ERR);
+
+    //
+    // Enable all endpoint interrupts.
+    //
+    MAP_USBIntEnableEndpoint(USB0_BASE, USB_INTEP_ALL);
+
+    //
+    // Initialize the USB tick module.
+    //
+    InternalUSBTickInit();
+
+    //
+    // Enable the USB interrupt.
+    //
+    OS_INT_ENABLE(g_psDCDInst[0].ui32IntNum);
+    //
+    // Turn on session request to enable ID pin checking.
+    //
+    USBOTGSessionRequest(USB0_BASE, true);
+
+    //
+    // Initialize the power configuration.
+    //
+    USBHostPwrConfig(USB0_BASE, USBHCDPowerConfigGet(ui32Index));
+
+    //
+    // If power enable is automatic then then USBHostPwrEnable() has to be
+    // called to allow the USB controller to control the power enable pin.
+    //
+    if(USBHCDPowerAutomatic(ui32Index))
+    {
+        //
+        // This will not turn on power but instead will allow the USB
+        // controller to turn on power when needed.
+        //
+        USBHostPwrEnable(USB0_BASE);
+    }
+}
+
+//*****************************************************************************
+//
+//! Returns the USB controller to the default mode when in dual mode operation.
+//!
+//! \param ui32Index specifies the USB controller whose dual mode operation is
+//! to be ended.  This parameter must be set to 0.
+//!
+//! Applications using both host and device modes may call this function to
+//! disable interrupts in preparation for shutdown or a change of operating
+//! mode.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBDualModeTerm(uint32_t ui32Index)
+{
+    //
+    // We only support a single USB controller.
+    //
+    ASSERT(ui32Index == 0);
+
+    //
+    // Disable the USB interrupt.
+    //
+    OS_INT_DISABLE(g_psDCDInst[0].ui32IntNum);
+
+    MAP_USBIntDisableControl(USB0_BASE, USB_INTCTRL_ALL);
+
+    MAP_USBIntDisableEndpoint(USB0_BASE, USB_INTEP_ALL);
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group dualmode_api.
+//! @}
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! \addtogroup usblib_otg
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! Returns the USB controller to and inactive state when in OTG mode
+//! operation.
+//!
+//! \param ui32Index specifies the USB controller to end OTG mode operations.
+//!
+//! Applications using OTG mode may call this function to disable interrupts
+//! in preparation for shutdown or a change of operating mode.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBOTGModeTerm(uint32_t ui32Index)
+{
+    //
+    // We only support a single USB controller.
+    //
+    ASSERT(ui32Index == 0);
+
+    //
+    // Disable the USB interrupt.
+    //
+    OS_INT_DISABLE(g_psDCDInst[0].ui32IntNum);
+
+    //
+    // Disable all control interrupts.
+    //
+    MAP_USBIntDisableControl(USB0_BASE, USB_INTCTRL_ALL);
+
+    //
+    // Disable all endpoint interrupts.
+    //
+    MAP_USBIntDisableEndpoint(USB0_BASE, USB_INTEP_ALL);
+
+    //
+    // Set the mode to none if it is not already.
+    //
+    USBOTGSetMode(eUSBModeNone);
+}
+
+//*****************************************************************************
+//
+//! Initializes the USB controller for OTG mode operation.
+//!
+//! \param ui32Index specifies the USB controller that is to be initialized for
+//! OTG mode operation.
+//! \param ui32PollingRate is the rate in milliseconds to poll the controller
+//! for changes in mode.
+//! \param pvPool is a pointer to the data to use as a memory pool for this
+//! controller.
+//! \param ui32PoolSize is the size in bytes of the buffer passed in as
+//! \e pvPool.
+//!
+//! This function initializes the USB controller hardware into a state
+//! suitable for OTG mode operation.  Applications must use this function to
+//! ensure that the controller is in a neutral state and able to receive
+//! appropriate interrupts before host or device mode is chosen by OTG
+//! negotiation.  The \e ui32PollingRate parameter is used to set the rate at
+//! which the USB library will poll the controller to determine the mode.  This
+//! has the most effect on how quickly the USB library will detect changes when
+//! going to host mode.  The parameters \e pvPool and \e ui32PoolSize are
+//! passed on to the USB host library functions to provide memory for the USB
+//! library when it is acting as a  host. Any device and host initialization
+//! should have been called before calling this function to prevent the USB
+//! library from attempting to run in device or host mode before the USB
+//! library is fully configured.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBOTGModeInit(uint32_t ui32Index, uint32_t ui32PollingRate,
+               void *pvPool, uint32_t ui32PoolSize)
+{
+    //
+    // We only support a single USB controller.
+    //
+    ASSERT(ui32Index == 0);
+
+    //
+    // This should never be called if not in OTG mode.
+    //
+    ASSERT(g_iUSBMode == eUSBModeOTG);
+
+    //
+    // Force OTG mode in all cases since anything else is invalid, but a DEBUG
+    // build will still ASSERT above if this value is incorrect.
+    //
+    g_iUSBMode = eUSBModeOTG;
+
+    //
+    // Remember that we have not yet determined whether we are device or
+    // host.
+    //
+    g_iDualMode = eUSBModeNone;
+
+    //
+    // Set the default polling rate.
+    //
+    g_ui32PollRate = ui32PollingRate;
+
+    //
+    // Enable the USB controller.
+    //
+    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_USB0);
+
+    //
+    // Turn on USB Phy clock.
+    //
+    MAP_SysCtlUSBPLLEnable();
+
+    //
+    // Initialize the host controller stack.
+    //
+    USBHCDInit(ui32Index, pvPool, ui32PoolSize);
+
+    //
+    // Configure the End point 0.
+    //
+    USBHostEndpointConfig(USB0_BASE, USB_EP_0, 64, 0, 0,
+                          (USB_EP_MODE_CTRL | USB_EP_SPEED_FULL |
+                           USB_EP_HOST_OUT));
+
+    //
+    // Enable control interrupts.
+    //
+    MAP_USBIntEnableControl(USB0_BASE, USB_INTCTRL_RESET |
+                                       USB_INTCTRL_DISCONNECT |
+                                       USB_INTCTRL_SESSION |
+                                       USB_INTCTRL_BABBLE |
+                                       USB_INTCTRL_CONNECT |
+                                       USB_INTCTRL_RESUME |
+                                       USB_INTCTRL_SUSPEND |
+                                       USB_INTCTRL_VBUS_ERR |
+                                       USB_INTCTRL_MODE_DETECT |
+                                       USB_INTCTRL_SOF);
+
+    //
+    // Make sure the mode OTG mode and not forced device or host.
+    //
+    USBOTGMode(USB0_BASE);
+
+    //
+    // Enable all endpoint interrupts.
+    //
+    MAP_USBIntEnableEndpoint(USB0_BASE, USB_INTEP_ALL);
+
+    //
+    // Initialize the power configuration.
+    //
+    USBHCDPowerConfigSet(ui32Index, USBHCDPowerConfigGet(ui32Index));
+
+    //
+    // If power enable is automatic then then USBHostPwrEnable() has to be
+    // called to allow the USB controller to control the power enable pin.
+    //
+    if(USBHCDPowerAutomatic(ui32Index))
+    {
+        //
+        // This will not turn on power but instead will allow the USB
+        // controller to turn on power when needed.
+        //
+        USBHostPwrEnable(USB0_BASE);
+    }
+
+    //
+    // Enable the USB interrupt.
+    //
+    if(CLASS_IS_TM4C129)
+    {
+        OS_INT_ENABLE(INT_USB0_TM4C129);
+    }
+    else
+    {
+        OS_INT_ENABLE(INT_USB0_TM4C123);
+    }
+}
+
+//*****************************************************************************
+//
+// This function handles the steps required to remove power in OTG mode.
+//
+// \param ui32Index specifies which USB controller should remove power.
+//
+// This function will perform the steps required to remove power from the USB
+// bus as required by the OTG specification.  This call will first issue a
+// bus suspend followed by clearing the current session and then removing
+// power.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+USBOTGRemovePower(uint32_t ui32Index)
+{
+    tEventInfo sEvent;
+
+    //
+    // Do suspend signaling.
+    //
+    USBHostSuspend(USB0_BASE);
+
+    //
+    // End the session in either device or host mode.
+    //
+    USBOTGSessionRequest(USB0_BASE, false);
+
+    //
+    // Check if the controller is automatically applying power or not.
+    //
+    if(USBHCDPowerAutomatic(ui32Index) == 0)
+    {
+        //
+        // Call the registered event driver to allow it to disable power.
+        //
+        sEvent.ui32Event = USB_EVENT_POWER_DISABLE;
+        sEvent.ui32Instance = 0;
+        InternalUSBHCDSendEvent(0, &sEvent, USBHCD_EVFLAG_PWRDIS);
+    }
+}
+
+//*****************************************************************************
+//
+//! This call sets the USB OTG controllers poll rate when checking for the mode
+//! of the controller.
+//!
+//! \param ui32Index specifies which USB controller to set the polling rate.
+//! \param ui32PollRate is the rate in milliseconds to poll for changes in the
+//! controller mode.
+//!
+//! This function is called to set the USB OTG libraries polling rate when
+//! checking the status of the cable.  The \e ui32PollRate value used sets the
+//! rate in milliseconds that the USB OTG library will poll the cable to see
+//! if the controller should enter host mode.  This value has no effect on
+//! device detection rate as the controller will detect being connected to a
+//! host controller automatically.  The \e ui32PollRate can be set to 0 to
+//! disable polling.  The USB OTG library can still function with the polling
+//! rate set to zero, however it will fail to detect host mode properly when no
+//! device is present at the end of the USB OTG B side of the cable.
+//!
+//! \note This function should only be called on devices that support OTG
+//! functionality.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBOTGPollRate(uint32_t ui32Index, uint32_t ui32PollRate)
+{
+    //
+    // Save the timeout.
+    //
+    g_ui32PollRate = ui32PollRate;
+}
+
+//*****************************************************************************
+//
+//! Handles OTG mode changes and also steers other USB interrupts from
+//! the controller to the correct handler in the USB stack.
+//!
+//! This interrupt handler is used in applications which require to operate
+//! in both host and device mode using OTG.  When in host or device mode, it
+//! steers the USB hardware interrupt to the correct handler in the USB stack
+//! depending upon the current operating mode.  It also handles other OTG
+//! related interrupt events.
+//!
+//! For successful OTG mode operation, an application must register
+//! USB0OTGModeIntHandler() in the CPU vector table as the interrupt handler
+//! for the USB0 interrupt.
+//!
+//! \note This interrupt handler should only be used on controllers that
+//! support OTG functionality.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USB0OTGModeIntHandler(void)
+{
+    uint32_t ui32Status;
+    tEventInfo sEvent;
+
+    //
+    // Read the USB interrupt status.
+    //
+    ui32Status = USBIntStatusControl(USB0_BASE);
+
+    //
+    // Check if this was an mode detect interrupt and under manual power
+    // control.
+    //
+    if((ui32Status & USB_INTCTRL_MODE_DETECT) &&
+       (USBHCDPowerAutomatic(0) == 0))
+    {
+        uint32_t ui32Mode;
+
+        ui32Mode = USBModeGet(USB0_BASE);
+
+        switch(ui32Mode)
+        {
+            //
+            // Device is on the A side of the cable and power needs to be
+            // applied.
+            //
+            case USB_OTG_MODE_ASIDE_NPWR:
+            case USB_OTG_MODE_ASIDE_SESS:
+            case USB_OTG_MODE_ASIDE_AVAL:
+            {
+                //
+                // Since power is not automatically enabled, call the
+                // registered event handler to allow the application to turn
+                // on power.
+                //
+                sEvent.ui32Event = USB_EVENT_POWER_ENABLE;
+                sEvent.ui32Instance = 0;
+                InternalUSBHCDSendEvent(0, &sEvent, USBHCD_EVFLAG_PWREN);
+
+                break;
+            }
+
+            //
+            // Device is on the B side of the cable and powered.
+            //
+            case USB_OTG_MODE_BSIDE_DEV:
+            {
+                //
+                // Now in device mode on the B side of the cable and will wait
+                // for a connect before becoming a device.
+                //
+                g_eOTGModeState = eUSBOTGModeBWaitCon;
+
+                break;
+            }
+
+            //
+            // Any other mode detect indicates eUSBModeNone.
+            //
+            default:
+            {
+                //
+                // Just inform the application that the mode was not device
+                // or host.
+                //
+                USBOTGSetMode(eUSBModeNone);
+
+                break;
+            }
+        }
+    }
+
+    //
+    // If there was a VBUS error then the power should be shut off and the
+    // system is reset to waiting for detection again.
+    //
+    if(ui32Status & USB_INTCTRL_VBUS_ERR)
+    {
+        //
+        // Just inform the application that the mode was not device
+        // or host.
+        //
+        USBOTGSetMode(eUSBModeNone);
+
+        //
+        // Return to idle mode.
+        //
+        g_eOTGModeState = eUSBOTGModeWait;
+    }
+
+    //
+    // If there is a disconnect interrupt and the controller was on the B side
+    // cable as a device then go back to the IDLE state.
+    //
+    if((ui32Status & USB_INTCTRL_DISCONNECT) &&
+       (g_eOTGModeState == eUSBOTGModeBDevice))
+    {
+        //
+        // No longer a device so switch to unconfigured mode.
+        //
+        USBOTGSetMode(eUSBModeNone);
+
+        //
+        // Return to idle mode.
+        //
+        g_eOTGModeState = eUSBOTGModeWait;
+
+        return;
+    }
+
+    //
+    // Handle receiving a reset.
+    //
+    if((ui32Status & USB_INTCTRL_RESET)&&
+       (g_eOTGModeState != eUSBOTGModeBDevice))
+    {
+        //
+        // Getting a reset interrupt when not already a b side device indicates
+        // that a host is resetting the device and the controller should
+        // move to device mode.
+        //
+        g_eOTGModeState = eUSBOTGModeBDevice;
+
+        //
+        // Save the new mode.
+        //
+        USBOTGSetMode(eUSBModeDevice);
+    }
+
+    //
+    // If there is a connect interrupt while the library is waiting for
+    // one then move to full host mode state.
+    //
+    if(ui32Status & USB_INTCTRL_CONNECT)
+    {
+        //
+        // Move to A side host state.
+        //
+        g_eOTGModeState = eUSBOTGModeAHost;
+
+        //
+        // Inform the application that controller is in host mode.
+        //
+        USBOTGSetMode(eUSBModeHost);
+    }
+
+    //
+    // Call the correct device or host interrupt handler based on the current
+    // mode of operation.
+    //
+    switch(g_eOTGModeState)
+    {
+        case eUSBOTGModeAHost:
+        {
+            //
+            // Call the host interrupt handler if there is anything still to
+            // process.
+            //
+            USBHostIntHandlerInternal(0, ui32Status);
+
+            break;
+        }
+
+        //
+        // Operating in pure device mode.
+        //
+        case eUSBOTGModeBDevice:
+        {
+            //
+            // Call the device interrupt handler.
+            //
+            USBDeviceIntHandlerInternal(0, ui32Status);
+
+            break;
+        }
+        default:
+        {
+            break;
+        }
+    }
+}
+
+//*****************************************************************************
+//
+// This function is called by the USB host stack code to indicated that it
+// has completed handing the device disconnection.
+//
+// \param ui32Index specifies the USB controller that has completed disconnect.
+//
+// This internal library function is used when the hsot controller has
+// completed any deferred handling when it has detected a device has been
+// disconnected.  The functions main purpose is to return the OTG controller to
+// a state that allows for resuming normal OTG cable detection and negotiation.
+//
+// \note This function should not be called outside the library.
+//
+//*****************************************************************************
+void
+OTGDeviceDisconnect(uint32_t ui32Index)
+{
+    //
+    // This function is only valid when called in host mode.
+    //
+    if(g_eOTGModeState == eUSBOTGModeAHost)
+    {
+        //
+        // No longer a host so switch to unconfigured mode.
+        //
+        USBOTGSetMode(eUSBModeNone);
+
+        g_eOTGModeState = eUSBOTGModeWait;
+    }
+}
+
+//*****************************************************************************
+//
+//! This function is the main routine for the OTG Controller Driver.
+//!
+//! \param ui32MsTicks is the number of milliseconds that have passed since the
+//! last time this function was called.
+//!
+//! This function is the main routine for the USB controller when using the
+//! library in OTG mode.  This routine must be called periodically by the main
+//! application outside of a callback context.  The \e ui32MsTicks value is
+//! used for basic timing needed by the USB library when operating in OTG mode.
+//! This allows for a simple cooperative system to access the the OTG
+//! controller driver interface without the need for an RTOS.  All time
+//! critical operations are handled in interrupt context but all longer
+//! operations are run from the this function to allow them to block and wait
+//! for completion without holding off other interrupts.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBOTGMain(uint32_t ui32MsTicks)
+{
+    tEventInfo sEvent;
+
+    if(ui32MsTicks > g_ui32WaitTicks)
+    {
+        g_ui32WaitTicks = 0;
+    }
+    else
+    {
+        g_ui32WaitTicks -= ui32MsTicks;
+    }
+
+    switch(g_eOTGModeState)
+    {
+        case eUSBOTGModeIdle:
+        {
+            g_eOTGModeState = eUSBOTGModeWaitID;
+
+            //
+            // Initiate a session request and check the ID pin.
+            //
+            USBOTGSessionRequest(USB0_BASE, true);
+            break;
+        }
+        case eUSBOTGModeWait:
+        case eUSBOTGModeWaitID:
+        {
+            //
+            // If reached the timeout and polling is enabled then look again.
+            //
+            if((g_ui32WaitTicks == 0) && (g_ui32PollRate != 0))
+            {
+                //
+                // Remove the session request.
+                //
+                USBOTGSessionRequest(USB0_BASE, false);
+
+                //
+                // Return to idle mode.
+                //
+                USBOTGSetMode(eUSBModeNone);
+
+                //
+                // Check if the controller is automatically applying power or
+                // not.
+                //
+                if(USBHCDPowerAutomatic(0) == 0)
+                {
+                    //
+                    // Call the registered event driver to allow it to disable
+                    // power.
+                    //
+                    sEvent.ui32Event = USB_EVENT_POWER_DISABLE;
+                    sEvent.ui32Instance = 0;
+                    InternalUSBHCDSendEvent(0, &sEvent, USBHCD_EVFLAG_PWRDIS);
+                }
+
+                //
+                // Go back to the idle state.
+                //
+                g_eOTGModeState = eUSBOTGModeIdle;
+            }
+            break;
+        }
+        case eUSBOTGModeAHost:
+        {
+            //
+            // Call the host main routine when acting as a host.
+            //
+            USBHCDMain();
+            break;
+        }
+        case eUSBOTGModeBWaitCon:
+        case eUSBOTGModeBDevice:
+        default:
+        {
+            break;
+        }
+    }
+}
+
+//*****************************************************************************
+//
+//! This function sets one of the \b USBLIB_FEATURE_ requests.
+//!
+//! \param ui32Index is the index of the USB controller to access.
+//! \param ui32Feature is one of the \b USBLIB_FEATURE_ defines.
+//! \param pvFeature is a pointer to the data for the \b USBLIB_FEATURE
+//!        request.
+//!
+//! This function sends the requested feature request to the USB library.
+//! Not all features are supported by all devices so see the documentation
+//! for the \b USBLIB_FEATURE_ to determine if the feature is supported.
+//!
+//! \return Returns \b true if the feature was set and \b false if the feature
+//! is not supported or could not be changed to the requested value.
+//
+//*****************************************************************************
+bool
+USBOTGFeatureSet(uint32_t ui32Index, uint32_t ui32Feature, void *pvFeature)
+{
+    bool bRetCode;
+
+    bRetCode = true;
+
+    //
+    // Pass this on to the host and device and indicate false if
+    // either fails.
+    //
+    if(USBDCDFeatureSet(ui32Index, ui32Feature, pvFeature) == false)
+    {
+        bRetCode = false;
+    }
+
+    if(USBHCDFeatureSet(ui32Index, ui32Feature, pvFeature) == false)
+    {
+        bRetCode = false;
+    }
+
+    return(bRetCode);
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
diff --git a/bsp/tm4c129x/libraries/usblib/usbmsc.h b/bsp/tm4c129x/libraries/usblib/usbmsc.h
new file mode 100755
index 0000000..32faae1
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/usbmsc.h
@@ -0,0 +1,444 @@
+//*****************************************************************************
+//
+// usbmsc.h - Generic types and defines use by the mass storage class.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#ifndef __USBMSC_H__
+#define __USBMSC_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+//*****************************************************************************
+//
+// The request for the maximum number of logical units on a mass storage
+// device.
+//
+//*****************************************************************************
+#define USBREQ_GET_MAX_LUN      0xfe
+
+//*****************************************************************************
+//
+// The request for the bulk only reset of a mass storage device.
+//
+//*****************************************************************************
+#define USBREQ_BULK_ONLY_RESET  0xff
+
+//*****************************************************************************
+//
+// The signatures defined by USB MSC class specification.
+//
+//*****************************************************************************
+#define CBW_SIGNATURE           0x43425355
+#define CSW_SIGNATURE           0x53425355
+
+//*****************************************************************************
+//
+// Flag for the bmCBWFlags member of tMSCCBW
+//
+//*****************************************************************************
+#define CBWFLAGS_DIR_M          0x80
+#define CBWFLAGS_DIR_IN         0x80
+#define CBWFLAGS_DIR_OUT        0x00
+
+//*****************************************************************************
+//
+// All structures defined in this section of the header require byte packing of
+// fields.  This is usually accomplished using the PACKED macro but, for IAR
+// Embedded Workbench, this requries a pragma.
+//
+//*****************************************************************************
+#ifdef ewarm
+#pragma pack(1)
+#endif
+
+//*****************************************************************************
+//
+// The following packed structure is used to access the Command Block Wrapper
+// (CBW) data structure that is used when communicating with USB Mass Storage
+// Class devices.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    // Signature that helps identify this data packet as a CBW.  The signature
+    // field shall contain the value 0x43425355 (little endian), indicating a
+    // CBW.
+    //
+    uint32_t dCBWSignature;
+
+    //
+    // The Command Block Tag sent by the host controller.  The device shall
+    // echo the contents of this field back to the host in the dCSWTag field
+    // of the associated CSW.  The dCSWTag positively associates a CSW with the
+    // corresponding CBW.
+    //
+    uint32_t dCBWTag;
+
+    //
+    // The number of bytes of data that the host expects to transfer on the
+    // Bulk-In or Bulk-Out endpoint (as indicated by the Direction bit) during
+    // the execution of this command.  If this field is zero, the device and
+    // the host will not transfer data between the CBW and the associated CSW,
+    // and the device will ignore the value of the Direction bit in
+    // bmCBWFlags.
+    //
+    uint32_t dCBWDataTransferLength;
+
+    //
+    // The device will ignore these bits if the dCBWDataTransferLength value
+    // is set to 0.
+    //
+    // The bits of this field are defined as follows:
+    // Bit 7 Direction
+    //   0 = Data-Out from host to the device,
+    //   1 = Data-In from the device to the host.
+    // Bit 6 Obsolete - The host shall set this bit to zero.
+    // Bits 5..0 Reserved - the host shall set these bits to zero.
+    //
+    uint8_t bmCBWFlags;
+
+    //
+    // The device Logical Unit Number (LUN) to which the command block is being
+    // sent.  For devices that support multiple LUNs, the host shall place into
+    // this field the LUN to which this command block is addressed.  Otherwise,
+    // the host shall set this field to zero.
+    //
+    uint8_t bCBWLUN;
+
+    //
+    // The valid length of the CBWCB in bytes.  This defines the valid length
+    // of the command block.  The only legal values are 1 through 16.  All
+    // other values are reserved.
+    //
+    uint8_t bCBWCBLength;
+
+    //
+    // This array holds the command block to be executed by the device.  The
+    // MSC device will interpret the first bCBWCBLength bytes in this field as
+    // a command block as defined by the command set identified by
+    // bInterfaceSubClass.  If the command set supported by the device uses
+    // command blocks of fewer than 16 bytes in length, the significant bytes
+    // shall be transferred first, beginning with the byte at offset 15.  The
+    // device will ignore the content of the CBWCB field past the byte at
+    // offset (15 + bCBWCBLength - 1).
+    //
+    uint8_t CBWCB[16];
+}
+PACKED tMSCCBW;
+
+//*****************************************************************************
+//
+// Flags for the bCSWStatus member of tMSCCSW
+//
+//*****************************************************************************
+#define CSWSTATUS_CMD_SUCCESS   0
+#define CSWSTATUS_CMD_FAILED    1
+#define CSWSTATUS_PHASE_ERROR   2
+
+//*****************************************************************************
+//
+// This structure encapsulates the Command Status Word (CSW) structure that is
+// sent in response to all CBW commands.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    // Signature that identifies this data packet as a CSW.  The signature
+    // field must contain the value 53425355h (little endian) to indicate CSW.
+    //
+    uint32_t dCSWSignature;
+
+    //
+    // The device will set this field to the value received in the dCBWTag of
+    // the associated CBW.
+    //
+    uint32_t dCSWTag;
+
+    //
+    // For OUT transactions the device will fill the dCSWDataResidue field with
+    // the difference between the amount of data expected as stated in the
+    // dCBWDataTransferLength, and the actual amount of data processed by the
+    // device.  For IN transactions the device will fill the dCSWDataResidue
+    // field with the difference between the amount of data expected as stated
+    // in the dCBWDataTransferLength and the actual amount of relevant data
+    // sent by the device.  The dCSWDataResidue will not exceed the value sent
+    // in the dCBWDataTransferLength.
+    //
+    uint32_t dCSWDataResidue;
+
+    //
+    // The bCSWStatus field indicates the success or failure of the command.
+    // The device shall set this byte to zero if the command completed
+    // successfully.  A non-zero value shall indicate a failure during command
+    // execution.
+    //
+    uint8_t bCSWStatus;
+}
+PACKED tMSCCSW;
+
+//*****************************************************************************
+//
+// Return to default packing when using the IAR Embedded Workbench compiler.
+//
+//*****************************************************************************
+#ifdef ewarm
+#pragma pack()
+#endif
+
+//*****************************************************************************
+//
+// SCSI Command return codes.
+//
+//*****************************************************************************
+#define SCSI_CMD_STATUS_PASS        0x00
+#define SCSI_CMD_STATUS_FAIL        0x01
+
+//*****************************************************************************
+//
+// SCSI commands.
+//
+//*****************************************************************************
+#define SCSI_TEST_UNIT_READY        0x00
+#define SCSI_REQUEST_SENSE          0x03
+#define SCSI_INQUIRY_CMD            0x12
+#define SCSI_MODE_SENSE_6           0x1a
+#define SCSI_START_STOP_UNIT        0x1b
+#define SCSI_MEDIUM_REMOVAL         0x1e
+#define SCSI_READ_CAPACITIES        0x23
+#define SCSI_READ_CAPACITY          0x25
+#define SCSI_READ_10                0x28
+#define SCSI_WRITE_10               0x2a
+
+//*****************************************************************************
+//
+// SCSI Test Unit Ready definitions.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// SCSI Inquiry command definitions.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Size of the SCSI inquiry response data.
+//
+//*****************************************************************************
+#define SCSI_INQUIRY_DATA_SZ    36
+
+//*****************************************************************************
+//
+// Offset 0 of the Inquiry Data.
+//
+//*****************************************************************************
+#define SCSI_INQ_PQ_M           0xe0  // Peripheral Qualifier Mask.
+#define SCSI_INQ_PQ_CNCT        0x00  // Device connected.
+#define SCSI_INQ_PQ_DISC        0x20  // Device disconnected.
+#define SCSI_INQ_PDT_M          0x1f  // Peripheral Device Type Mask.
+#define SCSI_INQ_PDT_SBC        0x00  // Direct Access device.
+
+//*****************************************************************************
+//
+// Offset 1 of the Inquiry Data.
+//
+//*****************************************************************************
+#define SCSI_INQ_RMB            0x80  // Device is removable.
+
+//*****************************************************************************
+//
+// Macro to check if removeable.
+//
+//*****************************************************************************
+#define SCSIIsRemovable(pData)                                                \
+                                (((uint8_t *)pData)[1] & SCSI_INQ_RMB)
+
+//*****************************************************************************
+//
+// SCSI Read Capacity definitions.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Size of the SCSI Read Capacity response data.
+//
+//*****************************************************************************
+#define SCSI_READ_CAPACITY_SZ   0x08
+
+//*****************************************************************************
+//
+// SCSI Mode Sense definitions, these are passed in via the ui32Flags parameter
+// of the SCSIModeSense() function call.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Disable block descriptors.
+//
+//*****************************************************************************
+#define SCSI_MS_DBD             0x00000800
+
+//*****************************************************************************
+//
+// Page Code values, used in combination with Page Control values.
+//
+//*****************************************************************************
+#define SCSI_MS_PC_VENDOR       0x00000000
+#define SCSI_MS_PC_DISCO        0x00020000
+#define SCSI_MS_PC_CONTROL      0x000a0000
+#define SCSI_MS_PC_LUN          0x00180000
+#define SCSI_MS_PC_PORT         0x00190000
+#define SCSI_MS_PC_POWER        0x001a0000
+#define SCSI_MS_PC_INFORM       0x001c0000
+#define SCSI_MS_PC_ALL          0x003f0000
+
+//*****************************************************************************
+//
+// Page Control values.
+//
+//*****************************************************************************
+#define SCSI_MS_PC_CURRENT      0x00000000
+#define SCSI_MS_PC_CHANGEABLE   0x00400000
+#define SCSI_MS_PC_DEFAULT      0x00800000
+#define SCSI_MS_PC_SAVED        0x00c00000
+
+//*****************************************************************************
+//
+// Request Sense Definitions.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Size of the data returned by the Request Sense command.
+//
+//*****************************************************************************
+#define SCSI_REQUEST_SENSE_SZ   18
+
+#define SCSI_RS_SKEY            2     // Sense Key offset.
+#define SCSI_RS_SKEY_AD_SKEY    12    // Additional Sense Key offset.
+
+//*****************************************************************************
+//
+// Offset 0 in the Request Sense response.
+//
+//*****************************************************************************
+#define SCSI_RS_VALID           0x80  // Response is valid.
+#define SCSI_RS_CUR_ERRORS      0x70  // Current errors returned.
+#define SCSI_RS_DEFER_ERRORS    0x71  // Deferred errors returned.
+
+//*****************************************************************************
+//
+// Offset 2 in the Request Sense response.
+//
+//*****************************************************************************
+#define SCSI_RS_KEY_M           0x0f  // Sense Key.
+#define SCSI_RS_KEY_NO_SENSE    0x00  // No Sense Data.
+#define SCSI_RS_KEY_RECOVRD_ERR 0x01  // Recovered Error.
+#define SCSI_RS_KEY_NOT_READY   0x02  // Not Ready.
+#define SCSI_RS_KEY_MEDIUM_ERR  0x03  // Error in the media.
+#define SCSI_RS_KEY_HW_ERR      0x04  // Hardware Error, non recoverable.
+#define SCSI_RS_KEY_ILGL_RQST   0x05  // Illegal request.
+#define SCSI_RS_KEY_UNIT_ATTN   0x06  // Unit changed or reset.
+#define SCSI_RS_KEY_DATA_PROT   0x07  // Write Protect error.
+#define SCSI_RS_KEY_BLANK_CHK   0x08  // Write once error, block not clear.
+#define SCSI_RS_KEY_ABORT       0x0b  // Last command was aborted.
+#define SCSI_RS_ILI             0x20  // Incorrect length indicator.
+#define SCSI_RS_EOM             0x40  // End of medium condition.
+#define SCSI_RS_FILEMARK        0x80  // Command has read a filemark/setmark.
+#define SCSI_RS_MED_NOT_PRSNT   0x003a  // Medium not present.
+#define SCSI_RS_MED_NOTRDY2RDY  0x0028  // Not ready to ready transition.
+#define SCSI_RS_PV_INVALID      0x0226  // Parameter Value Invalid.
+
+//*****************************************************************************
+//
+// Additional information for SCSI_RS_KEY_NOT_READY
+//
+//*****************************************************************************
+#define SCSI_RS_KEY_NOTPRSNT    0x3A  // Media Not Present.
+
+//*****************************************************************************
+//
+// Prevent/Allow Medium Removal Definitions.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Offset 4 in the Prevent/Allow Medium Removal command.
+//
+//*****************************************************************************
+#define SCSI_PE_MEDRMV_M           0x03
+#define SCSI_PE_MEDRMV_ALLOW    0x00
+#define SCSI_PE_MEDRMV_PREVENT    0x01
+
+//*****************************************************************************
+//
+// Start/Stop Unit Definitions.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Offset 1 in the Start/Stop Unit command.
+//
+//*****************************************************************************
+#define SCSI_SS_UNIT_IMMED        0x01
+#define SCSI_SS_UNIT_LUN_M        0xe0
+
+//*****************************************************************************
+//
+// Offset 4 in the Start/Stop Unit command.
+//
+//*****************************************************************************
+#define SCSI_SS_UNIT_START        0x01
+#define SCSI_SS_UNIT_LOEJ        0x02
+#define SCSI_SS_UNIT_PWR_M      0xf0
+#define SCSI_SS_UNIT_PWR_ACTIVE 0x10
+#define SCSI_SS_UNIT_PWR_IDLE   0x20
+#define SCSI_SS_UNIT_PWR_STDBY  0x30
+#define SCSI_SS_UNIT_PWR_DSLEEP 0x50
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __USBMSC_H__
diff --git a/bsp/tm4c129x/libraries/usblib/usbringbuf.c b/bsp/tm4c129x/libraries/usblib/usbringbuf.c
new file mode 100755
index 0000000..afe4eb6
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/usbringbuf.c
@@ -0,0 +1,715 @@
+//*****************************************************************************
+//
+// usbringbuf.c - USB library ring buffer management utilities.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "inc/hw_types.h"
+#include "driverlib/debug.h"
+#include "driverlib/interrupt.h"
+#include "usblib/usblib.h"
+
+//*****************************************************************************
+//
+//! \addtogroup usblib_buffer_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// Define NULL, if not already defined.
+//
+//*****************************************************************************
+#ifndef NULL
+#define NULL                    ((void *)0)
+#endif
+
+//*****************************************************************************
+//
+// Change the value of a variable atomically.
+//
+// \param pui32Val points to the index whose value is to be modified.
+// \param ui32Delta is the number of bytes to increment the index by.
+// \param ui32Size is the size of the buffer the index refers to.
+//
+// This function is used to increment a read or write buffer index that may be
+// written in various different contexts.  It ensures that the
+// read/modify/write sequence is not interrupted and, hence, guards against
+// corruption of the variable.  The new value is adjusted for buffer wrap.
+//
+// \return None.
+//
+//*****************************************************************************
+static void
+UpdateIndexAtomic(volatile uint32_t *pui32Val, uint32_t ui32Delta,
+                  uint32_t ui32Size)
+{
+    bool bIntsOff;
+
+    //
+    // Turn interrupts off temporarily.
+    //
+    bIntsOff = IntMasterDisable();
+
+    //
+    // Update the variable value.
+    //
+    *pui32Val += ui32Delta;
+
+    //
+    // Correct for wrap.  We use a loop here since we don't want to use a
+    // modulus operation with interrupts off but we don't want to fail in
+    // case ui32Delta is greater than ui32Size (which is extremely unlikely
+    // but...)
+    //
+    while(*pui32Val >= ui32Size)
+    {
+        *pui32Val -= ui32Size;
+    }
+
+    //
+    // Restore the interrupt state
+    //
+    if(!bIntsOff)
+    {
+        IntMasterEnable();
+    }
+}
+
+//*****************************************************************************
+//
+//! Determines whether a ring buffer is full or not.
+//!
+//! \param psUSBRingBuf is the ring buffer object to empty.
+//!
+//! This function is used to determine whether or not a given ring buffer is
+//! full.  The structure is specifically to ensure that we do not see
+//! warnings from the compiler related to the order of volatile accesses
+//! being undefined.
+//!
+//! \return Returns \b true if the buffer is full or \b false otherwise.
+//
+//*****************************************************************************
+bool
+USBRingBufFull(tUSBRingBufObject *psUSBRingBuf)
+{
+    uint32_t ui32Write;
+    uint32_t ui32Read;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(psUSBRingBuf != NULL);
+
+    //
+    // Copy the Read/Write indices for calculation.
+    //
+    ui32Write = psUSBRingBuf->ui32WriteIndex;
+    ui32Read = psUSBRingBuf->ui32ReadIndex;
+
+    //
+    // Return the full status of the buffer.
+    //
+    return((((ui32Write + 1) % psUSBRingBuf->ui32Size) == ui32Read) ? true :
+                                                                      false);
+}
+
+//*****************************************************************************
+//
+//! Determines whether a ring buffer is empty or not.
+//!
+//! \param psUSBRingBuf is the ring buffer object to empty.
+//!
+//! This function is used to determine whether or not a given ring buffer is
+//! empty.  The structure is specifically to ensure that we do not see
+//! warnings from the compiler related to the order of volatile accesses
+//! being undefined.
+//!
+//! \return Returns \b true if the buffer is empty or \b false otherwise.
+//
+//*****************************************************************************
+bool
+USBRingBufEmpty(tUSBRingBufObject *psUSBRingBuf)
+{
+    uint32_t ui32Write;
+    uint32_t ui32Read;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(psUSBRingBuf != NULL);
+
+    //
+    // Copy the Read/Write indices for calculation.
+    //
+    ui32Write = psUSBRingBuf->ui32WriteIndex;
+    ui32Read = psUSBRingBuf->ui32ReadIndex;
+
+    //
+    // Return the empty status of the buffer.
+    //
+    return((ui32Write == ui32Read) ? true : false);
+}
+
+//*****************************************************************************
+//
+//! Empties the ring buffer.
+//!
+//! \param psUSBRingBuf is the ring buffer object to empty.
+//!
+//! Discards all data from the ring buffer.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBRingBufFlush(tUSBRingBufObject *psUSBRingBuf)
+{
+    bool bIntsOff;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(psUSBRingBuf != NULL);
+
+    //
+    // Set the Read/Write pointers to be the same.  Do this with interrupts
+    // disabled to prevent the possibility of corruption of the read index.
+    //
+    bIntsOff = IntMasterDisable();
+    psUSBRingBuf->ui32ReadIndex = psUSBRingBuf->ui32WriteIndex;
+    if(!bIntsOff)
+    {
+        IntMasterEnable();
+    }
+}
+
+//*****************************************************************************
+//
+//! Returns number of bytes stored in ring buffer.
+//!
+//! \param psUSBRingBuf is the ring buffer object to check.
+//!
+//! This function returns the number of bytes stored in the ring buffer.
+//!
+//! \return Returns the number of bytes stored in the ring buffer.
+//
+//*****************************************************************************
+uint32_t
+USBRingBufUsed(tUSBRingBufObject *psUSBRingBuf)
+{
+    uint32_t ui32Write;
+    uint32_t ui32Read;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(psUSBRingBuf != NULL);
+
+    //
+    // Copy the Read/Write indices for calculation.
+    //
+    ui32Write = psUSBRingBuf->ui32WriteIndex;
+    ui32Read = psUSBRingBuf->ui32ReadIndex;
+
+    //
+    // Return the number of bytes contained in the ring buffer.
+    //
+    return((ui32Write >= ui32Read) ? (ui32Write - ui32Read) :
+           (psUSBRingBuf->ui32Size - (ui32Read - ui32Write)));
+}
+
+//*****************************************************************************
+//
+//! Returns number of bytes available in a ring buffer.
+//!
+//! \param psUSBRingBuf is the ring buffer object to check.
+//!
+//! This function returns the number of bytes available in the ring buffer.
+//!
+//! \return Returns the number of bytes available in the ring buffer.
+//
+//*****************************************************************************
+uint32_t
+USBRingBufFree(tUSBRingBufObject *psUSBRingBuf)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(psUSBRingBuf != NULL);
+
+    //
+    // Return the number of bytes available in the ring buffer.
+    //
+    return((psUSBRingBuf->ui32Size - 1) - USBRingBufUsed(psUSBRingBuf));
+}
+
+//*****************************************************************************
+//
+//! Returns number of contiguous bytes of data stored in ring buffer ahead of
+//! the current read pointer.
+//!
+//! \param psUSBRingBuf is the ring buffer object to check.
+//!
+//! This function returns the number of contiguous bytes of data available in
+//! the ring buffer ahead of the current read pointer.  This represents the
+//! largest block of data which does not straddle the buffer wrap.
+//!
+//! \return Returns the number of contiguous bytes available.
+//
+//*****************************************************************************
+uint32_t
+USBRingBufContigUsed(tUSBRingBufObject *psUSBRingBuf)
+{
+    uint32_t ui32Write;
+    uint32_t ui32Read;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(psUSBRingBuf != NULL);
+
+    //
+    // Copy the Read/Write indices for calculation.
+    //
+    ui32Write = psUSBRingBuf->ui32WriteIndex;
+    ui32Read = psUSBRingBuf->ui32ReadIndex;
+
+    //
+    // Return the number of contiguous bytes available.
+    //
+    return((ui32Write >= ui32Read) ? (ui32Write - ui32Read) :
+           (psUSBRingBuf->ui32Size - ui32Read));
+}
+
+//*****************************************************************************
+//
+//! Returns number of contiguous free bytes available in a ring buffer.
+//!
+//! \param psUSBRingBuf is the ring buffer object to check.
+//!
+//! This function returns the number of contiguous free bytes ahead of the
+//! current write pointer in the ring buffer.
+//!
+//! \return Returns the number of contiguous bytes available in the ring
+//! buffer.
+//
+//*****************************************************************************
+uint32_t
+USBRingBufContigFree(tUSBRingBufObject *psUSBRingBuf)
+{
+    uint32_t ui32Write;
+    uint32_t ui32Read;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(psUSBRingBuf != NULL);
+
+    //
+    // Copy the Read/Write indices for calculation.
+    //
+    ui32Write = psUSBRingBuf->ui32WriteIndex;
+    ui32Read = psUSBRingBuf->ui32ReadIndex;
+
+    //
+    // Return the number of contiguous bytes available.
+    //
+    if(ui32Read > ui32Write)
+    {
+        //
+        // The read pointer is above the write pointer so the amount of free
+        // space is the difference between the two indices minus 1 to account
+        // for the buffer full condition (write index one behind read index).
+        //
+        return((ui32Read - ui32Write) - 1);
+    }
+    else
+    {
+        //
+        // If the write pointer is above the read pointer, the amount of free
+        // space is the size of the buffer minus the write index.  We need to
+        // add a special-case adjustment if the read index is 0 since we need
+        // to leave 1 byte empty to ensure we can tell the difference between
+        // the buffer being full and empty.
+        //
+        return(psUSBRingBuf->ui32Size - ui32Write - ((ui32Read == 0) ? 1 : 0));
+    }
+}
+
+//*****************************************************************************
+//
+//! Returns the size in bytes of a ring buffer.
+//!
+//! \param psUSBRingBuf is the ring buffer object to check.
+//!
+//! This function returns the size of the ring buffer.
+//!
+//! \return Returns the size in bytes of the ring buffer.
+//
+//*****************************************************************************
+uint32_t
+USBRingBufSize(tUSBRingBufObject *psUSBRingBuf)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(psUSBRingBuf != NULL);
+
+    //
+    // Return the number of bytes available in the ring buffer.
+    //
+    return(psUSBRingBuf->ui32Size);
+}
+
+//*****************************************************************************
+//
+//! Reads a single byte of data from a ring buffer.
+//!
+//! \param psUSBRingBuf points to the ring buffer to be written to.
+//!
+//! This function reads a single byte of data from a ring buffer.
+//!
+//! \return The byte read from the ring buffer.
+//
+//*****************************************************************************
+uint8_t
+USBRingBufReadOne(tUSBRingBufObject *psUSBRingBuf)
+{
+    uint8_t ui8Temp;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(psUSBRingBuf != NULL);
+
+    //
+    // Verify that space is available in the buffer.
+    //
+    ASSERT(USBRingBufUsed(psUSBRingBuf) != 0);
+
+    //
+    // Write the data byte.
+    //
+    ui8Temp = psUSBRingBuf->pui8Buf[psUSBRingBuf->ui32ReadIndex];
+
+    //
+    // Increment the read index.
+    //
+    UpdateIndexAtomic(&psUSBRingBuf->ui32ReadIndex, 1, psUSBRingBuf->ui32Size);
+
+    //
+    // Return the character read.
+    //
+    return(ui8Temp);
+}
+
+//*****************************************************************************
+//
+//! Reads data from a ring buffer.
+//!
+//! \param psUSBRingBuf points to the ring buffer to be read from.
+//! \param pui8Data points to where the data should be stored.
+//! \param ui32Length is the number of bytes to be read.
+//!
+//! This function reads a sequence of bytes from a ring buffer.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBRingBufRead(tUSBRingBufObject *psUSBRingBuf, uint8_t *pui8Data,
+               uint32_t ui32Length)
+{
+    uint32_t ui32Temp;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(psUSBRingBuf != NULL);
+    ASSERT(pui8Data != NULL);
+    ASSERT(ui32Length != 0);
+
+    //
+    // Verify that data is available in the buffer.
+    //
+    ASSERT(ui32Length <= USBRingBufUsed(psUSBRingBuf));
+
+    //
+    // Read the data from the ring buffer.
+    //
+    for(ui32Temp = 0; ui32Temp < ui32Length; ui32Temp++)
+    {
+        pui8Data[ui32Temp] = USBRingBufReadOne(psUSBRingBuf);
+    }
+}
+
+//*****************************************************************************
+//
+//! Removes bytes from the ring buffer by advancing the read index.
+//!
+//! \param psUSBRingBuf points to the ring buffer from which bytes are to be
+//! removed.
+//! \param ui32NumBytes is the number of bytes to be removed from the buffer.
+//!
+//! This function advances the ring buffer read index by a given number of
+//! bytes, removing that number of bytes of data from the buffer.  If
+//! \e ui32NumBytes is larger than the number of bytes currently in the buffer,
+//! the buffer is emptied.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBRingBufAdvanceRead(tUSBRingBufObject *psUSBRingBuf, uint32_t ui32NumBytes)
+{
+    uint32_t ui32Count;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(psUSBRingBuf != NULL);
+
+    //
+    // Make sure that we are not being asked to remove more data than is
+    // there to be removed.
+    //
+    ui32Count = USBRingBufUsed(psUSBRingBuf);
+    ui32Count =  (ui32Count < ui32NumBytes) ? ui32Count : ui32NumBytes;
+
+    //
+    // Advance the buffer read index by the required number of bytes.
+    //
+    UpdateIndexAtomic(&psUSBRingBuf->ui32ReadIndex, ui32Count,
+                      psUSBRingBuf->ui32Size);
+}
+
+//*****************************************************************************
+//
+//! Adds bytes to the ring buffer by advancing the write index.
+//!
+//! \param psUSBRingBuf points to the ring buffer to which bytes have been
+//! added.
+//! \param ui32NumBytes is the number of bytes added to the buffer.
+//!
+//! This function should be used by clients who wish to add data to the buffer
+//! directly rather than via calls to USBRingBufWrite() or
+//! USBRingBufWriteOne().  It advances the write index by a given number of
+//! bytes.
+//!
+//! \note It is considered an error if the \e ui32NumBytes parameter is larger
+//! than the amount of free space in the buffer and a debug build of this
+//! function will fail (ASSERT) if this condition is detected.  In a release
+//! build, the buffer read pointer will be advanced if too much data is written
+//! but this will, of course, result in some of the oldest data in the buffer
+//! being discarded and also, depending upon how data is being read from
+//! the buffer, may result in a race condition which could corrupt the read
+//! pointer.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBRingBufAdvanceWrite(tUSBRingBufObject *psUSBRingBuf, uint32_t ui32NumBytes)
+{
+    uint32_t ui32Count;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(psUSBRingBuf != NULL);
+
+    //
+    // Make sure we were not asked to add a silly number of bytes.
+    //
+    ASSERT(ui32NumBytes <= psUSBRingBuf->ui32Size);
+
+    //
+    // Determine how much free space we currently think the buffer has.
+    //
+    ui32Count = USBRingBufFree(psUSBRingBuf);
+
+    //
+    // Check that the client has not added more data to the buffer than there
+    // is space for.  In this case, corruption may have occurred since the
+    // buffer may have been read under interrupt context while the writer was
+    // busy trashing the area around the read pointer.
+    //
+    ASSERT(ui32Count >= ui32NumBytes);
+
+    //
+    // Update the write pointer.
+    //
+    psUSBRingBuf->ui32WriteIndex += ui32NumBytes;
+
+    //
+    // Check and correct for wrap.
+    //
+    if(psUSBRingBuf->ui32WriteIndex >= psUSBRingBuf->ui32Size)
+    {
+        psUSBRingBuf->ui32WriteIndex -= psUSBRingBuf->ui32Size;
+    }
+
+    //
+    // Did the client add more bytes than the buffer had free space for?  This
+    // should be considered a bug since, unless this function is called in
+    // the same context as the code which is reading from the buffer, writing
+    // over the earliest data can cause corrupted data to be read.  The
+    // ASSERT above catches this in debug builds but, in release builds, we
+    // go ahead and try to fix up the read pointer appropriately.
+    //
+    if(ui32Count < ui32NumBytes)
+    {
+        //
+        // Yes - we need to advance the read pointer to ahead of the write
+        // pointer to discard some of the oldest data.
+        //
+        psUSBRingBuf->ui32ReadIndex = psUSBRingBuf->ui32WriteIndex + 1;
+
+        //
+        // Correct for buffer wrap if necessary.
+        //
+        if(psUSBRingBuf->ui32ReadIndex >= psUSBRingBuf->ui32Size)
+        {
+            psUSBRingBuf->ui32ReadIndex -= psUSBRingBuf->ui32Size;
+        }
+    }
+
+}
+
+//*****************************************************************************
+//
+//! Writes a single byte of data to a ring buffer.
+//!
+//! \param psUSBRingBuf points to the ring buffer to be written to.
+//! \param ui8Data is the byte to be written.
+//!
+//! This function writes a single byte of data into a ring buffer.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBRingBufWriteOne(tUSBRingBufObject *psUSBRingBuf, uint8_t ui8Data)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(psUSBRingBuf != NULL);
+
+    //
+    // Verify that space is available in the buffer.
+    //
+    ASSERT(USBRingBufFree(psUSBRingBuf) != 0);
+
+    //
+    // Write the data byte.
+    //
+    psUSBRingBuf->pui8Buf[psUSBRingBuf->ui32WriteIndex] = ui8Data;
+
+    //
+    // Increment the write index.
+    //
+    UpdateIndexAtomic(&psUSBRingBuf->ui32WriteIndex, 1,
+                      psUSBRingBuf->ui32Size);
+}
+
+//*****************************************************************************
+//
+//! Writes data to a ring buffer.
+//!
+//! \param psUSBRingBuf points to the ring buffer to be written to.
+//! \param pui8Data points to the data to be written.
+//! \param ui32Length is the number of bytes to be written.
+//!
+//! This function write a sequence of bytes into a ring buffer.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBRingBufWrite(tUSBRingBufObject *psUSBRingBuf, const uint8_t *pui8Data,
+                uint32_t ui32Length)
+{
+    uint32_t ui32Temp;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(psUSBRingBuf != NULL);
+    ASSERT(pui8Data != NULL);
+    ASSERT(ui32Length != 0);
+
+    //
+    // Verify that space is available in the buffer.
+    //
+    ASSERT(ui32Length <= USBRingBufFree(psUSBRingBuf));
+
+    //
+    // Write the data into the ring buffer.
+    //
+    for(ui32Temp = 0; ui32Temp < ui32Length; ui32Temp++)
+    {
+        USBRingBufWriteOne(psUSBRingBuf, pui8Data[ui32Temp]);
+    }
+}
+
+//*****************************************************************************
+//
+//! Initializes a ring buffer object.
+//!
+//! \param psUSBRingBuf points to the ring buffer to be initialized.
+//! \param pui8Buf points to the data buffer to be used for the ring buffer.
+//! \param ui32Size is the size of the buffer in bytes.
+//!
+//! This function initializes a ring buffer object, preparing it to store data.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+USBRingBufInit(tUSBRingBufObject *psUSBRingBuf, uint8_t *pui8Buf,
+               uint32_t ui32Size)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(psUSBRingBuf != NULL);
+    ASSERT(pui8Buf != NULL);
+    ASSERT(ui32Size != 0);
+
+    //
+    // Initialize the ring buffer object.
+    //
+    psUSBRingBuf->ui32Size = ui32Size;
+    psUSBRingBuf->pui8Buf = pui8Buf;
+    psUSBRingBuf->ui32WriteIndex = psUSBRingBuf->ui32ReadIndex = 0;
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
diff --git a/bsp/tm4c129x/libraries/usblib/usbtick.c b/bsp/tm4c129x/libraries/usblib/usbtick.c
new file mode 100755
index 0000000..2964968
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/usbtick.c
@@ -0,0 +1,219 @@
+//*****************************************************************************
+//
+// usbtick.c - Functions related to USB stack tick timer handling.
+//
+// Copyright (c) 2008-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "inc/hw_types.h"
+#include "driverlib/debug.h"
+#include "usblib/usblib.h"
+#include "usblib/usblibpriv.h"
+
+//*****************************************************************************
+//
+//! \addtogroup general_usblib_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// These are the internal timer tick handlers used by the USB stack.  Handlers
+// in g_pfnTickHandlers are called in the context of the USB SOF interrupt
+// every USB_SOF_TICK_DIVIDE milliseconds.
+//
+//*****************************************************************************
+tUSBTickHandler g_pfnTickHandlers[MAX_USB_TICK_HANDLERS];
+void *g_pvTickInstance[MAX_USB_TICK_HANDLERS];
+
+//*****************************************************************************
+//
+// Flag to indicate whether or not we have been initialized.
+//
+//*****************************************************************************
+bool g_bUSBTimerInitialized = false;
+
+//*****************************************************************************
+//
+// This is the current tick value in ms for the system.  This is used for all
+// instances of USB controllers and for all timer tick handlers.
+//
+//*****************************************************************************
+uint32_t g_ui32CurrentUSBTick = 0;
+
+//*****************************************************************************
+//
+// This is the total number of SOF interrupts received since the system
+// booted.  The value is incremented by the low level device- or host-interrupt
+// handler functions.
+//
+//*****************************************************************************
+uint32_t g_ui32USBSOFCount = 0;
+
+//*****************************************************************************
+//
+// This internal function initializes the variables used in processing timer
+// ticks.
+//
+// This function should only be called from within the USB library.  It is set
+// up to ensure that it can be called multiple times if necessary without
+// the previous configuration being erased (to cater for OTG mode switching).
+//
+// \return None.
+//
+//*****************************************************************************
+void
+InternalUSBTickInit(void)
+{
+    uint32_t ui32Loop;
+
+    if(!g_bUSBTimerInitialized)
+    {
+        for(ui32Loop = 0; ui32Loop < MAX_USB_TICK_HANDLERS; ui32Loop++)
+        {
+            g_pfnTickHandlers[ui32Loop] = (tUSBTickHandler)0;
+            g_pvTickInstance[ui32Loop] = 0;
+        }
+
+        g_bUSBTimerInitialized = true;
+    }
+}
+
+//*****************************************************************************
+//
+// This internal function resets the USB tick handler.
+//
+// This function should only be called from within the USB library.  It will
+// clear out the tick handler state and should be called to allow the tick
+// handlers to be initialized once USBDCDInit() function is called.
+//
+// \return None.
+//
+//*****************************************************************************
+void
+InternalUSBTickReset(void)
+{
+    //
+    // Reset the initialized flag so that the next time InternalUSBTickInit()
+    // is called.
+    //
+    g_bUSBTimerInitialized = 0;
+}
+
+//*****************************************************************************
+//
+// This internal function handles registering OTG, Host, or Device SOF timer
+// handler functions.
+//
+// \param pfHandler specifies the handler to call for the given type of
+// handler.
+// \param pvInstance is the instance pointer that will be returned to the
+// function provided in the \e pfHandler function.
+//
+// This function should only be called inside the USB library and only as a
+// result to a call to reinitialize the stack in a new mode.  Currently the
+// following 3 types of timer tick handlers can be registered:
+// TICK_HANDLER_OTG, TICK_HANDLER_HOST, or TICK_HANDLER_DEVICE.  Handlers
+// registered via this function are called in the context of the SOF interrupt.
+//
+// \return A value of zero means that the tick handler was registered and any
+// other value indicates an error.
+//
+//*****************************************************************************
+int32_t
+InternalUSBRegisterTickHandler(tUSBTickHandler pfHandler, void *pvInstance)
+{
+    int32_t i32Idx;
+
+    for(i32Idx = 0; i32Idx < MAX_USB_TICK_HANDLERS; i32Idx++)
+    {
+        if(g_pfnTickHandlers[i32Idx] == 0)
+        {
+            //
+            // Save the handler.
+            //
+            g_pfnTickHandlers[i32Idx] = pfHandler;
+
+            //
+            // Save the instance data.
+            //
+            g_pvTickInstance[i32Idx] = pvInstance;
+
+            break;
+        }
+    }
+
+    if(i32Idx == MAX_USB_TICK_HANDLERS)
+    {
+        return(-1);
+    }
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! \internal
+//!
+//! Calls internal handlers in response to a tick based on the start of frame
+//! interrupt.
+//!
+//! \param ui32TicksmS specifies how many milliseconds have passed since the
+//! last call to this function.
+//!
+//! This function is called every 5mS in the context of the Start of Frame
+//! (SOF) interrupt.  It is used to call any registered internal tick
+//! functions.
+//!
+//! This function should only be called from within the USB library.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+InternalUSBStartOfFrameTick(uint32_t ui32TicksmS)
+{
+    int32_t i32Idx;
+
+    //
+    // Advance time.
+    //
+    g_ui32CurrentUSBTick += ui32TicksmS;
+
+    //
+    // Call any registered SOF tick handlers.
+    //
+    for(i32Idx = 0; i32Idx < MAX_USB_TICK_HANDLERS; i32Idx++)
+    {
+        if(g_pfnTickHandlers[i32Idx])
+        {
+            g_pfnTickHandlers[i32Idx](g_pvTickInstance[i32Idx], ui32TicksmS);
+        }
+    }
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
diff --git a/bsp/tm4c129x/libraries/usblib/usbulpi.c b/bsp/tm4c129x/libraries/usblib/usbulpi.c
new file mode 100755
index 0000000..cba7c89
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/usbulpi.c
@@ -0,0 +1,176 @@
+//*****************************************************************************
+//
+// usbulpi.c - ULPI access functions.
+//
+// Copyright (c) 2013-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+#include <stdbool.h>
+#include <stdint.h>
+#include "inc/hw_types.h"
+#include "driverlib/usb.h"
+#include "usbulpi.h"
+
+//*****************************************************************************
+//
+// Hardware ULPI registers.
+//
+//*****************************************************************************
+#define ULPI_FCTL               0x04
+#define ULPI_FCTL_SET           0x05
+#define ULPI_FCTL_CLEAR         0x06
+#define ULPI_ICTL               0x07
+#define ULPI_ICTL_SET           0x08
+#define ULPI_ICTL_CLEAR         0x09
+#define ULPI_OTGCTL             0x0A
+#define ULPI_OTGCTL_SET         0x0B
+#define ULPI_OTGCTL_CLEAR       0x0C
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ULPI_FCTL register.
+//
+//*****************************************************************************
+#define ULPI_FCTL_XCVR_M        0x03
+#define ULPI_FCTL_XCVR_HS       0x00
+#define ULPI_FCTL_XCVR_FS       0x01
+#define ULPI_FCTL_XCVR_LS       0x02
+#define ULPI_FCTL_XCVR_FSLS     0x03
+#define ULPI_FCTL_TERMSEL       0x04
+#define ULPI_FCTL_OPMODE_M      0x18
+#define ULPI_FCTL_OPMODE_NORM   0x00
+#define ULPI_FCTL_OPMODE_NODRV  0x08
+#define ULPI_FCTL_OPMODE_NONRZI 0x10
+#define ULPI_FCTL_OPMODE_DISAUTO \
+                                0x18
+#define ULPI_FCTL_OPMODE_RESET  0x20
+#define ULPI_FCTL_OPMODE_SUSPEND \
+                                0x40
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ULPI_ICTL register.
+//
+//*****************************************************************************
+#define ULPI_ICTL_SER6PIN       0x01
+#define ULPI_ICTL_SER3PIN       0x02
+#define ULPI_ICTL_AUTORESUME    0x10
+#define ULPI_ICTL_INDINV        0x20
+#define ULPI_ICTL_INDPASSTHRU   0x40
+#define ULPI_ICTL_PROTDIS       0x80
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ULPI_OTGCTL register.
+//
+//*****************************************************************************
+#define ULPI_OTGCTL_ID_EN       0x01
+#define ULPI_OTGCTL_DPPD_EN     0x02
+#define ULPI_OTGCTL_DMPD_EN     0x04
+#define ULPI_OTGCTL_DISCHRG_VBUS \
+                                0x08
+#define ULPI_OTGCTL_CHRG_VBUS   0x10
+#define ULPI_OTGCTL_VBUSINT_EN  0x20
+#define ULPI_OTGCTL_VBUSEXT_EN  0x40
+#define ULPI_OTGCTL_VBUSEXT_IND 0x80
+
+//*****************************************************************************
+//
+//! Sets the configuration of an external USB Phy.
+//!
+//! \param ui32Base specifies the USB module base address.
+//! \param ui32Config specifies the configuration options for the external Phy.
+//!
+//! This function sets the configuration options for an externally connected
+//! USB Phy that is connected using the ULPI interface.  The \e ui32Config
+//! parameter holds all of the configuration options defined by the
+//! \b UPLI_CFG_ values.  The values are grouped as follows:
+//!
+//! Connection speed, using one of the following:
+//! - \b UPLI_CFG_HS enables high speed operation.
+//! - \b UPLI_CFG_FS enables full speed operation.
+//! - \b UPLI_CFG_HS enables low speed operation.
+//!
+//! Any of the following can be included:
+//! - \b UPLI_CFG_AUTORESUME enable automatic transmission of resume signaling
+//!   from the Phy.
+//! - \b UPLI_CFG_INVVBUSIND inverts the external VBUS indicator if it is
+//!   selected.
+//! - \b UPLI_CFG_PASSTHRUIND passes the external VBUS indicator through
+//!   without using the Phy's VBUS comparator.
+//! - \b ULPI_CFG_EXTVBUSDRV enables an external VBUS drive source.
+//! - \b ULPI_CFG_EXTVBUSIND enables an external signal for VBUS valid.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ULPIConfigSet(uint32_t ui32Base, uint32_t ui32Config)
+{
+    uint8_t ui8Val;
+
+    ui8Val = USBULPIRegRead(ui32Base, ULPI_FCTL);
+    ui8Val &= ~(ULPI_FCTL_XCVR_M);
+    ui8Val = ui8Val | (uint8_t)ui32Config;
+
+    USBULPIRegWrite(ui32Base, ULPI_FCTL, ui8Val);
+
+    ui8Val = USBULPIRegRead(ui32Base, ULPI_ICTL);
+    ui8Val &= ~(ULPI_ICTL_AUTORESUME | ULPI_ICTL_INDINV |
+                ULPI_ICTL_INDPASSTHRU);
+    ui8Val = ui8Val | (uint8_t)((ui32Config >> 8) & 0xff);
+
+    USBULPIRegWrite(ui32Base, ULPI_ICTL, ui8Val);
+
+    ui8Val = USBULPIRegRead(ui32Base, ULPI_OTGCTL);
+    ui8Val &= ~(ULPI_OTGCTL_VBUSINT_EN | ULPI_OTGCTL_VBUSEXT_EN |
+                ULPI_OTGCTL_VBUSEXT_IND);
+    ui8Val = ui8Val | (uint8_t)((ui32Config >> 16) & 0xff);
+
+    USBULPIRegWrite(ui32Base, ULPI_OTGCTL, ui8Val);
+}
+
+//*****************************************************************************
+//
+//! Enables or disables power to the external USB Phy.
+//!
+//! \param ui32Base specifies the USB module base address.
+//! \param bEnable specifies if the Phy is fully powered or in suspend mode.
+//!
+//! This function sets the current power configuration for the external ULPI
+//! connected Phy.  When \e bEnable is \b true the Phy is fully powered and
+//! when \b false the USB Phy is in suspend mode.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ULPIPowerTransceiver(uint32_t ui32Base, bool bEnable)
+{
+    if(bEnable)
+    {
+        USBULPIRegWrite(ui32Base, ULPI_FCTL_CLEAR,
+                        ULPI_FCTL_OPMODE_SUSPEND);
+    }
+    else
+    {
+        USBULPIRegWrite(ui32Base, ULPI_FCTL_SET,
+                        ULPI_FCTL_OPMODE_SUSPEND);
+    }
+}
diff --git a/bsp/tm4c129x/libraries/usblib/usbulpi.h b/bsp/tm4c129x/libraries/usblib/usbulpi.h
new file mode 100755
index 0000000..b8d8343
--- /dev/null
+++ b/bsp/tm4c129x/libraries/usblib/usbulpi.h
@@ -0,0 +1,40 @@
+//*****************************************************************************
+//
+// usbulpi.h - Header file for ULPI access functions.
+//
+// Copyright (c) 2013-2014 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2.1.0.12573 of the Tiva USB Library.
+//
+//*****************************************************************************
+
+#ifndef __ULPI_H__
+#define __ULPI_H__
+
+#define ULPI_CFG_HS             0x00000000
+#define ULPI_CFG_FS             0x00000001
+#define ULPI_CFG_LS             0x00000002
+#define ULPI_CFG_AUTORESUME     0x00001000
+#define ULPI_CFG_INVVBUSIND     0x00002000
+#define ULPI_CFG_PASSTHRUIND    0x00004000
+#define ULPI_CFG_EXTVBUSDRV     0x00400000
+#define ULPI_CFG_EXTVBUSIND     0x00800000
+
+extern void ULPIConfigSet(uint32_t ui32Base, uint32_t ui32Config);
+extern void ULPIPowerTransceiver(uint32_t ui32Base, bool bEnable);
+
+#endif
diff --git a/bsp/tm4c129x/make.sh b/bsp/tm4c129x/make.sh
new file mode 100755
index 0000000..572289c
--- /dev/null
+++ b/bsp/tm4c129x/make.sh
@@ -0,0 +1,3 @@
+#! /bin/bash
+scons.bat
+openocd -f openocd.cfg -c "flash_image"
diff --git a/bsp/tm4c129x/openocd.cfg b/bsp/tm4c129x/openocd.cfg
new file mode 100755
index 0000000..ef95001
--- /dev/null
+++ b/bsp/tm4c129x/openocd.cfg
@@ -0,0 +1,12 @@
+source [find board/ek-tm4c1294xl.cfg]
+
+init
+
+proc flash_image {} {
+    reset halt
+    flash write_image erase rtthread.bin 0x00000000
+
+    reset init
+    shutdown
+    reset
+}
diff --git a/bsp/tm4c129x/rtconfig.h b/bsp/tm4c129x/rtconfig.h
index c00e453..0cff4ad 100644
--- a/bsp/tm4c129x/rtconfig.h
+++ b/bsp/tm4c129x/rtconfig.h
@@ -91,7 +91,7 @@
 // <integer name="RT_MMCSD_THREAD_PREORITY" description="The prority of mmcsd thread" default="15" />
 #define RT_MMCSD_THREAD_PREORITY    15
 // <section name="RT_USING_CONSOLE" description="Using console" default="true" >
-#define RT_USING_CONSOLE
+//#define RT_USING_CONSOLE
 // <integer name="RT_CONSOLEBUF_SIZE" description="The buffer size for console output" default="128" />
 #define RT_CONSOLEBUF_SIZE  128
 // <string name="RT_CONSOLE_DEVICE_NAME" description="The device name for console" default="uart" />
@@ -101,7 +101,7 @@
 // <bool name="RT_USING_COMPONENTS_INIT" description="Using RT-Thread components initialization" default="true" />
 #define RT_USING_COMPONENTS_INIT
 // <section name="RT_USING_FINSH" description="Using finsh as shell, which is a C-Express shell" default="true" >
-#define RT_USING_FINSH
+//#define RT_USING_FINSH
 // <bool name="FINSH_USING_SYMTAB" description="Using symbol table in finsh shell" default="true" />
 #define FINSH_USING_SYMTAB
 // <bool name="FINSH_USING_DESCRIPTION" description="Keeping description in symbol table" default="true" />
@@ -120,7 +120,7 @@
 // </section>
 
 // <section name="RT_USING_DFS" description="Device file system" default="true" >
-//#define RT_USING_DFS
+#define RT_USING_DFS
 // <bool name="DFS_USING_WORKDIR" description="Using working directory" default="true" />
 //#define DFS_USING_WORKDIR
 // <integer name="DFS_FILESYSTEM_TYPES_MAX" description="The maximal number of the supported file system type" default="4" />
@@ -158,21 +158,21 @@
 // <bool name="RT_USING_DFS_DEVFS" description="Using devfs for device objects" default="true" />
 #define RT_USING_DFS_DEVFS
 // <bool name="RT_USING_DFS_ROMFS" description="Using ROMFS" default="false" />
-//#define RT_USING_DFS_ROMFS
+#define RT_USING_DFS_ROMFS
 // <bool name="RT_USING_DFS_NFS" description="Using NFS" default="false" />
-//#define RT_USING_DFS_NFS
+#define RT_USING_DFS_NFS
 // <string name="RT_NFS_HOST_EXPORT" description="The exported NFS host path" default="192.168.1.10:/" />
-#define RT_NFS_HOST_EXPORT  "192.168.1.20:/"
+#define RT_NFS_HOST_EXPORT  "192.168.1.6:/"
 // </section>
 
 // <section name="RT_USING_LWIP" description="lwip, a lightweight TCP/IP protocol stack" default="true" >
 #define RT_USING_LWIP
 // <bool name="RT_USING_LWIP141" description="Using lwIP 1.4.1 version" default="true" />
-#define RT_USING_LWIP141
+/*#define RT_USING_LWIP141*/
 // <bool name="RT_LWIP_ICMP" description="Enable ICMP protocol" default="true" />
 #define RT_LWIP_ICMP
 // <bool name="RT_LWIP_IGMP" description="Enable IGMP protocol" default="false" />
-// #define RT_LWIP_IGMP
+#define RT_LWIP_IGMP
 // <bool name="RT_LWIP_UDP" description="Enable UDP protocol" default="true" />
 #define RT_LWIP_UDP
 // <bool name="RT_LWIP_TCP" description="Enable TCP protocol" default="true" />
@@ -180,19 +180,19 @@
 // <bool name="RT_LWIP_DNS" description="Enable DNS protocol" default="true" />
 #define RT_LWIP_DNS
 // <integer name="RT_LWIP_PBUF_NUM" description="Maximal number of buffers in the pbuf pool" default="4" />
-#define RT_LWIP_PBUF_NUM    8
+#define RT_LWIP_PBUF_NUM    36
 // <integer name="RT_LWIP_TCP_PCB_NUM" description="Maximal number of simultaneously active TCP connections" default="5" />
-#define RT_LWIP_TCP_PCB_NUM 5
+#define RT_LWIP_TCP_PCB_NUM 9
 // <integer name="RT_LWIP_TCP_SND_BUF" description="TCP sender buffer size" default="8192" />
-#define RT_LWIP_TCP_SND_BUF 8192
+#define RT_LWIP_TCP_SND_BUF 8192 //4096
 // <integer name="RT_LWIP_TCP_WND" description="TCP receive window" default="8192" />
-#define RT_LWIP_TCP_WND 8192
+#define RT_LWIP_TCP_WND 4096//2048
 // <bool name="RT_LWIP_SNMP" description="Enable SNMP protocol" default="false" />
 // #define RT_LWIP_SNMP
 // <bool name="RT_LWIP_DHCP" description="Enable DHCP client to get IP address" default="false" />
- #define RT_LWIP_DHCP
+//#define RT_LWIP_DHCP
 // <integer name="RT_LWIP_TCP_SEG_NUM" description="the number of simultaneously queued TCP" default="4" />
-#define RT_LWIP_TCP_SEG_NUM 24
+#define RT_LWIP_TCP_SEG_NUM 144
 // <integer name="RT_LWIP_TCPTHREAD_PRIORITY" description="the thread priority of TCP thread" default="128" />
 #define RT_LWIP_TCPTHREAD_PRIORITY  12
 // <integer name="RT_LWIP_TCPTHREAD_MBOX_SIZE" description="the mail box size of TCP thread to wait for" default="32" />
@@ -200,7 +200,7 @@
 // <integer name="RT_LWIP_TCPTHREAD_STACKSIZE" description="the thread stack size of TCP thread" default="4096" />
 #define RT_LWIP_TCPTHREAD_STACKSIZE 4096
 // <integer name="RT_LWIP_ETHTHREAD_PRIORITY" description="the thread priority of ethnetif thread" default="144" />
-#define RT_LWIP_ETHTHREAD_PRIORITY  14
+#define RT_LWIP_ETHTHREAD_PRIORITY  8
 // <integer name="RT_LWIP_ETHTHREAD_MBOX_SIZE" description="the mail box size of ethnetif thread to wait for" default="8" />
 #define RT_LWIP_ETHTHREAD_MBOX_SIZE 8
 // <integer name="RT_LWIP_ETHTHREAD_STACKSIZE" description="the stack size of ethnetif thread" default="512" />
@@ -220,9 +220,24 @@
 #define RT_LWIP_MSKADDR1 255
 #define RT_LWIP_MSKADDR2 255
 #define RT_LWIP_MSKADDR3 0
-// </section>
-
 
+// </section>
+#define RT_LWIP_IPV6 1
+#define RT_LWIP_IPV6_AUTOCONFIG 1
+#define RT_USING_LWIP_HEAD 1
+#define RT_USING_NETUTILS 1
+#define LWIP_CHECKSUM_ON_COPY 0
+#define CHECKSUM_GEN_UDP 0
+#define CHECKSUM_GEN_TCP 0
+#define CHECKSUM_GEN_ICMP 0
+#define CHECKSUM_GEN_ICMP6 0
+#define CHECKSUM_GEN_IP 0
+#define CHECKSUM_CHECK_IP 0
+#define CHECKSUM_CHECK_UDP 0
+#define CHECKSUM_CHECK_TCP 0
+#define CHECKSUM_CHECK_ICMP 0
+#define CHECKSUM_CHECK_ICMP6 0
+#define RT_SERIAL_RB_BUFSZ 2048
 
 // </RDTConfigurator>
 
diff --git a/bsp/tm4c129x/rtconfig.py b/bsp/tm4c129x/rtconfig.py
index ba3fc51..9a2e05a 100644
--- a/bsp/tm4c129x/rtconfig.py
+++ b/bsp/tm4c129x/rtconfig.py
@@ -11,7 +11,7 @@ if os.getenv('RTT_CC'):
 	CROSS_TOOL = os.getenv('RTT_CC')
 	
 #device options
-PART_TYPE = 'PART_TM4C129XNCZAD'
+PART_TYPE = 'PART_TM4C1294NCPDT'
 # cross_tool provides the cross compiler
 # EXEC_PATH is the compiler execute path, for example, CodeSourcery, Keil MDK, IAR
 if  CROSS_TOOL == 'gcc':
diff --git a/components/net/lwip-head/SConscript b/components/net/lwip-head/SConscript
index f075886..787a99f 100644
--- a/components/net/lwip-head/SConscript
+++ b/components/net/lwip-head/SConscript
@@ -110,7 +110,7 @@ if GetDepend(['RT_LWIP_PPP']):
 
 # For testing apps
 if GetDepend(['RT_USING_NETUTILS']):
-    src += Glob('./apps/*.c')
+    src += Glob('../lwip/apps/netio.c') +Glob('../lwip/apps/tcpecho.c')
 
 group = DefineGroup('LwIP', src, depend = ['RT_USING_LWIP', 'RT_USING_LWIP_HEAD'], CPPPATH = path)
 
diff --git a/components/net/lwip-head/apps/ipv6/tcpclient.c b/components/net/lwip-head/apps/ipv6/tcpclient.c
new file mode 100755
index 0000000..7a0d4b5
--- /dev/null
+++ b/components/net/lwip-head/apps/ipv6/tcpclient.c
@@ -0,0 +1,98 @@
+#include <rtthread.h>
+#include <lwip/netdb.h> /* 为了解析主机名，需要包含netdb.h头文件 */
+#include <lwip/sockets.h> /* 使用BSD socket，需要包含sockets.h头文件 */
+
+#define BUFSZ	1024
+
+static const char send_data[] = "This is TCP Client from RT-Thread."; /* 发送用到的数据 */
+void tcpclient(const char* url, int port)
+{
+    char *recv_data;
+    struct hostent *host;
+    int sock, bytes_received;
+    struct sockaddr_in server_addr;
+
+    /* 通过函数入口参数url获得host地址（如果是域名，会做域名解析） */
+    host = gethostbyname(url);
+
+    /* 分配用于存放接收数据的缓冲 */
+    recv_data = rt_malloc(BUFSZ);
+    if (recv_data == RT_NULL)
+    {
+        rt_kprintf("No memory\n");
+        return;
+    }
+
+    /* 创建一个socket，类型是SOCKET_STREAM，TCP类型 */
+    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
+    {
+        /* 创建socket失败 */
+        rt_kprintf("Socket error\n");
+
+        /* 释放接收缓冲 */
+        rt_free(recv_data);
+        return;
+    }
+
+    /* 初始化预连接的服务端地址 */
+    server_addr.sin_family = AF_INET;
+    server_addr.sin_port = htons(port);
+    server_addr.sin_addr = *((struct in_addr *)host->h_addr);
+    rt_memset(&(server_addr.sin_zero), 0, sizeof(server_addr.sin_zero));
+
+    /* 连接到服务端 */
+    if (connect(sock, (struct sockaddr *)&server_addr, sizeof(struct sockaddr)) == -1)
+    {
+        /* 连接失败 */
+        rt_kprintf("Connect fail!\n");
+        lwip_close(sock);
+
+        /*释放接收缓冲 */
+        rt_free(recv_data);
+        return;
+    }
+
+    while(1)
+    {
+        /* 从sock连接中接收最大BUFSZ - 1字节数据 */
+        bytes_received = recv(sock, recv_data, BUFSZ - 1, 0);
+        if (bytes_received <= 0)
+        {
+            /* 接收失败，关闭这个连接 */
+            lwip_close(sock);
+
+            /* 释放接收缓冲 */
+            rt_free(recv_data);
+            break;
+        }
+
+        /* 有接收到数据，把末端清零 */
+        recv_data[bytes_received] = '\0';
+
+        if (strcmp(recv_data , "q") == 0 || strcmp(recv_data , "Q") == 0)
+        {
+            /* 如果是首字母是q或Q，关闭这个连接 */
+            lwip_close(sock);
+
+            /* 释放接收缓冲 */
+            rt_free(recv_data);
+            break;
+        }
+        else
+        {
+            /* 在控制终端显示收到的数据 */
+            rt_kprintf("\nReceived data = %s " , recv_data);
+        }
+
+        /* 发送数据到sock连接 */
+        send(sock,send_data,strlen(send_data), 0);
+    }
+
+    return;
+}
+
+#ifdef RT_USING_FINSH
+#include <finsh.h>
+/* 输出tcpclient函数到finsh shell中 */
+FINSH_FUNCTION_EXPORT(tcpclient, startup tcp client);
+#endif
diff --git a/components/net/lwip-head/apps/ipv6/tcpclient6.c b/components/net/lwip-head/apps/ipv6/tcpclient6.c
index dfe9d6a..9e3f69e 100644
--- a/components/net/lwip-head/apps/ipv6/tcpclient6.c
+++ b/components/net/lwip-head/apps/ipv6/tcpclient6.c
@@ -2,18 +2,19 @@
 #include <lwip/netdb.h>
 #include <lwip/sockets.h>
 
-#define SERV_PORT 12345
-#define SERVADDR "4006:e024:680:c6e:223:8bff:fe59:de90"	// Do not use link-local address, lwip-head did not implement it.
+#define SERV_PORT 1234
+#define SERVADDR "fe80::5867:8730:e9e6:d5c5%11"	// Do not use link-local address, lwip-head did not implement it.
 #define BUF_SIZE 1024
 static const char send_data[] = "This is TCP Client from RT-Thread.";
-
-void tcpclient6(void)
+long g_recv_len=0,g_sent_len=0;
+void tcpclient6(char *server_addr,int server_port)
 {
 	char* recv_data;
 	int sockfd, bytes_received;
 	struct sockaddr_in6 server_addr6;
 	int status = 0;
-	
+	g_recv_len=0;
+	g_sent_len=0;
 	recv_data = rt_malloc(BUF_SIZE);
 	if(recv_data == RT_NULL)
 	{
@@ -30,8 +31,8 @@ void tcpclient6(void)
 	
 	memset(&server_addr6, 0, sizeof(server_addr6));
 	server_addr6.sin6_family = AF_INET6;
-	server_addr6.sin6_port = htons(SERV_PORT);
-	if(inet_pton(AF_INET6, SERVADDR, &server_addr6.sin6_addr.s6_addr) != 1)
+	server_addr6.sin6_port = htons(server_port);
+	if(inet_pton(AF_INET6, server_addr, &server_addr6.sin6_addr.s6_addr) != 1)
 	{
 		rt_kprintf("inet_pton() error\n");
 		rt_free(recv_data);
@@ -64,7 +65,9 @@ void tcpclient6(void)
 		}
 		else
 		{
-			rt_kprintf("\nReceived data = %s ", recv_data);
+			g_recv_len+=bytes_received;
+			g_sent_len+=strlen(send_data);
+			rt_kprintf("\nReceived length = %d ,Sent length = %d ", g_recv_len,g_sent_len);
 		}
 		send(sockfd, send_data, strlen(send_data), 0);
 	}
diff --git a/components/net/lwip-head/apps/ipv6/udpclient.c b/components/net/lwip-head/apps/ipv6/udpclient.c
new file mode 100755
index 0000000..50e0d39
--- /dev/null
+++ b/components/net/lwip-head/apps/ipv6/udpclient.c
@@ -0,0 +1,50 @@
+#include <rtthread.h>
+#include <lwip/netdb.h> /* 为了解析主机名，需要包含netdb.h头文件 */
+#include <lwip/sockets.h> /* 使用BSD socket，需要包含sockets.h头文件 */
+
+const char send_data[] = "This is UDP Client from RT-Thread.\n"; /* 发送用到的数据 */
+void udpclient(const char* url, int port, int count)
+{
+   int sock;
+   struct hostent *host;
+   struct sockaddr_in server_addr;
+
+   /* 通过函数入口参数url获得host地址（如果是域名，会做域名解析） */
+   host= (struct hostent *) gethostbyname(url);
+
+   /* 创建一个socket，类型是SOCK_DGRAM，UDP类型 */
+   if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
+   {
+       rt_kprintf("Socket error\n");
+       return;
+   }
+
+   /* 初始化预连接的服务端地址 */
+   server_addr.sin_family = AF_INET;
+   server_addr.sin_port = htons(port);
+   server_addr.sin_addr = *((struct in_addr *)host->h_addr);
+   rt_memset(&(server_addr.sin_zero), 0, sizeof(server_addr.sin_zero));
+
+   /* 总计发送count次数据 */
+   while (count)
+   {
+       /* 发送数据到服务远端 */
+       sendto(sock, send_data, strlen(send_data), 0,
+              (struct sockaddr *)&server_addr, sizeof(struct sockaddr));
+
+       /* 线程休眠一段时间 */
+       rt_thread_delay(50);
+
+       /* 计数值减一 */
+       count --;
+   }
+
+   /* 关闭这个socket */
+   lwip_close(sock);
+}
+
+#ifdef RT_USING_FINSH
+#include <finsh.h>
+/* 输出udpclient函数到finsh shell中 */
+FINSH_FUNCTION_EXPORT(udpclient, startup udp client);
+#endif
diff --git a/components/net/lwip-head/apps/ipv6/udpclient6.c b/components/net/lwip-head/apps/ipv6/udpclient6.c
index 26fa9eb..7bcf2fd 100644
--- a/components/net/lwip-head/apps/ipv6/udpclient6.c
+++ b/components/net/lwip-head/apps/ipv6/udpclient6.c
@@ -6,8 +6,9 @@
 #define SERVADDR "4006:e024:680:c6e:223:8bff:fe59:de90"
 #define BUF_SIZE 1024
 static const char send_data[] = "This is UDP Client from RT-Thread.";
+long g_sent1_len=0;
 
-void udpclient6(void)
+void udpclient6(char *server_addr,int server_port)
 {
 	char *recv_data;
 	int sockfd;
@@ -30,21 +31,26 @@ void udpclient6(void)
 	
 	memset(&server_addr6, 0, sizeof(server_addr6));
 	server_addr6.sin6_family = AF_INET6;
-	server_addr6.sin6_port = htons(SERV_PORT);
-	if(inet_pton(AF_INET6, SERVADDR, &server_addr6.sin6_addr.s6_addr) != 1)
+	server_addr6.sin6_port = htons(server_port);
+	if(inet_pton(AF_INET6, server_addr, &server_addr6.sin6_addr.s6_addr) != 1)
 	{
 		rt_kprintf("inet_pton() error\n");
 		rt_free(recv_data);
 		return ;
 	}
-	
-	if(sendto(sockfd, send_data, sizeof(recv_data), 0, (struct sockaddr *)&server_addr6, sizeof(server_addr6)) < 0)
+	while(1)
 	{
-		rt_kprintf("Sendto error\n");
-		rt_free(recv_data);
-		return ;
+		if(sendto(sockfd, send_data, sizeof(send_data), 0, (struct sockaddr *)&server_addr6, sizeof(server_addr6)) < 0)
+		{
+			rt_kprintf("Sendto error\n");
+			closesocket(sockfd);
+			rt_free(recv_data);
+			return ;
+		}
+		g_sent1_len+=sizeof(send_data);
+		rt_kprintf("\nSent length = %d ", g_sent1_len);
 	}
-	
+	/*
 	rt_kprintf("Waiting for a reply...\n");
 	
 	clientlen = sizeof(client_addr6);
@@ -54,7 +60,7 @@ void udpclient6(void)
 		rt_free(recv_data);
 		return ;
 	}
-	rt_kprintf("got '%s'\n", recv_data);
+	rt_kprintf("got '%s'\n", recv_data);*/
 	closesocket(sockfd);
 }
 #ifdef RT_USING_FINSH
diff --git a/components/net/lwip-head/src/arch/include/arch/cc.h b/components/net/lwip-head/src/arch/include/arch/cc.h
index 0633494..f134a43 100644
--- a/components/net/lwip-head/src/arch/include/arch/cc.h
+++ b/components/net/lwip-head/src/arch/include/arch/cc.h
@@ -98,7 +98,7 @@ typedef rt_uint32_t	mem_ptr_t;
 
 void sys_arch_assert(const char* file, int line);
 #define LWIP_PLATFORM_DIAG(x)	do {rt_kprintf x;} while(0)
-#define LWIP_PLATFORM_ASSERT(x) do {rt_kprintf(x); sys_arch_assert(__FILE__, __LINE__);}while(0)
+#define LWIP_PLATFORM_ASSERT(x) do {rt_kprintf(x); sys_arch_assert("__FILE__", /*__LINE__*/0);}while(0)
 
 
 #include "string.h"
diff --git a/components/net/lwip-head/src/lwipopts.h b/components/net/lwip-head/src/lwipopts.h
index 4d7961d..7caf461 100644
--- a/components/net/lwip-head/src/lwipopts.h
+++ b/components/net/lwip-head/src/lwipopts.h
@@ -18,6 +18,7 @@
 #ifdef RT_LWIP_IPV6_AUTOCONFIG
 #define LWIP_IPV6_AUTOCONFIG        1
 #endif
+#define TCP_KEEPINTVL_DEFAULT 1 //new add
 
 #endif
 
@@ -58,7 +59,7 @@
 #define LWIP_SO_RCVTIMEO            1
 #define LWIP_SO_SNDTIMEO            1
 
-/* #define RT_LWIP_DEBUG */
+/*#define RT_LWIP_DEBUG*/
 
 #ifdef RT_LWIP_DEBUG
 #define LWIP_DEBUG
@@ -144,7 +145,7 @@
 /* MEMP_NUM_NETBUF: the number of struct netbufs. */
 #define MEMP_NUM_NETBUF             2
 /* MEMP_NUM_NETCONN: the number of struct netconns. */
-#define MEMP_NUM_NETCONN            4
+#define MEMP_NUM_NETCONN            10
 /* MEMP_NUM_TCPIP_MSG_*: the number of struct tcpip_msg, which is used
    for sequential API communication and incoming packets. Used in
    src/api/tcpip.c. */
@@ -358,10 +359,9 @@
 
 /* MEMP_NUM_SYS_TIMEOUT: the number of simulateously active timeouts. */
 //#define MEMP_NUM_SYS_TIMEOUT       (LWIP_TCP + IP_REASSEMBLY + LWIP_ARP + (2*LWIP_DHCP) + LWIP_AUTOIP + LWIP_IGMP + LWIP_DNS + PPP_SUPPORT)
-#define MEMP_NUM_SYS_TIMEOUT	    8
+#define MEMP_NUM_SYS_TIMEOUT	    10//8
 #ifdef LWIP_IGMP
 #include <stdlib.h>
 #define LWIP_RAND                  rand
 #endif
-
 #endif /* __LWIPOPTS_H__ */
diff --git a/components/net/lwip-head/src/netif/ethernetif.c b/components/net/lwip-head/src/netif/ethernetif.c
index cf3262b..3f096fd 100644
--- a/components/net/lwip-head/src/netif/ethernetif.c
+++ b/components/net/lwip-head/src/netif/ethernetif.c
@@ -387,9 +387,37 @@ int eth_system_device_init(void)
 	return 0;
 }
 INIT_DEVICE_EXPORT(eth_system_device_init);
+#if LWIP_IPV6
+void set_if6(char* netif_name, char* ip6_addr)
+{
+	struct netif* netif = netif_list;
+	struct ip6_addr ip6addr;
+	
+	if(strlen(netif_name) > sizeof(netif->name))
+	{
+		rt_kprintf("network interface name too long!\r\n");
+		return;
+	}
+	
+	while(netif != RT_NULL)
+	{
+		if(strncmp(netif_name, netif->name, sizeof(netif->name)) == 0)
+			break;
 
-#ifdef RT_USING_FINSH
-#include <finsh.h>
+		netif = netif->next;
+		if( netif == RT_NULL)
+		{
+			rt_kprintf("network interface: %s not found!\r\n", netif_name);
+			return;
+		}		
+	}
+	if((ip6_addr != RT_NULL) && ip6addr_aton(ip6_addr, &ip6addr))
+	{
+		ip6_addr_copy(netif->ip6_addr[1], ip6addr);
+		netif_ip6_addr_set_state(netif, 1, IP6_ADDR_TENTATIVE);
+	}	
+}
+#endif
 void set_if(char* netif_name, char* ip_addr, char* gw_addr, char* nm_addr)
 {
     struct ip_addr *ip;
@@ -435,38 +463,12 @@ void set_if(char* netif_name, char* ip_addr, char* gw_addr, char* nm_addr)
         netif_set_netmask(netif, ip);
     }
 }
+#ifdef RT_USING_FINSH
+#include <finsh.h>
+
 FINSH_FUNCTION_EXPORT(set_if, set network interface address);
 
 #if LWIP_IPV6
-void set_if6(char* netif_name, char* ip6_addr)
-{
-	struct netif* netif = netif_list;
-	struct ip6_addr ip6addr;
-	
-	if(strlen(netif_name) > sizeof(netif->name))
-	{
-		rt_kprintf("network interface name too long!\r\n");
-		return;
-	}
-	
-	while(netif != RT_NULL)
-	{
-		if(strncmp(netif_name, netif->name, sizeof(netif->name)) == 0)
-			break;
-
-		netif = netif->next;
-		if( netif == RT_NULL)
-		{
-			rt_kprintf("network interface: %s not found!\r\n", netif_name);
-			return;
-		}		
-	}
-	if((ip6_addr != RT_NULL) && ip6addr_aton(ip6_addr, &ip6addr))
-	{
-		ip6_addr_copy(netif->ip6_addr[1], ip6addr);
-		netif_ip6_addr_set_state(netif, 1, IP6_ADDR_TENTATIVE);
-	}	
-}
 FINSH_FUNCTION_EXPORT(set_if6, set ipv6 local address)
 #endif
 
