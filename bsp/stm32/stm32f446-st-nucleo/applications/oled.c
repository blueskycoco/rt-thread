#include <rtthread.h>
#include <rtdevice.h>
#include <string.h>
#include "board.h"
#include "drv_spi.h"
#include "oled.h"
#if defined(BSP_USING_OLED)
/*
	stm32f413mg      dp
	
	PC3                     DP_RST_1V8
	PC2                     DP_SLEEP_1V8
	
	stm32f413mg      oled
	
	PA2                     OLED_RST
	PA4                     SPI1_NSS0
	PA5			SPI1_SCK
	PA6			SPI1_MISO
	PA7			SPI1_MOSI
	PD2			OLED1_VSYNC
 */

#define DP_RST_PIN    		GET_PIN(C, 3)
#define DP_SLEEP_PIN    	GET_PIN(C, 2)
#define OLED_RST_PIN    	GET_PIN(A, 2)
#define OLED1_VSYNC_PIN    	GET_PIN(D, 2)

#ifndef RT_OLED_SPI_MAX_HZ
#define RT_OLED_SPI_MAX_HZ 8000000
#endif

#define RT_OLED_DEFAULT_SPI_CFG                  \
{                                                \
    .mode = RT_SPI_MODE_0 | RT_SPI_LSB,          \
    .data_width = 8,                             \
    .max_hz = RT_OLED_SPI_MAX_HZ,                \
}

#define DBG_ENABLE
#define DBG_SECTION_NAME "oled"
#define DBG_LEVEL DBG_LOG
#define DBG_COLOR
#include <rtdbg.h>

// Register map for oled
struct oled_reg_value {
	uint8_t reg_addr;
	uint8_t val;
	uint8_t mask;
	uint32_t delay_ms;
};

struct oled_reg_value reg_duty[] = {
	{0x30, 0x00, 0, 0}, {0x31, 0x00, 0, 0},
	{0x32, 0x00, 0, 0}
};

struct oled_reg_value init_3d540[] = {
	{0x00, 0x0E, 0, 0}, {0x01, 0x00, 0, 0},
	{0x02, 0x40, 0, 0}, {0x03, 0x20, 0, 0},
	{0x04, 0x5F, 0, 0}, {0x05, 0x84, 0, 0},
	{0x06, 0x00, 0, 0}, {0x07, 0x40, 0, 0},
	{0x08, 0x04, 0, 0}, {0x09, 0x56, 0, 0},
	{0x0A, 0x00, 0, 0}, {0x0B, 0x00, 0, 0},
	{0x0C, 0x00, 0, 0}, {0x0D, 0x00, 0, 0},
	{0x0E, 0x00, 0, 0}, {0x0F, 0x00, 0, 0},
	{0x10, 0x00, 0, 0}, {0x11, 0x00, 0, 0},
	{0x12, 0x00, 0, 0}, {0x13, 0x00, 0, 0},
	{0x14, 0x00, 0, 0}, {0x15, 0xC0, 0, 0},
	{0x16, 0x40, 0, 0}, {0x17, 0x40, 0, 0},	
	{0x18, 0x80, 0, 0}, {0x19, 0x40, 0, 0},
	{0x1A, 0x40, 0, 0}, {0x1B, 0x40, 0, 0},
	{0x1C, 0x0A, 0, 0}, {0x1D, 0x5D, 0, 0},
	{0x1E, 0x22, 0, 0}, {0x1F, 0x10, 0, 0},
	{0x20, 0x60, 0, 0}, 
/*SETMODE_3D540*/
	{0x21, 0x24, 0, 0},
	{0x22, 0x20, 0, 0}, {0x23, 0x14, 0, 0},
	{0x24, 0x30, 0, 0}, 

	{0x25, 0x00, 0, 0},
	{0x26, 0x00, 0, 0}, {0x27, 0x00, 0, 0},
	{0x28, 0x40, 0, 0}, {0x29, 0x58, 0, 0},
	{0x2A, 0x28, 0, 0}, {0x2B, 0x00, 0, 0},
	{0x2C, 0x00, 0, 0}, {0x2D, 0x00, 0, 0},
/*SETMODE_3D540*/
	{0x2E, 0x0B, 0, 0}, 
	{0x2F, 0x0C, 0, 0},
	{0x30, 0x22, 0, 0}, {0x31, 0x05, 0, 0},
	{0x32, 0x06, 0, 0}, 

	{0x33, 0xFF, 0, 0},
	{0x34, 0x00, 0, 0}, {0x35, 0x24, 0, 0},
	{0x36, 0xDD, 0, 0}, {0x37, 0x00, 0, 0},
	{0x38, 0x05, 0, 0}, {0x39, 0x04, 0, 0},
	{0x3A, 0x35, 0, 0}, {0x3B, 0x07, 0, 0},
	{0x3C, 0x5D, 0, 0}, {0x3D, 0x0A, 0, 0},
	{0x3E, 0xE6, 0, 0}, {0x3F, 0x03, 0, 0},
	{0x40, 0x5D, 0, 0}, {0x41, 0x00, 0, 0},
	{0x42, 0x01, 0, 0}, {0x43, 0x7B, 0, 0},
	{0x44, 0x00, 0, 0}, {0x45, 0x17, 0, 0},
	{0x46, 0x76, 0, 0}, {0x47, 0x00, 0, 0},
	{0x48, 0x76, 0, 0}, {0x49, 0x00, 0, 0},
	{0x4A, 0x5A, 0, 0}, {0x4B, 0x00, 0, 0},
	{0x4C, 0x0A, 0, 0}, {0x4D, 0x5D, 0, 0},
	{0x4E, 0x0A, 0, 0}, {0x4F, 0x5D, 0, 0},
	{0x50, 0x00, 0, 0}, {0x51, 0x0A, 0, 0},
	{0x52, 0x41, 0, 0}, {0x53, 0x00, 0, 0},
	{0x54, 0x51, 0, 0}, {0x55, 0x0A, 0, 0},
	{0x56, 0x38, 0, 0}, {0x57, 0x40, 0, 0},
	{0x58, 0x62, 0, 0}, {0x59, 0x2F, 0, 0},
	{0x5A, 0x00, 0, 0}, {0x5B, 0x00, 0, 0},
	{0x5C, 0x00, 0, 0}, {0x5D, 0x00, 0, 0},
	{0x5E, 0x00, 0, 0}, {0x5F, 0x00, 0, 0},
	{0x60, 0x00, 0, 0}, {0x61, 0x00, 0, 0},
	{0x62, 0x00, 0, 0}, {0x63, 0x00, 0, 0},
	{0x64, 0x00, 0, 0}, {0x65, 0x00, 0, 0},
	{0x66, 0x00, 0, 0}, {0x67, 0x00, 0, 0},
	{0x68, 0x00, 0, 0}, {0x69, 0x00, 0, 0},
	{0x6A, 0x00, 0, 0}, {0x6B, 0x00, 0, 0},
	{0x6C, 0x02, 0, 0}, 
/*SETMODE_3D540	*/
	{0x6D, 0x84, 0, 0},
	
	{0x6E, 0xE8, 0, 0}, {0x6F, 0x03, 0, 0},
	{0x70, 0x00, 0, 0}, {0x71, 0x4E, 0, 0},
	{0x72, 0x4E, 0, 0}, {0x73, 0x00, 0, 0},
	{0x74, 0x41, 0, 0}, {0x75, 0x27, 0, 0},
	{0x76, 0x85, 0, 0}, {0x77, 0x30, 0, 0},
	{0x78, 0x06, 0, 0}, {0x79, 0x36, 0, 0},
	{0x7A, 0x80, 0, 0}, {0x7B, 0x25, 0, 0},
	{0x7C, 0x47, 0, 0}, {0x7D, 0x61, 0, 0},
	{0x7E, 0x00, 0, 0}, {0x7F, 0x00, 0, 0},
	{0x80, 0x01, 0, 2}, {0x00, 0x0F, 0, 5},
	{0x01, 0x01, 0, 5}, {0x04, 0x3f, 0, 2},
	{0x71, 0x46, 0, 0}, {0x72, 0x46, 0, 2},
/*SETMODE_3D540	*/
	{0x6d, 0x80, 0, 0}, 
	
	{0x6f, 0x00, 0, 0},
	{0x71, 0x00, 0, 0}, {0x72, 0x00, 0, 2},
	{0x03, 0x20, 0, 0}, {0x03, 0xA0, 0, 0},
	{0x01, 0x00, 0, 0}
};

struct oled_reg_value init_non_3d540[] = {
	{0x00, 0x0E, 0, 0}, {0x01, 0x00, 0, 0},
	{0x02, 0x40, 0, 0}, {0x03, 0x20, 0, 0},
	{0x04, 0x5F, 0, 0}, {0x05, 0x84, 0, 0},
	{0x06, 0x00, 0, 0}, {0x07, 0x40, 0, 0},
	{0x08, 0x04, 0, 0}, {0x09, 0x56, 0, 0},
	{0x0A, 0x00, 0, 0}, {0x0B, 0x00, 0, 0},
	{0x0C, 0x00, 0, 0}, {0x0D, 0x00, 0, 0},
	{0x0E, 0x00, 0, 0}, {0x0F, 0x00, 0, 0},
	{0x10, 0x00, 0, 0}, {0x11, 0x00, 0, 0},
	{0x12, 0x00, 0, 0}, {0x13, 0x00, 0, 0},
	{0x14, 0x00, 0, 0}, {0x15, 0xC0, 0, 0},
	{0x16, 0x40, 0, 0}, {0x17, 0x40, 0, 0},	
	{0x18, 0x80, 0, 0}, {0x19, 0x40, 0, 0},
	{0x1A, 0x40, 0, 0}, {0x1B, 0x40, 0, 0},
	{0x1C, 0x0A, 0, 0}, {0x1D, 0x5D, 0, 0},
	{0x1E, 0x22, 0, 0}, {0x1F, 0x10, 0, 0},
	{0x20, 0x60, 0, 0}, 
/*SETMODE_OTHERS*/
	{0x21, 0x44, 0, 0},
	{0x22, 0x20, 0, 0}, {0x23,0x29, 0, 0},
	{0x24, 0x61, 0, 0}, 

	{0x25, 0x00, 0, 0},
	{0x26, 0x00, 0, 0}, {0x27, 0x00, 0, 0},
	{0x28, 0x40, 0, 0}, {0x29, 0x58, 0, 0},
	{0x2A, 0x28, 0, 0}, {0x2B, 0x00, 0, 0},
	{0x2C, 0x00, 0, 0}, {0x2D, 0x00, 0, 0},
/*SETMODE_OTHERS*/
	{0x2E, 0x19, 0, 0}, 
	{0x2F, 0x1A, 0, 0},
	{0x30, 0x44, 0, 0}, {0x31,0x0D, 0, 0},
	{0x32, 0x0E, 0, 0}, 

	{0x33, 0xFF, 0, 0},
	{0x34, 0x00, 0, 0}, {0x35, 0x24, 0, 0},
	{0x36, 0xDD, 0, 0}, {0x37, 0x00, 0, 0},
	{0x38, 0x05, 0, 0}, {0x39, 0x04, 0, 0},
	{0x3A, 0x35, 0, 0}, {0x3B, 0x07, 0, 0},
	{0x3C, 0x5D, 0, 0}, {0x3D, 0x0A, 0, 0},
	{0x3E, 0xE6, 0, 0}, {0x3F, 0x03, 0, 0},
	{0x40, 0x5D, 0, 0}, {0x41, 0x00, 0, 0},
	{0x42, 0x01, 0, 0}, {0x43, 0x7B, 0, 0},
	{0x44, 0x00, 0, 0}, {0x45, 0x17, 0, 0},
	{0x46, 0x76, 0, 0}, {0x47, 0x00, 0, 0},
	{0x48, 0x76, 0, 0}, {0x49, 0x00, 0, 0},
	{0x4A, 0x5A, 0, 0}, {0x4B, 0x00, 0, 0},
	{0x4C, 0x0A, 0, 0}, {0x4D, 0x5D, 0, 0},
	{0x4E, 0x0A, 0, 0}, {0x4F, 0x5D, 0, 0},
	{0x50, 0x00, 0, 0}, {0x51, 0x0A, 0, 0},
	{0x52, 0x41, 0, 0}, {0x53, 0x00, 0, 0},
	{0x54, 0x51, 0, 0}, {0x55, 0x0A, 0, 0},
	{0x56, 0x38, 0, 0}, {0x57, 0x40, 0, 0},
	{0x58, 0x62, 0, 0}, {0x59, 0x2F, 0, 0},
	{0x5A, 0x00, 0, 0}, {0x5B, 0x00, 0, 0},
	{0x5C, 0x00, 0, 0}, {0x5D, 0x00, 0, 0},
	{0x5E, 0x00, 0, 0}, {0x5F, 0x00, 0, 0},
	{0x60, 0x00, 0, 0}, {0x61, 0x00, 0, 0},
	{0x62, 0x00, 0, 0}, {0x63, 0x00, 0, 0},
	{0x64, 0x00, 0, 0}, {0x65, 0x00, 0, 0},
	{0x66, 0x00, 0, 0}, {0x67, 0x00, 0, 0},
	{0x68, 0x00, 0, 0}, {0x69, 0x00, 0, 0},
	{0x6A, 0x00, 0, 0}, {0x6B, 0x00, 0, 0},
	{0x6C, 0x02, 0, 0}, 
/*SETMODE_OTHERS */
	{0x6D, 0x04, 0, 0},
	
	{0x6E, 0xE8, 0, 0}, {0x6F, 0x03, 0, 0},
	{0x70, 0x00, 0, 0}, {0x71, 0x4E, 0, 0},
	{0x72, 0x4E, 0, 0}, {0x73, 0x00, 0, 0},
	{0x74, 0x41, 0, 0}, {0x75, 0x27, 0, 0},
	{0x76, 0x85, 0, 0}, {0x77, 0x30, 0, 0},
	{0x78, 0x06, 0, 0}, {0x79, 0x36, 0, 0},
	{0x7A, 0x80, 0, 0}, {0x7B, 0x25, 0, 0},
	{0x7C, 0x47, 0, 0}, {0x7D, 0x61, 0, 0},
	{0x7E, 0x00, 0, 0}, {0x7F, 0x00, 0, 0},
	{0x80, 0x01, 0, 2}, {0x00, 0x0F, 0, 5},
	{0x01, 0x01, 0, 5}, {0x04, 0x3f, 0, 2},
	{0x71, 0x46, 0, 0}, {0x72, 0x46, 0, 2},
/*SETMODE_OTHERS	*/
	{0x6d, 0x00, 0, 0}, 
	
	{0x6f, 0x00, 0, 0},
	{0x71, 0x00, 0, 0}, {0x72, 0x00, 0, 2},
	{0x03, 0x20, 0, 0}, {0x03, 0xA0, 0, 0},
	{0x01, 0x00, 0, 0}
};
/**
 * This function burst writes sequences, include single-byte.
 *
 * @param bus the pointer of iic bus
 * @param reg the address regisgter
 * @param len the length of bytes
 * @param buf the writing value
 *
 * @return the writing status of accelerometer, RT_EOK reprensents setting successfully.
 */
static rt_err_t write_regs(struct rt_spi_device *spi_dev, rt_uint8_t reg,
		rt_uint8_t val)
{
	rt_uint8_t tx[2] = {0};
	tx[0] = reg;
	tx[1] = val;
	int ret = rt_spi_send(spi_dev, tx, 2);
	return (ret == 2) ? RT_EOK : RT_ERROR;
}

static rt_err_t read_regs(struct rt_spi_device *spi_dev, rt_uint8_t *buf)
{
	rt_uint8_t tx[2] = {0x81};
	rt_size_t ret = rt_spi_transfer(spi_dev, tx, buf, 2);
	return (ret == 2) ? RT_EOK : RT_ERROR;
}
static rt_err_t oled_reg_load(struct rt_spi_device *spi_dev, struct oled_reg_value *setting, int len)
{
	rt_err_t res = RT_EOK;
	int i;
	const struct oled_reg_value *regs = setting;
	for (i=0; i<len; i++,regs++) {
		res = write_regs(spi_dev, regs->reg_addr, regs->val);
		if (res != RT_EOK) {
			rt_kprintf("write 0x%x 0x%x failed\r\n",
					regs->reg_addr, setting->val);
			return res;
		}

		if (setting->delay_ms)
			rt_thread_mdelay(setting->delay_ms);
	}
	return res;
}
rt_err_t oled_read_reg(struct rt_spi_device *spi_dev, uint8_t reg, uint8_t *val)
{
	static rt_uint8_t rd_on = 0;
	rt_err_t res = RT_EOK;

	uint8_t rd_on_reg[] = {0x80, 0x01};
	uint8_t read_reg[] = {0x81, 0x00};
	uint8_t response[2] = {0x00};

	if (rd_on == 0) {
		res = write_regs(spi_dev, 0x80, 0x01);
		if (res == RT_EOK)
			rd_on = 1;
	}

	if (res == RT_EOK)
		res = write_regs(spi_dev, 0x81, reg);
	
	if (res == RT_EOK)
		res = read_regs(spi_dev, response);
	
	if (res == RT_EOK)
		*val = response[1];

	return res;
}

static rt_err_t oled_set_duty(struct rt_spi_device *spi_dev, uint8_t duty)
{
	uint16_t wsst2_u=0; 
	uint16_t wsst2_d=0;
	wsst2_u = 25+1125*duty/100;    
	wsst2_d = wsst2_u+1;
	reg_duty[0].val = ((wsst2_d&0x700)>>4)|((wsst2_u>>8)&0x07);
	reg_duty[1].val = wsst2_u&0xff;
	reg_duty[2].val = wsst2_d&0xff;
	return oled_reg_load(spi_dev, reg_duty,
				sizeof(reg_duty)/sizeof(struct oled_reg_value));
}
rt_err_t _oled_power_ctl(struct rt_spi_device *spi_dev, rt_uint8_t on)
{
	if (on) {
		write_regs(spi_dev, 0x00, 0x03);
		rt_thread_mdelay(5);
		write_regs(spi_dev, 0x01, 0x01);
		rt_thread_mdelay(5);
		write_regs(spi_dev, 0x04, 0x3f);
		rt_thread_mdelay(2);
		write_regs(spi_dev, 0x71, 0x46);
		write_regs(spi_dev, 0x72, 0x46);
		rt_thread_mdelay(2);
		write_regs(spi_dev, 0x6d, 0x00);
		write_regs(spi_dev, 0x6f, 0x00);
		write_regs(spi_dev, 0x71, 0x00);
		write_regs(spi_dev, 0x72, 0x00);
		rt_thread_mdelay(2);
		write_regs(spi_dev, 0x03, 0x20);
	} else {
		write_regs(spi_dev, 0x00, 0x02);
		rt_thread_mdelay(1);
		write_regs(spi_dev, 0x01, 0x00);
		rt_thread_mdelay(1);
	}
}
void init_oled()
{
    struct rt_spi_device *spi;
    struct rt_spi_configuration cfg = RT_OLED_DEFAULT_SPI_CFG;
    int i;
    rt_uint8_t val;

    rt_pin_mode(DP_RST_PIN, 		PIN_MODE_OUTPUT);
    rt_pin_mode(DP_SLEEP_PIN, 		PIN_MODE_OUTPUT);
    rt_pin_mode(OLED_RST_PIN, 		PIN_MODE_OUTPUT);
    //rt_pin_mode(OLED1_VSYNC_PIN, 	PIN_MODE_INPUT);
        
    rt_pin_write(DP_SLEEP_PIN, PIN_LOW);
    rt_pin_write(DP_RST_PIN, PIN_HIGH);
    rt_pin_write(OLED_RST_PIN, PIN_HIGH);
    rt_thread_mdelay(10);
    rt_pin_write(OLED_RST_PIN, PIN_LOW);
    rt_pin_write(DP_RST_PIN, PIN_LOW);
    rt_thread_mdelay(30);
    rt_pin_write(DP_RST_PIN, PIN_HIGH);
    rt_pin_write(OLED_RST_PIN, PIN_HIGH);
    rt_thread_mdelay(70);
	
    rt_hw_spi_device_attach("spi1", "spi10", GPIOA, GPIO_PIN_4);
    spi = (struct rt_spi_device *)rt_device_find("spi10");

    if (spi == RT_NULL)
    {
	rt_kprintf("Can't find oled device on 'spi10'");
	return;
    }

    rt_spi_configure(spi, &cfg);
    oled_reg_load(spi, init_non_3d540, sizeof(init_non_3d540)/sizeof(struct oled_reg_value));
#if 0
    for (i=0; i<=0x81; i++)
  	if (RT_EOK == oled_read_reg(spi, i, &val)) {
		rt_kprintf("read oled 0x%x ok, 0x%x\r\n", i, val);
	} else
		rt_kprintf("read oled 0x%x failed\r\n", i);
#endif
    oled_set_duty(spi, 90);
    _oled_power_ctl(spi, 1);
}
#endif
