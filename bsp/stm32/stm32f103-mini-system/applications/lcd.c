#include <rtthread.h>
#include <rtdevice.h>
#include <drivers/spi.h>
#include "drv_spi.h"
#include <board.h>
#define WS_PIN    	GET_PIN(A, 6)
#define CS_PIN    	GET_PIN(A, 4)
#define RST_PIN		GET_PIN(A, 8)
#define LIGHT_PIN	GET_PIN(A,11)

struct rt_spi_device *spi_device;
volatile rt_uint8_t FONT[] =              // ASCII
{
	0x00,0x00,0x00,0x00,0x00, // - -

	0x00,0x00,0x5F,0x00,0x00, // -!-

	0x00,0x07,0x00,0x07,0x00, // -"-

	0x14,0x7F,0x14,0x7F,0x14, // -#-

	0x24,0x2E,0x7B,0x2A,0x12, // -$-

	0x23,0x13,0x08,0x64,0x62, // -%-

	0x36,0x49,0x56,0x20,0x50, // -&-

	0x00,0x04,0x03,0x01,0x00, // -'-

	0x00,0x1C,0x22,0x41,0x00, // -(-

	0x00,0x41,0x22,0x1C,0x00, // -)-

	0x22,0x14,0x7F,0x14,0x22, // -*-

	0x08,0x08,0x7F,0x08,0x08, // -+-

	0x40,0x30,0x10,0x00,0x00, // -,-

	0x08,0x08,0x08,0x08,0x08, // ---

	0x00,0x60,0x60,0x00,0x00, // -.-

	0x20,0x10,0x08,0x04,0x02, // -/-

	0x3E,0x51,0x49,0x45,0x3E, // -0-

	0x00,0x42,0x7F,0x40,0x00, // -1-

	0x62,0x51,0x49,0x49,0x46, // -2-

	0x21,0x41,0x49,0x4D,0x33, // -3-

	0x18,0x14,0x12,0x7F,0x10, // -4-

	0x27,0x45,0x45,0x45,0x39, // -5-

	0x3C,0x4A,0x49,0x49,0x31, // -6-

	0x01,0x71,0x09,0x05,0x03, // -7-

	0x36,0x49,0x49,0x49,0x36, // -8-

	0x46,0x49,0x49,0x29,0x1E, // -9-

	0x00,0x36,0x36,0x00,0x00, // -:-

	0x40,0x36,0x36,0x00,0x00, // -;-

	0x08,0x14,0x22,0x41,0x00, // -<-

	0x14,0x14,0x14,0x14,0x14, // -=-

	0x00,0x41,0x22,0x14,0x08, // ->-

	0x02,0x01,0x59,0x05,0x02, // -?-

	0x3E,0x41,0x5D,0x55,0x5E, // -@-

	0x7C,0x12,0x11,0x12,0x7C, // -A-

	0x7F,0x49,0x49,0x49,0x36, // -B-

	0x3E,0x41,0x41,0x41,0x22, // -C-

	0x7F,0x41,0x41,0x41,0x3E, // -D-

	0x7F,0x49,0x49,0x49,0x41, // -E-

	0x7F,0x09,0x09,0x09,0x01, // -F-

	0x3E,0x41,0x51,0x51,0x72, // -G-

	0x7F,0x08,0x08,0x08,0x7F, // -H-

	0x00,0x41,0x7F,0x41,0x00, // -I-

	0x20,0x40,0x41,0x3F,0x01, // -J-

	0x7F,0x08,0x14,0x22,0x41, // -K-

	0x7F,0x40,0x40,0x40,0x40, // -L-

	0x7F,0x02,0x0C,0x02,0x7F, // -M-

	0x7F,0x04,0x08,0x10,0x7F, // -N-

	0x3E,0x41,0x41,0x41,0x3E, // -O-

	0x7F,0x09,0x09,0x09,0x06, // -P-

	0x3E,0x41,0x51,0x21,0x5E, // -Q-

	0x7F,0x09,0x19,0x29,0x46, // -R-

	0x26,0x49,0x49,0x49,0x32, // -S-

	0x01,0x01,0x7F,0x01,0x01, // -T-

	0x3F,0x40,0x40,0x40,0x3F, // -U-

	0x1F,0x20,0x40,0x20,0x1F, // -V-

	0x7F,0x20,0x18,0x20,0x7F, // -W-

	0x63,0x14,0x08,0x14,0x63, // -X-

	0x03,0x04,0x78,0x04,0x03, // -Y-

	0x61,0x51,0x49,0x45,0x43, // -Z-

	0x7F,0x7F,0x41,0x41,0x00, // -[-

	0x02,0x04,0x08,0x10,0x20, // -\-

	0x00,0x41,0x41,0x7F,0x7F, // -]-

	0x04,0x02,0x7F,0x02,0x04, // -^-

	0x08,0x1C,0x2A,0x08,0x08, // -_-

	0x00,0x00,0x01,0x02,0x04, // -`-

	0x24,0x54,0x54,0x38,0x40, // -a-

	0x7F,0x28,0x44,0x44,0x38, // -b-

	0x38,0x44,0x44,0x44,0x08, // -c-

	0x38,0x44,0x44,0x28,0x7F, // -d-

	0x38,0x54,0x54,0x54,0x08, // -e-

	0x08,0x7E,0x09,0x09,0x02, // -f-

	0x98,0xA4,0xA4,0xA4,0x78, // -g-

	0x7F,0x08,0x04,0x04,0x78, // -h-

	0x00,0x00,0x79,0x00,0x00, // -i-

	0x00,0x80,0x88,0x79,0x00, // -j-

	0x7F,0x10,0x28,0x44,0x40, // -k-

	0x00,0x41,0x7F,0x40,0x00, // -l-

	0x78,0x04,0x78,0x04,0x78, // -m-

	0x04,0x78,0x04,0x04,0x78, // -n-

	0x38,0x44,0x44,0x44,0x38, // -o-

	0xFC,0x24,0x24,0x24,0x18, // -p-

	0x18,0x24,0x24,0x24,0xFC, // -q-

	0x04,0x78,0x04,0x04,0x08, // -r-

	0x48,0x54,0x54,0x54,0x24, // -s-

	0x04,0x3F,0x44,0x44,0x24, // -t-

	0x3C,0x40,0x40,0x3C,0x40, // -u-

	0x1C,0x20,0x40,0x20,0x1C, // -v-

	0x3C,0x40,0x3C,0x40,0x3C, // -w-

	0x44,0x28,0x10,0x28,0x44, // -x-

	0x9C,0xA0,0xA0,0x90,0x7C, // -y-

	0x44,0x64,0x54,0x4C,0x44, // -z-

	0x08,0x36,0x41,0x00,0x00, // -{-

	0x00,0x00,0x77,0x00,0x00, // -|-

	0x00,0x00,0x41,0x36,0x08, // -}-

	0x08,0x04,0x08,0x10,0x08, // -~-

	0x55,0x2A,0x55,0x2A,0x55, // -
};
void ST7585_Write(rt_uint8_t data, rt_uint8_t cd)
{
	if (cd)
		rt_pin_write(WS_PIN, PIN_LOW);
	else
		rt_pin_write(WS_PIN, PIN_HIGH);
	rt_spi_send(spi_device, &data, 1);
}
void ST7585_Set_XY(rt_uint8_t X, rt_uint8_t Y)
{    
	ST7585_Write(0x40|Y,1);	
	ST7585_Write(0x80|X,1); 
}
void ST7585_Clear(void)
{
	rt_uint16_t i;
	ST7585_Set_XY(0,0);
	for(i = 0; i <960; i++)
	{		
		ST7585_Write(0x00,0);
	}
}
void ST7585_Write_Char(rt_uint8_t X,rt_uint8_t Y,rt_uint8_t Data)
{
	rt_uint8_t i;
	ST7585_Set_XY(X,Y);
	for(i=0;i<5;i++)
		ST7585_Write(FONT[(Data-0x20)*5+i],0);
}
void ST7585_Write_String(rt_uint8_t X,rt_uint8_t Y,rt_uint8_t *S)
{
	while(*S!=0)
	{
		ST7585_Write_Char(X,Y,*S++);
		X=X+6;
		if(X>=96)
		{
			X=0;
			Y--;
			if (Y == 0)
				Y = 7;
		}
	}
}
void Draw_bat(unsigned char level)
{
	ST7585_Set_XY(95,8);
	ST7585_Write(0x00,0);		
	ST7585_Set_XY(94,8);
	ST7585_Write(0x00,0);		
	ST7585_Set_XY(93,8);
	ST7585_Write(0x00,0);
	ST7585_Set_XY(80,8);				 //bat icon
	ST7585_Write(0xFF,0);

	if(level==0)
		return;

	ST7585_Set_XY(94,8);
	ST7585_Write(0xFF,0);

	if(level==1)
		return;

	ST7585_Set_XY(95,8);
	ST7585_Write(0xFF,0);

	if(level==2)
		return;

	ST7585_Set_XY(93,8);
	ST7585_Write(0xFF,0);
}
rt_uint8_t st7585_init(void)
{
	rt_pin_mode(WS_PIN, PIN_MODE_OUTPUT);
	rt_pin_mode(CS_PIN, PIN_MODE_OUTPUT);
	rt_pin_mode(RST_PIN, PIN_MODE_OUTPUT);
	rt_pin_mode(LIGHT_PIN, PIN_MODE_OUTPUT);
	rt_pin_write(CS_PIN, PIN_LOW);
	rt_pin_write(LIGHT_PIN, PIN_HIGH);
	rt_pin_write(RST_PIN, PIN_LOW);
	rt_thread_delay(1);
	rt_pin_write(RST_PIN, PIN_HIGH);
	rt_thread_delay(1);

	rt_err_t result = rt_hw_spi_device_attach("spi1", "spi10", GPIOA, GPIO_PIN_4); 
    if (result != RT_EOK)
    {
        rt_kprintf("lcd attach to spi1 faild, %d\n", result);
        return -2;
    }
	spi_device = (struct rt_spi_device *)rt_device_find("spi10");
	if (spi_device == RT_NULL)
	{
		rt_kprintf("spi device spi1 not found!\r\n");
		return -RT_ENOSYS;
	}

	/* config spi */
	{
		struct rt_spi_configuration cfg;
		cfg.data_width = 8;
		cfg.mode = RT_SPI_MODE_0 | RT_SPI_MSB | RT_SPI_3WIRE; /* SPI Compatible Modes 0 */
		cfg.max_hz = 20 * 1000 * 1000; /* SPI Interface with Clock Speeds Up to 20 MHz */
		rt_spi_configure(spi_device, &cfg);
	} /* config spi */
	rt_kprintf("st7585 init 4\n");

	ST7585_Write(0x21,1);    
	ST7585_Write(0x9C,1);  
	ST7585_Write(0x30,1);  
	ST7585_Write(0x20,1);   
	ST7585_Write(0x0C,1);   
	ST7585_Clear();   
	ST7585_Write_String(2,3, "Thanks Amo!");
	return 0;
}
#ifdef FINSH_USING_MSH
#include "msh.h"
#include <finsh.h>
int cmd_print(int argc, char **argv)
{
    if (argc == 4) {
		ST7585_Clear();   
		ST7585_Write_String(atoi(argv[1]), atoi(argv[2]), argv[3]);
	} else {
		rt_kprintf("wrong paramter, print 1 2 hello");
	}
    return 0;
}
FINSH_FUNCTION_EXPORT_ALIAS(cmd_print, __cmd_print, print string to lcd.);
#endif
